# coding: utf-8

"""
    Grafana HTTP API.

    The Grafana backend exposes an HTTP API, the same API is used by the frontend to do everything from saving dashboards, creating users and updating data sources.

    The version of the OpenAPI document: 0.0.1
    Contact: hello@grafana.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError

from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist

from typing import List, Optional

from bgrafana_api.models.get_annotation_tags_response import GetAnnotationTagsResponse
from bgrafana_api.models.item_dto import ItemDTO
from bgrafana_api.models.mass_delete_annotations_cmd import MassDeleteAnnotationsCmd
from bgrafana_api.models.patch_annotations_cmd import PatchAnnotationsCmd
from bgrafana_api.models.post_annotation200_response import PostAnnotation200Response
from bgrafana_api.models.post_annotations_cmd import PostAnnotationsCmd
from bgrafana_api.models.post_graphite_annotations_cmd import PostGraphiteAnnotationsCmd
from bgrafana_api.models.success_response_body import SuccessResponseBody
from bgrafana_api.models.update_annotations_cmd import UpdateAnnotationsCmd

from bgrafana_api.api_client import ApiClient
from bgrafana_api.api_response import ApiResponse
from bgrafana_api.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class AnnotationsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def delete_annotation_by_id(self, annotation_id : StrictStr, **kwargs) -> SuccessResponseBody:  # noqa: E501
        """Delete Annotation By ID.  # noqa: E501

        Deletes the annotation that matches the specified ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_annotation_by_id(annotation_id, async_req=True)
        >>> result = thread.get()

        :param annotation_id: (required)
        :type annotation_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuccessResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_annotation_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.delete_annotation_by_id_with_http_info(annotation_id, **kwargs)  # noqa: E501

    @validate_arguments
    def delete_annotation_by_id_with_http_info(self, annotation_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """Delete Annotation By ID.  # noqa: E501

        Deletes the annotation that matches the specified ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_annotation_by_id_with_http_info(annotation_id, async_req=True)
        >>> result = thread.get()

        :param annotation_id: (required)
        :type annotation_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuccessResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'annotation_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_annotation_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['annotation_id']:
            _path_params['annotation_id'] = _params['annotation_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['api_key', 'basic']  # noqa: E501

        _response_types_map = {
            '200': "SuccessResponseBody",
            '401': "ErrorResponseBody",
            '403': "ErrorResponseBody",
            '500': "ErrorResponseBody",
        }

        return self.api_client.call_api(
            '/annotations/{annotation_id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_annotation_by_id(self, annotation_id : StrictStr, **kwargs) -> ItemDTO:  # noqa: E501
        """Get Annotation by ID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotation_by_id(annotation_id, async_req=True)
        >>> result = thread.get()

        :param annotation_id: (required)
        :type annotation_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ItemDTO
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_annotation_by_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_annotation_by_id_with_http_info(annotation_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_annotation_by_id_with_http_info(self, annotation_id : StrictStr, **kwargs) -> ApiResponse:  # noqa: E501
        """Get Annotation by ID.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotation_by_id_with_http_info(annotation_id, async_req=True)
        >>> result = thread.get()

        :param annotation_id: (required)
        :type annotation_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ItemDTO, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'annotation_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotation_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['annotation_id']:
            _path_params['annotation_id'] = _params['annotation_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['api_key', 'basic']  # noqa: E501

        _response_types_map = {
            '200': "ItemDTO",
            '401': "ErrorResponseBody",
            '500': "ErrorResponseBody",
        }

        return self.api_client.call_api(
            '/annotations/{annotation_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_annotation_tags(self, tag : Annotated[Optional[StrictStr], Field(description="Tag is a string that you can use to filter tags.")] = None, limit : Annotated[Optional[StrictStr], Field(description="Max limit for results returned.")] = None, **kwargs) -> GetAnnotationTagsResponse:  # noqa: E501
        """Find Annotations Tags.  # noqa: E501

        Find all the event tags created in the annotations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotation_tags(tag, limit, async_req=True)
        >>> result = thread.get()

        :param tag: Tag is a string that you can use to filter tags.
        :type tag: str
        :param limit: Max limit for results returned.
        :type limit: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: GetAnnotationTagsResponse
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_annotation_tags_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_annotation_tags_with_http_info(tag, limit, **kwargs)  # noqa: E501

    @validate_arguments
    def get_annotation_tags_with_http_info(self, tag : Annotated[Optional[StrictStr], Field(description="Tag is a string that you can use to filter tags.")] = None, limit : Annotated[Optional[StrictStr], Field(description="Max limit for results returned.")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Find Annotations Tags.  # noqa: E501

        Find all the event tags created in the annotations.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotation_tags_with_http_info(tag, limit, async_req=True)
        >>> result = thread.get()

        :param tag: Tag is a string that you can use to filter tags.
        :type tag: str
        :param limit: Max limit for results returned.
        :type limit: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(GetAnnotationTagsResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'tag',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotation_tags" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('tag') is not None:  # noqa: E501
            _query_params.append(('tag', _params['tag']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['api_key', 'basic']  # noqa: E501

        _response_types_map = {
            '200': "GetAnnotationTagsResponse",
            '401': "ErrorResponseBody",
            '500': "ErrorResponseBody",
        }

        return self.api_client.call_api(
            '/annotations/tags', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_annotations(self, var_from : Annotated[Optional[StrictInt], Field(description="Find annotations created after specific epoch datetime in milliseconds.")] = None, to : Annotated[Optional[StrictInt], Field(description="Find annotations created before specific epoch datetime in milliseconds.")] = None, user_id : Annotated[Optional[StrictInt], Field(description="Limit response to annotations created by specific user.")] = None, alert_id : Annotated[Optional[StrictInt], Field(description="Find annotations for a specified alert.")] = None, dashboard_id : Annotated[Optional[StrictInt], Field(description="Find annotations that are scoped to a specific dashboard")] = None, dashboard_uid : Annotated[Optional[StrictStr], Field(description="Find annotations that are scoped to a specific dashboard")] = None, panel_id : Annotated[Optional[StrictInt], Field(description="Find annotations that are scoped to a specific panel")] = None, limit : Annotated[Optional[StrictInt], Field(description="Max limit for results returned.")] = None, tags : Annotated[Optional[conlist(StrictStr)], Field(description="Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.")] = None, type : Annotated[Optional[StrictStr], Field(description="Return alerts or user created annotations")] = None, match_any : Annotated[Optional[StrictBool], Field(description="Match any or all tags")] = None, **kwargs) -> List[ItemDTO]:  # noqa: E501
        """Find Annotations.  # noqa: E501

        Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotations(var_from, to, user_id, alert_id, dashboard_id, dashboard_uid, panel_id, limit, tags, type, match_any, async_req=True)
        >>> result = thread.get()

        :param var_from: Find annotations created after specific epoch datetime in milliseconds.
        :type var_from: int
        :param to: Find annotations created before specific epoch datetime in milliseconds.
        :type to: int
        :param user_id: Limit response to annotations created by specific user.
        :type user_id: int
        :param alert_id: Find annotations for a specified alert.
        :type alert_id: int
        :param dashboard_id: Find annotations that are scoped to a specific dashboard
        :type dashboard_id: int
        :param dashboard_uid: Find annotations that are scoped to a specific dashboard
        :type dashboard_uid: str
        :param panel_id: Find annotations that are scoped to a specific panel
        :type panel_id: int
        :param limit: Max limit for results returned.
        :type limit: int
        :param tags: Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.
        :type tags: List[str]
        :param type: Return alerts or user created annotations
        :type type: str
        :param match_any: Match any or all tags
        :type match_any: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[ItemDTO]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_annotations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.get_annotations_with_http_info(var_from, to, user_id, alert_id, dashboard_id, dashboard_uid, panel_id, limit, tags, type, match_any, **kwargs)  # noqa: E501

    @validate_arguments
    def get_annotations_with_http_info(self, var_from : Annotated[Optional[StrictInt], Field(description="Find annotations created after specific epoch datetime in milliseconds.")] = None, to : Annotated[Optional[StrictInt], Field(description="Find annotations created before specific epoch datetime in milliseconds.")] = None, user_id : Annotated[Optional[StrictInt], Field(description="Limit response to annotations created by specific user.")] = None, alert_id : Annotated[Optional[StrictInt], Field(description="Find annotations for a specified alert.")] = None, dashboard_id : Annotated[Optional[StrictInt], Field(description="Find annotations that are scoped to a specific dashboard")] = None, dashboard_uid : Annotated[Optional[StrictStr], Field(description="Find annotations that are scoped to a specific dashboard")] = None, panel_id : Annotated[Optional[StrictInt], Field(description="Find annotations that are scoped to a specific panel")] = None, limit : Annotated[Optional[StrictInt], Field(description="Max limit for results returned.")] = None, tags : Annotated[Optional[conlist(StrictStr)], Field(description="Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.")] = None, type : Annotated[Optional[StrictStr], Field(description="Return alerts or user created annotations")] = None, match_any : Annotated[Optional[StrictBool], Field(description="Match any or all tags")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Find Annotations.  # noqa: E501

        Starting in Grafana v6.4 regions annotations are now returned in one entity that now includes the timeEnd property.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_annotations_with_http_info(var_from, to, user_id, alert_id, dashboard_id, dashboard_uid, panel_id, limit, tags, type, match_any, async_req=True)
        >>> result = thread.get()

        :param var_from: Find annotations created after specific epoch datetime in milliseconds.
        :type var_from: int
        :param to: Find annotations created before specific epoch datetime in milliseconds.
        :type to: int
        :param user_id: Limit response to annotations created by specific user.
        :type user_id: int
        :param alert_id: Find annotations for a specified alert.
        :type alert_id: int
        :param dashboard_id: Find annotations that are scoped to a specific dashboard
        :type dashboard_id: int
        :param dashboard_uid: Find annotations that are scoped to a specific dashboard
        :type dashboard_uid: str
        :param panel_id: Find annotations that are scoped to a specific panel
        :type panel_id: int
        :param limit: Max limit for results returned.
        :type limit: int
        :param tags: Use this to filter organization annotations. Organization annotations are annotations from an annotation data source that are not connected specifically to a dashboard or panel. You can filter by multiple tags.
        :type tags: List[str]
        :param type: Return alerts or user created annotations
        :type type: str
        :param match_any: Match any or all tags
        :type match_any: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[ItemDTO], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_from',
            'to',
            'user_id',
            'alert_id',
            'dashboard_id',
            'dashboard_uid',
            'panel_id',
            'limit',
            'tags',
            'type',
            'match_any'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_annotations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('var_from') is not None:  # noqa: E501
            _query_params.append(('from', _params['var_from']))

        if _params.get('to') is not None:  # noqa: E501
            _query_params.append(('to', _params['to']))

        if _params.get('user_id') is not None:  # noqa: E501
            _query_params.append(('userId', _params['user_id']))

        if _params.get('alert_id') is not None:  # noqa: E501
            _query_params.append(('alertId', _params['alert_id']))

        if _params.get('dashboard_id') is not None:  # noqa: E501
            _query_params.append(('dashboardId', _params['dashboard_id']))

        if _params.get('dashboard_uid') is not None:  # noqa: E501
            _query_params.append(('dashboardUID', _params['dashboard_uid']))

        if _params.get('panel_id') is not None:  # noqa: E501
            _query_params.append(('panelId', _params['panel_id']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        if _params.get('tags') is not None:  # noqa: E501
            _query_params.append(('tags', _params['tags']))
            _collection_formats['tags'] = 'multi'

        if _params.get('type') is not None:  # noqa: E501
            _query_params.append(('type', _params['type']))

        if _params.get('match_any') is not None:  # noqa: E501
            _query_params.append(('matchAny', _params['match_any']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['api_key', 'basic']  # noqa: E501

        _response_types_map = {
            '200': "List[ItemDTO]",
            '401': "ErrorResponseBody",
            '500': "ErrorResponseBody",
        }

        return self.api_client.call_api(
            '/annotations', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def mass_delete_annotations(self, mass_delete_annotations_cmd : MassDeleteAnnotationsCmd, **kwargs) -> SuccessResponseBody:  # noqa: E501
        """Delete multiple annotations.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mass_delete_annotations(mass_delete_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param mass_delete_annotations_cmd: (required)
        :type mass_delete_annotations_cmd: MassDeleteAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuccessResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the mass_delete_annotations_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.mass_delete_annotations_with_http_info(mass_delete_annotations_cmd, **kwargs)  # noqa: E501

    @validate_arguments
    def mass_delete_annotations_with_http_info(self, mass_delete_annotations_cmd : MassDeleteAnnotationsCmd, **kwargs) -> ApiResponse:  # noqa: E501
        """Delete multiple annotations.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.mass_delete_annotations_with_http_info(mass_delete_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param mass_delete_annotations_cmd: (required)
        :type mass_delete_annotations_cmd: MassDeleteAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuccessResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'mass_delete_annotations_cmd'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mass_delete_annotations" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['mass_delete_annotations_cmd'] is not None:
            _body_params = _params['mass_delete_annotations_cmd']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api_key', 'basic']  # noqa: E501

        _response_types_map = {
            '200': "SuccessResponseBody",
            '401': "ErrorResponseBody",
            '500': "ErrorResponseBody",
        }

        return self.api_client.call_api(
            '/annotations/mass-delete', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def patch_annotation(self, annotation_id : StrictStr, patch_annotations_cmd : PatchAnnotationsCmd, **kwargs) -> SuccessResponseBody:  # noqa: E501
        """Patch Annotation.  # noqa: E501

        Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_annotation(annotation_id, patch_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param annotation_id: (required)
        :type annotation_id: str
        :param patch_annotations_cmd: (required)
        :type patch_annotations_cmd: PatchAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuccessResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the patch_annotation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.patch_annotation_with_http_info(annotation_id, patch_annotations_cmd, **kwargs)  # noqa: E501

    @validate_arguments
    def patch_annotation_with_http_info(self, annotation_id : StrictStr, patch_annotations_cmd : PatchAnnotationsCmd, **kwargs) -> ApiResponse:  # noqa: E501
        """Patch Annotation.  # noqa: E501

        Updates one or more properties of an annotation that matches the specified ID. This operation currently supports updating of the `text`, `tags`, `time` and `timeEnd` properties. This is available in Grafana 6.0.0-beta2 and above.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.patch_annotation_with_http_info(annotation_id, patch_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param annotation_id: (required)
        :type annotation_id: str
        :param patch_annotations_cmd: (required)
        :type patch_annotations_cmd: PatchAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuccessResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'annotation_id',
            'patch_annotations_cmd'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method patch_annotation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['annotation_id']:
            _path_params['annotation_id'] = _params['annotation_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['patch_annotations_cmd'] is not None:
            _body_params = _params['patch_annotations_cmd']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api_key', 'basic']  # noqa: E501

        _response_types_map = {
            '200': "SuccessResponseBody",
            '401': "ErrorResponseBody",
            '403': "ErrorResponseBody",
            '404': "ErrorResponseBody",
            '500': "ErrorResponseBody",
        }

        return self.api_client.call_api(
            '/annotations/{annotation_id}', 'PATCH',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def post_annotation(self, post_annotations_cmd : PostAnnotationsCmd, **kwargs) -> PostAnnotation200Response:  # noqa: E501
        """Create Annotation.  # noqa: E501

        Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_annotation(post_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param post_annotations_cmd: (required)
        :type post_annotations_cmd: PostAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PostAnnotation200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_annotation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.post_annotation_with_http_info(post_annotations_cmd, **kwargs)  # noqa: E501

    @validate_arguments
    def post_annotation_with_http_info(self, post_annotations_cmd : PostAnnotationsCmd, **kwargs) -> ApiResponse:  # noqa: E501
        """Create Annotation.  # noqa: E501

        Creates an annotation in the Grafana database. The dashboardId and panelId fields are optional. If they are not specified then an organization annotation is created and can be queried in any dashboard that adds the Grafana annotations data source. When creating a region annotation include the timeEnd property. The format for `time` and `timeEnd` should be epoch numbers in millisecond resolution. The response for this HTTP request is slightly different in versions prior to v6.4. In prior versions you would also get an endId if you where creating a region. But in 6.4 regions are represented using a single event with time and timeEnd properties.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_annotation_with_http_info(post_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param post_annotations_cmd: (required)
        :type post_annotations_cmd: PostAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PostAnnotation200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'post_annotations_cmd'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_annotation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['post_annotations_cmd'] is not None:
            _body_params = _params['post_annotations_cmd']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api_key', 'basic']  # noqa: E501

        _response_types_map = {
            '200': "PostAnnotation200Response",
            '400': "ErrorResponseBody",
            '401': "ErrorResponseBody",
            '403': "ErrorResponseBody",
            '500': "ErrorResponseBody",
        }

        return self.api_client.call_api(
            '/annotations', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def post_graphite_annotation(self, post_graphite_annotations_cmd : PostGraphiteAnnotationsCmd, **kwargs) -> PostAnnotation200Response:  # noqa: E501
        """Create Annotation in Graphite format.  # noqa: E501

        Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotations timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_graphite_annotation(post_graphite_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param post_graphite_annotations_cmd: (required)
        :type post_graphite_annotations_cmd: PostGraphiteAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PostAnnotation200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the post_graphite_annotation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.post_graphite_annotation_with_http_info(post_graphite_annotations_cmd, **kwargs)  # noqa: E501

    @validate_arguments
    def post_graphite_annotation_with_http_info(self, post_graphite_annotations_cmd : PostGraphiteAnnotationsCmd, **kwargs) -> ApiResponse:  # noqa: E501
        """Create Annotation in Graphite format.  # noqa: E501

        Creates an annotation by using Graphite-compatible event format. The `when` and `data` fields are optional. If `when` is not specified then the current time will be used as annotations timestamp. The `tags` field can also be in prior to Graphite `0.10.0` format (string with multiple tags being separated by a space).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.post_graphite_annotation_with_http_info(post_graphite_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param post_graphite_annotations_cmd: (required)
        :type post_graphite_annotations_cmd: PostGraphiteAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PostAnnotation200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'post_graphite_annotations_cmd'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_graphite_annotation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['post_graphite_annotations_cmd'] is not None:
            _body_params = _params['post_graphite_annotations_cmd']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api_key', 'basic']  # noqa: E501

        _response_types_map = {
            '200': "PostAnnotation200Response",
            '400': "ErrorResponseBody",
            '401': "ErrorResponseBody",
            '403': "ErrorResponseBody",
            '500': "ErrorResponseBody",
        }

        return self.api_client.call_api(
            '/annotations/graphite', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_annotation(self, annotation_id : StrictStr, update_annotations_cmd : UpdateAnnotationsCmd, **kwargs) -> SuccessResponseBody:  # noqa: E501
        """Update Annotation.  # noqa: E501

        Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_annotation(annotation_id, update_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param annotation_id: (required)
        :type annotation_id: str
        :param update_annotations_cmd: (required)
        :type update_annotations_cmd: UpdateAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SuccessResponseBody
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the update_annotation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)
        return self.update_annotation_with_http_info(annotation_id, update_annotations_cmd, **kwargs)  # noqa: E501

    @validate_arguments
    def update_annotation_with_http_info(self, annotation_id : StrictStr, update_annotations_cmd : UpdateAnnotationsCmd, **kwargs) -> ApiResponse:  # noqa: E501
        """Update Annotation.  # noqa: E501

        Updates all properties of an annotation that matches the specified id. To only update certain property, consider using the Patch Annotation operation.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_annotation_with_http_info(annotation_id, update_annotations_cmd, async_req=True)
        >>> result = thread.get()

        :param annotation_id: (required)
        :type annotation_id: str
        :param update_annotations_cmd: (required)
        :type update_annotations_cmd: UpdateAnnotationsCmd
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SuccessResponseBody, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'annotation_id',
            'update_annotations_cmd'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_annotation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['annotation_id']:
            _path_params['annotation_id'] = _params['annotation_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_annotations_cmd'] is not None:
            _body_params = _params['update_annotations_cmd']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['api_key', 'basic']  # noqa: E501

        _response_types_map = {
            '200': "SuccessResponseBody",
            '400': "ErrorResponseBody",
            '401': "ErrorResponseBody",
            '403': "ErrorResponseBody",
            '500': "ErrorResponseBody",
        }

        return self.api_client.call_api(
            '/annotations/{annotation_id}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
