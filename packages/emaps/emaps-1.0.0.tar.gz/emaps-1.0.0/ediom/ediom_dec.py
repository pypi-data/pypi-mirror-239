def add_ediom(target):
    '''
    ediom - diffraction pattern indexing
    It depends on dpgen - diffraction pattern database generator

    ediom takes an experimental image and its associated measurements
    parameters and search and index for intensity peaks and the peaks 
    based on the DP database generated by pyemaps dpgen module.

    Feature preview limitations:
    1. Image format: grays scale small header 
       formatted image. Other image formats will be added later.
    2. Image size less than 512 pixels.
    3. Cubic systems with space group numbers: 225, 227, 229 only.
    4. 
     '''
    try:
        from . import ediom
    except ImportError as e:               
        # raise ModuleNotFoundError from e
        # return an empty target for free package
        print(f'diffraction pattern indexing module is not available')
        return target
    
    MAX_IMAGESIZE = ediom.MAX_IMAGESIZE
    MIN_IMAGESIZE = ediom.MIN_IMAGESIZE
    # DEF_FOPTION = 12
    DEF_FILTER_THRESHOLD = 0.2                       
    DEF_SEARCH_THRESHOLD = 0.825
    DEF_RMIN = 7
    DEF_BOXSIZE = 10
    DEF_CC = ediom.cvar.edc.cc      #default value from backend
    DEF_SIGMA = ediom.cvar.edc.sigma
    DEF_ICENTER = ediom.cvar.edc.get_center()
    DEF_XSCALE = 1
    DEF_TSCALE = 2

    E_INT = ediom.E_INT
    EM_INT = ediom.EM_INT,
    E_FLOAT = ediom.E_FLOAT
    EM_FLOAT = ediom.EM_FLOAT
    E_DOUBLE = ediom.E_DOUBLE
    EM_DOUBLE = ediom.EM_DOUBLE

    import matplotlib.pyplot as plt
    import numpy as np


    clrs = ["#2973A5", "cyan", "limegreen", "yellow", "red"]
    qedDPI = 600
    gclrs=plt.get_cmap('gray')
    EDIOM_TITLE = 'Pyemaps Preview - Ediom Diffraction Pattern Indexing'

    def _imgNormalize(img):
        if img is None:
            print("Probe error: image file empty")
            return False
        y0 = np.mean(img, dtype=np.float32)
        medImg = np.std(img, dtype=np.float32)

        Ymin1 = y0 - 3.0 * medImg
        Ymin = np.amin(img)
        if Ymin < Ymin1: Ymin = Ymin1

        Ymax1 = y0 + 3.0 * medImg
        Ymax = np.amax(img)
        if Ymax > Ymax1: Ymax = Ymax1

        if Ymin >= Ymax:
            print("not finding right min-max: ")
            return False
        ran = Ymax-Ymin

        img[img < Ymin] = Ymin
        img[img > Ymax] = Ymax
        img = (img - Ymin)/ran
        return True

    # def _getXTemplateFn():
    #     import os
    #     db_home = os.getenv('PYEMAPS_DATA')
    #     return os.path.join(db_home, 'dpdb', 'ediom', 'PeakTemplate.im3')
    
    def _displayImage(img, 
                      fsize=(0,0), 
                      bColor= False, 
                      isMask = False, 
                      bIndexed=False, 
                      iShow = False, 
                      ds = None,
                      suptitle = ''):   
        """
        Internal ediom helper function displaying image.

        :return:  
        :rtype: None
        
        """
        
        import matplotlib.patches as patches
        from matplotlib.colors import LinearSegmentedColormap
        nr,nc = fsize

        if isMask:
            bsize = (0.5, 0.5*int(nr/nc))
        else:
            bsize = (1.0, 1.0*int(nr/nc))

        fig, ax = plt.subplots(figsize=bsize, dpi=qedDPI)
        
        fig.canvas.set_window_title(EDIOM_TITLE)
        # ax.set_xlabel(suptitle, fontsize=1.5)
        fig.suptitle(suptitle, va='top', fontsize=1.5)
        
        clrMap = gclrs #default to grey
        if bColor:
            clrMap = LinearSegmentedColormap.from_list("mycmap", clrs)
        plt.imshow(img, cmap = clrMap)

        ax.set_axis_off()
        
        count = 0
        if ds is not None:
            for d in ds:
                cx, cy, rad, indx, itype = d
                
                if bIndexed and itype != 2 and count != 0:
                    continue

                centre = (cx, cy)
                
                circle = plt.Circle(centre, rad, 
                                    fill=False, 
                                    linewidth = 0.1, 
                                    # alpha=0.6, 
                                    color='white')
                ax.add_patch(circle)
                count += 1

                if iShow:
                    ax.text(centre[0],centre[1], 
                        str(indx),
                        {'color': 'red', 'fontsize': 1.4},
                        horizontalalignment='center',
                        verticalalignment='bottom')
        
        plt.show()
    
    def _displaySearchMask(nr, nc):    
        """
        Internal ediom helper function displaying image mask image 
        generated in peak search.

        :return:  
        :rtype: None
        
        """
        len = nr*nc
        ret = 1


        ret, img1d = ediom.getXMask(len)

        if ret != 0 :
            print(f'Python ----Error getting current image slice')

        _displayImage(img1d.reshape((nr,nc)), fsize = (nr,nc), suptitle='Search Mask')
        return 0

    def _displaySearchKernel(nr, nc):     
        """
        Internal ediom helper function displaying image kernel image 
        generated in peak search.

        :return:  
        :rtype: None
        
        """
        len = nr*nc
        ret = -1


        ret, img1d = ediom.getXTemplateMask(len)

        if ret != 0 :
            print(f'Python ----Error getting current image slice')
            return -1
        
        _displayImage(img1d.reshape((nr,nc)), 
                      fsize = (nr,nc), 
                      isMask=True, 
                      suptitle = 'Search Kernel')
        return 0

    def showMatchingIndexMap(self, fr, fc):
            
        """
        Helper function in ediom module to display matching indexes map. The colored
        heat map with the peak indicates the orientation in which experimental and 
        database diffraction patterns best match.

        :param fr: stereo projection map height. This number is obtained from 
                   `loadDPDB <pyemaps.crystals.html#pyemaps.crystals.Crystal.loadDPDB>`_ call. 
        :type fr: int, required

        :param fc: stereo projection map width. This number is obtained from 
                   `loadDPDB <pyemaps.crystals.html#pyemaps.crystals.Crystal.loadDPDB>`_ call.
        :type: int, required

        :return: status code 
        :rtype: int
        
        """
        
        flen = fc*fr
        
        ret, fmask = ediom.getFitMap(flen)
        if ret != 0:
            print(f'Python ----Failed to get for map')
            return ret

        _displayImage(fmask.reshape(fr,fc), 
                      fsize =(fr, fc), 
                      isMask = True, 
                      bColor=True,
                      suptitle = 'Matching Index Map')
        return 0
    
    
    def _displayFitImage(nr, nc):
        """
        Internal intermediate helper function for display fit images.
        """
       
        filen = nr*nc
        ret, fimg = ediom.getFitImage(filen)
        if ret != 0:
            print(f'Python ----Failed to get fit image')
            return ret
            
        _displayImage(fimg.reshape(nr, nc), fsize=(nr, nc))
        return 0 
    
    def viewExpImage(self, peakDP = False, Indexed = False, iShow = False):      
        """
        Helper function in ediom module to display experimental diffraction database 
        diffraction pattern currently loaded.

        :param peakDP: kinematic diffraction with miller index. 
        :type peakDP: Boolean, optional

        :param Indexed: show the kinematic patterns after indexing is completed.
        :type Indexed: boolean, optional, default to `False`

        :param iShow: whether to show miller indexes
        :type iShow: boolean, optional, default to `False`
        
        :return:  
        :rtype: None
        
        This function is typically used to display experimental image after diffraction 
        patterns matched and indexed. It can also be used to display intermediate
        search results after peaks are found but before indexes are matched. The latter
        display is turned on only by *bDebug* flag in 
        `loadDPDB <pyemaps.crystals.html#pyemaps.crystals.Crystal.loadDPDB>`_ call.

        """

        img1d = ediom.cvar.ximg.getImageData()
        xnc, xnr = ediom.cvar.ximg.h.ncol, ediom.cvar.ximg.h.nrow
        
        if img1d is None:
            print(f'Experimental image is not loaded or invalid')
            return
        
        try:
            yi = np.ascontiguousarray(img1d, dtype=np.float32).reshape(xnc, xnr)
        except Exception as e:
            print("Error converting image data to numpy array")
            raise ValueError from e
        else:
            xkdisk = None
            if peakDP:
                nps = ediom.getExpImagePeaks()
                
                if nps <= 0:
                    print(f'Image is not indexed or indexing data is invalid')
                    return
                
                ret, xkdisk = ediom.getXKDif(nps+1)
                
                if ret != 0:
                    print(f'Python ----Failed to get diffraction patterns for the experimental image')
                    return ret
                
            _displayImage(yi, 
                          fsize=(xnc, xnr), 
                          bIndexed=Indexed, 
                          iShow = iShow, 
                          ds = xkdisk,
                          suptitle = 'Experimental Diffraction Image' if not Indexed else 'Experimental Diffraction Image - Indexed')

    def showMatchedDBDP(self):        
        """
        Helper function in ediom module to display diffraction database diffraction pattern 
        that best matches that of the experimental diffraction image pattern.

        This function is typically used to confirm its match with experimental diffraction 
        pattern. See sample code *al_ediom.py* for usage of this function.

        """
        nr, nc = MAX_IMAGESIZE, MAX_IMAGESIZE
        
        img1d = np.ascontiguousarray(np.zeros(shape=(nc,nr)), dtype=np.float32)
       
        nPeaks = ediom.DPGetCurrentImage(img1d)
        if nPeaks <=0:
            print(f'Python ----Failed to get selected database image')
            return -1

        if not _imgNormalize(img1d):
            print("Python ----Error normalizing the image for display")
            return -1
       
        knum = nPeaks+1
        ret, kdisk = ediom.getDPListKDif(knum) 
        
        if ret != 0:
            print(f'Python ----Failed to get diffraction disks list')
            exit(1)
        _displayImage(img1d, 
                      fsize=(nc,nr), 
                      iShow=True, 
                      ds=kdisk,
                      suptitle = 'Matching Database Diffraction Pattern')

        return 0
    
    @staticmethod
    def release_ediom(self):
        """
        Releases ediom internal memory. 
        
        This must be called after completing or existing from DP search and indexing calls.

        See an example of typical usage in sample code *al_ediom.py*

        """
        ediom.freeEdiom()

    def printDPIndexDetails(self):
           
        """
        Ediom helper function displaying more details of the matched peak indexes.

        :return: status code, 0 for successful run 
        :rtype: int

        An example of the print out from this function:
    .. code-block:: console

            Peak #  Miller Index     Distance           Peak Loc         Intensity 
            1     2     0    -2   15.216021   75.524544   77.989143   57.99596
            2     2    -2     0   15.943615   58.909172   81.734337  100.00000
            3     0     2    -2   16.269718   80.777145   63.026917   41.76962
            4     0    -2     2   16.515915   48.621555   69.126495   61.30554
            5    -2     2     0   16.771706   69.907181   50.962242   59.11509
            6    -2     0     2   16.911699   53.869732   54.267258   76.78214
            7     4    -2    -2   27.182039   69.673668   93.777229   30.43030
            8     2     2    -4   28.084078   91.914803   75.019279   14.09216
            9     2     4    -2   28.336311   86.383392   48.407070   17.27392
            10   -4     2     2   28.374109   59.550945   39.154034   31.84980
            11    2    -4     2   28.521149   42.821850   84.932808   36.47014
            12   -2    -2     4   28.755293   37.739792   57.848614   19.96975
            13    4    -4     0   31.887535   53.672882   96.807907   51.87958
            14   -4     0     4   32.313499   43.617867   42.772602   39.38488
            15   -4     4     0   32.576725   75.825447   36.274559   13.99698
            16    0    -4     4   32.871819   32.674446   72.967834   22.33116
            17    0     4    -4   33.117977   97.612862   61.237911   12.88735

        """
        print("\n")
        print("-----------------Indexed Diffraction Pattern Details------------------")

        print(f"""{'DP #':^7}{'Miller Index':^15}{'Distance':^15}{'DP Loc':^23}{'Intensity':^11}""")
    
        return ediom.printIndexDetails()
   
    def importRawExpImage(self, imgfn, 
                          offset, type = E_FLOAT, 
                          width = MAX_IMAGESIZE, height = MAX_IMAGESIZE, depth=1, 
                          sel=1, bShow = False):
        """
        Loads a raw experimental image with diffraction patterns into **pyemaps** ediom module
        for peaks search and DP indexing.

        :param imgfn: the raw image full path with file name.
        :type imgfn: string, required

        :param offset: offset in bytes to image data. This is normally the size of image header in bytes
        :type offset: integer, required

        :param type: the image data type. 
        :type type: integer, optional

        :param width: the image width
        :type width: integer, optional
        
        :param height: the image height
        :type height: integer, optional
        
        :param depth: image stack size or the number of layers
        :type depth: integer, optional. Default to 1.
        
        :param sel: the image stack or layer selection - ediom search on specific stack of a multiple stacks image
        :type sel: integer, optional, default to 1 - the first layer.
        
        :param bShow: weather to display the image after successful import
        :type bShow: boolean, optional, default to `False`.

        :return: status code, 0 for successful run
        :rtype: int
        
        List of image data types supported:

        .. code-block:: console
        
            char (signed or unsigned, 8 bits)
            short (signed or unsigned, 16 bits)
            int (signed or unsigned, at least 16 bits)
            long (signed or unsigned, at least 32 bits)
            float (32 bits, default)
            double (64 bits, may result in reduction in precision) 

        """
        
        ret = ediom.loadRawImage(imgfn, 
                          offset, type, 
                          width, height, depth, 
                          stack=sel)
        if ret != 0:
            raise ValueError("Failed importing experimental diffraction pattern")
        
        if bShow:
            self.viewExpImage()

        return 0

        
    def importSHExpImage(self, imgfn, sel=1, bShow=False):
        """
        Loads a pyemaps proprietory experimental image with diffraction patterns into **pyemaps** ediom module
        for peaks search and indexing. 

        :param imgfn: the raw image file.
        :type imgfn: string, required
        
        :param sel: the image stack or layer selection - ediom search on specific stack of a multiple stacks image
        :type sel: integer, optional, Default to 1.
        
        :param bShow: weather to display the image after successful import
        :type bShow: boolean, optional. Default to `False`.

        :return: status code. 0 successful.
        :rtype: int

        
        .. note::
        
            This is a pyemaps's own proprietory image format where the image attributes are defined
            in a small header C-structure of size 8 bytes:

        .. code-block:: C

            struct SHeader {
                unsigned short int width;
                unsigned short int height;
                unsigned short int stacks;
                unsigned short int type;
            }

        """
        # open the image file and return its dimensions
        
        ret = 0
        xnr, xnc = 0, 0
        
        ret = ediom.loadXImage(imgfn, lsel=sel)
        
        if ret != 0:
            print(f'Failed loading experimental iamge file')
            return None
        
        xnr, xnc = ediom.cvar.ximg.h.nrow, ediom.cvar.ximg.h.ncol
        
        if bShow:
            self.viewExpImage()
        
        return (ret, xnr, xnc)

    def importExpImageFromNPY(self, npy_arr, bShow = False):
        """
        Loads a python numpy array representation of diffraction pattern into **pyemaps** ediom module
        for peaks search and indexing. 

        :param npy_arr: a numpy array of basic types that can be converted into float32 type.
        :type npy_arr: numpy array, required
        
        :param bShow: display the image or not after successful importing
        :type bShow: boolean, optional. Default to `False`

        :return: status code, 0 for successful run 
        :rtype: int
        
        An example of numpy array:
        
        .. code-block:: python

            img_arr = np.array(np.zeros((n,n), dtype=numpy.float32))
            for i in range(n):
                for j in range(n):
                    img_arr[i][j] = np.random.uniform(0.01, 1.0)

        where *dtype* can be any type from a list of numpy types that can be converted into numpy.float32.
        The list covers most of the numpy data types, except the complex types:
        
        #. numpy.bool_
        #. numpy.byte
        #. numpy.short
        #. numpy.ushort
        #. numpy.intc
        #. numpy.uintc
        #. numpy.uint
        #. numpy.longlong
        #. numpy.ulonglong
        #. numpy.float16
        #. numpy.single
        #. numpy.double
    
        or corresponding python C API types:

        #. NPY_BOOL: Boolean data type.
        #. NPY_BYTE: Signed byte data type.
        #. NPY_UBYTE: Unsigned byte data type.
        #. NPY_SHORT: Signed short integer data type.
        #. NPY_USHORT: Unsigned short integer data type.
        #. NPY_INT: Signed integer data type.
        #. NPY_UINT: Unsigned integer data type.
        #. NPY_LONG: Signed long integer data type.
        #. NPY_ULONG: Unsigned long integer data type.
        #. NPY_LONGLONG: Signed long long integer data type.
        #. NPY_ULONGLONG: Unsigned long long integer data type.
        #. NPY_FLOAT: Single-precision floating point data type.
        #. NPY_DOUBLE: Double-precision floating point data type.

        """
        np_type = npy_arr.dtype 
        if np_type != np.int and np_type != np.float32 and np_type != np.double:
            raise ValueError("Numpy array must be int, float or double type")
        
        np_ndim = npy_arr.ndim
        if np_ndim != 2:
            raise ValueError("Numpy array must be 2 dimensional")
        
        width, height = npy_arr.shape

        if width < MIN_IMAGESIZE or height < MIN_IMAGESIZE:
            raise ValueError("Array representation of the image too small")
        
        ret = ediom.cvar.ximg.setImage_from_numpy(npy_arr)
        if ret != 0:
            raise ValueError("Failed to import the image via numpy array")
        
        if bShow:
            self.viewExpImage()
        return 0

    
    def _showDPDBMMask(mr, mc):

        """
        Internal function to display loaded DP database stereo projection map
        as explained in the following
        
        .. image:: https://github.com/emlab-solutions/imagepypy/raw/main/stereoprojectionmap.png
           :width: 75%
           :align: center

        """
        len = mr*mc
        
        mask = np.ascontiguousarray(np.zeros(len), dtype=np.short)
        
        ret= ediom.DPGetMask(mask)
        
        if ret != 0:
            print(f'Python ----Error getting the mask data')
            return -1

        _displayImage(mask.reshape(mr,mc), 
                      fsize =(mr, mc), 
                      isMask = True,
                      suptitle="Stereo Projection Map")
        # _displayImage(mask.reshape(mr,mc), fsize =(mr, mc), isMask = True)
        return 0
    
    def loadDPDB(self, dbfn, bShowDBMap=False):
        """
        Loads the diffraction database file *dbfn* into ediom for diffraction peak searching and indexing.

        See sample code *al_dpgen.py* for how to generate a diffraction pattern database with
        pyemaps `generateDPDB <pyemaps.crystals.html#pyemaps.crystals.Crystal.generateDPDB>`_.

        The database file can also be saved and reused.

        :param dbfn: DP database file name.
        :type dbfn: string, required
        
        :param bShowDBMap: weather to display the stereodigram project map after successful 
                           loading of the database file

        :type bShowDBMap: boolean, optional, default to `False`

        :return: status code, stereo projection map dimension - two integers tuple 
        :rtype: tuple

        See the following for stereo projection map representing the DP database:
        
        .. image:: https://github.com/emlab-solutions/imagepypy/raw/main/stereoprojectionmap.png
           :width: 75%
           :align: center

        """
        # load DP database into ediom and return database fitmap dimensions
        ret, mrow, mcol = ediom.readDPDB(dbfn)
        if ret != 0:            #need to replace this with ediom return value
            print(f'Error loading image file')
            return ret, 0, 0

        print(f'Diffraction Database loaded successfully.')
        print(f'Dimension of stereo projection map: width ={mcol}, height={mrow}')
        
        if bShowDBMap:
            _showDPDBMMask(mrow, mcol)

        return ret, mrow, mcol

    def peekDBDPAt(self, loc=(0, 0)):
        """
        Looks up currently loaded DP database for the kinematic diffraction image at stereodiagram
        projection map location *loc*.

        :param loc: location represented by 2 integers on the stereo projection map.
        :type loc: tuple, required

        :return: status code, stereo projection map dimension two integers tuple 
        :rtype: tuple

        This function helps users navigate current diffraction (DP) database. A typical DP database
        contains thousands of diffraction patterns depending on the number of sampling points taken.
        Each of the diffraction patterns in the database is indexed by its map location.

        """
        ret = ediom.DPListMaskSelect(loc[0], loc[1])
        if ret != 0:
            print(f'Python ----Mask location selection failed')
            return ret
        
        nr, nc = MAX_IMAGESIZE, MAX_IMAGESIZE
        
        img1d = np.ascontiguousarray(np.zeros(shape=(nc,nr)), dtype=np.float32)
       
        nPeaks = ediom.DPGetCurrentImage(img1d)
        if nPeaks <=0:
            print(f'Python ----Failed to get selected database image')
            return -1

        if not _imgNormalize(img1d):
            print("Python ----Error normalizing the image for display")
            return -1
       
        knum = nPeaks+1
        ret, kdisk = ediom.getDPListKDif(knum) 
        
        if ret != 0:
            print(f'Python ----Failed to get diffraction disks list')
            exit(1)
        _displayImage(img1d, fsize=(nc,nr), iShow=True, ds=kdisk)
        return 0

    def indexExpDP( self,                  
                    cc                      = DEF_CC,             
                    sigma                   = DEF_SIGMA,         
                    img_center              = DEF_ICENTER,
                    rmin                    = DEF_RMIN,         
                    search_box              = DEF_BOXSIZE,
                    scaling_option          = (DEF_XSCALE, DEF_TSCALE), 
                    filter_threshold        = DEF_FILTER_THRESHOLD,  
                    peak_threshold          = DEF_SEARCH_THRESHOLD, 
                    bDebug                  = False
                  ):
        """
        Searches and indexes loaded experimental diffraction image. The experimental diffraction image must be loaded 
        or imported before this call. There are many ways to import your image:

        1. Use `importRawExpImage <pyemaps.crystals.html#pyemaps.crystals.Crystal.importRawExpImage>`_,
        if the image format is known and image data can be read from a fixed offset from the start of the file.

        2. Otherwise, use `importExpImageFromNPY <pyemaps.crystals.html#pyemaps.crystals.Crystal.importExpImageFromNPY>`_,
        if the image can be exported and stored into a numpy array. 

        3. Finally, use `importSHExpImage <pyemaps.crystals.html#pyemaps.crystals.Crystal.importSHExpImage>`_,
        if the image id a proprietory formatted image file with a small header of 8 bytes offset,

        .. note::

            We are working on importing images with popular formats, stay tuned.

        In addition, a diffraction database also needs to be loaded by preceeding this call with
        `loadDPDB <pyemaps.crystals.html#pyemaps.crystals.Crystal.loadDPDB>`_ 

        :param dpdbfn: diffraction pattern database file name. The file is generated by pyemaps dp_gen module 
        or database file name saved from previous runs.
        :type dpdbfn: string, required
        
        :param cc: Camera constant in 1/Angstrom/pixel.
        :type cc: float, optional

        :param sigma: Diffraction peak width - estimated image peak width.
        :type sigma: float, optional.

        :param img_center: diffraction pattern center in (col, row) coordinate.
        :type img_center: float tuple, optional

        :param rmin: low cutoff radius for excluding center beam and diffuse intensities.
        :type rmin: float, optional

        :param search_box: Parameter in pixels used to define peak search. Recommended value 
                           of 3 to 4 times of sigma value for selected area diffraction.
        :type search_box: float, optional

        :param filter_threshold: Diffraction pattern screening threshold. Between 0.0 and 1.0 
                                 use 0 to include all database patterns for search.
        :type filter_threshold: float, optional

        :param peak_threshold: Peak threshold. value between 0.0 and 1.0. used to remove noisy peaks.
        :type peak_threshold: float, optional

        :return: status code, 0 for successful run
        :rtype: int

        
        The image control parameters cc - rmin above are image meaurements controls. The accuraccies
        of these measurements can greatly affect the peak search and eventually indexing results.

        The remaining input parameters directly control the search and indexing functions and its results.
        Use these parameters to tune your results.

        The following is a typical sequence of displays during the execution:

        1. Once the DP database is loaded successfully, the steoreo projection map associated
        with the DP database will be shown.
        
        .. image:: https://github.com/emlab-solutions/imagepypy/raw/main/stereoprojmap.png
            :width: 75%
            :align: center

        2. Successful experimental DP image importing will also show the image. This gives users
        the opportunity to verify the image:

        .. image:: https://github.com/emlab-solutions/imagepypy/raw/main/expimagoriginal.png
            :width: 75%
            :align: center

        3. Following the display of the experimental DP image and if *bDebug* is not set (by default), 
        the indexing result will be displayed on top of the experimental image:

        .. image:: https://github.com/emlab-solutions/imagepypy/raw/main/expimgindexed.png
            :width: 75%
            :align: center

        4. Once the indexing results are generated, users have the option to call more display
        *EDIOM* functions to show other results generated by this call. For examples, 
        the matching database DP image and DP database matching index map as shown below:

        .. image:: https://github.com/emlab-solutions/imagepypy/raw/main/matchingDPDB.png
            :width: 75%
            :align: center

        .. image:: https://github.com/emlab-solutions/imagepypy/raw/main/matchingindexmap.png
            :width: 75%
            :align: center

        The latter map presents the likely matching location  (in red) between the DP in database, 
        also considered the theoretical diffraction patterns, and the experimental DP image. 

        5. Finally, in addition to the above visual representation of the run and results, 
        more verbose results are also shown in standard output:

        .. code-block:: console

            Number of peaks found: 45

            -----------------Diffraction Pattern(DP) Indexing Results--------------------
            ***** DP stack loaded and indexed: 1
            ***** Best matching database DP: 1715
            ***** DP rotation angle: 284.191 (degrees)
            ***** Number of diffraction peaks indexed: 11
            ***** Experimental and database DP correlation maximum: 0.988308
            ***** Beam direction: 0.0575418 0.0599394 0.232559
            ***** Reliability index (> 5.0): 30.5407


            -----------------Indexed Diffraction Pattern Details------------------
            DP #   Miller Index     Distance            DP Loc          Intensity
                1     2    -2     0   18.805359  114.912613  109.021492   14.05505
                2    -2     2     0   20.888754   81.346603   87.833191  100.00000
                3     3     1    -1   22.201900   95.978333  120.995316   28.63353
                4    -1    -3     1   22.830843  117.979164   86.309898    9.12775
                5    -3    -1     1   23.202806  101.336617   75.915146   17.33628
                6     1     3    -1   23.803307   78.843224  111.661034   97.01090
                7     5    -1    -1   36.265705  112.098000  132.817802    2.99402
                8    -5     1     1   36.616173   85.120682   65.116249    4.92946
                9    -1     5    -1   36.805595   62.239502  100.821404   33.52511
                10   -4     4     0   39.269745   66.114388   77.537254   18.77301
                11    4     4    -2   42.499973   76.063011  134.779076    2.83128

        where Reliability index greater than 5.0 is considered successful run. DP stands for
        diffraction pattern. If your results do not fit in a run, adjusting search and indexing paramemers
        such as filter_threshold and peak threshold can also help ediom module to search and match peaks.

        .. note::

            When *bDebug* flag is set (to 'True'), users are offered to chance to display more information of 
            ediom's intermediate execution steps. For example, peak discovery step will show results
            of all found peaks by image peak matching algorithms before indexing is done. 
            These intermediate images are mainly for debugging purposes.

        """  

        if scaling_option[0] < 0 or scaling_option[0] > 5:
            raise ValueError('Experimental scaling factor out of range')
        
        if scaling_option[1] < 0 or scaling_option[1] > 5:
            raise ValueError('Theoretical scaling factor out of range')
        
        soption = scaling_option[0] * 10 + scaling_option[1]
        if soption == 0:
             raise ValueError('Both scaling factor out of range')
        

        xim = ediom.cvar.ximg
        # setting image control parameters
        ediom.cvar.edc.cc = cc
        ediom.cvar.edc.sigma = sigma

        # check if experimental image is loaded
        if not xim.img_loaded():
            raise ValueError("Experimental image must be loaded")
        
        xnc, xnr = xim.get_width(), xim.get_height()

        # validate image center
        
        if img_center[0] < 0 or img_center[0] > xnc or \
            img_center[1] < 0 or img_center[1] > xnr:
            raise ValueError('Experimental image DP center invalid')
        
        ediom.cvar.edc.set_center(img_center[0], img_center[1])

        # load ediom control parameters with which the image is generated
        # and search and return search kernel dimensions
        ret, kc, kr = ediom.prepareSearch(img_center[0], img_center[1], rmin)
        if ret != 0 or kc <= 0 or kr <= 0:
            print(f'Error preparing for experimental image peak search')
            return -1
        
        if bDebug:
            _displaySearchMask(ediom.cvar.ximg.h.ncol, ediom.cvar.ximg.h.nrow)
            _displaySearchKernel(kr, kc) 

        # Start peaks search...
        xpeaks = ediom.searchXPeaks(search_box, threshold=peak_threshold)

        if xpeaks == -1:
            print(f'Peaks search failed')
            return -1
        
        if xpeaks <= 3:
            print(f'Insufficient number of peaks found for indexing')
            return -1
        
        if bDebug:
            self.viewExpImage(peakDP=True, Indexed=False, iShow = False)
        
        ret = ediom.indexXPeaks(rmin, soption, filter_threshold)
        
        if ret != 0:
            print(f'Error indexing experimental image for DP')
            return ret
        

        self.viewExpImage(peakDP=True, Indexed=True, iShow = True)
        # if bDebug:
        #     _displayFitImage(2*xnr, xnc)
        # _displayFitMap(mcol, mrow)
        

        return 0

    def generateADF(self, 
                    imgfn, 
                    center=(0.0, 0.0), 
                    rads = (0.0, 0.0),
                    scol = 0.0,
                    bShow=False):
        """
        generate an Annular Dark Field(ADF) image from an experimental image.

        :param imgfn: experimental image file name. 
        :type imgfn: string, required
        
        :param center: The center of ADF detector.
        :type cc: tuple of floats

        :param rads: a pair of radius for inner and outer ADF detector.
        :type rads: tuple, optional.

        :param scol: The size of the output image along column direction.
        :type scol: float, optional

        :param bShow: whether to display the resulting ADF image.
        :type bShow: boolean, optional, default `False`

        :return: status code, 0 successful, otherwise failed
        :rtype: integer

        """
        if not isinstance(scol, (int, float)) or scol <= 0:
            print(f'The size of the output image along column direction must be numeral and positive')
            return
        
        if not isinstance(center, tuple) or len(center) !=2 or \
           not all(isinstance(x, (int, float)) for x in center):
            print(f'Invalid ADF detector center')
            return
        
        if not isinstance(rads, tuple) or len(rads) !=2 or \
           not all(isinstance(x, (int, float)) for x in rads) or \
           rads[0] == rads[1]:
            print(f'Invalid ADF detector inner and outer radius, it must be a pair of numerals')
            return
                   
        ret = ediom.getADF(imgfn, center[0], center[1], rads[0], rads[1], scol)
        if ret != 0:
            print(f'Failed to generate ADF image for experimental image {imgfn}')
            return
        
        if bShow:
            self.viewExpImage()
        
    

    target.indexExpDP = indexExpDP

    # DP database functions
    target.loadDPDB = loadDPDB
    target.peekDBDPAt = peekDBDPAt

    target.viewExpImage = viewExpImage
    target.showMatchedDBDP = showMatchedDBDP
    target.release_ediom = release_ediom
    target.printDPIndexDetails = printDPIndexDetails
    target.importSHExpImage = importSHExpImage
    target.importRawExpImage = importRawExpImage
    target.importExpImageFromNPY = importExpImageFromNPY

    target.showMatchingIndexMap = showMatchingIndexMap

    # Annular Dark Field
    target.generateADF = generateADF

    return target