# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['pysailfish',
 'pysailfish.app',
 'pysailfish.app.EAs',
 'pysailfish.internal',
 'pysailfish.internal.DataCtrl',
 'pysailfish.internal.DataCtrl.MT4DataCtrl',
 'pysailfish.internal.MT_EA',
 'pysailfish.internal.Network',
 'pysailfish.internal.devTools',
 'pysailfish.internal.observability',
 'pysailfish.internal.observability.logging_json',
 'pysailfish.internal.observability.logstash']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'pysailfish',
    'version': '1.11.0',
    'description': '',
    'long_description': '\n## pysailfish\n\n### Example EA --- simple client\n```python\nfrom pysailfish.internal.MT_EA.MT4_EA import MT4_EA\n\nclass MT4DemoEA(MT4_EA):\n    def __init__(self):\n        super().__init__()\n\n    # override\n    def _OnInit(self) -> int:\n        self._logger.info(self._user_inputs)\n        self._logger.info("Here")\n        return 0\n\n    # override\n    def _OnDeinit(self, reason: int) -> None:\n        self._logger.info(f"Here reason: {reason}")\n        return None\n\n    # override\n    def _OnTick(self) -> None:\n        self._logger.info("Here")\n        return None\n\n    # override\n    def _OnTimer(self) -> None:\n        return None\n\n    # override\n    def _OnTester(self) -> float:\n        self._logger.info("Here")\n        return 0.0\n\n    # override\n    def _OnChartEvent(self\n                      , id: int\n                      , lparam: int\n                      , dparam: float\n                      , sparam: str) -> None:\n        self._logger.info(f"Here id: {id} lparam: {lparam} dparam: {dparam} sparam: {sparam}")\n        return None\n\ndef main() -> None:\n    ea = MT4DemoEA()\n    ea.InitComponent(server_ip="127.0.0.1"\n                     , server_port=23456\n                     , ea_name="MT4DemoEA")\n    ea.StartEA()\n\nif __name__ == "__main__":\n    main()\n```\n\n### Example EA --- Moving Average EA\n```python\nfrom datetime import datetime\n\nimport pysailfish.internal.MT_EA.mt4_const as mc\nfrom pysailfish.internal.MT_EA.MT4_EA import MT4_EA\n\nclass MA_EA(MT4_EA):\n    def __init__(self):\n        super().__init__()\n\n    # override\n    def _OnInit(self) -> int:\n        self._logger.info(self._user_inputs)\n        self._logger.info("Here")\n        return 0\n\n    # override\n    def _OnDeinit(self, reason: int) -> None:\n        self._logger.info(f"Here reason: {reason}")\n        return None\n\n    # override\n    def _OnTick(self) -> None:\n        vv = self.iADX(symbol=self._pv.symbol\n                       , timeframe=mc.PERIOD_CURRENT\n                       , period=self._user_inputs["MovingPeriod"]\n                       , applied_price=mc.PRICE_CLOSE\n                       , mode=mc.MODE_MAIN\n                       , shift=0)\n        # self._logger.info(f"Here {self._pv.symbol} {self._pv.time[0]}")\n        # --- check for history and trading\n        if self._pv.bars < 100 or self._pv.is_trade_allowed == False:\n            return\n\n        # --- calculate open orders by current symbol\n        if self.__calculate_current_orders(self._pv.symbol) == 0:\n            self.__check_for_open()\n        else:\n            self.__check_for_close()\n        return None\n\n    # override\n    def _OnTimer(self) -> None:\n        return None\n\n    # override\n    def _OnTester(self) -> float:\n        self._logger.info("Here")\n        return 0.0\n\n    # override\n    def _OnChartEvent(self\n                      , id: int\n                      , lparam: int\n                      , dparam: float\n                      , sparam: str) -> None:\n        self._logger.info(f"Here id: {id} lparam: {lparam} dparam: {dparam} sparam: {sparam}")\n        return None\n\n    def __check_for_close(self) -> None:\n        ma: float = 0\n        #--- go trading only for first tiks of new bar\n        if self._pv.volume[0] > 1:\n            return None\n        #--- get Moving Average\n        ma = self.iMA(symbol=self._pv.symbol\n                      , timeframe=mc.PERIOD_CURRENT\n                      , ma_period=self._user_inputs["MovingPeriod"]\n                      , ma_shift=self._user_inputs["MovingShift"]\n                      , ma_method=mc.MODE_SMA\n                      , applied_price=mc.PRICE_CLOSE\n                      , shift=0)\n        #---\n        for i in range(self.OrdersTotal()):\n            if self.OrderSelect(index=i, select=mc.SELECT_BY_POS, pool=mc.MODE_TRADES) == False:\n                break\n            if self.OrderMagicNumber() != self._pv.magic_num or self.OrderSymbol() != self._pv.symbol:\n                continue\n            #--- check order type\n            if self.OrderType() == mc.OP_BUY:\n                if self._pv.open[1] > ma and self._pv.close[1] < ma:\n                    if not self.OrderClose(ticket=self.OrderTicket(), lots=self.OrderLots(), price=self._pv.bid, slippage=3, arrow_color=mc.clrWhite):\n                        self._logger.error(f"OrderClose error {self.GetLastError()}")\n                break\n            if self.OrderType() == mc.OP_SELL:\n                if self._pv.open[1] < ma and self._pv.close[1] > ma:\n                    if not self.OrderClose(ticket=self.OrderTicket(), lots=self.OrderLots(), price=self._pv.ask, slippage=3, arrow_color=mc.clrWhite):\n                        self._logger.error(f"OrderClose error {self.GetLastError()}");\n                break\n\n    def __lots_optimized(self) -> float:\n        lot: float = float(self._user_inputs["Lots"])\n        maximum_risk: float = float(self._user_inputs["MaximumRisk"])\n        decrease_factor: float = float(self._user_inputs["DecreaseFactor"])\n        orders: int = self.OrdersHistoryTotal() # history orders total\n        losses: int = 0 # number of losses orders without a break\n        #--- select lot size\n        lot = self.NormalizeDouble(value=(self.AccountFreeMargin() * maximum_risk / 1000.0), digits=1);\n        #--- calcuulate number of losses orders without a break\n        if decrease_factor > 0:\n            for i in reversed(range(orders)):\n                if self.OrderSelect(index=i, select=mc.SELECT_BY_POS, pool=mc.MODE_HISTORY) == False:\n                    self._logger.error("Error in history")\n                    break\n                if self.OrderSymbol() != self._pv.symbol or self.OrderType() > mc.OP_SELL:\n                    continue\n                #---\n                if self.OrderProfit() > 0:\n                    break\n                if self.OrderProfit() < 0:\n                    losses += 1\n            if losses > 1:\n                lot = self.NormalizeDouble(value=(lot - lot * losses / decrease_factor), digits=1)\n        #--- return lot size\n        if lot < 0.1:\n            lot = 0.1\n        return lot\n\n    def __check_for_open(self) -> None:\n        ma: float = 0\n        res: int = 0\n        #--- go trading only for first tiks of new bar\n        if self._pv.volume[0] > 1:\n            return None\n        #--- get Moving Average\n        ma = self.iMA(symbol=self._pv.symbol\n                      , timeframe=mc.PERIOD_CURRENT\n                      , ma_period=self._user_inputs["MovingPeriod"]\n                      , ma_shift=self._user_inputs["MovingShift"]\n                      , ma_method=mc.MODE_SMA\n                      , applied_price=mc.PRICE_CLOSE\n                      , shift=0)\n        #--- sell conditions\n        if self._pv.open[1] > ma and self._pv.close[1] < ma:\n            res = self.OrderSend(symbol=self._pv.symbol\n                                 , cmd=mc.OP_SELL\n                                 , volume=self.__lots_optimized()\n                                 , price=self._pv.bid\n                                 , slippage=3\n                                 , stoploss=0\n                                 , takeprofit=0\n                                 , comment=""\n                                 , magic=self._pv.magic_num\n                                 , expiration=datetime(1970, 1, 1, 0, 0, 0)\n                                 , arrow_color=mc.clrRed)\n            return None\n        #--- buy conditions\n        if self._pv.open[1] < ma and self._pv.close[1] > ma:\n            res = self.OrderSend(symbol=self._pv.symbol\n                                 , cmd=mc.OP_BUY\n                                 , volume=self.__lots_optimized()\n                                 , price=self._pv.ask\n                                 , slippage=3\n                                 , stoploss=0\n                                 , takeprofit=0\n                                 , comment=""\n                                 , magic=self._pv.magic_num\n                                 , expiration=datetime(1970, 1, 1, 0, 0, 0)\n                                 , arrow_color=mc.clrBlue)\n            return None\n\n    def __calculate_current_orders(self, symbol: str) -> int:\n        buys: int = 0\n        sells: int = 0\n        # ---\n        for i in range(self.OrdersTotal()):\n            if self._tf.order_select(index=i, select=mc.SELECT_BY_POS, pool=mc.MODE_TRADES) == False:\n                break\n            if self.OrderSymbol() == self._pv.symbol and self.OrderMagicNumber() == self._pv.magic_num:\n                if self.OrderType() == mc.OP_BUY:\n                    buys += 1\n                if self.OrderType() == mc.OP_SELL:\n                    sells += 1\n        # --- return orders volume\n        if buys > 0:\n            return buys\n        else:\n            return -sells\n\ndef main() -> None:\n    ea = MA_EA()\n    ea.InitComponent(server_ip="127.0.0.1"\n                     , server_port=23456\n                     , ea_name="MA_EA")\n    ea.StartEA()\n\nif __name__ == "__main__":\n    main()\n```\n\n### How to publish to pypi\n```bash\n# set up pypi token\n$ poetry config pypi-token.pypi my-token\n\n# build the project\n$ poetry build\n\n# publish the project\n$ poetry publish\n\n# DONE\n```\n',
    'author': 'SulfredLee',
    'author_email': 'sflee1112@gmail.com',
    'maintainer': 'None',
    'maintainer_email': 'None',
    'url': 'None',
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.8,<4.0',
}


setup(**setup_kwargs)
