# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import typing
import platform

# Used for default argument values
DEFAULT = object()


class RustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_int32),
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def alloc(size):
        return rust_call(_UniFFILib.ffi_rgb_lib_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return rust_call(_UniFFILib.ffi_rgb_lib_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return rust_call(_UniFFILib.ffi_rgb_lib_rustbuffer_free, self)

    def __str__(self):
        return "RustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def allocWithBuilder(*args):
        """Context-manger to allocate a buffer using a RustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = RustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consumeWithStream(self):
        """Context-manager to consume a buffer using a RustBufferStream.

        The RustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = RustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consumeWithStream")
        finally:
            self.free()

    @contextlib.contextmanager
    def readWithStream(self):
        """Context-manager to read a buffer using a RustBufferStream.

        This is like consumeWithStream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `RustBuffer` data.
        """
        s = RustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of readWithStream")

class ForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "ForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class RustBufferStream:
    """
    Helper for structured reading of bytes from a RustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def readI8(self):
        return self._unpack_from(1, ">b")

    def readU8(self):
        return self._unpack_from(1, ">B")

    def readI16(self):
        return self._unpack_from(2, ">h")

    def readU16(self):
        return self._unpack_from(2, ">H")

    def readI32(self):
        return self._unpack_from(4, ">i")

    def readU32(self):
        return self._unpack_from(4, ">I")

    def readI64(self):
        return self._unpack_from(8, ">q")

    def readU64(self):
        return self._unpack_from(8, ">Q")

    def readFloat(self):
        v = self._unpack_from(4, ">f")
        return v

    def readDouble(self):
        return self._unpack_from(8, ">d")

    def readCSizeT(self):
        return self._unpack_from(ctypes.sizeof(ctypes.c_size_t) , "@N")

class RustBufferBuilder:
    """
    Helper for structured writing of bytes into a RustBuffer.
    """

    def __init__(self):
        self.rbuf = RustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, numBytes):
        if self.rbuf.len + numBytes > self.rbuf.capacity:
            self.rbuf = RustBuffer.reserve(self.rbuf, numBytes)
        yield None
        self.rbuf.len += numBytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def writeI8(self, v):
        self._pack_into(1, ">b", v)

    def writeU8(self, v):
        self._pack_into(1, ">B", v)

    def writeI16(self, v):
        self._pack_into(2, ">h", v)

    def writeU16(self, v):
        self._pack_into(2, ">H", v)

    def writeI32(self, v):
        self._pack_into(4, ">i", v)

    def writeU32(self, v):
        self._pack_into(4, ">I", v)

    def writeI64(self, v):
        self._pack_into(8, ">q", v)

    def writeU64(self, v):
        self._pack_into(8, ">Q", v)

    def writeFloat(self, v):
        self._pack_into(4, ">f", v)

    def writeDouble(self, v):
        self._pack_into(8, ">d", v)

    def writeCSizeT(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class RustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", RustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_PANIC = 2

    def __str__(self):
        if self.code == RustCallStatus.CALL_SUCCESS:
            return "RustCallStatus(CALL_SUCCESS)"
        elif self.code == RustCallStatus.CALL_ERROR:
            return "RustCallStatus(CALL_ERROR)"
        elif self.code == RustCallStatus.CALL_PANIC:
            return "RustCallStatus(CALL_PANIC)"
        else:
            return "RustCallStatus(<invalid code>)"

def rust_call(fn, *args):
    # Call a rust function
    return rust_call_with_error(None, fn, *args)

def rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the FfiConverter for the error class that corresponds to the result.
    call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def rust_call_async(scaffolding_fn, callback_fn, *args):
    # Call the scaffolding function, passing it a callback handler for `AsyncTypes.py` and a pointer
    # to a python Future object.  The async function then awaits the Future.
    uniffi_eventloop = asyncio.get_running_loop()
    uniffi_py_future = uniffi_eventloop.create_future()
    uniffi_call_status = RustCallStatus(code=RustCallStatus.CALL_SUCCESS, error_buf=RustBuffer(0, 0, None))
    scaffolding_fn(*args,
       FfiConverterForeignExecutor._pointer_manager.new_pointer(uniffi_eventloop),
       callback_fn,
       # Note: It's tempting to skip the pointer manager and just use a `py_object` pointing to a
       # local variable like we do in Swift.  However, Python doesn't use cooperative cancellation
       # -- asyncio can cancel a task at anytime.  This means if we use a local variable, the Rust
       # callback could fire with a dangling pointer.
       UniFfiPyFuturePointerManager.new_pointer(uniffi_py_future),
       ctypes.byref(uniffi_call_status),
    )
    uniffi_check_call_status(None, uniffi_call_status)
    return uniffi_py_future

def uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == RustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == RustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == RustCallStatus.CALL_PANIC:
        # When the rust code sees a panic, it tries to construct a RustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = FfiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid RustCallStatus code: {}".format(
            call_status.code))

# A function pointer for a callback as defined by UniFFI.
# Rust definition `fn(handle: u64, method: u32, args: RustBuffer, buf_ptr: *mut RustBuffer) -> int`
FOREIGN_CALLBACK_T = ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_ulonglong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_char), ctypes.c_int, ctypes.POINTER(RustBuffer))
class UniFfiPointerManagerCPython:
    """
    Manage giving out pointers to Python objects on CPython

    This class is used to generate opaque pointers that reference Python objects to pass to Rust.
    It assumes a CPython platform.  See UniFfiPointerManagerGeneral for the alternative.
    """

    def new_pointer(self, obj):
        """
        Get a pointer for an object as a ctypes.c_size_t instance

        Each call to new_pointer() must be balanced with exactly one call to release_pointer()

        This returns a ctypes.c_size_t.  This is always the same size as a pointer and can be
        interchanged with pointers for FFI function arguments and return values.
        """
        # IncRef the object since we're going to pass a pointer to Rust
        ctypes.pythonapi.Py_IncRef(ctypes.py_object(obj))
        # id() is the object address on CPython
        # (https://docs.python.org/3/library/functions.html#id)
        return id(obj)

    def release_pointer(self, address):
        py_obj = ctypes.cast(address, ctypes.py_object)
        obj = py_obj.value
        ctypes.pythonapi.Py_DecRef(py_obj)
        return obj

    def lookup(self, address):
        return ctypes.cast(address, ctypes.py_object).value

class UniFfiPointerManagerGeneral:
    """
    Manage giving out pointers to Python objects on non-CPython platforms

    This has the same API as UniFfiPointerManagerCPython, but doesn't assume we're running on
    CPython and is slightly slower.

    Instead of using real pointers, it maps integer values to objects and returns the keys as
    c_size_t values.
    """

    def __init__(self):
        self._map = {}
        self._lock = threading.Lock()
        self._current_handle = 0

    def new_pointer(self, obj):
        with self._lock:
            handle = self._current_handle
            self._current_handle += 1
            self._map[handle] = obj
        return handle

    def release_pointer(self, handle):
        with self._lock:
            return self._map.pop(handle)

    def lookup(self, handle):
        with self._lock:
            return self._map[handle]

# Pick an pointer manager implementation based on the platform
if platform.python_implementation() == 'CPython':
    UniFfiPointerManager = UniFfiPointerManagerCPython  # type: ignore
else:
    UniFfiPointerManager = UniFfiPointerManagerGeneral  # type: ignore
# Types conforming to `FfiConverterPrimitive` pass themselves directly over the FFI.
class FfiConverterPrimitive:
    @classmethod
    def check(cls, value):
        return value

    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return cls.lowerUnchecked(cls.check(value))

    @classmethod
    def lowerUnchecked(cls, value):
        return value

    @classmethod
    def write(cls, value, buf):
        cls.writeUnchecked(cls.check(value), buf)

class FfiConverterPrimitiveInt(FfiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))
        return super().check(value)

class FfiConverterPrimitiveFloat(FfiConverterPrimitive):
    @classmethod
    def check(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))
        return super().check(value)

# Helper class for wrapper types that will always go through a RustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class FfiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consumeWithStream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with RustBuffer.allocWithBuilder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code,
# and the FFI Function declarations in a com.sun.jna.Library.
# Define some ctypes FFI types that we use in the library

"""
ctypes type for the foreign executor callback.  This is a built-in interface for scheduling
tasks

Args:
  executor: opaque c_size_t value representing the eventloop
  delay: delay in ms
  task: function pointer to the task callback
  task_data: void pointer to the task callback data

Normally we should call task(task_data) after the detail.
However, when task is NULL this indicates that Rust has dropped the ForeignExecutor and we should
decrease the EventLoop refcount.
"""
UNIFFI_FOREIGN_EXECUTOR_CALLBACK_T = ctypes.CFUNCTYPE(None, ctypes.c_size_t, ctypes.c_uint32, ctypes.c_void_p, ctypes.c_void_p)

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p)

def uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_size_t, return_type, RustCallStatus)

from pathlib import Path

def loadIndirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("rgblibffi")
    path = str(Path(__file__).parent / libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 22
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_rgb_lib_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def uniffi_check_api_checksums(lib):
    if lib.uniffi_rgb_lib_checksum_func_generate_keys() != 53799:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_func_restore_keys() != 43532:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_func_restore_backup() != 22749:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_transportendpoint_transport_type() != 38883:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_invoice_invoice_data() != 30838:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_invoice_invoice_string() != 902:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_backup() != 20993:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_backup_info() != 63633:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_blind_receive() != 17097:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_witness_receive() != 29684:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_sign_psbt() != 8305:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_create_utxos() != 31926:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_create_utxos_begin() != 4000:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_create_utxos_end() != 13912:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_delete_transfers() != 43012:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_drain_to() != 6563:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_drain_to_begin() != 40327:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_drain_to_end() != 26165:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_fail_transfers() != 16189:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_get_address() != 24678:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_get_asset_balance() != 64863:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_get_btc_balance() != 4173:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_get_asset_metadata() != 27386:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_go_online() != 37329:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_issue_asset_nia() != 9784:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_issue_asset_cfa() != 51998:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_list_assets() != 41445:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_list_transactions() != 41002:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_list_transfers() != 28091:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_list_unspents() != 48173:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_refresh() != 9624:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_send() != 27400:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_send_begin() != 9845:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_send_end() != 14109:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_method_wallet_send_btc() != 46442:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_constructor_blindedutxo_new() != 3614:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_constructor_transportendpoint_new() != 40664:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_constructor_invoice_new() != 29839:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_constructor_invoice_from_invoice_data() != 17537:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_rgb_lib_checksum_constructor_wallet_new() != 19115:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniFFILib = loadIndirect()
_UniFFILib.uniffi_rgb_lib_fn_free_blindedutxo.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_free_blindedutxo.restype = None
_UniFFILib.uniffi_rgb_lib_fn_constructor_blindedutxo_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_constructor_blindedutxo_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_rgb_lib_fn_free_transportendpoint.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_free_transportendpoint.restype = None
_UniFFILib.uniffi_rgb_lib_fn_constructor_transportendpoint_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_constructor_transportendpoint_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_rgb_lib_fn_method_transportendpoint_transport_type.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_transportendpoint_transport_type.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_free_invoice.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_free_invoice.restype = None
_UniFFILib.uniffi_rgb_lib_fn_constructor_invoice_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_constructor_invoice_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_rgb_lib_fn_constructor_invoice_from_invoice_data.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_constructor_invoice_from_invoice_data.restype = ctypes.c_void_p
_UniFFILib.uniffi_rgb_lib_fn_method_invoice_invoice_data.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_invoice_invoice_data.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_invoice_invoice_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_invoice_invoice_string.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_free_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_free_wallet.restype = None
_UniFFILib.uniffi_rgb_lib_fn_constructor_wallet_new.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_constructor_wallet_new.restype = ctypes.c_void_p
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_backup.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_backup.restype = None
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_backup_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_backup_info.restype = ctypes.c_int8
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_blind_receive.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_blind_receive.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_witness_receive.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_witness_receive.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_sign_psbt.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_sign_psbt.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_create_utxos.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_int8,
    RustBuffer,
    RustBuffer,
    ctypes.c_float,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_create_utxos.restype = ctypes.c_uint8
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_create_utxos_begin.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_int8,
    RustBuffer,
    RustBuffer,
    ctypes.c_float,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_create_utxos_begin.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_create_utxos_end.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_create_utxos_end.restype = ctypes.c_uint8
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_delete_transfers.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_delete_transfers.restype = ctypes.c_int8
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_drain_to.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.c_float,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_drain_to.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_drain_to_begin.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.c_float,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_drain_to_begin.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_drain_to_end.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_drain_to_end.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_fail_transfers.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_fail_transfers.restype = ctypes.c_int8
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_address.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_asset_balance.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_asset_balance.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_btc_balance.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_btc_balance.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_asset_metadata.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_asset_metadata.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_go_online.argtypes = (
    ctypes.c_void_p,
    ctypes.c_int8,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_go_online.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_issue_asset_nia.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.c_uint8,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_issue_asset_nia.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_issue_asset_cfa.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.c_uint8,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_issue_asset_cfa.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_assets.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_assets.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_transactions.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_transactions.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_transfers.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_transfers.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_unspents.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    ctypes.c_int8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_unspents.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_refresh.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_refresh.restype = ctypes.c_int8
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.c_float,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send_begin.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_int8,
    ctypes.c_float,
    ctypes.c_uint8,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send_begin.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send_end.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send_end.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send_btc.argtypes = (
    ctypes.c_void_p,
    RustBuffer,
    RustBuffer,
    ctypes.c_uint64,
    ctypes.c_float,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send_btc.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_func_generate_keys.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_func_generate_keys.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_func_restore_keys.argtypes = (
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_func_restore_keys.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_fn_func_restore_backup.argtypes = (
    RustBuffer,
    RustBuffer,
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.uniffi_rgb_lib_fn_func_restore_backup.restype = None
_UniFFILib.ffi_rgb_lib_rustbuffer_alloc.argtypes = (
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_rgb_lib_rustbuffer_alloc.restype = RustBuffer
_UniFFILib.ffi_rgb_lib_rustbuffer_from_bytes.argtypes = (
    ForeignBytes,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_rgb_lib_rustbuffer_from_bytes.restype = RustBuffer
_UniFFILib.ffi_rgb_lib_rustbuffer_free.argtypes = (
    RustBuffer,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_rgb_lib_rustbuffer_free.restype = None
_UniFFILib.ffi_rgb_lib_rustbuffer_reserve.argtypes = (
    RustBuffer,
    ctypes.c_int32,
    ctypes.POINTER(RustCallStatus),
)
_UniFFILib.ffi_rgb_lib_rustbuffer_reserve.restype = RustBuffer
_UniFFILib.uniffi_rgb_lib_checksum_func_generate_keys.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_func_generate_keys.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_func_restore_keys.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_func_restore_keys.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_func_restore_backup.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_func_restore_backup.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_transportendpoint_transport_type.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_transportendpoint_transport_type.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_invoice_invoice_data.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_invoice_invoice_data.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_invoice_invoice_string.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_invoice_invoice_string.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_backup.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_backup.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_backup_info.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_backup_info.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_blind_receive.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_blind_receive.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_witness_receive.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_witness_receive.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_sign_psbt.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_sign_psbt.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_create_utxos.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_create_utxos.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_create_utxos_begin.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_create_utxos_begin.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_create_utxos_end.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_create_utxos_end.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_delete_transfers.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_delete_transfers.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_drain_to.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_drain_to.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_drain_to_begin.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_drain_to_begin.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_drain_to_end.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_drain_to_end.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_fail_transfers.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_fail_transfers.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_get_address.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_get_address.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_get_asset_balance.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_get_asset_balance.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_get_btc_balance.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_get_btc_balance.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_get_asset_metadata.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_get_asset_metadata.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_go_online.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_go_online.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_issue_asset_nia.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_issue_asset_nia.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_issue_asset_cfa.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_issue_asset_cfa.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_list_assets.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_list_assets.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_list_transactions.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_list_transactions.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_list_transfers.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_list_transfers.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_list_unspents.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_list_unspents.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_refresh.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_refresh.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_send.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_send.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_send_begin.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_send_begin.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_send_end.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_send_end.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_send_btc.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_method_wallet_send_btc.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_constructor_blindedutxo_new.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_constructor_blindedutxo_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_constructor_transportendpoint_new.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_constructor_transportendpoint_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_constructor_invoice_new.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_constructor_invoice_new.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_constructor_invoice_from_invoice_data.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_constructor_invoice_from_invoice_data.restype = ctypes.c_uint16
_UniFFILib.uniffi_rgb_lib_checksum_constructor_wallet_new.argtypes = (
)
_UniFFILib.uniffi_rgb_lib_checksum_constructor_wallet_new.restype = ctypes.c_uint16
_UniFFILib.ffi_rgb_lib_uniffi_contract_version.argtypes = (
)
_UniFFILib.ffi_rgb_lib_uniffi_contract_version.restype = ctypes.c_uint32
uniffi_check_contract_api_version(_UniFFILib)
uniffi_check_api_checksums(_UniFFILib)

# Public interface members begin here.


class FfiConverterUInt8(FfiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.readU8()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeU8(value)

class FfiConverterUInt32(FfiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.readU32()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeU32(value)

class FfiConverterInt32(FfiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.readI32()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeI32(value)

class FfiConverterUInt64(FfiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.readU64()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeU64(value)

class FfiConverterInt64(FfiConverterPrimitiveInt):
    CLASS_NAME = "i64"
    VALUE_MIN = -2**63
    VALUE_MAX = 2**63

    @staticmethod
    def read(buf):
        return buf.readI64()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeI64(value)

class FfiConverterFloat(FfiConverterPrimitiveFloat):
    @staticmethod
    def read(buf):
        return buf.readFloat()

    @staticmethod
    def writeUnchecked(value, buf):
        buf.writeFloat(value)

class FfiConverterBool(FfiConverterPrimitive):
    @classmethod
    def check(cls, value):
        return not not value

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.readU8())

    @classmethod
    def writeUnchecked(cls, value, buf):
        buf.writeU8(value)

    @staticmethod
    def lift(value):
        return value != 0

class FfiConverterString:
    @staticmethod
    def check(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.readI32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8Bytes = buf.read(size)
        return utf8Bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        value = FfiConverterString.check(value)
        utf8Bytes = value.encode("utf-8")
        buf.writeI32(len(utf8Bytes))
        buf.write(utf8Bytes)

    @staticmethod
    def lift(buf):
        with buf.consumeWithStream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        value = FfiConverterString.check(value)
        with RustBuffer.allocWithBuilder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class BlindedUtxo:
    _pointer: ctypes.c_void_p
    def __init__(self, blinded_utxo: "str"):
        
        self._pointer = rust_call_with_error(FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_constructor_blindedutxo_new,
        FfiConverterString.lower(blinded_utxo))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_rgb_lib_fn_free_blindedutxo, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


class FfiConverterTypeBlindedUTXO:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, BlindedUtxo):
            raise TypeError("Expected BlindedUtxo instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return BlindedUtxo._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Invoice:
    _pointer: ctypes.c_void_p
    def __init__(self, invoice_string: "str"):
        
        self._pointer = rust_call_with_error(FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_constructor_invoice_new,
        FfiConverterString.lower(invoice_string))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_rgb_lib_fn_free_invoice, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_invoice_data(cls, invoice_data: "InvoiceData"):
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = rust_call_with_error(FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_constructor_invoice_from_invoice_data,
        FfiConverterTypeInvoiceData.lower(invoice_data))
        return cls._make_instance_(pointer)



    def invoice_data(self, ) -> "InvoiceData":
        return FfiConverterTypeInvoiceData.lift(
            rust_call(_UniFFILib.uniffi_rgb_lib_fn_method_invoice_invoice_data,self._pointer,)
        )






    def invoice_string(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call(_UniFFILib.uniffi_rgb_lib_fn_method_invoice_invoice_string,self._pointer,)
        )






class FfiConverterTypeInvoice:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Invoice):
            raise TypeError("Expected Invoice instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Invoice._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class TransportEndpoint:
    _pointer: ctypes.c_void_p
    def __init__(self, transport_endpoint: "str"):
        
        self._pointer = rust_call_with_error(FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_constructor_transportendpoint_new,
        FfiConverterString.lower(transport_endpoint))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_rgb_lib_fn_free_transportendpoint, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def transport_type(self, ) -> "TransportType":
        return FfiConverterTypeTransportType.lift(
            rust_call(_UniFFILib.uniffi_rgb_lib_fn_method_transportendpoint_transport_type,self._pointer,)
        )






class FfiConverterTypeTransportEndpoint:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, TransportEndpoint):
            raise TypeError("Expected TransportEndpoint instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return TransportEndpoint._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer



class Wallet:
    _pointer: ctypes.c_void_p
    def __init__(self, wallet_data: "WalletData"):
        
        self._pointer = rust_call_with_error(FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_constructor_wallet_new,
        FfiConverterTypeWalletData.lower(wallet_data))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            rust_call(_UniFFILib.uniffi_rgb_lib_fn_free_wallet, pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def backup(self, backup_path: "str",password: "str"):
        
        
        rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_backup,self._pointer,
        FfiConverterString.lower(backup_path),
        FfiConverterString.lower(password))







    def backup_info(self, ) -> "bool":
        return FfiConverterBool.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_backup_info,self._pointer,)
        )






    def blind_receive(self, asset_id: "typing.Optional[str]",amount: "typing.Optional[int]",duration_seconds: "typing.Optional[int]",transport_endpoints: "typing.List[str]",min_confirmations: "int") -> "ReceiveData":
        
        
        
        
        
        return FfiConverterTypeReceiveData.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_blind_receive,self._pointer,
        FfiConverterOptionalString.lower(asset_id),
        FfiConverterOptionalUInt64.lower(amount),
        FfiConverterOptionalUInt32.lower(duration_seconds),
        FfiConverterSequenceString.lower(transport_endpoints),
        FfiConverterUInt8.lower(min_confirmations))
        )






    def witness_receive(self, asset_id: "typing.Optional[str]",amount: "typing.Optional[int]",duration_seconds: "typing.Optional[int]",transport_endpoints: "typing.List[str]",min_confirmations: "int") -> "ReceiveData":
        
        
        
        
        
        return FfiConverterTypeReceiveData.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_witness_receive,self._pointer,
        FfiConverterOptionalString.lower(asset_id),
        FfiConverterOptionalUInt64.lower(amount),
        FfiConverterOptionalUInt32.lower(duration_seconds),
        FfiConverterSequenceString.lower(transport_endpoints),
        FfiConverterUInt8.lower(min_confirmations))
        )






    def sign_psbt(self, unsigned_psbt: "str") -> "str":
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_sign_psbt,self._pointer,
        FfiConverterString.lower(unsigned_psbt))
        )






    def create_utxos(self, online: "Online",up_to: "bool",num: "typing.Optional[int]",size: "typing.Optional[int]",fee_rate: "float") -> "int":
        
        
        
        
        
        return FfiConverterUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_create_utxos,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterBool.lower(up_to),
        FfiConverterOptionalUInt8.lower(num),
        FfiConverterOptionalUInt32.lower(size),
        FfiConverterFloat.lower(fee_rate))
        )






    def create_utxos_begin(self, online: "Online",up_to: "bool",num: "typing.Optional[int]",size: "typing.Optional[int]",fee_rate: "float") -> "str":
        
        
        
        
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_create_utxos_begin,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterBool.lower(up_to),
        FfiConverterOptionalUInt8.lower(num),
        FfiConverterOptionalUInt32.lower(size),
        FfiConverterFloat.lower(fee_rate))
        )






    def create_utxos_end(self, online: "Online",signed_psbt: "str") -> "int":
        
        
        return FfiConverterUInt8.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_create_utxos_end,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(signed_psbt))
        )






    def delete_transfers(self, blinded_utxo: "typing.Optional[str]",txid: "typing.Optional[str]",no_asset_only: "bool") -> "bool":
        
        
        
        return FfiConverterBool.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_delete_transfers,self._pointer,
        FfiConverterOptionalString.lower(blinded_utxo),
        FfiConverterOptionalString.lower(txid),
        FfiConverterBool.lower(no_asset_only))
        )






    def drain_to(self, online: "Online",address: "str",destroy_assets: "bool",fee_rate: "float") -> "str":
        
        
        
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_drain_to,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(address),
        FfiConverterBool.lower(destroy_assets),
        FfiConverterFloat.lower(fee_rate))
        )






    def drain_to_begin(self, online: "Online",address: "str",destroy_assets: "bool",fee_rate: "float") -> "str":
        
        
        
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_drain_to_begin,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(address),
        FfiConverterBool.lower(destroy_assets),
        FfiConverterFloat.lower(fee_rate))
        )






    def drain_to_end(self, online: "Online",signed_psbt: "str") -> "str":
        
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_drain_to_end,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(signed_psbt))
        )






    def fail_transfers(self, online: "Online",blinded_utxo: "typing.Optional[str]",txid: "typing.Optional[str]",no_asset_only: "bool") -> "bool":
        
        
        
        
        return FfiConverterBool.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_fail_transfers,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterOptionalString.lower(blinded_utxo),
        FfiConverterOptionalString.lower(txid),
        FfiConverterBool.lower(no_asset_only))
        )






    def get_address(self, ) -> "str":
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_address,self._pointer,)
        )






    def get_asset_balance(self, asset_id: "str") -> "Balance":
        
        return FfiConverterTypeBalance.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_asset_balance,self._pointer,
        FfiConverterString.lower(asset_id))
        )






    def get_btc_balance(self, online: "Online") -> "BtcBalance":
        
        return FfiConverterTypeBtcBalance.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_btc_balance,self._pointer,
        FfiConverterTypeOnline.lower(online))
        )






    def get_asset_metadata(self, asset_id: "str") -> "Metadata":
        
        return FfiConverterTypeMetadata.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_get_asset_metadata,self._pointer,
        FfiConverterString.lower(asset_id))
        )






    def go_online(self, skip_consistency_check: "bool",electrum_url: "str") -> "Online":
        
        
        return FfiConverterTypeOnline.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_go_online,self._pointer,
        FfiConverterBool.lower(skip_consistency_check),
        FfiConverterString.lower(electrum_url))
        )






    def issue_asset_nia(self, online: "Online",ticker: "str",name: "str",precision: "int",amounts: "typing.List[int]") -> "AssetNia":
        
        
        
        
        
        return FfiConverterTypeAssetNIA.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_issue_asset_nia,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(ticker),
        FfiConverterString.lower(name),
        FfiConverterUInt8.lower(precision),
        FfiConverterSequenceUInt64.lower(amounts))
        )






    def issue_asset_cfa(self, online: "Online",name: "str",description: "typing.Optional[str]",precision: "int",amounts: "typing.List[int]",file_path: "typing.Optional[str]") -> "AssetCfa":
        
        
        
        
        
        
        return FfiConverterTypeAssetCFA.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_issue_asset_cfa,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(name),
        FfiConverterOptionalString.lower(description),
        FfiConverterUInt8.lower(precision),
        FfiConverterSequenceUInt64.lower(amounts),
        FfiConverterOptionalString.lower(file_path))
        )






    def list_assets(self, filter_asset_schemas: "typing.List[AssetSchema]") -> "Assets":
        
        return FfiConverterTypeAssets.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_assets,self._pointer,
        FfiConverterSequenceTypeAssetSchema.lower(filter_asset_schemas))
        )






    def list_transactions(self, online: "typing.Optional[Online]") -> "typing.List[Transaction]":
        
        return FfiConverterSequenceTypeTransaction.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_transactions,self._pointer,
        FfiConverterOptionalTypeOnline.lower(online))
        )






    def list_transfers(self, asset_id: "typing.Optional[str]") -> "typing.List[Transfer]":
        
        return FfiConverterSequenceTypeTransfer.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_transfers,self._pointer,
        FfiConverterOptionalString.lower(asset_id))
        )






    def list_unspents(self, online: "typing.Optional[Online]",settled_only: "bool") -> "typing.List[Unspent]":
        
        
        return FfiConverterSequenceTypeUnspent.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_list_unspents,self._pointer,
        FfiConverterOptionalTypeOnline.lower(online),
        FfiConverterBool.lower(settled_only))
        )






    def refresh(self, online: "Online",asset_id: "typing.Optional[str]",filter: "typing.List[RefreshFilter]") -> "bool":
        
        
        
        return FfiConverterBool.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_refresh,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterOptionalString.lower(asset_id),
        FfiConverterSequenceTypeRefreshFilter.lower(filter))
        )






    def send(self, online: "Online",recipient_map: "dict",donation: "bool",fee_rate: "float",min_confirmations: "int") -> "str":
        
        
        
        
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterMapStringSequenceTypeRecipient.lower(recipient_map),
        FfiConverterBool.lower(donation),
        FfiConverterFloat.lower(fee_rate),
        FfiConverterUInt8.lower(min_confirmations))
        )






    def send_begin(self, online: "Online",recipient_map: "dict",donation: "bool",fee_rate: "float",min_confirmations: "int") -> "str":
        
        
        
        
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send_begin,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterMapStringSequenceTypeRecipient.lower(recipient_map),
        FfiConverterBool.lower(donation),
        FfiConverterFloat.lower(fee_rate),
        FfiConverterUInt8.lower(min_confirmations))
        )






    def send_end(self, online: "Online",signed_psbt: "str") -> "str":
        
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send_end,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(signed_psbt))
        )






    def send_btc(self, online: "Online",address: "str",amount: "int",fee_rate: "float") -> "str":
        
        
        
        
        return FfiConverterString.lift(
            rust_call_with_error(
    FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_method_wallet_send_btc,self._pointer,
        FfiConverterTypeOnline.lower(online),
        FfiConverterString.lower(address),
        FfiConverterUInt64.lower(amount),
        FfiConverterFloat.lower(fee_rate))
        )






class FfiConverterTypeWallet:
    @classmethod
    def read(cls, buf):
        ptr = buf.readU64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value, buf):
        if not isinstance(value, Wallet):
            raise TypeError("Expected Wallet instance, {} found".format(value.__class__.__name__))
        buf.writeU64(cls.lower(value))

    @staticmethod
    def lift(value):
        return Wallet._make_instance_(value)

    @staticmethod
    def lower(value):
        return value._pointer


class AssetCfa:

    def __init__(self, asset_id, asset_iface, name, description, precision, issued_supply, timestamp, added_at, balance, data_paths):
        self.asset_id = asset_id
        self.asset_iface = asset_iface
        self.name = name
        self.description = description
        self.precision = precision
        self.issued_supply = issued_supply
        self.timestamp = timestamp
        self.added_at = added_at
        self.balance = balance
        self.data_paths = data_paths

    def __str__(self):
        return "AssetCfa(asset_id={}, asset_iface={}, name={}, description={}, precision={}, issued_supply={}, timestamp={}, added_at={}, balance={}, data_paths={})".format(self.asset_id, self.asset_iface, self.name, self.description, self.precision, self.issued_supply, self.timestamp, self.added_at, self.balance, self.data_paths)

    def __eq__(self, other):
        if self.asset_id != other.asset_id:
            return False
        if self.asset_iface != other.asset_iface:
            return False
        if self.name != other.name:
            return False
        if self.description != other.description:
            return False
        if self.precision != other.precision:
            return False
        if self.issued_supply != other.issued_supply:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.added_at != other.added_at:
            return False
        if self.balance != other.balance:
            return False
        if self.data_paths != other.data_paths:
            return False
        return True

class FfiConverterTypeAssetCFA(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetCfa(
            asset_id=FfiConverterString.read(buf),
            asset_iface=FfiConverterTypeAssetIface.read(buf),
            name=FfiConverterString.read(buf),
            description=FfiConverterOptionalString.read(buf),
            precision=FfiConverterUInt8.read(buf),
            issued_supply=FfiConverterUInt64.read(buf),
            timestamp=FfiConverterInt64.read(buf),
            added_at=FfiConverterInt64.read(buf),
            balance=FfiConverterTypeBalance.read(buf),
            data_paths=FfiConverterSequenceTypeMedia.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.asset_id, buf)
        FfiConverterTypeAssetIface.write(value.asset_iface, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterOptionalString.write(value.description, buf)
        FfiConverterUInt8.write(value.precision, buf)
        FfiConverterUInt64.write(value.issued_supply, buf)
        FfiConverterInt64.write(value.timestamp, buf)
        FfiConverterInt64.write(value.added_at, buf)
        FfiConverterTypeBalance.write(value.balance, buf)
        FfiConverterSequenceTypeMedia.write(value.data_paths, buf)


class AssetNia:

    def __init__(self, asset_id, asset_iface, ticker, name, precision, issued_supply, timestamp, added_at, balance, data_paths):
        self.asset_id = asset_id
        self.asset_iface = asset_iface
        self.ticker = ticker
        self.name = name
        self.precision = precision
        self.issued_supply = issued_supply
        self.timestamp = timestamp
        self.added_at = added_at
        self.balance = balance
        self.data_paths = data_paths

    def __str__(self):
        return "AssetNia(asset_id={}, asset_iface={}, ticker={}, name={}, precision={}, issued_supply={}, timestamp={}, added_at={}, balance={}, data_paths={})".format(self.asset_id, self.asset_iface, self.ticker, self.name, self.precision, self.issued_supply, self.timestamp, self.added_at, self.balance, self.data_paths)

    def __eq__(self, other):
        if self.asset_id != other.asset_id:
            return False
        if self.asset_iface != other.asset_iface:
            return False
        if self.ticker != other.ticker:
            return False
        if self.name != other.name:
            return False
        if self.precision != other.precision:
            return False
        if self.issued_supply != other.issued_supply:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.added_at != other.added_at:
            return False
        if self.balance != other.balance:
            return False
        if self.data_paths != other.data_paths:
            return False
        return True

class FfiConverterTypeAssetNIA(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AssetNia(
            asset_id=FfiConverterString.read(buf),
            asset_iface=FfiConverterTypeAssetIface.read(buf),
            ticker=FfiConverterString.read(buf),
            name=FfiConverterString.read(buf),
            precision=FfiConverterUInt8.read(buf),
            issued_supply=FfiConverterUInt64.read(buf),
            timestamp=FfiConverterInt64.read(buf),
            added_at=FfiConverterInt64.read(buf),
            balance=FfiConverterTypeBalance.read(buf),
            data_paths=FfiConverterSequenceTypeMedia.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.asset_id, buf)
        FfiConverterTypeAssetIface.write(value.asset_iface, buf)
        FfiConverterString.write(value.ticker, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterUInt8.write(value.precision, buf)
        FfiConverterUInt64.write(value.issued_supply, buf)
        FfiConverterInt64.write(value.timestamp, buf)
        FfiConverterInt64.write(value.added_at, buf)
        FfiConverterTypeBalance.write(value.balance, buf)
        FfiConverterSequenceTypeMedia.write(value.data_paths, buf)


class Assets:

    def __init__(self, nia, cfa):
        self.nia = nia
        self.cfa = cfa

    def __str__(self):
        return "Assets(nia={}, cfa={})".format(self.nia, self.cfa)

    def __eq__(self, other):
        if self.nia != other.nia:
            return False
        if self.cfa != other.cfa:
            return False
        return True

class FfiConverterTypeAssets(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Assets(
            nia=FfiConverterOptionalSequenceTypeAssetNIA.read(buf),
            cfa=FfiConverterOptionalSequenceTypeAssetCFA.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalSequenceTypeAssetNIA.write(value.nia, buf)
        FfiConverterOptionalSequenceTypeAssetCFA.write(value.cfa, buf)


class Balance:

    def __init__(self, settled, future, spendable):
        self.settled = settled
        self.future = future
        self.spendable = spendable

    def __str__(self):
        return "Balance(settled={}, future={}, spendable={})".format(self.settled, self.future, self.spendable)

    def __eq__(self, other):
        if self.settled != other.settled:
            return False
        if self.future != other.future:
            return False
        if self.spendable != other.spendable:
            return False
        return True

class FfiConverterTypeBalance(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Balance(
            settled=FfiConverterUInt64.read(buf),
            future=FfiConverterUInt64.read(buf),
            spendable=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.settled, buf)
        FfiConverterUInt64.write(value.future, buf)
        FfiConverterUInt64.write(value.spendable, buf)


class BlockTime:

    def __init__(self, height, timestamp):
        self.height = height
        self.timestamp = timestamp

    def __str__(self):
        return "BlockTime(height={}, timestamp={})".format(self.height, self.timestamp)

    def __eq__(self, other):
        if self.height != other.height:
            return False
        if self.timestamp != other.timestamp:
            return False
        return True

class FfiConverterTypeBlockTime(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BlockTime(
            height=FfiConverterUInt32.read(buf),
            timestamp=FfiConverterUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt32.write(value.height, buf)
        FfiConverterUInt64.write(value.timestamp, buf)


class BtcBalance:

    def __init__(self, vanilla, colored):
        self.vanilla = vanilla
        self.colored = colored

    def __str__(self):
        return "BtcBalance(vanilla={}, colored={})".format(self.vanilla, self.colored)

    def __eq__(self, other):
        if self.vanilla != other.vanilla:
            return False
        if self.colored != other.colored:
            return False
        return True

class FfiConverterTypeBtcBalance(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BtcBalance(
            vanilla=FfiConverterTypeBalance.read(buf),
            colored=FfiConverterTypeBalance.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeBalance.write(value.vanilla, buf)
        FfiConverterTypeBalance.write(value.colored, buf)


class InvoiceData:

    def __init__(self, recipient_id, asset_iface, asset_id, amount, network, expiration_timestamp, transport_endpoints):
        self.recipient_id = recipient_id
        self.asset_iface = asset_iface
        self.asset_id = asset_id
        self.amount = amount
        self.network = network
        self.expiration_timestamp = expiration_timestamp
        self.transport_endpoints = transport_endpoints

    def __str__(self):
        return "InvoiceData(recipient_id={}, asset_iface={}, asset_id={}, amount={}, network={}, expiration_timestamp={}, transport_endpoints={})".format(self.recipient_id, self.asset_iface, self.asset_id, self.amount, self.network, self.expiration_timestamp, self.transport_endpoints)

    def __eq__(self, other):
        if self.recipient_id != other.recipient_id:
            return False
        if self.asset_iface != other.asset_iface:
            return False
        if self.asset_id != other.asset_id:
            return False
        if self.amount != other.amount:
            return False
        if self.network != other.network:
            return False
        if self.expiration_timestamp != other.expiration_timestamp:
            return False
        if self.transport_endpoints != other.transport_endpoints:
            return False
        return True

class FfiConverterTypeInvoiceData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InvoiceData(
            recipient_id=FfiConverterString.read(buf),
            asset_iface=FfiConverterOptionalTypeAssetIface.read(buf),
            asset_id=FfiConverterOptionalString.read(buf),
            amount=FfiConverterOptionalUInt64.read(buf),
            network=FfiConverterOptionalTypeBitcoinNetwork.read(buf),
            expiration_timestamp=FfiConverterOptionalInt64.read(buf),
            transport_endpoints=FfiConverterSequenceString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.recipient_id, buf)
        FfiConverterOptionalTypeAssetIface.write(value.asset_iface, buf)
        FfiConverterOptionalString.write(value.asset_id, buf)
        FfiConverterOptionalUInt64.write(value.amount, buf)
        FfiConverterOptionalTypeBitcoinNetwork.write(value.network, buf)
        FfiConverterOptionalInt64.write(value.expiration_timestamp, buf)
        FfiConverterSequenceString.write(value.transport_endpoints, buf)


class Keys:

    def __init__(self, mnemonic, xpub, xpub_fingerprint):
        self.mnemonic = mnemonic
        self.xpub = xpub
        self.xpub_fingerprint = xpub_fingerprint

    def __str__(self):
        return "Keys(mnemonic={}, xpub={}, xpub_fingerprint={})".format(self.mnemonic, self.xpub, self.xpub_fingerprint)

    def __eq__(self, other):
        if self.mnemonic != other.mnemonic:
            return False
        if self.xpub != other.xpub:
            return False
        if self.xpub_fingerprint != other.xpub_fingerprint:
            return False
        return True

class FfiConverterTypeKeys(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Keys(
            mnemonic=FfiConverterString.read(buf),
            xpub=FfiConverterString.read(buf),
            xpub_fingerprint=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.mnemonic, buf)
        FfiConverterString.write(value.xpub, buf)
        FfiConverterString.write(value.xpub_fingerprint, buf)


class Media:

    def __init__(self, file_path, mime):
        self.file_path = file_path
        self.mime = mime

    def __str__(self):
        return "Media(file_path={}, mime={})".format(self.file_path, self.mime)

    def __eq__(self, other):
        if self.file_path != other.file_path:
            return False
        if self.mime != other.mime:
            return False
        return True

class FfiConverterTypeMedia(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Media(
            file_path=FfiConverterString.read(buf),
            mime=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.file_path, buf)
        FfiConverterString.write(value.mime, buf)


class Metadata:

    def __init__(self, asset_iface, asset_schema, issued_supply, timestamp, name, precision, ticker, description):
        self.asset_iface = asset_iface
        self.asset_schema = asset_schema
        self.issued_supply = issued_supply
        self.timestamp = timestamp
        self.name = name
        self.precision = precision
        self.ticker = ticker
        self.description = description

    def __str__(self):
        return "Metadata(asset_iface={}, asset_schema={}, issued_supply={}, timestamp={}, name={}, precision={}, ticker={}, description={})".format(self.asset_iface, self.asset_schema, self.issued_supply, self.timestamp, self.name, self.precision, self.ticker, self.description)

    def __eq__(self, other):
        if self.asset_iface != other.asset_iface:
            return False
        if self.asset_schema != other.asset_schema:
            return False
        if self.issued_supply != other.issued_supply:
            return False
        if self.timestamp != other.timestamp:
            return False
        if self.name != other.name:
            return False
        if self.precision != other.precision:
            return False
        if self.ticker != other.ticker:
            return False
        if self.description != other.description:
            return False
        return True

class FfiConverterTypeMetadata(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Metadata(
            asset_iface=FfiConverterTypeAssetIface.read(buf),
            asset_schema=FfiConverterTypeAssetSchema.read(buf),
            issued_supply=FfiConverterUInt64.read(buf),
            timestamp=FfiConverterInt64.read(buf),
            name=FfiConverterString.read(buf),
            precision=FfiConverterUInt8.read(buf),
            ticker=FfiConverterOptionalString.read(buf),
            description=FfiConverterOptionalString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeAssetIface.write(value.asset_iface, buf)
        FfiConverterTypeAssetSchema.write(value.asset_schema, buf)
        FfiConverterUInt64.write(value.issued_supply, buf)
        FfiConverterInt64.write(value.timestamp, buf)
        FfiConverterString.write(value.name, buf)
        FfiConverterUInt8.write(value.precision, buf)
        FfiConverterOptionalString.write(value.ticker, buf)
        FfiConverterOptionalString.write(value.description, buf)


class Online:

    def __init__(self, id, electrum_url):
        self.id = id
        self.electrum_url = electrum_url

    def __str__(self):
        return "Online(id={}, electrum_url={})".format(self.id, self.electrum_url)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.electrum_url != other.electrum_url:
            return False
        return True

class FfiConverterTypeOnline(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Online(
            id=FfiConverterUInt64.read(buf),
            electrum_url=FfiConverterString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterUInt64.write(value.id, buf)
        FfiConverterString.write(value.electrum_url, buf)


class Outpoint:

    def __init__(self, txid, vout):
        self.txid = txid
        self.vout = vout

    def __str__(self):
        return "Outpoint(txid={}, vout={})".format(self.txid, self.vout)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.vout != other.vout:
            return False
        return True

class FfiConverterTypeOutpoint(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Outpoint(
            txid=FfiConverterString.read(buf),
            vout=FfiConverterUInt32.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.txid, buf)
        FfiConverterUInt32.write(value.vout, buf)


class ReceiveData:

    def __init__(self, invoice, recipient_id, expiration_timestamp):
        self.invoice = invoice
        self.recipient_id = recipient_id
        self.expiration_timestamp = expiration_timestamp

    def __str__(self):
        return "ReceiveData(invoice={}, recipient_id={}, expiration_timestamp={})".format(self.invoice, self.recipient_id, self.expiration_timestamp)

    def __eq__(self, other):
        if self.invoice != other.invoice:
            return False
        if self.recipient_id != other.recipient_id:
            return False
        if self.expiration_timestamp != other.expiration_timestamp:
            return False
        return True

class FfiConverterTypeReceiveData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceiveData(
            invoice=FfiConverterString.read(buf),
            recipient_id=FfiConverterString.read(buf),
            expiration_timestamp=FfiConverterOptionalInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.invoice, buf)
        FfiConverterString.write(value.recipient_id, buf)
        FfiConverterOptionalInt64.write(value.expiration_timestamp, buf)


class Recipient:

    def __init__(self, blinded_utxo, script_data, amount, transport_endpoints):
        self.blinded_utxo = blinded_utxo
        self.script_data = script_data
        self.amount = amount
        self.transport_endpoints = transport_endpoints

    def __str__(self):
        return "Recipient(blinded_utxo={}, script_data={}, amount={}, transport_endpoints={})".format(self.blinded_utxo, self.script_data, self.amount, self.transport_endpoints)

    def __eq__(self, other):
        if self.blinded_utxo != other.blinded_utxo:
            return False
        if self.script_data != other.script_data:
            return False
        if self.amount != other.amount:
            return False
        if self.transport_endpoints != other.transport_endpoints:
            return False
        return True

class FfiConverterTypeRecipient(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Recipient(
            blinded_utxo=FfiConverterOptionalString.read(buf),
            script_data=FfiConverterOptionalTypeScriptData.read(buf),
            amount=FfiConverterUInt64.read(buf),
            transport_endpoints=FfiConverterSequenceString.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalString.write(value.blinded_utxo, buf)
        FfiConverterOptionalTypeScriptData.write(value.script_data, buf)
        FfiConverterUInt64.write(value.amount, buf)
        FfiConverterSequenceString.write(value.transport_endpoints, buf)


class RefreshFilter:

    def __init__(self, status, incoming):
        self.status = status
        self.incoming = incoming

    def __str__(self):
        return "RefreshFilter(status={}, incoming={})".format(self.status, self.incoming)

    def __eq__(self, other):
        if self.status != other.status:
            return False
        if self.incoming != other.incoming:
            return False
        return True

class FfiConverterTypeRefreshFilter(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RefreshFilter(
            status=FfiConverterTypeRefreshTransferStatus.read(buf),
            incoming=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeRefreshTransferStatus.write(value.status, buf)
        FfiConverterBool.write(value.incoming, buf)


class RgbAllocation:

    def __init__(self, asset_id, amount, settled):
        self.asset_id = asset_id
        self.amount = amount
        self.settled = settled

    def __str__(self):
        return "RgbAllocation(asset_id={}, amount={}, settled={})".format(self.asset_id, self.amount, self.settled)

    def __eq__(self, other):
        if self.asset_id != other.asset_id:
            return False
        if self.amount != other.amount:
            return False
        if self.settled != other.settled:
            return False
        return True

class FfiConverterTypeRgbAllocation(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return RgbAllocation(
            asset_id=FfiConverterOptionalString.read(buf),
            amount=FfiConverterUInt64.read(buf),
            settled=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterOptionalString.write(value.asset_id, buf)
        FfiConverterUInt64.write(value.amount, buf)
        FfiConverterBool.write(value.settled, buf)


class ScriptData:

    def __init__(self, script, amount_sat, blinding):
        self.script = script
        self.amount_sat = amount_sat
        self.blinding = blinding

    def __str__(self):
        return "ScriptData(script={}, amount_sat={}, blinding={})".format(self.script, self.amount_sat, self.blinding)

    def __eq__(self, other):
        if self.script != other.script:
            return False
        if self.amount_sat != other.amount_sat:
            return False
        if self.blinding != other.blinding:
            return False
        return True

class FfiConverterTypeScriptData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ScriptData(
            script=FfiConverterString.read(buf),
            amount_sat=FfiConverterUInt64.read(buf),
            blinding=FfiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.script, buf)
        FfiConverterUInt64.write(value.amount_sat, buf)
        FfiConverterOptionalUInt64.write(value.blinding, buf)


class Transaction:

    def __init__(self, transaction_type, txid, received, sent, fee, confirmation_time):
        self.transaction_type = transaction_type
        self.txid = txid
        self.received = received
        self.sent = sent
        self.fee = fee
        self.confirmation_time = confirmation_time

    def __str__(self):
        return "Transaction(transaction_type={}, txid={}, received={}, sent={}, fee={}, confirmation_time={})".format(self.transaction_type, self.txid, self.received, self.sent, self.fee, self.confirmation_time)

    def __eq__(self, other):
        if self.transaction_type != other.transaction_type:
            return False
        if self.txid != other.txid:
            return False
        if self.received != other.received:
            return False
        if self.sent != other.sent:
            return False
        if self.fee != other.fee:
            return False
        if self.confirmation_time != other.confirmation_time:
            return False
        return True

class FfiConverterTypeTransaction(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Transaction(
            transaction_type=FfiConverterTypeTransactionType.read(buf),
            txid=FfiConverterString.read(buf),
            received=FfiConverterUInt64.read(buf),
            sent=FfiConverterUInt64.read(buf),
            fee=FfiConverterOptionalUInt64.read(buf),
            confirmation_time=FfiConverterOptionalTypeBlockTime.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeTransactionType.write(value.transaction_type, buf)
        FfiConverterString.write(value.txid, buf)
        FfiConverterUInt64.write(value.received, buf)
        FfiConverterUInt64.write(value.sent, buf)
        FfiConverterOptionalUInt64.write(value.fee, buf)
        FfiConverterOptionalTypeBlockTime.write(value.confirmation_time, buf)


class Transfer:

    def __init__(self, idx, created_at, updated_at, status, amount, kind, txid, recipient_id, receive_utxo, change_utxo, expiration, transport_endpoints):
        self.idx = idx
        self.created_at = created_at
        self.updated_at = updated_at
        self.status = status
        self.amount = amount
        self.kind = kind
        self.txid = txid
        self.recipient_id = recipient_id
        self.receive_utxo = receive_utxo
        self.change_utxo = change_utxo
        self.expiration = expiration
        self.transport_endpoints = transport_endpoints

    def __str__(self):
        return "Transfer(idx={}, created_at={}, updated_at={}, status={}, amount={}, kind={}, txid={}, recipient_id={}, receive_utxo={}, change_utxo={}, expiration={}, transport_endpoints={})".format(self.idx, self.created_at, self.updated_at, self.status, self.amount, self.kind, self.txid, self.recipient_id, self.receive_utxo, self.change_utxo, self.expiration, self.transport_endpoints)

    def __eq__(self, other):
        if self.idx != other.idx:
            return False
        if self.created_at != other.created_at:
            return False
        if self.updated_at != other.updated_at:
            return False
        if self.status != other.status:
            return False
        if self.amount != other.amount:
            return False
        if self.kind != other.kind:
            return False
        if self.txid != other.txid:
            return False
        if self.recipient_id != other.recipient_id:
            return False
        if self.receive_utxo != other.receive_utxo:
            return False
        if self.change_utxo != other.change_utxo:
            return False
        if self.expiration != other.expiration:
            return False
        if self.transport_endpoints != other.transport_endpoints:
            return False
        return True

class FfiConverterTypeTransfer(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Transfer(
            idx=FfiConverterInt32.read(buf),
            created_at=FfiConverterInt64.read(buf),
            updated_at=FfiConverterInt64.read(buf),
            status=FfiConverterTypeTransferStatus.read(buf),
            amount=FfiConverterUInt64.read(buf),
            kind=FfiConverterTypeTransferKind.read(buf),
            txid=FfiConverterOptionalString.read(buf),
            recipient_id=FfiConverterOptionalString.read(buf),
            receive_utxo=FfiConverterOptionalTypeOutpoint.read(buf),
            change_utxo=FfiConverterOptionalTypeOutpoint.read(buf),
            expiration=FfiConverterOptionalInt64.read(buf),
            transport_endpoints=FfiConverterSequenceTypeTransferTransportEndpoint.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterInt32.write(value.idx, buf)
        FfiConverterInt64.write(value.created_at, buf)
        FfiConverterInt64.write(value.updated_at, buf)
        FfiConverterTypeTransferStatus.write(value.status, buf)
        FfiConverterUInt64.write(value.amount, buf)
        FfiConverterTypeTransferKind.write(value.kind, buf)
        FfiConverterOptionalString.write(value.txid, buf)
        FfiConverterOptionalString.write(value.recipient_id, buf)
        FfiConverterOptionalTypeOutpoint.write(value.receive_utxo, buf)
        FfiConverterOptionalTypeOutpoint.write(value.change_utxo, buf)
        FfiConverterOptionalInt64.write(value.expiration, buf)
        FfiConverterSequenceTypeTransferTransportEndpoint.write(value.transport_endpoints, buf)


class TransferTransportEndpoint:

    def __init__(self, endpoint, transport_type, used):
        self.endpoint = endpoint
        self.transport_type = transport_type
        self.used = used

    def __str__(self):
        return "TransferTransportEndpoint(endpoint={}, transport_type={}, used={})".format(self.endpoint, self.transport_type, self.used)

    def __eq__(self, other):
        if self.endpoint != other.endpoint:
            return False
        if self.transport_type != other.transport_type:
            return False
        if self.used != other.used:
            return False
        return True

class FfiConverterTypeTransferTransportEndpoint(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TransferTransportEndpoint(
            endpoint=FfiConverterString.read(buf),
            transport_type=FfiConverterTypeTransportType.read(buf),
            used=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.endpoint, buf)
        FfiConverterTypeTransportType.write(value.transport_type, buf)
        FfiConverterBool.write(value.used, buf)


class Unspent:

    def __init__(self, utxo, rgb_allocations):
        self.utxo = utxo
        self.rgb_allocations = rgb_allocations

    def __str__(self):
        return "Unspent(utxo={}, rgb_allocations={})".format(self.utxo, self.rgb_allocations)

    def __eq__(self, other):
        if self.utxo != other.utxo:
            return False
        if self.rgb_allocations != other.rgb_allocations:
            return False
        return True

class FfiConverterTypeUnspent(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Unspent(
            utxo=FfiConverterTypeUtxo.read(buf),
            rgb_allocations=FfiConverterSequenceTypeRgbAllocation.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeUtxo.write(value.utxo, buf)
        FfiConverterSequenceTypeRgbAllocation.write(value.rgb_allocations, buf)


class Utxo:

    def __init__(self, outpoint, btc_amount, colorable):
        self.outpoint = outpoint
        self.btc_amount = btc_amount
        self.colorable = colorable

    def __str__(self):
        return "Utxo(outpoint={}, btc_amount={}, colorable={})".format(self.outpoint, self.btc_amount, self.colorable)

    def __eq__(self, other):
        if self.outpoint != other.outpoint:
            return False
        if self.btc_amount != other.btc_amount:
            return False
        if self.colorable != other.colorable:
            return False
        return True

class FfiConverterTypeUtxo(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Utxo(
            outpoint=FfiConverterTypeOutpoint.read(buf),
            btc_amount=FfiConverterUInt64.read(buf),
            colorable=FfiConverterBool.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterTypeOutpoint.write(value.outpoint, buf)
        FfiConverterUInt64.write(value.btc_amount, buf)
        FfiConverterBool.write(value.colorable, buf)


class WalletData:

    def __init__(self, data_dir, bitcoin_network, database_type, max_allocations_per_utxo, pubkey, mnemonic, vanilla_keychain):
        self.data_dir = data_dir
        self.bitcoin_network = bitcoin_network
        self.database_type = database_type
        self.max_allocations_per_utxo = max_allocations_per_utxo
        self.pubkey = pubkey
        self.mnemonic = mnemonic
        self.vanilla_keychain = vanilla_keychain

    def __str__(self):
        return "WalletData(data_dir={}, bitcoin_network={}, database_type={}, max_allocations_per_utxo={}, pubkey={}, mnemonic={}, vanilla_keychain={})".format(self.data_dir, self.bitcoin_network, self.database_type, self.max_allocations_per_utxo, self.pubkey, self.mnemonic, self.vanilla_keychain)

    def __eq__(self, other):
        if self.data_dir != other.data_dir:
            return False
        if self.bitcoin_network != other.bitcoin_network:
            return False
        if self.database_type != other.database_type:
            return False
        if self.max_allocations_per_utxo != other.max_allocations_per_utxo:
            return False
        if self.pubkey != other.pubkey:
            return False
        if self.mnemonic != other.mnemonic:
            return False
        if self.vanilla_keychain != other.vanilla_keychain:
            return False
        return True

class FfiConverterTypeWalletData(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return WalletData(
            data_dir=FfiConverterString.read(buf),
            bitcoin_network=FfiConverterTypeBitcoinNetwork.read(buf),
            database_type=FfiConverterTypeDatabaseType.read(buf),
            max_allocations_per_utxo=FfiConverterUInt32.read(buf),
            pubkey=FfiConverterString.read(buf),
            mnemonic=FfiConverterOptionalString.read(buf),
            vanilla_keychain=FfiConverterOptionalUInt8.read(buf),
        )

    @staticmethod
    def write(value, buf):
        FfiConverterString.write(value.data_dir, buf)
        FfiConverterTypeBitcoinNetwork.write(value.bitcoin_network, buf)
        FfiConverterTypeDatabaseType.write(value.database_type, buf)
        FfiConverterUInt32.write(value.max_allocations_per_utxo, buf)
        FfiConverterString.write(value.pubkey, buf)
        FfiConverterOptionalString.write(value.mnemonic, buf)
        FfiConverterOptionalUInt8.write(value.vanilla_keychain, buf)





class AssetIface(enum.Enum):
    RGB20 = 1
    RGB25 = 2
    


class FfiConverterTypeAssetIface(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return AssetIface.RGB20
        if variant == 2:
            return AssetIface.RGB25
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == AssetIface.RGB20:
            buf.writeI32(1)
        if value == AssetIface.RGB25:
            buf.writeI32(2)






class AssetSchema(enum.Enum):
    NIA = 1
    CFA = 2
    


class FfiConverterTypeAssetSchema(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return AssetSchema.NIA
        if variant == 2:
            return AssetSchema.CFA
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == AssetSchema.NIA:
            buf.writeI32(1)
        if value == AssetSchema.CFA:
            buf.writeI32(2)






class BitcoinNetwork(enum.Enum):
    MAINNET = 1
    TESTNET = 2
    SIGNET = 3
    REGTEST = 4
    


class FfiConverterTypeBitcoinNetwork(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return BitcoinNetwork.MAINNET
        if variant == 2:
            return BitcoinNetwork.TESTNET
        if variant == 3:
            return BitcoinNetwork.SIGNET
        if variant == 4:
            return BitcoinNetwork.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == BitcoinNetwork.MAINNET:
            buf.writeI32(1)
        if value == BitcoinNetwork.TESTNET:
            buf.writeI32(2)
        if value == BitcoinNetwork.SIGNET:
            buf.writeI32(3)
        if value == BitcoinNetwork.REGTEST:
            buf.writeI32(4)






class DatabaseType(enum.Enum):
    SQLITE = 1
    


class FfiConverterTypeDatabaseType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return DatabaseType.SQLITE
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == DatabaseType.SQLITE:
            buf.writeI32(1)






class RefreshTransferStatus(enum.Enum):
    WAITING_COUNTERPARTY = 1
    WAITING_CONFIRMATIONS = 2
    


class FfiConverterTypeRefreshTransferStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return RefreshTransferStatus.WAITING_COUNTERPARTY
        if variant == 2:
            return RefreshTransferStatus.WAITING_CONFIRMATIONS
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == RefreshTransferStatus.WAITING_COUNTERPARTY:
            buf.writeI32(1)
        if value == RefreshTransferStatus.WAITING_CONFIRMATIONS:
            buf.writeI32(2)



# RgbLibError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class RgbLibError(Exception):
    pass

UniFFITempRgbLibError = RgbLibError

class RgbLibError:  # type: ignore
    class AllocationsAlreadyAvailable(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.AllocationsAlreadyAvailable({})".format(str(self))
    UniFFITempRgbLibError.AllocationsAlreadyAvailable = AllocationsAlreadyAvailable  # type: ignore
    class AssetNotFound(UniFFITempRgbLibError):
        def __init__(self, asset_id):
            super().__init__(", ".join([
                "asset_id={!r}".format(asset_id),
            ]))
            self.asset_id = asset_id
        def __repr__(self):
            return "RgbLibError.AssetNotFound({})".format(str(self))
    UniFFITempRgbLibError.AssetNotFound = AssetNotFound  # type: ignore
    class BatchTransferNotFound(UniFFITempRgbLibError):
        def __init__(self, txid):
            super().__init__(", ".join([
                "txid={!r}".format(txid),
            ]))
            self.txid = txid
        def __repr__(self):
            return "RgbLibError.BatchTransferNotFound({})".format(str(self))
    UniFFITempRgbLibError.BatchTransferNotFound = BatchTransferNotFound  # type: ignore
    class CannotChangeOnline(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.CannotChangeOnline({})".format(str(self))
    UniFFITempRgbLibError.CannotChangeOnline = CannotChangeOnline  # type: ignore
    class CannotDeleteTransfer(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.CannotDeleteTransfer({})".format(str(self))
    UniFFITempRgbLibError.CannotDeleteTransfer = CannotDeleteTransfer  # type: ignore
    class CannotFailTransfer(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.CannotFailTransfer({})".format(str(self))
    UniFFITempRgbLibError.CannotFailTransfer = CannotFailTransfer  # type: ignore
    class Electrum(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.Electrum({})".format(str(self))
    UniFFITempRgbLibError.Electrum = Electrum  # type: ignore
    class FailedBdkSync(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.FailedBdkSync({})".format(str(self))
    UniFFITempRgbLibError.FailedBdkSync = FailedBdkSync  # type: ignore
    class FailedBroadcast(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.FailedBroadcast({})".format(str(self))
    UniFFITempRgbLibError.FailedBroadcast = FailedBroadcast  # type: ignore
    class FailedIssuance(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.FailedIssuance({})".format(str(self))
    UniFFITempRgbLibError.FailedIssuance = FailedIssuance  # type: ignore
    class FileAlreadyExists(UniFFITempRgbLibError):
        def __init__(self, path):
            super().__init__(", ".join([
                "path={!r}".format(path),
            ]))
            self.path = path
        def __repr__(self):
            return "RgbLibError.FileAlreadyExists({})".format(str(self))
    UniFFITempRgbLibError.FileAlreadyExists = FileAlreadyExists  # type: ignore
    class Io(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.Io({})".format(str(self))
    UniFFITempRgbLibError.Io = Io  # type: ignore
    class Inconsistency(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.Inconsistency({})".format(str(self))
    UniFFITempRgbLibError.Inconsistency = Inconsistency  # type: ignore
    class InexistentDataDir(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.InexistentDataDir({})".format(str(self))
    UniFFITempRgbLibError.InexistentDataDir = InexistentDataDir  # type: ignore
    class InsufficientAllocationSlots(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.InsufficientAllocationSlots({})".format(str(self))
    UniFFITempRgbLibError.InsufficientAllocationSlots = InsufficientAllocationSlots  # type: ignore
    class InsufficientBitcoins(UniFFITempRgbLibError):
        def __init__(self, needed, available):
            super().__init__(", ".join([
                "needed={!r}".format(needed),
                "available={!r}".format(available),
            ]))
            self.needed = needed
            self.available = available
        def __repr__(self):
            return "RgbLibError.InsufficientBitcoins({})".format(str(self))
    UniFFITempRgbLibError.InsufficientBitcoins = InsufficientBitcoins  # type: ignore
    class InsufficientSpendableAssets(UniFFITempRgbLibError):
        def __init__(self, asset_id):
            super().__init__(", ".join([
                "asset_id={!r}".format(asset_id),
            ]))
            self.asset_id = asset_id
        def __repr__(self):
            return "RgbLibError.InsufficientSpendableAssets({})".format(str(self))
    UniFFITempRgbLibError.InsufficientSpendableAssets = InsufficientSpendableAssets  # type: ignore
    class InsufficientTotalAssets(UniFFITempRgbLibError):
        def __init__(self, asset_id):
            super().__init__(", ".join([
                "asset_id={!r}".format(asset_id),
            ]))
            self.asset_id = asset_id
        def __repr__(self):
            return "RgbLibError.InsufficientTotalAssets({})".format(str(self))
    UniFFITempRgbLibError.InsufficientTotalAssets = InsufficientTotalAssets  # type: ignore
    class Internal(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.Internal({})".format(str(self))
    UniFFITempRgbLibError.Internal = Internal  # type: ignore
    class InvalidAddress(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidAddress({})".format(str(self))
    UniFFITempRgbLibError.InvalidAddress = InvalidAddress  # type: ignore
    class InvalidAmountZero(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.InvalidAmountZero({})".format(str(self))
    UniFFITempRgbLibError.InvalidAmountZero = InvalidAmountZero  # type: ignore
    class InvalidAssetId(UniFFITempRgbLibError):
        def __init__(self, asset_id):
            super().__init__(", ".join([
                "asset_id={!r}".format(asset_id),
            ]))
            self.asset_id = asset_id
        def __repr__(self):
            return "RgbLibError.InvalidAssetId({})".format(str(self))
    UniFFITempRgbLibError.InvalidAssetId = InvalidAssetId  # type: ignore
    class InvalidBitcoinKeys(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.InvalidBitcoinKeys({})".format(str(self))
    UniFFITempRgbLibError.InvalidBitcoinKeys = InvalidBitcoinKeys  # type: ignore
    class InvalidBitcoinNetwork(UniFFITempRgbLibError):
        def __init__(self, network):
            super().__init__(", ".join([
                "network={!r}".format(network),
            ]))
            self.network = network
        def __repr__(self):
            return "RgbLibError.InvalidBitcoinNetwork({})".format(str(self))
    UniFFITempRgbLibError.InvalidBitcoinNetwork = InvalidBitcoinNetwork  # type: ignore
    class InvalidBlindedUtxo(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidBlindedUtxo({})".format(str(self))
    UniFFITempRgbLibError.InvalidBlindedUtxo = InvalidBlindedUtxo  # type: ignore
    class InvalidDescription(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidDescription({})".format(str(self))
    UniFFITempRgbLibError.InvalidDescription = InvalidDescription  # type: ignore
    class InvalidElectrum(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidElectrum({})".format(str(self))
    UniFFITempRgbLibError.InvalidElectrum = InvalidElectrum  # type: ignore
    class InvalidFeeRate(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidFeeRate({})".format(str(self))
    UniFFITempRgbLibError.InvalidFeeRate = InvalidFeeRate  # type: ignore
    class InvalidFilePath(UniFFITempRgbLibError):
        def __init__(self, file_path):
            super().__init__(", ".join([
                "file_path={!r}".format(file_path),
            ]))
            self.file_path = file_path
        def __repr__(self):
            return "RgbLibError.InvalidFilePath({})".format(str(self))
    UniFFITempRgbLibError.InvalidFilePath = InvalidFilePath  # type: ignore
    class InvalidInvoice(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidInvoice({})".format(str(self))
    UniFFITempRgbLibError.InvalidInvoice = InvalidInvoice  # type: ignore
    class InvalidInvoiceData(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidInvoiceData({})".format(str(self))
    UniFFITempRgbLibError.InvalidInvoiceData = InvalidInvoiceData  # type: ignore
    class InvalidMnemonic(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidMnemonic({})".format(str(self))
    UniFFITempRgbLibError.InvalidMnemonic = InvalidMnemonic  # type: ignore
    class InvalidName(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidName({})".format(str(self))
    UniFFITempRgbLibError.InvalidName = InvalidName  # type: ignore
    class InvalidPrecision(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidPrecision({})".format(str(self))
    UniFFITempRgbLibError.InvalidPrecision = InvalidPrecision  # type: ignore
    class InvalidPsbt(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidPsbt({})".format(str(self))
    UniFFITempRgbLibError.InvalidPsbt = InvalidPsbt  # type: ignore
    class InvalidPubkey(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidPubkey({})".format(str(self))
    UniFFITempRgbLibError.InvalidPubkey = InvalidPubkey  # type: ignore
    class InvalidRecipientId(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.InvalidRecipientId({})".format(str(self))
    UniFFITempRgbLibError.InvalidRecipientId = InvalidRecipientId  # type: ignore
    class InvalidScript(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidScript({})".format(str(self))
    UniFFITempRgbLibError.InvalidScript = InvalidScript  # type: ignore
    class InvalidTicker(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidTicker({})".format(str(self))
    UniFFITempRgbLibError.InvalidTicker = InvalidTicker  # type: ignore
    class InvalidTransportEndpoint(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidTransportEndpoint({})".format(str(self))
    UniFFITempRgbLibError.InvalidTransportEndpoint = InvalidTransportEndpoint  # type: ignore
    class InvalidTransportEndpoints(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.InvalidTransportEndpoints({})".format(str(self))
    UniFFITempRgbLibError.InvalidTransportEndpoints = InvalidTransportEndpoints  # type: ignore
    class InvalidVanillaKeychain(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.InvalidVanillaKeychain({})".format(str(self))
    UniFFITempRgbLibError.InvalidVanillaKeychain = InvalidVanillaKeychain  # type: ignore
    class NoIssuanceAmounts(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.NoIssuanceAmounts({})".format(str(self))
    UniFFITempRgbLibError.NoIssuanceAmounts = NoIssuanceAmounts  # type: ignore
    class NoValidTransportEndpoint(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.NoValidTransportEndpoint({})".format(str(self))
    UniFFITempRgbLibError.NoValidTransportEndpoint = NoValidTransportEndpoint  # type: ignore
    class Offline(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.Offline({})".format(str(self))
    UniFFITempRgbLibError.Offline = Offline  # type: ignore
    class OutputBelowDustLimit(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.OutputBelowDustLimit({})".format(str(self))
    UniFFITempRgbLibError.OutputBelowDustLimit = OutputBelowDustLimit  # type: ignore
    class Proxy(UniFFITempRgbLibError):
        def __init__(self, details):
            super().__init__(", ".join([
                "details={!r}".format(details),
            ]))
            self.details = details
        def __repr__(self):
            return "RgbLibError.Proxy({})".format(str(self))
    UniFFITempRgbLibError.Proxy = Proxy  # type: ignore
    class RecipientIdAlreadyUsed(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.RecipientIdAlreadyUsed({})".format(str(self))
    UniFFITempRgbLibError.RecipientIdAlreadyUsed = RecipientIdAlreadyUsed  # type: ignore
    class RecipientIdDuplicated(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.RecipientIdDuplicated({})".format(str(self))
    UniFFITempRgbLibError.RecipientIdDuplicated = RecipientIdDuplicated  # type: ignore
    class TooHighIssuanceAmounts(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.TooHighIssuanceAmounts({})".format(str(self))
    UniFFITempRgbLibError.TooHighIssuanceAmounts = TooHighIssuanceAmounts  # type: ignore
    class TransferNotFound(UniFFITempRgbLibError):
        def __init__(self, recipient_id):
            super().__init__(", ".join([
                "recipient_id={!r}".format(recipient_id),
            ]))
            self.recipient_id = recipient_id
        def __repr__(self):
            return "RgbLibError.TransferNotFound({})".format(str(self))
    UniFFITempRgbLibError.TransferNotFound = TransferNotFound  # type: ignore
    class UnknownRgbInterface(UniFFITempRgbLibError):
        def __init__(self, interface):
            super().__init__(", ".join([
                "interface={!r}".format(interface),
            ]))
            self.interface = interface
        def __repr__(self):
            return "RgbLibError.UnknownRgbInterface({})".format(str(self))
    UniFFITempRgbLibError.UnknownRgbInterface = UnknownRgbInterface  # type: ignore
    class UnknownRgbSchema(UniFFITempRgbLibError):
        def __init__(self, schema_id):
            super().__init__(", ".join([
                "schema_id={!r}".format(schema_id),
            ]))
            self.schema_id = schema_id
        def __repr__(self):
            return "RgbLibError.UnknownRgbSchema({})".format(str(self))
    UniFFITempRgbLibError.UnknownRgbSchema = UnknownRgbSchema  # type: ignore
    class UnsupportedBackupVersion(UniFFITempRgbLibError):
        def __init__(self, version):
            super().__init__(", ".join([
                "version={!r}".format(version),
            ]))
            self.version = version
        def __repr__(self):
            return "RgbLibError.UnsupportedBackupVersion({})".format(str(self))
    UniFFITempRgbLibError.UnsupportedBackupVersion = UnsupportedBackupVersion  # type: ignore
    class UnsupportedInvoice(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.UnsupportedInvoice({})".format(str(self))
    UniFFITempRgbLibError.UnsupportedInvoice = UnsupportedInvoice  # type: ignore
    class UnsupportedTransportType(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.UnsupportedTransportType({})".format(str(self))
    UniFFITempRgbLibError.UnsupportedTransportType = UnsupportedTransportType  # type: ignore
    class WatchOnly(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.WatchOnly({})".format(str(self))
    UniFFITempRgbLibError.WatchOnly = WatchOnly  # type: ignore
    class WrongPassword(UniFFITempRgbLibError):
        def __init__(self):
            pass
        def __repr__(self):
            return "RgbLibError.WrongPassword({})".format(str(self))
    UniFFITempRgbLibError.WrongPassword = WrongPassword  # type: ignore

RgbLibError = UniFFITempRgbLibError  # type: ignore
del UniFFITempRgbLibError


class FfiConverterTypeRgbLibError(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return RgbLibError.AllocationsAlreadyAvailable(
            )
        if variant == 2:
            return RgbLibError.AssetNotFound(
                asset_id=FfiConverterString.read(buf),
            )
        if variant == 3:
            return RgbLibError.BatchTransferNotFound(
                txid=FfiConverterString.read(buf),
            )
        if variant == 4:
            return RgbLibError.CannotChangeOnline(
            )
        if variant == 5:
            return RgbLibError.CannotDeleteTransfer(
            )
        if variant == 6:
            return RgbLibError.CannotFailTransfer(
            )
        if variant == 7:
            return RgbLibError.Electrum(
                details=FfiConverterString.read(buf),
            )
        if variant == 8:
            return RgbLibError.FailedBdkSync(
                details=FfiConverterString.read(buf),
            )
        if variant == 9:
            return RgbLibError.FailedBroadcast(
                details=FfiConverterString.read(buf),
            )
        if variant == 10:
            return RgbLibError.FailedIssuance(
                details=FfiConverterString.read(buf),
            )
        if variant == 11:
            return RgbLibError.FileAlreadyExists(
                path=FfiConverterString.read(buf),
            )
        if variant == 12:
            return RgbLibError.Io(
                details=FfiConverterString.read(buf),
            )
        if variant == 13:
            return RgbLibError.Inconsistency(
                details=FfiConverterString.read(buf),
            )
        if variant == 14:
            return RgbLibError.InexistentDataDir(
            )
        if variant == 15:
            return RgbLibError.InsufficientAllocationSlots(
            )
        if variant == 16:
            return RgbLibError.InsufficientBitcoins(
                needed=FfiConverterUInt64.read(buf),
                available=FfiConverterUInt64.read(buf),
            )
        if variant == 17:
            return RgbLibError.InsufficientSpendableAssets(
                asset_id=FfiConverterString.read(buf),
            )
        if variant == 18:
            return RgbLibError.InsufficientTotalAssets(
                asset_id=FfiConverterString.read(buf),
            )
        if variant == 19:
            return RgbLibError.Internal(
                details=FfiConverterString.read(buf),
            )
        if variant == 20:
            return RgbLibError.InvalidAddress(
                details=FfiConverterString.read(buf),
            )
        if variant == 21:
            return RgbLibError.InvalidAmountZero(
            )
        if variant == 22:
            return RgbLibError.InvalidAssetId(
                asset_id=FfiConverterString.read(buf),
            )
        if variant == 23:
            return RgbLibError.InvalidBitcoinKeys(
            )
        if variant == 24:
            return RgbLibError.InvalidBitcoinNetwork(
                network=FfiConverterString.read(buf),
            )
        if variant == 25:
            return RgbLibError.InvalidBlindedUtxo(
                details=FfiConverterString.read(buf),
            )
        if variant == 26:
            return RgbLibError.InvalidDescription(
                details=FfiConverterString.read(buf),
            )
        if variant == 27:
            return RgbLibError.InvalidElectrum(
                details=FfiConverterString.read(buf),
            )
        if variant == 28:
            return RgbLibError.InvalidFeeRate(
                details=FfiConverterString.read(buf),
            )
        if variant == 29:
            return RgbLibError.InvalidFilePath(
                file_path=FfiConverterString.read(buf),
            )
        if variant == 30:
            return RgbLibError.InvalidInvoice(
                details=FfiConverterString.read(buf),
            )
        if variant == 31:
            return RgbLibError.InvalidInvoiceData(
                details=FfiConverterString.read(buf),
            )
        if variant == 32:
            return RgbLibError.InvalidMnemonic(
                details=FfiConverterString.read(buf),
            )
        if variant == 33:
            return RgbLibError.InvalidName(
                details=FfiConverterString.read(buf),
            )
        if variant == 34:
            return RgbLibError.InvalidPrecision(
                details=FfiConverterString.read(buf),
            )
        if variant == 35:
            return RgbLibError.InvalidPsbt(
                details=FfiConverterString.read(buf),
            )
        if variant == 36:
            return RgbLibError.InvalidPubkey(
                details=FfiConverterString.read(buf),
            )
        if variant == 37:
            return RgbLibError.InvalidRecipientId(
            )
        if variant == 38:
            return RgbLibError.InvalidScript(
                details=FfiConverterString.read(buf),
            )
        if variant == 39:
            return RgbLibError.InvalidTicker(
                details=FfiConverterString.read(buf),
            )
        if variant == 40:
            return RgbLibError.InvalidTransportEndpoint(
                details=FfiConverterString.read(buf),
            )
        if variant == 41:
            return RgbLibError.InvalidTransportEndpoints(
                details=FfiConverterString.read(buf),
            )
        if variant == 42:
            return RgbLibError.InvalidVanillaKeychain(
            )
        if variant == 43:
            return RgbLibError.NoIssuanceAmounts(
            )
        if variant == 44:
            return RgbLibError.NoValidTransportEndpoint(
            )
        if variant == 45:
            return RgbLibError.Offline(
            )
        if variant == 46:
            return RgbLibError.OutputBelowDustLimit(
            )
        if variant == 47:
            return RgbLibError.Proxy(
                details=FfiConverterString.read(buf),
            )
        if variant == 48:
            return RgbLibError.RecipientIdAlreadyUsed(
            )
        if variant == 49:
            return RgbLibError.RecipientIdDuplicated(
            )
        if variant == 50:
            return RgbLibError.TooHighIssuanceAmounts(
            )
        if variant == 51:
            return RgbLibError.TransferNotFound(
                recipient_id=FfiConverterString.read(buf),
            )
        if variant == 52:
            return RgbLibError.UnknownRgbInterface(
                interface=FfiConverterString.read(buf),
            )
        if variant == 53:
            return RgbLibError.UnknownRgbSchema(
                schema_id=FfiConverterString.read(buf),
            )
        if variant == 54:
            return RgbLibError.UnsupportedBackupVersion(
                version=FfiConverterString.read(buf),
            )
        if variant == 55:
            return RgbLibError.UnsupportedInvoice(
            )
        if variant == 56:
            return RgbLibError.UnsupportedTransportType(
            )
        if variant == 57:
            return RgbLibError.WatchOnly(
            )
        if variant == 58:
            return RgbLibError.WrongPassword(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def write(value, buf):
        if isinstance(value, RgbLibError.AllocationsAlreadyAvailable):
            buf.writeI32(1)
        if isinstance(value, RgbLibError.AssetNotFound):
            buf.writeI32(2)
            FfiConverterString.write(value.asset_id, buf)
        if isinstance(value, RgbLibError.BatchTransferNotFound):
            buf.writeI32(3)
            FfiConverterString.write(value.txid, buf)
        if isinstance(value, RgbLibError.CannotChangeOnline):
            buf.writeI32(4)
        if isinstance(value, RgbLibError.CannotDeleteTransfer):
            buf.writeI32(5)
        if isinstance(value, RgbLibError.CannotFailTransfer):
            buf.writeI32(6)
        if isinstance(value, RgbLibError.Electrum):
            buf.writeI32(7)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.FailedBdkSync):
            buf.writeI32(8)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.FailedBroadcast):
            buf.writeI32(9)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.FailedIssuance):
            buf.writeI32(10)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.FileAlreadyExists):
            buf.writeI32(11)
            FfiConverterString.write(value.path, buf)
        if isinstance(value, RgbLibError.Io):
            buf.writeI32(12)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.Inconsistency):
            buf.writeI32(13)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InexistentDataDir):
            buf.writeI32(14)
        if isinstance(value, RgbLibError.InsufficientAllocationSlots):
            buf.writeI32(15)
        if isinstance(value, RgbLibError.InsufficientBitcoins):
            buf.writeI32(16)
            FfiConverterUInt64.write(value.needed, buf)
            FfiConverterUInt64.write(value.available, buf)
        if isinstance(value, RgbLibError.InsufficientSpendableAssets):
            buf.writeI32(17)
            FfiConverterString.write(value.asset_id, buf)
        if isinstance(value, RgbLibError.InsufficientTotalAssets):
            buf.writeI32(18)
            FfiConverterString.write(value.asset_id, buf)
        if isinstance(value, RgbLibError.Internal):
            buf.writeI32(19)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidAddress):
            buf.writeI32(20)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidAmountZero):
            buf.writeI32(21)
        if isinstance(value, RgbLibError.InvalidAssetId):
            buf.writeI32(22)
            FfiConverterString.write(value.asset_id, buf)
        if isinstance(value, RgbLibError.InvalidBitcoinKeys):
            buf.writeI32(23)
        if isinstance(value, RgbLibError.InvalidBitcoinNetwork):
            buf.writeI32(24)
            FfiConverterString.write(value.network, buf)
        if isinstance(value, RgbLibError.InvalidBlindedUtxo):
            buf.writeI32(25)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidDescription):
            buf.writeI32(26)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidElectrum):
            buf.writeI32(27)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidFeeRate):
            buf.writeI32(28)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidFilePath):
            buf.writeI32(29)
            FfiConverterString.write(value.file_path, buf)
        if isinstance(value, RgbLibError.InvalidInvoice):
            buf.writeI32(30)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidInvoiceData):
            buf.writeI32(31)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidMnemonic):
            buf.writeI32(32)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidName):
            buf.writeI32(33)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidPrecision):
            buf.writeI32(34)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidPsbt):
            buf.writeI32(35)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidPubkey):
            buf.writeI32(36)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidRecipientId):
            buf.writeI32(37)
        if isinstance(value, RgbLibError.InvalidScript):
            buf.writeI32(38)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidTicker):
            buf.writeI32(39)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidTransportEndpoint):
            buf.writeI32(40)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidTransportEndpoints):
            buf.writeI32(41)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.InvalidVanillaKeychain):
            buf.writeI32(42)
        if isinstance(value, RgbLibError.NoIssuanceAmounts):
            buf.writeI32(43)
        if isinstance(value, RgbLibError.NoValidTransportEndpoint):
            buf.writeI32(44)
        if isinstance(value, RgbLibError.Offline):
            buf.writeI32(45)
        if isinstance(value, RgbLibError.OutputBelowDustLimit):
            buf.writeI32(46)
        if isinstance(value, RgbLibError.Proxy):
            buf.writeI32(47)
            FfiConverterString.write(value.details, buf)
        if isinstance(value, RgbLibError.RecipientIdAlreadyUsed):
            buf.writeI32(48)
        if isinstance(value, RgbLibError.RecipientIdDuplicated):
            buf.writeI32(49)
        if isinstance(value, RgbLibError.TooHighIssuanceAmounts):
            buf.writeI32(50)
        if isinstance(value, RgbLibError.TransferNotFound):
            buf.writeI32(51)
            FfiConverterString.write(value.recipient_id, buf)
        if isinstance(value, RgbLibError.UnknownRgbInterface):
            buf.writeI32(52)
            FfiConverterString.write(value.interface, buf)
        if isinstance(value, RgbLibError.UnknownRgbSchema):
            buf.writeI32(53)
            FfiConverterString.write(value.schema_id, buf)
        if isinstance(value, RgbLibError.UnsupportedBackupVersion):
            buf.writeI32(54)
            FfiConverterString.write(value.version, buf)
        if isinstance(value, RgbLibError.UnsupportedInvoice):
            buf.writeI32(55)
        if isinstance(value, RgbLibError.UnsupportedTransportType):
            buf.writeI32(56)
        if isinstance(value, RgbLibError.WatchOnly):
            buf.writeI32(57)
        if isinstance(value, RgbLibError.WrongPassword):
            buf.writeI32(58)





class TransactionType(enum.Enum):
    RGB_SEND = 1
    DRAIN = 2
    CREATE_UTXOS = 3
    USER = 4
    


class FfiConverterTypeTransactionType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TransactionType.RGB_SEND
        if variant == 2:
            return TransactionType.DRAIN
        if variant == 3:
            return TransactionType.CREATE_UTXOS
        if variant == 4:
            return TransactionType.USER
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == TransactionType.RGB_SEND:
            buf.writeI32(1)
        if value == TransactionType.DRAIN:
            buf.writeI32(2)
        if value == TransactionType.CREATE_UTXOS:
            buf.writeI32(3)
        if value == TransactionType.USER:
            buf.writeI32(4)






class TransferKind(enum.Enum):
    ISSUANCE = 1
    RECEIVE_BLIND = 2
    RECEIVE_WITNESS = 3
    SEND = 4
    


class FfiConverterTypeTransferKind(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TransferKind.ISSUANCE
        if variant == 2:
            return TransferKind.RECEIVE_BLIND
        if variant == 3:
            return TransferKind.RECEIVE_WITNESS
        if variant == 4:
            return TransferKind.SEND
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == TransferKind.ISSUANCE:
            buf.writeI32(1)
        if value == TransferKind.RECEIVE_BLIND:
            buf.writeI32(2)
        if value == TransferKind.RECEIVE_WITNESS:
            buf.writeI32(3)
        if value == TransferKind.SEND:
            buf.writeI32(4)






class TransferStatus(enum.Enum):
    WAITING_COUNTERPARTY = 1
    WAITING_CONFIRMATIONS = 2
    SETTLED = 3
    FAILED = 4
    


class FfiConverterTypeTransferStatus(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TransferStatus.WAITING_COUNTERPARTY
        if variant == 2:
            return TransferStatus.WAITING_CONFIRMATIONS
        if variant == 3:
            return TransferStatus.SETTLED
        if variant == 4:
            return TransferStatus.FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == TransferStatus.WAITING_COUNTERPARTY:
            buf.writeI32(1)
        if value == TransferStatus.WAITING_CONFIRMATIONS:
            buf.writeI32(2)
        if value == TransferStatus.SETTLED:
            buf.writeI32(3)
        if value == TransferStatus.FAILED:
            buf.writeI32(4)






class TransportType(enum.Enum):
    JSON_RPC = 1
    


class FfiConverterTypeTransportType(FfiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.readI32()
        if variant == 1:
            return TransportType.JSON_RPC
        raise InternalError("Raw enum value doesn't match any cases")

    def write(value, buf):
        if value == TransportType.JSON_RPC:
            buf.writeI32(1)




class FfiConverterOptionalUInt8(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt8.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt8.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalUInt32(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalUInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeBlockTime(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeBlockTime.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeBlockTime.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeOnline(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeOnline.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeOnline.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeOutpoint(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeOutpoint.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeOutpoint.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeScriptData(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeScriptData.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeScriptData.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeAssetIface(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeAssetIface.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeAssetIface.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalTypeBitcoinNetwork(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterTypeBitcoinNetwork.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterTypeBitcoinNetwork.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeAssetCFA(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeAssetCFA.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeAssetCFA.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterOptionalSequenceTypeAssetNIA(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.writeU8(0)
            return

        buf.writeU8(1)
        FfiConverterSequenceTypeAssetNIA.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.readU8()
        if flag == 0:
            return None
        elif flag == 1:
            return FfiConverterSequenceTypeAssetNIA.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class FfiConverterSequenceUInt64(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterUInt64.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterUInt64.read(buf) for i in range(count)
        ]



class FfiConverterSequenceString(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterString.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeAssetCFA(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeAssetCFA.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeAssetCFA.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeAssetNIA(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeAssetNIA.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeAssetNIA.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeMedia(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeMedia.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeMedia.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRecipient(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRecipient.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRecipient.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRefreshFilter(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRefreshFilter.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRefreshFilter.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeRgbAllocation(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeRgbAllocation.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeRgbAllocation.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeTransaction(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeTransaction.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeTransaction.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeTransfer(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeTransfer.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeTransfer.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeTransferTransportEndpoint(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeTransferTransportEndpoint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeTransferTransportEndpoint.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeUnspent(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeUnspent.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeUnspent.read(buf) for i in range(count)
        ]



class FfiConverterSequenceTypeAssetSchema(FfiConverterRustBuffer):
    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.writeI32(items)
        for item in value:
            FfiConverterTypeAssetSchema.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            FfiConverterTypeAssetSchema.read(buf) for i in range(count)
        ]



class FfiConverterMapStringSequenceTypeRecipient(FfiConverterRustBuffer):
    @classmethod
    def write(cls, items, buf):
        buf.writeI32(len(items))
        for (key, value) in items.items():
            FfiConverterString.write(key, buf)
            FfiConverterSequenceTypeRecipient.write(value, buf)

    @classmethod
    def read(cls, buf):
        count = buf.readI32()
        if count < 0:
            raise InternalError("Unexpected negative map size")

        # It would be nice to use a dict comprehension,
        # but in Python 3.7 and before the evaluation order is not according to spec,
        # so we we're reading the value before the key.
        # This loop makes the order explicit: first reading the key, then the value.
        d = {}
        for i in range(count):
            key = FfiConverterString.read(buf)
            val = FfiConverterSequenceTypeRecipient.read(buf)
            d[key] = val
        return d

def generate_keys(bitcoin_network: "BitcoinNetwork"):
    
    return FfiConverterTypeKeys.lift(rust_call(_UniFFILib.uniffi_rgb_lib_fn_func_generate_keys,
        FfiConverterTypeBitcoinNetwork.lower(bitcoin_network)))


def restore_keys(bitcoin_network: "BitcoinNetwork",mnemonic: "str"):
    
    
    return FfiConverterTypeKeys.lift(rust_call_with_error(FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_func_restore_keys,
        FfiConverterTypeBitcoinNetwork.lower(bitcoin_network),
        FfiConverterString.lower(mnemonic)))


def restore_backup(backup_path: "str",password: "str",data_dir: "str"):
    
    
    
    rust_call_with_error(FfiConverterTypeRgbLibError,_UniFFILib.uniffi_rgb_lib_fn_func_restore_backup,
        FfiConverterString.lower(backup_path),
        FfiConverterString.lower(password),
        FfiConverterString.lower(data_dir))


__all__ = [
    "InternalError",
    "AssetIface",
    "AssetSchema",
    "BitcoinNetwork",
    "DatabaseType",
    "RefreshTransferStatus",
    "RgbLibError",
    "TransactionType",
    "TransferKind",
    "TransferStatus",
    "TransportType",
    "AssetCfa",
    "AssetNia",
    "Assets",
    "Balance",
    "BlockTime",
    "BtcBalance",
    "InvoiceData",
    "Keys",
    "Media",
    "Metadata",
    "Online",
    "Outpoint",
    "ReceiveData",
    "Recipient",
    "RefreshFilter",
    "RgbAllocation",
    "ScriptData",
    "Transaction",
    "Transfer",
    "TransferTransportEndpoint",
    "Unspent",
    "Utxo",
    "WalletData",
    "generate_keys",
    "restore_keys",
    "restore_backup",
    "BlindedUtxo",
    "TransportEndpoint",
    "Invoice",
    "Wallet",
]

