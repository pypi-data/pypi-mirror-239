Metadata-Version: 2.1
Name: roboflex.imgui
Version: 0.1.9
Summary: Roboflex Visualization/GUI Library using IMGUI/IMPLOT
Home-page: https://github.com/flexrobotics/roboflex_imgui
Author: Colin Prepscius
Author-email: colinprepscius@gmail.com
License: MIT
Keywords: imgui,implot,gui,visualization,robotics,middleware,flexbuffers,python,c++,c++20
Platform: UNKNOWN
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Software Development :: Embedded Systems
Classifier: Framework :: Robot Framework
Classifier: Framework :: Robot Framework :: Library
Classifier: Framework :: Robot Framework :: Tool
Classifier: Programming Language :: C++
Classifier: Programming Language :: Python :: 3
Requires-Python: >=3.6
Description-Content-Type: text/markdown
License-File: LICENSE

# roboflex_imgui

Roboflex visualizers and guis using IMGUI/IMPLOT

![](onedviewer.png)

## System dependencies

Requires SDL and GLEW to be installed. More than likely, they already are installed in your distro. But if not:

    apt-get install libsdl2-dev
    apt-get install libglew-dev

    # or maybe on mac:

    brew install sdl2
    brew install glew
    brew install glfw

## pip install

    pip install roboflex.imgui

## Import

    import roboflex.imgui as rgu

## Nodes

There is only one so far: **OneDTV**

It expects to receive messages that contain a tensor under the key <data_key>. That tensor needs to be of shape (C, S), where C is number of channels, and S is sequence length. In general, C should be small (< 20), and S large. Think multiple audio channels.

    # all parameters optional: below are the defaults
    visualizer = rgu.OneDTV(
        data_key = "data",
        sample_size = 4,
        center_zero = True,
        initial_size = (640, 220),
        initial_pos = (-1, -1),
        name = "OneDTV",
        debug = False,
    )

    # must be started
    visualizer.start()

    # NOTE!!!
    # On some systems, such as mac, it's bad news to
    # run a UI on a non-main thread. So instead of 
    # calling start(), you can do this, which will 
    # run on the main thread. This call will block 
    # until the window is closed, in this case.
    visualizer.run()





