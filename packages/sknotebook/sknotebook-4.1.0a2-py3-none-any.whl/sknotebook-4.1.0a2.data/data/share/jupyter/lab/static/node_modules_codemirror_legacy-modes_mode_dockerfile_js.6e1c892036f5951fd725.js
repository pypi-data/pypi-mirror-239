"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_dockerfile_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/dockerfile.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/dockerfile.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dockerFile": () => (/* binding */ dockerFile)
/* harmony export */ });
/* harmony import */ var _simple_mode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./simple-mode.js */ "../node_modules/@codemirror/legacy-modes/mode/simple-mode.js");


var from = "from";
var fromRegex = new RegExp("^(\\s*)\\b(" + from + ")\\b", "i");

var shells = ["run", "cmd", "entrypoint", "shell"];
var shellsAsArrayRegex = new RegExp("^(\\s*)(" + shells.join('|') + ")(\\s+\\[)", "i");

var expose = "expose";
var exposeRegex = new RegExp("^(\\s*)(" + expose + ")(\\s+)", "i");

var others = [
  "arg", "from", "maintainer", "label", "env",
  "add", "copy", "volume", "user",
  "workdir", "onbuild", "stopsignal", "healthcheck", "shell"
];

// Collect all Dockerfile directives
var instructions = [from, expose].concat(shells).concat(others),
    instructionRegex = "(" + instructions.join('|') + ")",
    instructionOnlyLine = new RegExp("^(\\s*)" + instructionRegex + "(\\s*)(#.*)?$", "i"),
    instructionWithArguments = new RegExp("^(\\s*)" + instructionRegex + "(\\s+)", "i");

const dockerFile = (0,_simple_mode_js__WEBPACK_IMPORTED_MODULE_0__.simpleMode)({
  start: [
    // Block comment: This is a line starting with a comment
    {
      regex: /^\s*#.*$/,
      sol: true,
      token: "comment"
    },
    {
      regex: fromRegex,
      token: [null, "keyword"],
      sol: true,
      next: "from"
    },
    // Highlight an instruction without any arguments (for convenience)
    {
      regex: instructionOnlyLine,
      token: [null, "keyword", null, "error"],
      sol: true
    },
    {
      regex: shellsAsArrayRegex,
      token: [null, "keyword", null],
      sol: true,
      next: "array"
    },
    {
      regex: exposeRegex,
      token: [null, "keyword", null],
      sol: true,
      next: "expose"
    },
    // Highlight an instruction followed by arguments
    {
      regex: instructionWithArguments,
      token: [null, "keyword", null],
      sol: true,
      next: "arguments"
    },
    {
      regex: /./,
      token: null
    }
  ],
  from: [
    {
      regex: /\s*$/,
      token: null,
      next: "start"
    },
    {
      // Line comment without instruction arguments is an error
      regex: /(\s*)(#.*)$/,
      token: [null, "error"],
      next: "start"
    },
    {
      regex: /(\s*\S+\s+)(as)/i,
      token: [null, "keyword"],
      next: "start"
    },
    // Fail safe return to start
    {
      token: null,
      next: "start"
    }
  ],
  single: [
    {
      regex: /(?:[^\\']|\\.)/,
      token: "string"
    },
    {
      regex: /'/,
      token: "string",
      pop: true
    }
  ],
  double: [
    {
      regex: /(?:[^\\"]|\\.)/,
      token: "string"
    },
    {
      regex: /"/,
      token: "string",
      pop: true
    }
  ],
  array: [
    {
      regex: /\]/,
      token: null,
      next: "start"
    },
    {
      regex: /"(?:[^\\"]|\\.)*"?/,
      token: "string"
    }
  ],
  expose: [
    {
      regex: /\d+$/,
      token: "number",
      next: "start"
    },
    {
      regex: /[^\d]+$/,
      token: null,
      next: "start"
    },
    {
      regex: /\d+/,
      token: "number"
    },
    {
      regex: /[^\d]+/,
      token: null
    },
    // Fail safe return to start
    {
      token: null,
      next: "start"
    }
  ],
  arguments: [
    {
      regex: /^\s*#.*$/,
      sol: true,
      token: "comment"
    },
    {
      regex: /"(?:[^\\"]|\\.)*"?$/,
      token: "string",
      next: "start"
    },
    {
      regex: /"/,
      token: "string",
      push: "double"
    },
    {
      regex: /'(?:[^\\']|\\.)*'?$/,
      token: "string",
      next: "start"
    },
    {
      regex: /'/,
      token: "string",
      push: "single"
    },
    {
      regex: /[^#"']+[\\`]$/,
      token: null
    },
    {
      regex: /[^#"']+$/,
      token: null,
      next: "start"
    },
    {
      regex: /[^#"']+/,
      token: null
    },
    // Fail safe return to start
    {
      token: null,
      next: "start"
    }
  ],
  languageData: {
    commentTokens: {line: "#"}
  }
});



/***/ }),

/***/ "../node_modules/@codemirror/legacy-modes/mode/simple-mode.js":
/*!********************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/simple-mode.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "simpleMode": () => (/* binding */ simpleMode)
/* harmony export */ });
function simpleMode(states) {
  ensureState(states, "start");
  var states_ = {}, meta = states.languageData || {}, hasIndentation = false;
  for (var state in states) if (state != meta && states.hasOwnProperty(state)) {
    var list = states_[state] = [], orig = states[state];
    for (var i = 0; i < orig.length; i++) {
      var data = orig[i];
      list.push(new Rule(data, states));
      if (data.indent || data.dedent) hasIndentation = true;
    }
  }
  return {
    name: meta.name,
    startState: function() {
      return {state: "start", pending: null, indent: hasIndentation ? [] : null};
    },
    copyState: function(state) {
      var s = {state: state.state, pending: state.pending, indent: state.indent && state.indent.slice(0)};
      if (state.stack)
        s.stack = state.stack.slice(0);
      return s;
    },
    token: tokenFunction(states_),
    indent: indentFunction(states_, meta),
    languageData: meta
  }
};

function ensureState(states, name) {
  if (!states.hasOwnProperty(name))
    throw new Error("Undefined state " + name + " in simple mode");
}

function toRegex(val, caret) {
  if (!val) return /(?:)/;
  var flags = "";
  if (val instanceof RegExp) {
    if (val.ignoreCase) flags = "i";
    val = val.source;
  } else {
    val = String(val);
  }
  return new RegExp((caret === false ? "" : "^") + "(?:" + val + ")", flags);
}

function asToken(val) {
  if (!val) return null;
  if (val.apply) return val
  if (typeof val == "string") return val.replace(/\./g, " ");
  var result = [];
  for (var i = 0; i < val.length; i++)
    result.push(val[i] && val[i].replace(/\./g, " "));
  return result;
}

function Rule(data, states) {
  if (data.next || data.push) ensureState(states, data.next || data.push);
  this.regex = toRegex(data.regex);
  this.token = asToken(data.token);
  this.data = data;
}

function tokenFunction(states) {
  return function(stream, state) {
    if (state.pending) {
      var pend = state.pending.shift();
      if (state.pending.length == 0) state.pending = null;
      stream.pos += pend.text.length;
      return pend.token;
    }

    var curState = states[state.state];
    for (var i = 0; i < curState.length; i++) {
      var rule = curState[i];
      var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);
      if (matches) {
        if (rule.data.next) {
          state.state = rule.data.next;
        } else if (rule.data.push) {
          (state.stack || (state.stack = [])).push(state.state);
          state.state = rule.data.push;
        } else if (rule.data.pop && state.stack && state.stack.length) {
          state.state = state.stack.pop();
        }

        if (rule.data.indent)
          state.indent.push(stream.indentation() + stream.indentUnit);
        if (rule.data.dedent)
          state.indent.pop();
        var token = rule.token
        if (token && token.apply) token = token(matches)
        if (matches.length > 2 && rule.token && typeof rule.token != "string") {
          state.pending = [];
          for (var j = 2; j < matches.length; j++)
            if (matches[j])
              state.pending.push({text: matches[j], token: rule.token[j - 1]});
          stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));
          return token[0];
        } else if (token && token.join) {
          return token[0];
        } else {
          return token;
        }
      }
    }
    stream.next();
    return null;
  };
}

function indentFunction(states, meta) {
  return function(state, textAfter) {
    if (state.indent == null || meta.dontIndentStates && meta.doneIndentState.indexOf(state.state) > -1)
      return null

    var pos = state.indent.length - 1, rules = states[state.state];
    scan: for (;;) {
      for (var i = 0; i < rules.length; i++) {
        var rule = rules[i];
        if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {
          var m = rule.regex.exec(textAfter);
          if (m && m[0]) {
            pos--;
            if (rule.next || rule.push) rules = states[rule.next || rule.push];
            textAfter = textAfter.slice(m[0].length);
            continue scan;
          }
        }
      }
      break;
    }
    return pos < 0 ? 0 : state.indent[pos];
  };
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZG9ja2VyZmlsZV9qcy42ZTFjODkyMDM2ZjU5NTFmZDcyNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLG1CQUFtQiwyREFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQ3BNTTtBQUNQO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTDtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBLGtDQUFrQywyQ0FBMkM7QUFDN0U7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2RvY2tlcmZpbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9zaW1wbGUtbW9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge3NpbXBsZU1vZGV9IGZyb20gXCIuL3NpbXBsZS1tb2RlLmpzXCJcblxudmFyIGZyb20gPSBcImZyb21cIjtcbnZhciBmcm9tUmVnZXggPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXFxcXGIoXCIgKyBmcm9tICsgXCIpXFxcXGJcIiwgXCJpXCIpO1xuXG52YXIgc2hlbGxzID0gW1wicnVuXCIsIFwiY21kXCIsIFwiZW50cnlwb2ludFwiLCBcInNoZWxsXCJdO1xudmFyIHNoZWxsc0FzQXJyYXlSZWdleCA9IG5ldyBSZWdFeHAoXCJeKFxcXFxzKikoXCIgKyBzaGVsbHMuam9pbignfCcpICsgXCIpKFxcXFxzK1xcXFxbKVwiLCBcImlcIik7XG5cbnZhciBleHBvc2UgPSBcImV4cG9zZVwiO1xudmFyIGV4cG9zZVJlZ2V4ID0gbmV3IFJlZ0V4cChcIl4oXFxcXHMqKShcIiArIGV4cG9zZSArIFwiKShcXFxccyspXCIsIFwiaVwiKTtcblxudmFyIG90aGVycyA9IFtcbiAgXCJhcmdcIiwgXCJmcm9tXCIsIFwibWFpbnRhaW5lclwiLCBcImxhYmVsXCIsIFwiZW52XCIsXG4gIFwiYWRkXCIsIFwiY29weVwiLCBcInZvbHVtZVwiLCBcInVzZXJcIixcbiAgXCJ3b3JrZGlyXCIsIFwib25idWlsZFwiLCBcInN0b3BzaWduYWxcIiwgXCJoZWFsdGhjaGVja1wiLCBcInNoZWxsXCJcbl07XG5cbi8vIENvbGxlY3QgYWxsIERvY2tlcmZpbGUgZGlyZWN0aXZlc1xudmFyIGluc3RydWN0aW9ucyA9IFtmcm9tLCBleHBvc2VdLmNvbmNhdChzaGVsbHMpLmNvbmNhdChvdGhlcnMpLFxuICAgIGluc3RydWN0aW9uUmVnZXggPSBcIihcIiArIGluc3RydWN0aW9ucy5qb2luKCd8JykgKyBcIilcIixcbiAgICBpbnN0cnVjdGlvbk9ubHlMaW5lID0gbmV3IFJlZ0V4cChcIl4oXFxcXHMqKVwiICsgaW5zdHJ1Y3Rpb25SZWdleCArIFwiKFxcXFxzKikoIy4qKT8kXCIsIFwiaVwiKSxcbiAgICBpbnN0cnVjdGlvbldpdGhBcmd1bWVudHMgPSBuZXcgUmVnRXhwKFwiXihcXFxccyopXCIgKyBpbnN0cnVjdGlvblJlZ2V4ICsgXCIoXFxcXHMrKVwiLCBcImlcIik7XG5cbmV4cG9ydCBjb25zdCBkb2NrZXJGaWxlID0gc2ltcGxlTW9kZSh7XG4gIHN0YXJ0OiBbXG4gICAgLy8gQmxvY2sgY29tbWVudDogVGhpcyBpcyBhIGxpbmUgc3RhcnRpbmcgd2l0aCBhIGNvbW1lbnRcbiAgICB7XG4gICAgICByZWdleDogL15cXHMqIy4qJC8sXG4gICAgICBzb2w6IHRydWUsXG4gICAgICB0b2tlbjogXCJjb21tZW50XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiBmcm9tUmVnZXgsXG4gICAgICB0b2tlbjogW251bGwsIFwia2V5d29yZFwiXSxcbiAgICAgIHNvbDogdHJ1ZSxcbiAgICAgIG5leHQ6IFwiZnJvbVwiXG4gICAgfSxcbiAgICAvLyBIaWdobGlnaHQgYW4gaW5zdHJ1Y3Rpb24gd2l0aG91dCBhbnkgYXJndW1lbnRzIChmb3IgY29udmVuaWVuY2UpXG4gICAge1xuICAgICAgcmVnZXg6IGluc3RydWN0aW9uT25seUxpbmUsXG4gICAgICB0b2tlbjogW251bGwsIFwia2V5d29yZFwiLCBudWxsLCBcImVycm9yXCJdLFxuICAgICAgc29sOiB0cnVlXG4gICAgfSxcbiAgICB7XG4gICAgICByZWdleDogc2hlbGxzQXNBcnJheVJlZ2V4LFxuICAgICAgdG9rZW46IFtudWxsLCBcImtleXdvcmRcIiwgbnVsbF0sXG4gICAgICBzb2w6IHRydWUsXG4gICAgICBuZXh0OiBcImFycmF5XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiBleHBvc2VSZWdleCxcbiAgICAgIHRva2VuOiBbbnVsbCwgXCJrZXl3b3JkXCIsIG51bGxdLFxuICAgICAgc29sOiB0cnVlLFxuICAgICAgbmV4dDogXCJleHBvc2VcIlxuICAgIH0sXG4gICAgLy8gSGlnaGxpZ2h0IGFuIGluc3RydWN0aW9uIGZvbGxvd2VkIGJ5IGFyZ3VtZW50c1xuICAgIHtcbiAgICAgIHJlZ2V4OiBpbnN0cnVjdGlvbldpdGhBcmd1bWVudHMsXG4gICAgICB0b2tlbjogW251bGwsIFwia2V5d29yZFwiLCBudWxsXSxcbiAgICAgIHNvbDogdHJ1ZSxcbiAgICAgIG5leHQ6IFwiYXJndW1lbnRzXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiAvLi8sXG4gICAgICB0b2tlbjogbnVsbFxuICAgIH1cbiAgXSxcbiAgZnJvbTogW1xuICAgIHtcbiAgICAgIHJlZ2V4OiAvXFxzKiQvLFxuICAgICAgdG9rZW46IG51bGwsXG4gICAgICBuZXh0OiBcInN0YXJ0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIExpbmUgY29tbWVudCB3aXRob3V0IGluc3RydWN0aW9uIGFyZ3VtZW50cyBpcyBhbiBlcnJvclxuICAgICAgcmVnZXg6IC8oXFxzKikoIy4qKSQvLFxuICAgICAgdG9rZW46IFtudWxsLCBcImVycm9yXCJdLFxuICAgICAgbmV4dDogXCJzdGFydFwiXG4gICAgfSxcbiAgICB7XG4gICAgICByZWdleDogLyhcXHMqXFxTK1xccyspKGFzKS9pLFxuICAgICAgdG9rZW46IFtudWxsLCBcImtleXdvcmRcIl0sXG4gICAgICBuZXh0OiBcInN0YXJ0XCJcbiAgICB9LFxuICAgIC8vIEZhaWwgc2FmZSByZXR1cm4gdG8gc3RhcnRcbiAgICB7XG4gICAgICB0b2tlbjogbnVsbCxcbiAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgIH1cbiAgXSxcbiAgc2luZ2xlOiBbXG4gICAge1xuICAgICAgcmVnZXg6IC8oPzpbXlxcXFwnXXxcXFxcLikvLFxuICAgICAgdG9rZW46IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiAvJy8sXG4gICAgICB0b2tlbjogXCJzdHJpbmdcIixcbiAgICAgIHBvcDogdHJ1ZVxuICAgIH1cbiAgXSxcbiAgZG91YmxlOiBbXG4gICAge1xuICAgICAgcmVnZXg6IC8oPzpbXlxcXFxcIl18XFxcXC4pLyxcbiAgICAgIHRva2VuOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICB7XG4gICAgICByZWdleDogL1wiLyxcbiAgICAgIHRva2VuOiBcInN0cmluZ1wiLFxuICAgICAgcG9wOiB0cnVlXG4gICAgfVxuICBdLFxuICBhcnJheTogW1xuICAgIHtcbiAgICAgIHJlZ2V4OiAvXFxdLyxcbiAgICAgIHRva2VuOiBudWxsLFxuICAgICAgbmV4dDogXCJzdGFydFwiXG4gICAgfSxcbiAgICB7XG4gICAgICByZWdleDogL1wiKD86W15cXFxcXCJdfFxcXFwuKSpcIj8vLFxuICAgICAgdG9rZW46IFwic3RyaW5nXCJcbiAgICB9XG4gIF0sXG4gIGV4cG9zZTogW1xuICAgIHtcbiAgICAgIHJlZ2V4OiAvXFxkKyQvLFxuICAgICAgdG9rZW46IFwibnVtYmVyXCIsXG4gICAgICBuZXh0OiBcInN0YXJ0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiAvW15cXGRdKyQvLFxuICAgICAgdG9rZW46IG51bGwsXG4gICAgICBuZXh0OiBcInN0YXJ0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiAvXFxkKy8sXG4gICAgICB0b2tlbjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAge1xuICAgICAgcmVnZXg6IC9bXlxcZF0rLyxcbiAgICAgIHRva2VuOiBudWxsXG4gICAgfSxcbiAgICAvLyBGYWlsIHNhZmUgcmV0dXJuIHRvIHN0YXJ0XG4gICAge1xuICAgICAgdG9rZW46IG51bGwsXG4gICAgICBuZXh0OiBcInN0YXJ0XCJcbiAgICB9XG4gIF0sXG4gIGFyZ3VtZW50czogW1xuICAgIHtcbiAgICAgIHJlZ2V4OiAvXlxccyojLiokLyxcbiAgICAgIHNvbDogdHJ1ZSxcbiAgICAgIHRva2VuOiBcImNvbW1lbnRcIlxuICAgIH0sXG4gICAge1xuICAgICAgcmVnZXg6IC9cIig/OlteXFxcXFwiXXxcXFxcLikqXCI/JC8sXG4gICAgICB0b2tlbjogXCJzdHJpbmdcIixcbiAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgIH0sXG4gICAge1xuICAgICAgcmVnZXg6IC9cIi8sXG4gICAgICB0b2tlbjogXCJzdHJpbmdcIixcbiAgICAgIHB1c2g6IFwiZG91YmxlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiAvJyg/OlteXFxcXCddfFxcXFwuKSonPyQvLFxuICAgICAgdG9rZW46IFwic3RyaW5nXCIsXG4gICAgICBuZXh0OiBcInN0YXJ0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiAvJy8sXG4gICAgICB0b2tlbjogXCJzdHJpbmdcIixcbiAgICAgIHB1c2g6IFwic2luZ2xlXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiAvW14jXCInXStbXFxcXGBdJC8sXG4gICAgICB0b2tlbjogbnVsbFxuICAgIH0sXG4gICAge1xuICAgICAgcmVnZXg6IC9bXiNcIiddKyQvLFxuICAgICAgdG9rZW46IG51bGwsXG4gICAgICBuZXh0OiBcInN0YXJ0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHJlZ2V4OiAvW14jXCInXSsvLFxuICAgICAgdG9rZW46IG51bGxcbiAgICB9LFxuICAgIC8vIEZhaWwgc2FmZSByZXR1cm4gdG8gc3RhcnRcbiAgICB7XG4gICAgICB0b2tlbjogbnVsbCxcbiAgICAgIG5leHQ6IFwic3RhcnRcIlxuICAgIH1cbiAgXSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wifVxuICB9XG59KTtcblxuIiwiZXhwb3J0IGZ1bmN0aW9uIHNpbXBsZU1vZGUoc3RhdGVzKSB7XG4gIGVuc3VyZVN0YXRlKHN0YXRlcywgXCJzdGFydFwiKTtcbiAgdmFyIHN0YXRlc18gPSB7fSwgbWV0YSA9IHN0YXRlcy5sYW5ndWFnZURhdGEgfHwge30sIGhhc0luZGVudGF0aW9uID0gZmFsc2U7XG4gIGZvciAodmFyIHN0YXRlIGluIHN0YXRlcykgaWYgKHN0YXRlICE9IG1ldGEgJiYgc3RhdGVzLmhhc093blByb3BlcnR5KHN0YXRlKSkge1xuICAgIHZhciBsaXN0ID0gc3RhdGVzX1tzdGF0ZV0gPSBbXSwgb3JpZyA9IHN0YXRlc1tzdGF0ZV07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmlnLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGF0YSA9IG9yaWdbaV07XG4gICAgICBsaXN0LnB1c2gobmV3IFJ1bGUoZGF0YSwgc3RhdGVzKSk7XG4gICAgICBpZiAoZGF0YS5pbmRlbnQgfHwgZGF0YS5kZWRlbnQpIGhhc0luZGVudGF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBtZXRhLm5hbWUsXG4gICAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge3N0YXRlOiBcInN0YXJ0XCIsIHBlbmRpbmc6IG51bGwsIGluZGVudDogaGFzSW5kZW50YXRpb24gPyBbXSA6IG51bGx9O1xuICAgIH0sXG4gICAgY29weVN0YXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgICAgdmFyIHMgPSB7c3RhdGU6IHN0YXRlLnN0YXRlLCBwZW5kaW5nOiBzdGF0ZS5wZW5kaW5nLCBpbmRlbnQ6IHN0YXRlLmluZGVudCAmJiBzdGF0ZS5pbmRlbnQuc2xpY2UoMCl9O1xuICAgICAgaWYgKHN0YXRlLnN0YWNrKVxuICAgICAgICBzLnN0YWNrID0gc3RhdGUuc3RhY2suc2xpY2UoMCk7XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuICAgIHRva2VuOiB0b2tlbkZ1bmN0aW9uKHN0YXRlc18pLFxuICAgIGluZGVudDogaW5kZW50RnVuY3Rpb24oc3RhdGVzXywgbWV0YSksXG4gICAgbGFuZ3VhZ2VEYXRhOiBtZXRhXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGVuc3VyZVN0YXRlKHN0YXRlcywgbmFtZSkge1xuICBpZiAoIXN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmRlZmluZWQgc3RhdGUgXCIgKyBuYW1lICsgXCIgaW4gc2ltcGxlIG1vZGVcIik7XG59XG5cbmZ1bmN0aW9uIHRvUmVnZXgodmFsLCBjYXJldCkge1xuICBpZiAoIXZhbCkgcmV0dXJuIC8oPzopLztcbiAgdmFyIGZsYWdzID0gXCJcIjtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIGlmICh2YWwuaWdub3JlQ2FzZSkgZmxhZ3MgPSBcImlcIjtcbiAgICB2YWwgPSB2YWwuc291cmNlO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IFN0cmluZyh2YWwpO1xuICB9XG4gIHJldHVybiBuZXcgUmVnRXhwKChjYXJldCA9PT0gZmFsc2UgPyBcIlwiIDogXCJeXCIpICsgXCIoPzpcIiArIHZhbCArIFwiKVwiLCBmbGFncyk7XG59XG5cbmZ1bmN0aW9uIGFzVG9rZW4odmFsKSB7XG4gIGlmICghdmFsKSByZXR1cm4gbnVsbDtcbiAgaWYgKHZhbC5hcHBseSkgcmV0dXJuIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiKSByZXR1cm4gdmFsLnJlcGxhY2UoL1xcLi9nLCBcIiBcIik7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspXG4gICAgcmVzdWx0LnB1c2godmFsW2ldICYmIHZhbFtpXS5yZXBsYWNlKC9cXC4vZywgXCIgXCIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gUnVsZShkYXRhLCBzdGF0ZXMpIHtcbiAgaWYgKGRhdGEubmV4dCB8fCBkYXRhLnB1c2gpIGVuc3VyZVN0YXRlKHN0YXRlcywgZGF0YS5uZXh0IHx8IGRhdGEucHVzaCk7XG4gIHRoaXMucmVnZXggPSB0b1JlZ2V4KGRhdGEucmVnZXgpO1xuICB0aGlzLnRva2VuID0gYXNUb2tlbihkYXRhLnRva2VuKTtcbiAgdGhpcy5kYXRhID0gZGF0YTtcbn1cblxuZnVuY3Rpb24gdG9rZW5GdW5jdGlvbihzdGF0ZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUucGVuZGluZykge1xuICAgICAgdmFyIHBlbmQgPSBzdGF0ZS5wZW5kaW5nLnNoaWZ0KCk7XG4gICAgICBpZiAoc3RhdGUucGVuZGluZy5sZW5ndGggPT0gMCkgc3RhdGUucGVuZGluZyA9IG51bGw7XG4gICAgICBzdHJlYW0ucG9zICs9IHBlbmQudGV4dC5sZW5ndGg7XG4gICAgICByZXR1cm4gcGVuZC50b2tlbjtcbiAgICB9XG5cbiAgICB2YXIgY3VyU3RhdGUgPSBzdGF0ZXNbc3RhdGUuc3RhdGVdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY3VyU3RhdGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBydWxlID0gY3VyU3RhdGVbaV07XG4gICAgICB2YXIgbWF0Y2hlcyA9ICghcnVsZS5kYXRhLnNvbCB8fCBzdHJlYW0uc29sKCkpICYmIHN0cmVhbS5tYXRjaChydWxlLnJlZ2V4KTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIGlmIChydWxlLmRhdGEubmV4dCkge1xuICAgICAgICAgIHN0YXRlLnN0YXRlID0gcnVsZS5kYXRhLm5leHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocnVsZS5kYXRhLnB1c2gpIHtcbiAgICAgICAgICAoc3RhdGUuc3RhY2sgfHwgKHN0YXRlLnN0YWNrID0gW10pKS5wdXNoKHN0YXRlLnN0YXRlKTtcbiAgICAgICAgICBzdGF0ZS5zdGF0ZSA9IHJ1bGUuZGF0YS5wdXNoO1xuICAgICAgICB9IGVsc2UgaWYgKHJ1bGUuZGF0YS5wb3AgJiYgc3RhdGUuc3RhY2sgJiYgc3RhdGUuc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgc3RhdGUuc3RhdGUgPSBzdGF0ZS5zdGFjay5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChydWxlLmRhdGEuaW5kZW50KVxuICAgICAgICAgIHN0YXRlLmluZGVudC5wdXNoKHN0cmVhbS5pbmRlbnRhdGlvbigpICsgc3RyZWFtLmluZGVudFVuaXQpO1xuICAgICAgICBpZiAocnVsZS5kYXRhLmRlZGVudClcbiAgICAgICAgICBzdGF0ZS5pbmRlbnQucG9wKCk7XG4gICAgICAgIHZhciB0b2tlbiA9IHJ1bGUudG9rZW5cbiAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLmFwcGx5KSB0b2tlbiA9IHRva2VuKG1hdGNoZXMpXG4gICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDIgJiYgcnVsZS50b2tlbiAmJiB0eXBlb2YgcnVsZS50b2tlbiAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgc3RhdGUucGVuZGluZyA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGogPSAyOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgIGlmIChtYXRjaGVzW2pdKVxuICAgICAgICAgICAgICBzdGF0ZS5wZW5kaW5nLnB1c2goe3RleHQ6IG1hdGNoZXNbal0sIHRva2VuOiBydWxlLnRva2VuW2ogLSAxXX0pO1xuICAgICAgICAgIHN0cmVhbS5iYWNrVXAobWF0Y2hlc1swXS5sZW5ndGggLSAobWF0Y2hlc1sxXSA/IG1hdGNoZXNbMV0ubGVuZ3RoIDogMCkpO1xuICAgICAgICAgIHJldHVybiB0b2tlblswXTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlbiAmJiB0b2tlbi5qb2luKSB7XG4gICAgICAgICAgcmV0dXJuIHRva2VuWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRlbnRGdW5jdGlvbihzdGF0ZXMsIG1ldGEpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIpIHtcbiAgICBpZiAoc3RhdGUuaW5kZW50ID09IG51bGwgfHwgbWV0YS5kb250SW5kZW50U3RhdGVzICYmIG1ldGEuZG9uZUluZGVudFN0YXRlLmluZGV4T2Yoc3RhdGUuc3RhdGUpID4gLTEpXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgdmFyIHBvcyA9IHN0YXRlLmluZGVudC5sZW5ndGggLSAxLCBydWxlcyA9IHN0YXRlc1tzdGF0ZS5zdGF0ZV07XG4gICAgc2NhbjogZm9yICg7Oykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICBpZiAocnVsZS5kYXRhLmRlZGVudCAmJiBydWxlLmRhdGEuZGVkZW50SWZMaW5lU3RhcnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgdmFyIG0gPSBydWxlLnJlZ2V4LmV4ZWModGV4dEFmdGVyKTtcbiAgICAgICAgICBpZiAobSAmJiBtWzBdKSB7XG4gICAgICAgICAgICBwb3MtLTtcbiAgICAgICAgICAgIGlmIChydWxlLm5leHQgfHwgcnVsZS5wdXNoKSBydWxlcyA9IHN0YXRlc1tydWxlLm5leHQgfHwgcnVsZS5wdXNoXTtcbiAgICAgICAgICAgIHRleHRBZnRlciA9IHRleHRBZnRlci5zbGljZShtWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBwb3MgPCAwID8gMCA6IHN0YXRlLmluZGVudFtwb3NdO1xuICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9