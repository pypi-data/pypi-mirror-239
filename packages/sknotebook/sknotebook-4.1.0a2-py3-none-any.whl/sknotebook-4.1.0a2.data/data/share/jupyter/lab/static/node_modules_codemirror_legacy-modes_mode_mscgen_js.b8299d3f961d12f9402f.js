"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_mscgen_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/mscgen.js":
/*!***************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/mscgen.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mscgen": () => (/* binding */ mscgen),
/* harmony export */   "msgenny": () => (/* binding */ msgenny),
/* harmony export */   "xu": () => (/* binding */ xu)
/* harmony export */ });
function mkParser(lang) {
  return {
    name: "mscgen",
    startState: startStateFn,
    copyState: copyStateFn,
    token: produceTokenFunction(lang),
    languageData: {
      commentTokens: {line: "#", block: {open: "/*", close: "*/"}}
    }
  }
}

const mscgen = mkParser({
  "keywords" : ["msc"],
  "options" : ["hscale", "width", "arcgradient", "wordwraparcs"],
  "constants" : ["true", "false", "on", "off"],
  "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip"],
  "brackets" : ["\\{", "\\}"], // [ and  ] are brackets too, but these get handled in with lists
  "arcsWords" : ["note", "abox", "rbox", "box"],
  "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
  "singlecomment" : ["//", "#"],
  "operators" : ["="]
})

const msgenny = mkParser({
  "keywords" : null,
  "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "wordwrapentities", "watermark"],
  "constants" : ["true", "false", "on", "off", "auto"],
  "attributes" : null,
  "brackets" : ["\\{", "\\}"],
  "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],
  "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
  "singlecomment" : ["//", "#"],
  "operators" : ["="]
})

const xu = mkParser({
  "keywords" : ["msc", "xu"],
  "options" : ["hscale", "width", "arcgradient", "wordwraparcs", "wordwrapentities", "watermark"],
  "constants" : ["true", "false", "on", "off", "auto"],
  "attributes" : ["label", "idurl", "id", "url", "linecolor", "linecolour", "textcolor", "textcolour", "textbgcolor", "textbgcolour", "arclinecolor", "arclinecolour", "arctextcolor", "arctextcolour", "arctextbgcolor", "arctextbgcolour", "arcskip", "title", "deactivate", "activate", "activation"],
  "brackets" : ["\\{", "\\}"],  // [ and  ] are brackets too, but these get handled in with lists
  "arcsWords" : ["note", "abox", "rbox", "box", "alt", "else", "opt", "break", "par", "seq", "strict", "neg", "critical", "ignore", "consider", "assert", "loop", "ref", "exc"],
  "arcsOthers" : ["\\|\\|\\|", "\\.\\.\\.", "---", "--", "<->", "==", "<<=>>", "<=>", "\\.\\.", "<<>>", "::", "<:>", "->", "=>>", "=>", ">>", ":>", "<-", "<<=", "<=", "<<", "<:", "x-", "-x"],
  "singlecomment" : ["//", "#"],
  "operators" : ["="]
})

function wordRegexpBoundary(pWords) {
  return new RegExp("^\\b(" + pWords.join("|") + ")\\b", "i");
}

function wordRegexp(pWords) {
  return new RegExp("^(?:" + pWords.join("|") + ")", "i");
}

function startStateFn() {
  return {
    inComment : false,
    inString : false,
    inAttributeList : false,
    inScript : false
  };
}

function copyStateFn(pState) {
  return {
    inComment : pState.inComment,
    inString : pState.inString,
    inAttributeList : pState.inAttributeList,
    inScript : pState.inScript
  };
}

function produceTokenFunction(pConfig) {
  return function(pStream, pState) {
    if (pStream.match(wordRegexp(pConfig.brackets), true, true)) {
      return "bracket";
    }
    /* comments */
    if (!pState.inComment) {
      if (pStream.match(/\/\*[^\*\/]*/, true, true)) {
        pState.inComment = true;
        return "comment";
      }
      if (pStream.match(wordRegexp(pConfig.singlecomment), true, true)) {
        pStream.skipToEnd();
        return "comment";
      }
    }
    if (pState.inComment) {
      if (pStream.match(/[^\*\/]*\*\//, true, true))
        pState.inComment = false;
      else
        pStream.skipToEnd();
      return "comment";
    }
    /* strings */
    if (!pState.inString && pStream.match(/\"(\\\"|[^\"])*/, true, true)) {
      pState.inString = true;
      return "string";
    }
    if (pState.inString) {
      if (pStream.match(/[^\"]*\"/, true, true))
        pState.inString = false;
      else
        pStream.skipToEnd();
      return "string";
    }
    /* keywords & operators */
    if (!!pConfig.keywords && pStream.match(wordRegexpBoundary(pConfig.keywords), true, true))
      return "keyword";

    if (pStream.match(wordRegexpBoundary(pConfig.options), true, true))
      return "keyword";

    if (pStream.match(wordRegexpBoundary(pConfig.arcsWords), true, true))
      return "keyword";

    if (pStream.match(wordRegexp(pConfig.arcsOthers), true, true))
      return "keyword";

    if (!!pConfig.operators && pStream.match(wordRegexp(pConfig.operators), true, true))
      return "operator";

    if (!!pConfig.constants && pStream.match(wordRegexp(pConfig.constants), true, true))
      return "variable";

    /* attribute lists */
    if (!pConfig.inAttributeList && !!pConfig.attributes && pStream.match('[', true, true)) {
      pConfig.inAttributeList = true;
      return "bracket";
    }
    if (pConfig.inAttributeList) {
      if (pConfig.attributes !== null && pStream.match(wordRegexpBoundary(pConfig.attributes), true, true)) {
        return "attribute";
      }
      if (pStream.match(']', true, true)) {
        pConfig.inAttributeList = false;
        return "bracket";
      }
    }

    pStream.next();
    return null
  };
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfbXNjZ2VuX2pzLmI4Mjk5ZDNmOTYxZDEyZjk0MDJmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvbXNjZ2VuLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG1rUGFyc2VyKGxhbmcpIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcIm1zY2dlblwiLFxuICAgIHN0YXJ0U3RhdGU6IHN0YXJ0U3RhdGVGbixcbiAgICBjb3B5U3RhdGU6IGNvcHlTdGF0ZUZuLFxuICAgIHRva2VuOiBwcm9kdWNlVG9rZW5GdW5jdGlvbihsYW5nKSxcbiAgICBsYW5ndWFnZURhdGE6IHtcbiAgICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIiNcIiwgYmxvY2s6IHtvcGVuOiBcIi8qXCIsIGNsb3NlOiBcIiovXCJ9fVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbXNjZ2VuID0gbWtQYXJzZXIoe1xuICBcImtleXdvcmRzXCIgOiBbXCJtc2NcIl0sXG4gIFwib3B0aW9uc1wiIDogW1wiaHNjYWxlXCIsIFwid2lkdGhcIiwgXCJhcmNncmFkaWVudFwiLCBcIndvcmR3cmFwYXJjc1wiXSxcbiAgXCJjb25zdGFudHNcIiA6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcIm9uXCIsIFwib2ZmXCJdLFxuICBcImF0dHJpYnV0ZXNcIiA6IFtcImxhYmVsXCIsIFwiaWR1cmxcIiwgXCJpZFwiLCBcInVybFwiLCBcImxpbmVjb2xvclwiLCBcImxpbmVjb2xvdXJcIiwgXCJ0ZXh0Y29sb3JcIiwgXCJ0ZXh0Y29sb3VyXCIsIFwidGV4dGJnY29sb3JcIiwgXCJ0ZXh0Ymdjb2xvdXJcIiwgXCJhcmNsaW5lY29sb3JcIiwgXCJhcmNsaW5lY29sb3VyXCIsIFwiYXJjdGV4dGNvbG9yXCIsIFwiYXJjdGV4dGNvbG91clwiLCBcImFyY3RleHRiZ2NvbG9yXCIsIFwiYXJjdGV4dGJnY29sb3VyXCIsIFwiYXJjc2tpcFwiXSxcbiAgXCJicmFja2V0c1wiIDogW1wiXFxcXHtcIiwgXCJcXFxcfVwiXSwgLy8gWyBhbmQgIF0gYXJlIGJyYWNrZXRzIHRvbywgYnV0IHRoZXNlIGdldCBoYW5kbGVkIGluIHdpdGggbGlzdHNcbiAgXCJhcmNzV29yZHNcIiA6IFtcIm5vdGVcIiwgXCJhYm94XCIsIFwicmJveFwiLCBcImJveFwiXSxcbiAgXCJhcmNzT3RoZXJzXCIgOiBbXCJcXFxcfFxcXFx8XFxcXHxcIiwgXCJcXFxcLlxcXFwuXFxcXC5cIiwgXCItLS1cIiwgXCItLVwiLCBcIjwtPlwiLCBcIj09XCIsIFwiPDw9Pj5cIiwgXCI8PT5cIiwgXCJcXFxcLlxcXFwuXCIsIFwiPDw+PlwiLCBcIjo6XCIsIFwiPDo+XCIsIFwiLT5cIiwgXCI9Pj5cIiwgXCI9PlwiLCBcIj4+XCIsIFwiOj5cIiwgXCI8LVwiLCBcIjw8PVwiLCBcIjw9XCIsIFwiPDxcIiwgXCI8OlwiLCBcIngtXCIsIFwiLXhcIl0sXG4gIFwic2luZ2xlY29tbWVudFwiIDogW1wiLy9cIiwgXCIjXCJdLFxuICBcIm9wZXJhdG9yc1wiIDogW1wiPVwiXVxufSlcblxuZXhwb3J0IGNvbnN0IG1zZ2VubnkgPSBta1BhcnNlcih7XG4gIFwia2V5d29yZHNcIiA6IG51bGwsXG4gIFwib3B0aW9uc1wiIDogW1wiaHNjYWxlXCIsIFwid2lkdGhcIiwgXCJhcmNncmFkaWVudFwiLCBcIndvcmR3cmFwYXJjc1wiLCBcIndvcmR3cmFwZW50aXRpZXNcIiwgXCJ3YXRlcm1hcmtcIl0sXG4gIFwiY29uc3RhbnRzXCIgOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJvblwiLCBcIm9mZlwiLCBcImF1dG9cIl0sXG4gIFwiYXR0cmlidXRlc1wiIDogbnVsbCxcbiAgXCJicmFja2V0c1wiIDogW1wiXFxcXHtcIiwgXCJcXFxcfVwiXSxcbiAgXCJhcmNzV29yZHNcIiA6IFtcIm5vdGVcIiwgXCJhYm94XCIsIFwicmJveFwiLCBcImJveFwiLCBcImFsdFwiLCBcImVsc2VcIiwgXCJvcHRcIiwgXCJicmVha1wiLCBcInBhclwiLCBcInNlcVwiLCBcInN0cmljdFwiLCBcIm5lZ1wiLCBcImNyaXRpY2FsXCIsIFwiaWdub3JlXCIsIFwiY29uc2lkZXJcIiwgXCJhc3NlcnRcIiwgXCJsb29wXCIsIFwicmVmXCIsIFwiZXhjXCJdLFxuICBcImFyY3NPdGhlcnNcIiA6IFtcIlxcXFx8XFxcXHxcXFxcfFwiLCBcIlxcXFwuXFxcXC5cXFxcLlwiLCBcIi0tLVwiLCBcIi0tXCIsIFwiPC0+XCIsIFwiPT1cIiwgXCI8PD0+PlwiLCBcIjw9PlwiLCBcIlxcXFwuXFxcXC5cIiwgXCI8PD4+XCIsIFwiOjpcIiwgXCI8Oj5cIiwgXCItPlwiLCBcIj0+PlwiLCBcIj0+XCIsIFwiPj5cIiwgXCI6PlwiLCBcIjwtXCIsIFwiPDw9XCIsIFwiPD1cIiwgXCI8PFwiLCBcIjw6XCIsIFwieC1cIiwgXCIteFwiXSxcbiAgXCJzaW5nbGVjb21tZW50XCIgOiBbXCIvL1wiLCBcIiNcIl0sXG4gIFwib3BlcmF0b3JzXCIgOiBbXCI9XCJdXG59KVxuXG5leHBvcnQgY29uc3QgeHUgPSBta1BhcnNlcih7XG4gIFwia2V5d29yZHNcIiA6IFtcIm1zY1wiLCBcInh1XCJdLFxuICBcIm9wdGlvbnNcIiA6IFtcImhzY2FsZVwiLCBcIndpZHRoXCIsIFwiYXJjZ3JhZGllbnRcIiwgXCJ3b3Jkd3JhcGFyY3NcIiwgXCJ3b3Jkd3JhcGVudGl0aWVzXCIsIFwid2F0ZXJtYXJrXCJdLFxuICBcImNvbnN0YW50c1wiIDogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwib25cIiwgXCJvZmZcIiwgXCJhdXRvXCJdLFxuICBcImF0dHJpYnV0ZXNcIiA6IFtcImxhYmVsXCIsIFwiaWR1cmxcIiwgXCJpZFwiLCBcInVybFwiLCBcImxpbmVjb2xvclwiLCBcImxpbmVjb2xvdXJcIiwgXCJ0ZXh0Y29sb3JcIiwgXCJ0ZXh0Y29sb3VyXCIsIFwidGV4dGJnY29sb3JcIiwgXCJ0ZXh0Ymdjb2xvdXJcIiwgXCJhcmNsaW5lY29sb3JcIiwgXCJhcmNsaW5lY29sb3VyXCIsIFwiYXJjdGV4dGNvbG9yXCIsIFwiYXJjdGV4dGNvbG91clwiLCBcImFyY3RleHRiZ2NvbG9yXCIsIFwiYXJjdGV4dGJnY29sb3VyXCIsIFwiYXJjc2tpcFwiLCBcInRpdGxlXCIsIFwiZGVhY3RpdmF0ZVwiLCBcImFjdGl2YXRlXCIsIFwiYWN0aXZhdGlvblwiXSxcbiAgXCJicmFja2V0c1wiIDogW1wiXFxcXHtcIiwgXCJcXFxcfVwiXSwgIC8vIFsgYW5kICBdIGFyZSBicmFja2V0cyB0b28sIGJ1dCB0aGVzZSBnZXQgaGFuZGxlZCBpbiB3aXRoIGxpc3RzXG4gIFwiYXJjc1dvcmRzXCIgOiBbXCJub3RlXCIsIFwiYWJveFwiLCBcInJib3hcIiwgXCJib3hcIiwgXCJhbHRcIiwgXCJlbHNlXCIsIFwib3B0XCIsIFwiYnJlYWtcIiwgXCJwYXJcIiwgXCJzZXFcIiwgXCJzdHJpY3RcIiwgXCJuZWdcIiwgXCJjcml0aWNhbFwiLCBcImlnbm9yZVwiLCBcImNvbnNpZGVyXCIsIFwiYXNzZXJ0XCIsIFwibG9vcFwiLCBcInJlZlwiLCBcImV4Y1wiXSxcbiAgXCJhcmNzT3RoZXJzXCIgOiBbXCJcXFxcfFxcXFx8XFxcXHxcIiwgXCJcXFxcLlxcXFwuXFxcXC5cIiwgXCItLS1cIiwgXCItLVwiLCBcIjwtPlwiLCBcIj09XCIsIFwiPDw9Pj5cIiwgXCI8PT5cIiwgXCJcXFxcLlxcXFwuXCIsIFwiPDw+PlwiLCBcIjo6XCIsIFwiPDo+XCIsIFwiLT5cIiwgXCI9Pj5cIiwgXCI9PlwiLCBcIj4+XCIsIFwiOj5cIiwgXCI8LVwiLCBcIjw8PVwiLCBcIjw9XCIsIFwiPDxcIiwgXCI8OlwiLCBcIngtXCIsIFwiLXhcIl0sXG4gIFwic2luZ2xlY29tbWVudFwiIDogW1wiLy9cIiwgXCIjXCJdLFxuICBcIm9wZXJhdG9yc1wiIDogW1wiPVwiXVxufSlcblxuZnVuY3Rpb24gd29yZFJlZ2V4cEJvdW5kYXJ5KHBXb3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl5cXFxcYihcIiArIHBXb3Jkcy5qb2luKFwifFwiKSArIFwiKVxcXFxiXCIsIFwiaVwiKTtcbn1cblxuZnVuY3Rpb24gd29yZFJlZ2V4cChwV29yZHMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKD86XCIgKyBwV29yZHMuam9pbihcInxcIikgKyBcIilcIiwgXCJpXCIpO1xufVxuXG5mdW5jdGlvbiBzdGFydFN0YXRlRm4oKSB7XG4gIHJldHVybiB7XG4gICAgaW5Db21tZW50IDogZmFsc2UsXG4gICAgaW5TdHJpbmcgOiBmYWxzZSxcbiAgICBpbkF0dHJpYnV0ZUxpc3QgOiBmYWxzZSxcbiAgICBpblNjcmlwdCA6IGZhbHNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvcHlTdGF0ZUZuKHBTdGF0ZSkge1xuICByZXR1cm4ge1xuICAgIGluQ29tbWVudCA6IHBTdGF0ZS5pbkNvbW1lbnQsXG4gICAgaW5TdHJpbmcgOiBwU3RhdGUuaW5TdHJpbmcsXG4gICAgaW5BdHRyaWJ1dGVMaXN0IDogcFN0YXRlLmluQXR0cmlidXRlTGlzdCxcbiAgICBpblNjcmlwdCA6IHBTdGF0ZS5pblNjcmlwdFxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm9kdWNlVG9rZW5GdW5jdGlvbihwQ29uZmlnKSB7XG4gIHJldHVybiBmdW5jdGlvbihwU3RyZWFtLCBwU3RhdGUpIHtcbiAgICBpZiAocFN0cmVhbS5tYXRjaCh3b3JkUmVnZXhwKHBDb25maWcuYnJhY2tldHMpLCB0cnVlLCB0cnVlKSkge1xuICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgIH1cbiAgICAvKiBjb21tZW50cyAqL1xuICAgIGlmICghcFN0YXRlLmluQ29tbWVudCkge1xuICAgICAgaWYgKHBTdHJlYW0ubWF0Y2goL1xcL1xcKlteXFwqXFwvXSovLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICBwU3RhdGUuaW5Db21tZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgICAgaWYgKHBTdHJlYW0ubWF0Y2god29yZFJlZ2V4cChwQ29uZmlnLnNpbmdsZWNvbW1lbnQpLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICBwU3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwU3RhdGUuaW5Db21tZW50KSB7XG4gICAgICBpZiAocFN0cmVhbS5tYXRjaCgvW15cXCpcXC9dKlxcKlxcLy8sIHRydWUsIHRydWUpKVxuICAgICAgICBwU3RhdGUuaW5Db21tZW50ID0gZmFsc2U7XG4gICAgICBlbHNlXG4gICAgICAgIHBTdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICAgIC8qIHN0cmluZ3MgKi9cbiAgICBpZiAoIXBTdGF0ZS5pblN0cmluZyAmJiBwU3RyZWFtLm1hdGNoKC9cXFwiKFxcXFxcXFwifFteXFxcIl0pKi8sIHRydWUsIHRydWUpKSB7XG4gICAgICBwU3RhdGUuaW5TdHJpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgfVxuICAgIGlmIChwU3RhdGUuaW5TdHJpbmcpIHtcbiAgICAgIGlmIChwU3RyZWFtLm1hdGNoKC9bXlxcXCJdKlxcXCIvLCB0cnVlLCB0cnVlKSlcbiAgICAgICAgcFN0YXRlLmluU3RyaW5nID0gZmFsc2U7XG4gICAgICBlbHNlXG4gICAgICAgIHBTdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgLyoga2V5d29yZHMgJiBvcGVyYXRvcnMgKi9cbiAgICBpZiAoISFwQ29uZmlnLmtleXdvcmRzICYmIHBTdHJlYW0ubWF0Y2god29yZFJlZ2V4cEJvdW5kYXJ5KHBDb25maWcua2V5d29yZHMpLCB0cnVlLCB0cnVlKSlcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgIGlmIChwU3RyZWFtLm1hdGNoKHdvcmRSZWdleHBCb3VuZGFyeShwQ29uZmlnLm9wdGlvbnMpLCB0cnVlLCB0cnVlKSlcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgIGlmIChwU3RyZWFtLm1hdGNoKHdvcmRSZWdleHBCb3VuZGFyeShwQ29uZmlnLmFyY3NXb3JkcyksIHRydWUsIHRydWUpKVxuICAgICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gICAgaWYgKHBTdHJlYW0ubWF0Y2god29yZFJlZ2V4cChwQ29uZmlnLmFyY3NPdGhlcnMpLCB0cnVlLCB0cnVlKSlcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICAgIGlmICghIXBDb25maWcub3BlcmF0b3JzICYmIHBTdHJlYW0ubWF0Y2god29yZFJlZ2V4cChwQ29uZmlnLm9wZXJhdG9ycyksIHRydWUsIHRydWUpKVxuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcblxuICAgIGlmICghIXBDb25maWcuY29uc3RhbnRzICYmIHBTdHJlYW0ubWF0Y2god29yZFJlZ2V4cChwQ29uZmlnLmNvbnN0YW50cyksIHRydWUsIHRydWUpKVxuICAgICAgcmV0dXJuIFwidmFyaWFibGVcIjtcblxuICAgIC8qIGF0dHJpYnV0ZSBsaXN0cyAqL1xuICAgIGlmICghcENvbmZpZy5pbkF0dHJpYnV0ZUxpc3QgJiYgISFwQ29uZmlnLmF0dHJpYnV0ZXMgJiYgcFN0cmVhbS5tYXRjaCgnWycsIHRydWUsIHRydWUpKSB7XG4gICAgICBwQ29uZmlnLmluQXR0cmlidXRlTGlzdCA9IHRydWU7XG4gICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgfVxuICAgIGlmIChwQ29uZmlnLmluQXR0cmlidXRlTGlzdCkge1xuICAgICAgaWYgKHBDb25maWcuYXR0cmlidXRlcyAhPT0gbnVsbCAmJiBwU3RyZWFtLm1hdGNoKHdvcmRSZWdleHBCb3VuZGFyeShwQ29uZmlnLmF0dHJpYnV0ZXMpLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbiAgICAgIH1cbiAgICAgIGlmIChwU3RyZWFtLm1hdGNoKCddJywgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgcENvbmZpZy5pbkF0dHJpYnV0ZUxpc3QgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBTdHJlYW0ubmV4dCgpO1xuICAgIHJldHVybiBudWxsXG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=