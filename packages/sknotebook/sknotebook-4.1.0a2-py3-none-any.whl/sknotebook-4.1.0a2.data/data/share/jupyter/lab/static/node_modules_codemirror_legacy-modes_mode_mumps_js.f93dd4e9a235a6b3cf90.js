"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_mumps_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/mumps.js":
/*!**************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/mumps.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mumps": () => (/* binding */ mumps)
/* harmony export */ });
function wordRegexp(words) {
  return new RegExp("^((" + words.join(")|(") + "))\\b", "i");
}

var singleOperators = new RegExp("^[\\+\\-\\*/&#!_?\\\\<>=\\'\\[\\]]");
var doubleOperators = new RegExp("^(('=)|(<=)|(>=)|('>)|('<)|([[)|(]])|(^$))");
var singleDelimiters = new RegExp("^[\\.,:]");
var brackets = new RegExp("[()]");
var identifiers = new RegExp("^[%A-Za-z][A-Za-z0-9]*");
var commandKeywords = ["break","close","do","else","for","goto", "halt", "hang", "if", "job","kill","lock","merge","new","open", "quit", "read", "set", "tcommit", "trollback", "tstart", "use", "view", "write", "xecute", "b","c","d","e","f","g", "h", "i", "j","k","l","m","n","o", "q", "r", "s", "tc", "tro", "ts", "u", "v", "w", "x"];
// The following list includes intrinsic functions _and_ special variables
var intrinsicFuncsWords = ["\\$ascii", "\\$char", "\\$data", "\\$ecode", "\\$estack", "\\$etrap", "\\$extract", "\\$find", "\\$fnumber", "\\$get", "\\$horolog", "\\$io", "\\$increment", "\\$job", "\\$justify", "\\$length", "\\$name", "\\$next", "\\$order", "\\$piece", "\\$qlength", "\\$qsubscript", "\\$query", "\\$quit", "\\$random", "\\$reverse", "\\$select", "\\$stack", "\\$test", "\\$text", "\\$translate", "\\$view", "\\$x", "\\$y", "\\$a", "\\$c", "\\$d", "\\$e", "\\$ec", "\\$es", "\\$et", "\\$f", "\\$fn", "\\$g", "\\$h", "\\$i", "\\$j", "\\$l", "\\$n", "\\$na", "\\$o", "\\$p", "\\$q", "\\$ql", "\\$qs", "\\$r", "\\$re", "\\$s", "\\$st", "\\$t", "\\$tr", "\\$v", "\\$z"];
var intrinsicFuncs = wordRegexp(intrinsicFuncsWords);
var command = wordRegexp(commandKeywords);

function tokenBase(stream, state) {
  if (stream.sol()) {
    state.label = true;
    state.commandMode = 0;
  }

  // The <space> character has meaning in MUMPS. Ignoring consecutive
  // spaces would interfere with interpreting whether the next non-space
  // character belongs to the command or argument context.

  // Examine each character and update a mode variable whose interpretation is:
  //   >0 => command    0 => argument    <0 => command post-conditional
  var ch = stream.peek();

  if (ch == " " || ch == "\t") { // Pre-process <space>
    state.label = false;
    if (state.commandMode == 0)
      state.commandMode = 1;
    else if ((state.commandMode < 0) || (state.commandMode == 2))
      state.commandMode = 0;
  } else if ((ch != ".") && (state.commandMode > 0)) {
    if (ch == ":")
      state.commandMode = -1;   // SIS - Command post-conditional
    else
      state.commandMode = 2;
  }

  // Do not color parameter list as line tag
  if ((ch === "(") || (ch === "\u0009"))
    state.label = false;

  // MUMPS comment starts with ";"
  if (ch === ";") {
    stream.skipToEnd();
    return "comment";
  }

  // Number Literals // SIS/RLM - MUMPS permits canonic number followed by concatenate operator
  if (stream.match(/^[-+]?\d+(\.\d+)?([eE][-+]?\d+)?/))
    return "number";

  // Handle Strings
  if (ch == '"') {
    if (stream.skipTo('"')) {
      stream.next();
      return "string";
    } else {
      stream.skipToEnd();
      return "error";
    }
  }

  // Handle operators and Delimiters
  if (stream.match(doubleOperators) || stream.match(singleOperators))
    return "operator";

  // Prevents leading "." in DO block from falling through to error
  if (stream.match(singleDelimiters))
    return null;

  if (brackets.test(ch)) {
    stream.next();
    return "bracket";
  }

  if (state.commandMode > 0 && stream.match(command))
    return "controlKeyword";

  if (stream.match(intrinsicFuncs))
    return "builtin";

  if (stream.match(identifiers))
    return "variable";

  // Detect dollar-sign when not a documented intrinsic function
  // "^" may introduce a GVN or SSVN - Color same as function
  if (ch === "$" || ch === "^") {
    stream.next();
    return "builtin";
  }

  // MUMPS Indirection
  if (ch === "@") {
    stream.next();
    return "string.special";
  }

  if (/[\w%]/.test(ch)) {
    stream.eatWhile(/[\w%]/);
    return "variable";
  }

  // Handle non-detected items
  stream.next();
  return "error";
}

const mumps = {
  name: "mumps",
  startState: function() {
    return {
      label: false,
      commandMode: 0
    };
  },

  token: function(stream, state) {
    var style = tokenBase(stream, state);
    if (state.label) return "tag";
    return style;
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfbXVtcHNfanMuZjkzZGQ0ZTlhMjM1YTZiM2NmOTAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakMsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL211bXBzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHdvcmRSZWdleHAod29yZHMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoXCJeKChcIiArIHdvcmRzLmpvaW4oXCIpfChcIikgKyBcIikpXFxcXGJcIiwgXCJpXCIpO1xufVxuXG52YXIgc2luZ2xlT3BlcmF0b3JzID0gbmV3IFJlZ0V4cChcIl5bXFxcXCtcXFxcLVxcXFwqLyYjIV8/XFxcXFxcXFw8Pj1cXFxcJ1xcXFxbXFxcXF1dXCIpO1xudmFyIGRvdWJsZU9wZXJhdG9ycyA9IG5ldyBSZWdFeHAoXCJeKCgnPSl8KDw9KXwoPj0pfCgnPil8KCc8KXwoW1spfChdXSl8KF4kKSlcIik7XG52YXIgc2luZ2xlRGVsaW1pdGVycyA9IG5ldyBSZWdFeHAoXCJeW1xcXFwuLDpdXCIpO1xudmFyIGJyYWNrZXRzID0gbmV3IFJlZ0V4cChcIlsoKV1cIik7XG52YXIgaWRlbnRpZmllcnMgPSBuZXcgUmVnRXhwKFwiXlslQS1aYS16XVtBLVphLXowLTldKlwiKTtcbnZhciBjb21tYW5kS2V5d29yZHMgPSBbXCJicmVha1wiLFwiY2xvc2VcIixcImRvXCIsXCJlbHNlXCIsXCJmb3JcIixcImdvdG9cIiwgXCJoYWx0XCIsIFwiaGFuZ1wiLCBcImlmXCIsIFwiam9iXCIsXCJraWxsXCIsXCJsb2NrXCIsXCJtZXJnZVwiLFwibmV3XCIsXCJvcGVuXCIsIFwicXVpdFwiLCBcInJlYWRcIiwgXCJzZXRcIiwgXCJ0Y29tbWl0XCIsIFwidHJvbGxiYWNrXCIsIFwidHN0YXJ0XCIsIFwidXNlXCIsIFwidmlld1wiLCBcIndyaXRlXCIsIFwieGVjdXRlXCIsIFwiYlwiLFwiY1wiLFwiZFwiLFwiZVwiLFwiZlwiLFwiZ1wiLCBcImhcIiwgXCJpXCIsIFwialwiLFwia1wiLFwibFwiLFwibVwiLFwiblwiLFwib1wiLCBcInFcIiwgXCJyXCIsIFwic1wiLCBcInRjXCIsIFwidHJvXCIsIFwidHNcIiwgXCJ1XCIsIFwidlwiLCBcIndcIiwgXCJ4XCJdO1xuLy8gVGhlIGZvbGxvd2luZyBsaXN0IGluY2x1ZGVzIGludHJpbnNpYyBmdW5jdGlvbnMgX2FuZF8gc3BlY2lhbCB2YXJpYWJsZXNcbnZhciBpbnRyaW5zaWNGdW5jc1dvcmRzID0gW1wiXFxcXCRhc2NpaVwiLCBcIlxcXFwkY2hhclwiLCBcIlxcXFwkZGF0YVwiLCBcIlxcXFwkZWNvZGVcIiwgXCJcXFxcJGVzdGFja1wiLCBcIlxcXFwkZXRyYXBcIiwgXCJcXFxcJGV4dHJhY3RcIiwgXCJcXFxcJGZpbmRcIiwgXCJcXFxcJGZudW1iZXJcIiwgXCJcXFxcJGdldFwiLCBcIlxcXFwkaG9yb2xvZ1wiLCBcIlxcXFwkaW9cIiwgXCJcXFxcJGluY3JlbWVudFwiLCBcIlxcXFwkam9iXCIsIFwiXFxcXCRqdXN0aWZ5XCIsIFwiXFxcXCRsZW5ndGhcIiwgXCJcXFxcJG5hbWVcIiwgXCJcXFxcJG5leHRcIiwgXCJcXFxcJG9yZGVyXCIsIFwiXFxcXCRwaWVjZVwiLCBcIlxcXFwkcWxlbmd0aFwiLCBcIlxcXFwkcXN1YnNjcmlwdFwiLCBcIlxcXFwkcXVlcnlcIiwgXCJcXFxcJHF1aXRcIiwgXCJcXFxcJHJhbmRvbVwiLCBcIlxcXFwkcmV2ZXJzZVwiLCBcIlxcXFwkc2VsZWN0XCIsIFwiXFxcXCRzdGFja1wiLCBcIlxcXFwkdGVzdFwiLCBcIlxcXFwkdGV4dFwiLCBcIlxcXFwkdHJhbnNsYXRlXCIsIFwiXFxcXCR2aWV3XCIsIFwiXFxcXCR4XCIsIFwiXFxcXCR5XCIsIFwiXFxcXCRhXCIsIFwiXFxcXCRjXCIsIFwiXFxcXCRkXCIsIFwiXFxcXCRlXCIsIFwiXFxcXCRlY1wiLCBcIlxcXFwkZXNcIiwgXCJcXFxcJGV0XCIsIFwiXFxcXCRmXCIsIFwiXFxcXCRmblwiLCBcIlxcXFwkZ1wiLCBcIlxcXFwkaFwiLCBcIlxcXFwkaVwiLCBcIlxcXFwkalwiLCBcIlxcXFwkbFwiLCBcIlxcXFwkblwiLCBcIlxcXFwkbmFcIiwgXCJcXFxcJG9cIiwgXCJcXFxcJHBcIiwgXCJcXFxcJHFcIiwgXCJcXFxcJHFsXCIsIFwiXFxcXCRxc1wiLCBcIlxcXFwkclwiLCBcIlxcXFwkcmVcIiwgXCJcXFxcJHNcIiwgXCJcXFxcJHN0XCIsIFwiXFxcXCR0XCIsIFwiXFxcXCR0clwiLCBcIlxcXFwkdlwiLCBcIlxcXFwkelwiXTtcbnZhciBpbnRyaW5zaWNGdW5jcyA9IHdvcmRSZWdleHAoaW50cmluc2ljRnVuY3NXb3Jkcyk7XG52YXIgY29tbWFuZCA9IHdvcmRSZWdleHAoY29tbWFuZEtleXdvcmRzKTtcblxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0cmVhbS5zb2woKSkge1xuICAgIHN0YXRlLmxhYmVsID0gdHJ1ZTtcbiAgICBzdGF0ZS5jb21tYW5kTW9kZSA9IDA7XG4gIH1cblxuICAvLyBUaGUgPHNwYWNlPiBjaGFyYWN0ZXIgaGFzIG1lYW5pbmcgaW4gTVVNUFMuIElnbm9yaW5nIGNvbnNlY3V0aXZlXG4gIC8vIHNwYWNlcyB3b3VsZCBpbnRlcmZlcmUgd2l0aCBpbnRlcnByZXRpbmcgd2hldGhlciB0aGUgbmV4dCBub24tc3BhY2VcbiAgLy8gY2hhcmFjdGVyIGJlbG9uZ3MgdG8gdGhlIGNvbW1hbmQgb3IgYXJndW1lbnQgY29udGV4dC5cblxuICAvLyBFeGFtaW5lIGVhY2ggY2hhcmFjdGVyIGFuZCB1cGRhdGUgYSBtb2RlIHZhcmlhYmxlIHdob3NlIGludGVycHJldGF0aW9uIGlzOlxuICAvLyAgID4wID0+IGNvbW1hbmQgICAgMCA9PiBhcmd1bWVudCAgICA8MCA9PiBjb21tYW5kIHBvc3QtY29uZGl0aW9uYWxcbiAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICBpZiAoY2ggPT0gXCIgXCIgfHwgY2ggPT0gXCJcXHRcIikgeyAvLyBQcmUtcHJvY2VzcyA8c3BhY2U+XG4gICAgc3RhdGUubGFiZWwgPSBmYWxzZTtcbiAgICBpZiAoc3RhdGUuY29tbWFuZE1vZGUgPT0gMClcbiAgICAgIHN0YXRlLmNvbW1hbmRNb2RlID0gMTtcbiAgICBlbHNlIGlmICgoc3RhdGUuY29tbWFuZE1vZGUgPCAwKSB8fCAoc3RhdGUuY29tbWFuZE1vZGUgPT0gMikpXG4gICAgICBzdGF0ZS5jb21tYW5kTW9kZSA9IDA7XG4gIH0gZWxzZSBpZiAoKGNoICE9IFwiLlwiKSAmJiAoc3RhdGUuY29tbWFuZE1vZGUgPiAwKSkge1xuICAgIGlmIChjaCA9PSBcIjpcIilcbiAgICAgIHN0YXRlLmNvbW1hbmRNb2RlID0gLTE7ICAgLy8gU0lTIC0gQ29tbWFuZCBwb3N0LWNvbmRpdGlvbmFsXG4gICAgZWxzZVxuICAgICAgc3RhdGUuY29tbWFuZE1vZGUgPSAyO1xuICB9XG5cbiAgLy8gRG8gbm90IGNvbG9yIHBhcmFtZXRlciBsaXN0IGFzIGxpbmUgdGFnXG4gIGlmICgoY2ggPT09IFwiKFwiKSB8fCAoY2ggPT09IFwiXFx1MDAwOVwiKSlcbiAgICBzdGF0ZS5sYWJlbCA9IGZhbHNlO1xuXG4gIC8vIE1VTVBTIGNvbW1lbnQgc3RhcnRzIHdpdGggXCI7XCJcbiAgaWYgKGNoID09PSBcIjtcIikge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICAvLyBOdW1iZXIgTGl0ZXJhbHMgLy8gU0lTL1JMTSAtIE1VTVBTIHBlcm1pdHMgY2Fub25pYyBudW1iZXIgZm9sbG93ZWQgYnkgY29uY2F0ZW5hdGUgb3BlcmF0b3JcbiAgaWYgKHN0cmVhbS5tYXRjaCgvXlstK10/XFxkKyhcXC5cXGQrKT8oW2VFXVstK10/XFxkKyk/LykpXG4gICAgcmV0dXJuIFwibnVtYmVyXCI7XG5cbiAgLy8gSGFuZGxlIFN0cmluZ3NcbiAgaWYgKGNoID09ICdcIicpIHtcbiAgICBpZiAoc3RyZWFtLnNraXBUbygnXCInKSkge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJlcnJvclwiO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsZSBvcGVyYXRvcnMgYW5kIERlbGltaXRlcnNcbiAgaWYgKHN0cmVhbS5tYXRjaChkb3VibGVPcGVyYXRvcnMpIHx8IHN0cmVhbS5tYXRjaChzaW5nbGVPcGVyYXRvcnMpKVxuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG5cbiAgLy8gUHJldmVudHMgbGVhZGluZyBcIi5cIiBpbiBETyBibG9jayBmcm9tIGZhbGxpbmcgdGhyb3VnaCB0byBlcnJvclxuICBpZiAoc3RyZWFtLm1hdGNoKHNpbmdsZURlbGltaXRlcnMpKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChicmFja2V0cy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICB9XG5cbiAgaWYgKHN0YXRlLmNvbW1hbmRNb2RlID4gMCAmJiBzdHJlYW0ubWF0Y2goY29tbWFuZCkpXG4gICAgcmV0dXJuIFwiY29udHJvbEtleXdvcmRcIjtcblxuICBpZiAoc3RyZWFtLm1hdGNoKGludHJpbnNpY0Z1bmNzKSlcbiAgICByZXR1cm4gXCJidWlsdGluXCI7XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpXG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcblxuICAvLyBEZXRlY3QgZG9sbGFyLXNpZ24gd2hlbiBub3QgYSBkb2N1bWVudGVkIGludHJpbnNpYyBmdW5jdGlvblxuICAvLyBcIl5cIiBtYXkgaW50cm9kdWNlIGEgR1ZOIG9yIFNTVk4gLSBDb2xvciBzYW1lIGFzIGZ1bmN0aW9uXG4gIGlmIChjaCA9PT0gXCIkXCIgfHwgY2ggPT09IFwiXlwiKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gIH1cblxuICAvLyBNVU1QUyBJbmRpcmVjdGlvblxuICBpZiAoY2ggPT09IFwiQFwiKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gXCJzdHJpbmcuc3BlY2lhbFwiO1xuICB9XG5cbiAgaWYgKC9bXFx3JV0vLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3JV0vKTtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgLy8gSGFuZGxlIG5vbi1kZXRlY3RlZCBpdGVtc1xuICBzdHJlYW0ubmV4dCgpO1xuICByZXR1cm4gXCJlcnJvclwiO1xufVxuXG5leHBvcnQgY29uc3QgbXVtcHMgPSB7XG4gIG5hbWU6IFwibXVtcHNcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhYmVsOiBmYWxzZSxcbiAgICAgIGNvbW1hbmRNb2RlOiAwXG4gICAgfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBzdHlsZSA9IHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUubGFiZWwpIHJldHVybiBcInRhZ1wiO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==