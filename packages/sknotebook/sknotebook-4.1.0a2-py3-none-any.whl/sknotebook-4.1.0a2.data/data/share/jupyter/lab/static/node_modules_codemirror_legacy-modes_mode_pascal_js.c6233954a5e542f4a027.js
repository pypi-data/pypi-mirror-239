"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_pascal_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/pascal.js":
/*!***************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/pascal.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pascal": () => (/* binding */ pascal)
/* harmony export */ });
function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}
var keywords = words(
  "absolute and array asm begin case const constructor destructor div do " +
    "downto else end file for function goto if implementation in inherited " +
    "inline interface label mod nil not object of operator or packed procedure " +
    "program record reintroduce repeat self set shl shr string then to type " +
    "unit until uses var while with xor as class dispinterface except exports " +
    "finalization finally initialization inline is library on out packed " +
    "property raise resourcestring threadvar try absolute abstract alias " +
    "assembler bitpacked break cdecl continue cppdecl cvar default deprecated " +
    "dynamic enumerator experimental export external far far16 forward generic " +
    "helper implements index interrupt iocheck local message name near " +
    "nodefault noreturn nostackframe oldfpccall otherwise overload override " +
    "pascal platform private protected public published read register " +
    "reintroduce result safecall saveregisters softfloat specialize static " +
    "stdcall stored strict unaligned unimplemented varargs virtual write");
var atoms = {"null": true};

var isOperatorChar = /[+\-*&%=<>!?|\/]/;

function tokenBase(stream, state) {
  var ch = stream.next();
  if (ch == "#" && state.startOfLine) {
    stream.skipToEnd();
    return "meta";
  }
  if (ch == '"' || ch == "'") {
    state.tokenize = tokenString(ch);
    return state.tokenize(stream, state);
  }
  if (ch == "(" && stream.eat("*")) {
    state.tokenize = tokenComment;
    return tokenComment(stream, state);
  }
  if (ch == "{") {
    state.tokenize = tokenCommentBraces;
    return tokenCommentBraces(stream, state);
  }
  if (/[\[\]\(\),;\:\.]/.test(ch)) {
    return null;
  }
  if (/\d/.test(ch)) {
    stream.eatWhile(/[\w\.]/);
    return "number";
  }
  if (ch == "/") {
    if (stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
  }
  if (isOperatorChar.test(ch)) {
    stream.eatWhile(isOperatorChar);
    return "operator";
  }
  stream.eatWhile(/[\w\$_]/);
  var cur = stream.current();
  if (keywords.propertyIsEnumerable(cur)) return "keyword";
  if (atoms.propertyIsEnumerable(cur)) return "atom";
  return "variable";
}

function tokenString(quote) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while ((next = stream.next()) != null) {
      if (next == quote && !escaped) {end = true; break;}
      escaped = !escaped && next == "\\";
    }
    if (end || !escaped) state.tokenize = null;
    return "string";
  };
}

function tokenComment(stream, state) {
  var maybeEnd = false, ch;
  while (ch = stream.next()) {
    if (ch == ")" && maybeEnd) {
      state.tokenize = null;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return "comment";
}

function tokenCommentBraces(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "}") {
      state.tokenize = null;
      break;
    }
  }
  return "comment";
}

// Interface

const pascal = {
  name: "pascal",

  startState: function() {
    return {tokenize: null};
  },

  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    var style = (state.tokenize || tokenBase)(stream, state);
    if (style == "comment" || style == "meta") return style;
    return style;
  },

  languageData: {
    indentOnInput: /^\s*[{}]$/,
    commentTokens: {block: {open: "(*", close: "*)"}}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfcGFzY2FsX2pzLmM2MjMzOTU0YTVlNTQyZjRhMDI3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFTztBQUNQOztBQUVBO0FBQ0EsWUFBWTtBQUNaLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQkFBMkI7QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvcGFzY2FsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG52YXIga2V5d29yZHMgPSB3b3JkcyhcbiAgXCJhYnNvbHV0ZSBhbmQgYXJyYXkgYXNtIGJlZ2luIGNhc2UgY29uc3QgY29uc3RydWN0b3IgZGVzdHJ1Y3RvciBkaXYgZG8gXCIgK1xuICAgIFwiZG93bnRvIGVsc2UgZW5kIGZpbGUgZm9yIGZ1bmN0aW9uIGdvdG8gaWYgaW1wbGVtZW50YXRpb24gaW4gaW5oZXJpdGVkIFwiICtcbiAgICBcImlubGluZSBpbnRlcmZhY2UgbGFiZWwgbW9kIG5pbCBub3Qgb2JqZWN0IG9mIG9wZXJhdG9yIG9yIHBhY2tlZCBwcm9jZWR1cmUgXCIgK1xuICAgIFwicHJvZ3JhbSByZWNvcmQgcmVpbnRyb2R1Y2UgcmVwZWF0IHNlbGYgc2V0IHNobCBzaHIgc3RyaW5nIHRoZW4gdG8gdHlwZSBcIiArXG4gICAgXCJ1bml0IHVudGlsIHVzZXMgdmFyIHdoaWxlIHdpdGggeG9yIGFzIGNsYXNzIGRpc3BpbnRlcmZhY2UgZXhjZXB0IGV4cG9ydHMgXCIgK1xuICAgIFwiZmluYWxpemF0aW9uIGZpbmFsbHkgaW5pdGlhbGl6YXRpb24gaW5saW5lIGlzIGxpYnJhcnkgb24gb3V0IHBhY2tlZCBcIiArXG4gICAgXCJwcm9wZXJ0eSByYWlzZSByZXNvdXJjZXN0cmluZyB0aHJlYWR2YXIgdHJ5IGFic29sdXRlIGFic3RyYWN0IGFsaWFzIFwiICtcbiAgICBcImFzc2VtYmxlciBiaXRwYWNrZWQgYnJlYWsgY2RlY2wgY29udGludWUgY3BwZGVjbCBjdmFyIGRlZmF1bHQgZGVwcmVjYXRlZCBcIiArXG4gICAgXCJkeW5hbWljIGVudW1lcmF0b3IgZXhwZXJpbWVudGFsIGV4cG9ydCBleHRlcm5hbCBmYXIgZmFyMTYgZm9yd2FyZCBnZW5lcmljIFwiICtcbiAgICBcImhlbHBlciBpbXBsZW1lbnRzIGluZGV4IGludGVycnVwdCBpb2NoZWNrIGxvY2FsIG1lc3NhZ2UgbmFtZSBuZWFyIFwiICtcbiAgICBcIm5vZGVmYXVsdCBub3JldHVybiBub3N0YWNrZnJhbWUgb2xkZnBjY2FsbCBvdGhlcndpc2Ugb3ZlcmxvYWQgb3ZlcnJpZGUgXCIgK1xuICAgIFwicGFzY2FsIHBsYXRmb3JtIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBwdWJsaXNoZWQgcmVhZCByZWdpc3RlciBcIiArXG4gICAgXCJyZWludHJvZHVjZSByZXN1bHQgc2FmZWNhbGwgc2F2ZXJlZ2lzdGVycyBzb2Z0ZmxvYXQgc3BlY2lhbGl6ZSBzdGF0aWMgXCIgK1xuICAgIFwic3RkY2FsbCBzdG9yZWQgc3RyaWN0IHVuYWxpZ25lZCB1bmltcGxlbWVudGVkIHZhcmFyZ3MgdmlydHVhbCB3cml0ZVwiKTtcbnZhciBhdG9tcyA9IHtcIm51bGxcIjogdHJ1ZX07XG5cbnZhciBpc09wZXJhdG9yQ2hhciA9IC9bK1xcLSomJT08PiE/fFxcL10vO1xuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICBpZiAoY2ggPT0gXCIjXCIgJiYgc3RhdGUuc3RhcnRPZkxpbmUpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwibWV0YVwiO1xuICB9XG4gIGlmIChjaCA9PSAnXCInIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIGlmIChjaCA9PSBcIihcIiAmJiBzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5Db21tZW50O1xuICAgIHJldHVybiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgaWYgKGNoID09IFwie1wiKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNvbW1lbnRCcmFjZXM7XG4gICAgcmV0dXJuIHRva2VuQ29tbWVudEJyYWNlcyhzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBpZiAoL1tcXFtcXF1cXChcXCksO1xcOlxcLl0vLnRlc3QoY2gpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwuXS8pO1xuICAgIHJldHVybiBcIm51bWJlclwiO1xuICB9XG4gIGlmIChjaCA9PSBcIi9cIikge1xuICAgIGlmIChzdHJlYW0uZWF0KFwiL1wiKSkge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgfVxuICBpZiAoaXNPcGVyYXRvckNoYXIudGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoaXNPcGVyYXRvckNoYXIpO1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH1cbiAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX10vKTtcbiAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG4gIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKSByZXR1cm4gXCJhdG9tXCI7XG4gIHJldHVybiBcInZhcmlhYmxlXCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtlbmQgPSB0cnVlOyBicmVhazt9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgaWYgKGVuZCB8fCAhZXNjYXBlZCkgc3RhdGUudG9rZW5pemUgPSBudWxsO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0b2tlbkNvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCIpXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiB0b2tlbkNvbW1lbnRCcmFjZXMoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCJ9XCIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gbnVsbDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbi8vIEludGVyZmFjZVxuXG5leHBvcnQgY29uc3QgcGFzY2FsID0ge1xuICBuYW1lOiBcInBhc2NhbFwiLFxuXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7dG9rZW5pemU6IG51bGx9O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3R5bGUgPT0gXCJjb21tZW50XCIgfHwgc3R5bGUgPT0gXCJtZXRhXCIpIHJldHVybiBzdHlsZTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqW3t9XSQvLFxuICAgIGNvbW1lbnRUb2tlbnM6IHtibG9jazoge29wZW46IFwiKCpcIiwgY2xvc2U6IFwiKilcIn19XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=