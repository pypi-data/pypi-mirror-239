"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_sieve_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/sieve.js":
/*!**************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/sieve.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sieve": () => (/* binding */ sieve)
/* harmony export */ });
function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}

var keywords = words("if elsif else stop require");
var atoms = words("true false not");

function tokenBase(stream, state) {

  var ch = stream.next();
  if (ch == "/" && stream.eat("*")) {
    state.tokenize = tokenCComment;
    return tokenCComment(stream, state);
  }

  if (ch === '#') {
    stream.skipToEnd();
    return "comment";
  }

  if (ch == "\"") {
    state.tokenize = tokenString(ch);
    return state.tokenize(stream, state);
  }

  if (ch == "(") {
    state._indent.push("(");
    // add virtual angel wings so that editor behaves...
    // ...more sane incase of broken brackets
    state._indent.push("{");
    return null;
  }

  if (ch === "{") {
    state._indent.push("{");
    return null;
  }

  if (ch == ")")  {
    state._indent.pop();
    state._indent.pop();
  }

  if (ch === "}") {
    state._indent.pop();
    return null;
  }

  if (ch == ",")
    return null;

  if (ch == ";")
    return null;


  if (/[{}\(\),;]/.test(ch))
    return null;

  // 1*DIGIT "K" / "M" / "G"
  if (/\d/.test(ch)) {
    stream.eatWhile(/[\d]/);
    stream.eat(/[KkMmGg]/);
    return "number";
  }

  // ":" (ALPHA / "_") *(ALPHA / DIGIT / "_")
  if (ch == ":") {
    stream.eatWhile(/[a-zA-Z_]/);
    stream.eatWhile(/[a-zA-Z0-9_]/);

    return "operator";
  }

  stream.eatWhile(/\w/);
  var cur = stream.current();

  // "text:" *(SP / HTAB) (hash-comment / CRLF)
  // *(multiline-literal / multiline-dotstart)
  // "." CRLF
  if ((cur == "text") && stream.eat(":"))
  {
    state.tokenize = tokenMultiLineString;
    return "string";
  }

  if (keywords.propertyIsEnumerable(cur))
    return "keyword";

  if (atoms.propertyIsEnumerable(cur))
    return "atom";

  return null;
}

function tokenMultiLineString(stream, state)
{
  state._multiLineString = true;
  // the first line is special it may contain a comment
  if (!stream.sol()) {
    stream.eatSpace();

    if (stream.peek() == "#") {
      stream.skipToEnd();
      return "comment";
    }

    stream.skipToEnd();
    return "string";
  }

  if ((stream.next() == ".")  && (stream.eol()))
  {
    state._multiLineString = false;
    state.tokenize = tokenBase;
  }

  return "string";
}

function tokenCComment(stream, state) {
  var maybeEnd = false, ch;
  while ((ch = stream.next()) != null) {
    if (maybeEnd && ch == "/") {
      state.tokenize = tokenBase;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return "comment";
}

function tokenString(quote) {
  return function(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == quote && !escaped)
        break;
      escaped = !escaped && ch == "\\";
    }
    if (!escaped) state.tokenize = tokenBase;
    return "string";
  };
}

const sieve = {
  name: "sieve",
  startState: function(base) {
    return {tokenize: tokenBase,
            baseIndent: base || 0,
            _indent: []};
  },

  token: function(stream, state) {
    if (stream.eatSpace())
      return null;

    return (state.tokenize || tokenBase)(stream, state);
  },

  indent: function(state, _textAfter, cx) {
    var length = state._indent.length;
    if (_textAfter && (_textAfter[0] == "}"))
      length--;

    if (length <0)
      length = 0;

    return length * cx.unit;
  },

  languageData: {
    indentOnInput: /^\s*\}$/
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfc2lldmVfanMuYjM3ZmI4YjlhZWFiYzc1NGE0MjAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQSxlQUFlO0FBQ2YseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7O0FBR0EsVUFBVSxNQUFNO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3NpZXZlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHdvcmRzKHN0cikge1xuICB2YXIgb2JqID0ge30sIHdvcmRzID0gc3RyLnNwbGl0KFwiIFwiKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7ICsraSkgb2JqW3dvcmRzW2ldXSA9IHRydWU7XG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBrZXl3b3JkcyA9IHdvcmRzKFwiaWYgZWxzaWYgZWxzZSBzdG9wIHJlcXVpcmVcIik7XG52YXIgYXRvbXMgPSB3b3JkcyhcInRydWUgZmFsc2Ugbm90XCIpO1xuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuXG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCA9PSBcIi9cIiAmJiBzdHJlYW0uZWF0KFwiKlwiKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DQ29tbWVudDtcbiAgICByZXR1cm4gdG9rZW5DQ29tbWVudChzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gJyMnKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIGlmIChjaCA9PSBcIlxcXCJcIikge1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TdHJpbmcoY2gpO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIGlmIChjaCA9PSBcIihcIikge1xuICAgIHN0YXRlLl9pbmRlbnQucHVzaChcIihcIik7XG4gICAgLy8gYWRkIHZpcnR1YWwgYW5nZWwgd2luZ3Mgc28gdGhhdCBlZGl0b3IgYmVoYXZlcy4uLlxuICAgIC8vIC4uLm1vcmUgc2FuZSBpbmNhc2Ugb2YgYnJva2VuIGJyYWNrZXRzXG4gICAgc3RhdGUuX2luZGVudC5wdXNoKFwie1wiKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjaCA9PT0gXCJ7XCIpIHtcbiAgICBzdGF0ZS5faW5kZW50LnB1c2goXCJ7XCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNoID09IFwiKVwiKSAge1xuICAgIHN0YXRlLl9pbmRlbnQucG9wKCk7XG4gICAgc3RhdGUuX2luZGVudC5wb3AoKTtcbiAgfVxuXG4gIGlmIChjaCA9PT0gXCJ9XCIpIHtcbiAgICBzdGF0ZS5faW5kZW50LnBvcCgpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNoID09IFwiLFwiKVxuICAgIHJldHVybiBudWxsO1xuXG4gIGlmIChjaCA9PSBcIjtcIilcbiAgICByZXR1cm4gbnVsbDtcblxuXG4gIGlmICgvW3t9XFwoXFwpLDtdLy50ZXN0KGNoKSlcbiAgICByZXR1cm4gbnVsbDtcblxuICAvLyAxKkRJR0lUIFwiS1wiIC8gXCJNXCIgLyBcIkdcIlxuICBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXGRdLyk7XG4gICAgc3RyZWFtLmVhdCgvW0trTW1HZ10vKTtcbiAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgfVxuXG4gIC8vIFwiOlwiIChBTFBIQSAvIFwiX1wiKSAqKEFMUEhBIC8gRElHSVQgLyBcIl9cIilcbiAgaWYgKGNoID09IFwiOlwiKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bYS16QS1aX10vKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1thLXpBLVowLTlfXS8pO1xuXG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfVxuXG4gIHN0cmVhbS5lYXRXaGlsZSgvXFx3Lyk7XG4gIHZhciBjdXIgPSBzdHJlYW0uY3VycmVudCgpO1xuXG4gIC8vIFwidGV4dDpcIiAqKFNQIC8gSFRBQikgKGhhc2gtY29tbWVudCAvIENSTEYpXG4gIC8vICoobXVsdGlsaW5lLWxpdGVyYWwgLyBtdWx0aWxpbmUtZG90c3RhcnQpXG4gIC8vIFwiLlwiIENSTEZcbiAgaWYgKChjdXIgPT0gXCJ0ZXh0XCIpICYmIHN0cmVhbS5lYXQoXCI6XCIpKVxuICB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbk11bHRpTGluZVN0cmluZztcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIGlmIChrZXl3b3Jkcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKVxuICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICBpZiAoYXRvbXMucHJvcGVydHlJc0VudW1lcmFibGUoY3VyKSlcbiAgICByZXR1cm4gXCJhdG9tXCI7XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHRva2VuTXVsdGlMaW5lU3RyaW5nKHN0cmVhbSwgc3RhdGUpXG57XG4gIHN0YXRlLl9tdWx0aUxpbmVTdHJpbmcgPSB0cnVlO1xuICAvLyB0aGUgZmlyc3QgbGluZSBpcyBzcGVjaWFsIGl0IG1heSBjb250YWluIGEgY29tbWVudFxuICBpZiAoIXN0cmVhbS5zb2woKSkge1xuICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuXG4gICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCIjXCIpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG5cbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gIH1cblxuICBpZiAoKHN0cmVhbS5uZXh0KCkgPT0gXCIuXCIpICAmJiAoc3RyZWFtLmVvbCgpKSlcbiAge1xuICAgIHN0YXRlLl9tdWx0aUxpbmVTdHJpbmcgPSBmYWxzZTtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgfVxuXG4gIHJldHVybiBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiB0b2tlbkNDb21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgIGlmIChtYXliZUVuZCAmJiBjaCA9PSBcIi9cIikge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbWF5YmVFbmQgPSAoY2ggPT0gXCIqXCIpO1xuICB9XG4gIHJldHVybiBcImNvbW1lbnRcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgZXNjYXBlZCA9IGZhbHNlLCBjaDtcbiAgICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKGNoID09IHF1b3RlICYmICFlc2NhcGVkKVxuICAgICAgICBicmVhaztcbiAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZCAmJiBjaCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgaWYgKCFlc2NhcGVkKSBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IHNpZXZlID0ge1xuICBuYW1lOiBcInNpZXZlXCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICByZXR1cm4ge3Rva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICAgICAgICBiYXNlSW5kZW50OiBiYXNlIHx8IDAsXG4gICAgICAgICAgICBfaW5kZW50OiBbXX07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIHJldHVybiAoc3RhdGUudG9rZW5pemUgfHwgdG9rZW5CYXNlKShzdHJlYW0sIHN0YXRlKTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCBfdGV4dEFmdGVyLCBjeCkge1xuICAgIHZhciBsZW5ndGggPSBzdGF0ZS5faW5kZW50Lmxlbmd0aDtcbiAgICBpZiAoX3RleHRBZnRlciAmJiAoX3RleHRBZnRlclswXSA9PSBcIn1cIikpXG4gICAgICBsZW5ndGgtLTtcblxuICAgIGlmIChsZW5ndGggPDApXG4gICAgICBsZW5ndGggPSAwO1xuXG4gICAgcmV0dXJuIGxlbmd0aCAqIGN4LnVuaXQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqXFx9JC9cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==