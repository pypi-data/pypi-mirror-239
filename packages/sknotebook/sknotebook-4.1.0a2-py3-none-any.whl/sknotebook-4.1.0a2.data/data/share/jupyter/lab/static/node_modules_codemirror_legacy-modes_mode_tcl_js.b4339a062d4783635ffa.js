"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_tcl_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/tcl.js":
/*!************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/tcl.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "tcl": () => (/* binding */ tcl)
/* harmony export */ });
function parseWords(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}
var keywords = parseWords("Tcl safe after append array auto_execok auto_import auto_load " +
                          "auto_mkindex auto_mkindex_old auto_qualify auto_reset bgerror " +
                          "binary break catch cd close concat continue dde eof encoding error " +
                          "eval exec exit expr fblocked fconfigure fcopy file fileevent filename " +
                          "filename flush for foreach format gets glob global history http if " +
                          "incr info interp join lappend lindex linsert list llength load lrange " +
                          "lreplace lsearch lset lsort memory msgcat namespace open package parray " +
                          "pid pkg::create pkg_mkIndex proc puts pwd re_syntax read regex regexp " +
                          "registry regsub rename resource return scan seek set socket source split " +
                          "string subst switch tcl_endOfWord tcl_findLibrary tcl_startOfNextWord " +
                          "tcl_wordBreakAfter tcl_startOfPreviousWord tcl_wordBreakBefore tcltest " +
                          "tclvars tell time trace unknown unset update uplevel upvar variable " +
                          "vwait");
var functions = parseWords("if elseif else and not or eq ne in ni for foreach while switch");
var isOperatorChar = /[+\-*&%=<>!?^\/\|]/;
function chain(stream, state, f) {
  state.tokenize = f;
  return f(stream, state);
}
function tokenBase(stream, state) {
  var beforeParams = state.beforeParams;
  state.beforeParams = false;
  var ch = stream.next();
  if ((ch == '"' || ch == "'") && state.inParams) {
    return chain(stream, state, tokenString(ch));
  } else if (/[\[\]{}\(\),;\.]/.test(ch)) {
    if (ch == "(" && beforeParams) state.inParams = true;
    else if (ch == ")") state.inParams = false;
    return null;
  } else if (/\d/.test(ch)) {
    stream.eatWhile(/[\w\.]/);
    return "number";
  } else if (ch == "#") {
    if (stream.eat("*"))
      return chain(stream, state, tokenComment);
    if (ch == "#" && stream.match(/ *\[ *\[/))
      return chain(stream, state, tokenUnparsed);
    stream.skipToEnd();
    return "comment";
  } else if (ch == '"') {
    stream.skipTo(/"/);
    return "comment";
  } else if (ch == "$") {
    stream.eatWhile(/[$_a-z0-9A-Z\.{:]/);
    stream.eatWhile(/}/);
    state.beforeParams = true;
    return "builtin";
  } else if (isOperatorChar.test(ch)) {
    stream.eatWhile(isOperatorChar);
    return "comment";
  } else {
    stream.eatWhile(/[\w\$_{}\xa1-\uffff]/);
    var word = stream.current().toLowerCase();
    if (keywords && keywords.propertyIsEnumerable(word))
      return "keyword";
    if (functions && functions.propertyIsEnumerable(word)) {
      state.beforeParams = true;
      return "keyword";
    }
    return null;
  }
}
function tokenString(quote) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while ((next = stream.next()) != null) {
      if (next == quote && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    if (end) state.tokenize = tokenBase;
    return "string";
  };
}
function tokenComment(stream, state) {
  var maybeEnd = false, ch;
  while (ch = stream.next()) {
    if (ch == "#" && maybeEnd) {
      state.tokenize = tokenBase;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return "comment";
}
function tokenUnparsed(stream, state) {
  var maybeEnd = 0, ch;
  while (ch = stream.next()) {
    if (ch == "#" && maybeEnd == 2) {
      state.tokenize = tokenBase;
      break;
    }
    if (ch == "]")
      maybeEnd++;
    else if (ch != " ")
      maybeEnd = 0;
  }
  return "meta";
}
const tcl = {
  name: "tcl",
  startState: function() {
    return {
      tokenize: tokenBase,
      beforeParams: false,
      inParams: false
    };
  },
  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    return state.tokenize(stream, state);
  },
  languageData: {
    commentTokens: {line: "#"}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfdGNsX2pzLmI0MzM5YTA2MmQ0NzgzNjM1ZmZhLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLGNBQWM7QUFDZCxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUJBQWlCLE1BQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0NBQW9DO0FBQ3BDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvdGNsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHBhcnNlV29yZHMoc3RyKSB7XG4gIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIG9iajtcbn1cbnZhciBrZXl3b3JkcyA9IHBhcnNlV29yZHMoXCJUY2wgc2FmZSBhZnRlciBhcHBlbmQgYXJyYXkgYXV0b19leGVjb2sgYXV0b19pbXBvcnQgYXV0b19sb2FkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhdXRvX21raW5kZXggYXV0b19ta2luZGV4X29sZCBhdXRvX3F1YWxpZnkgYXV0b19yZXNldCBiZ2Vycm9yIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJiaW5hcnkgYnJlYWsgY2F0Y2ggY2QgY2xvc2UgY29uY2F0IGNvbnRpbnVlIGRkZSBlb2YgZW5jb2RpbmcgZXJyb3IgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImV2YWwgZXhlYyBleGl0IGV4cHIgZmJsb2NrZWQgZmNvbmZpZ3VyZSBmY29weSBmaWxlIGZpbGVldmVudCBmaWxlbmFtZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiZmlsZW5hbWUgZmx1c2ggZm9yIGZvcmVhY2ggZm9ybWF0IGdldHMgZ2xvYiBnbG9iYWwgaGlzdG9yeSBodHRwIGlmIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbmNyIGluZm8gaW50ZXJwIGpvaW4gbGFwcGVuZCBsaW5kZXggbGluc2VydCBsaXN0IGxsZW5ndGggbG9hZCBscmFuZ2UgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImxyZXBsYWNlIGxzZWFyY2ggbHNldCBsc29ydCBtZW1vcnkgbXNnY2F0IG5hbWVzcGFjZSBvcGVuIHBhY2thZ2UgcGFycmF5IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwaWQgcGtnOjpjcmVhdGUgcGtnX21rSW5kZXggcHJvYyBwdXRzIHB3ZCByZV9zeW50YXggcmVhZCByZWdleCByZWdleHAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcInJlZ2lzdHJ5IHJlZ3N1YiByZW5hbWUgcmVzb3VyY2UgcmV0dXJuIHNjYW4gc2VlayBzZXQgc29ja2V0IHNvdXJjZSBzcGxpdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwic3RyaW5nIHN1YnN0IHN3aXRjaCB0Y2xfZW5kT2ZXb3JkIHRjbF9maW5kTGlicmFyeSB0Y2xfc3RhcnRPZk5leHRXb3JkIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0Y2xfd29yZEJyZWFrQWZ0ZXIgdGNsX3N0YXJ0T2ZQcmV2aW91c1dvcmQgdGNsX3dvcmRCcmVha0JlZm9yZSB0Y2x0ZXN0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0Y2x2YXJzIHRlbGwgdGltZSB0cmFjZSB1bmtub3duIHVuc2V0IHVwZGF0ZSB1cGxldmVsIHVwdmFyIHZhcmlhYmxlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ2d2FpdFwiKTtcbnZhciBmdW5jdGlvbnMgPSBwYXJzZVdvcmRzKFwiaWYgZWxzZWlmIGVsc2UgYW5kIG5vdCBvciBlcSBuZSBpbiBuaSBmb3IgZm9yZWFjaCB3aGlsZSBzd2l0Y2hcIik7XG52YXIgaXNPcGVyYXRvckNoYXIgPSAvWytcXC0qJiU9PD4hP15cXC9cXHxdLztcbmZ1bmN0aW9uIGNoYWluKHN0cmVhbSwgc3RhdGUsIGYpIHtcbiAgc3RhdGUudG9rZW5pemUgPSBmO1xuICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbn1cbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBiZWZvcmVQYXJhbXMgPSBzdGF0ZS5iZWZvcmVQYXJhbXM7XG4gIHN0YXRlLmJlZm9yZVBhcmFtcyA9IGZhbHNlO1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICBpZiAoKGNoID09ICdcIicgfHwgY2ggPT0gXCInXCIpICYmIHN0YXRlLmluUGFyYW1zKSB7XG4gICAgcmV0dXJuIGNoYWluKHN0cmVhbSwgc3RhdGUsIHRva2VuU3RyaW5nKGNoKSk7XG4gIH0gZWxzZSBpZiAoL1tcXFtcXF17fVxcKFxcKSw7XFwuXS8udGVzdChjaCkpIHtcbiAgICBpZiAoY2ggPT0gXCIoXCIgJiYgYmVmb3JlUGFyYW1zKSBzdGF0ZS5pblBhcmFtcyA9IHRydWU7XG4gICAgZWxzZSBpZiAoY2ggPT0gXCIpXCIpIHN0YXRlLmluUGFyYW1zID0gZmFsc2U7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoL1xcZC8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tcXHdcXC5dLyk7XG4gICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpXG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5Db21tZW50KTtcbiAgICBpZiAoY2ggPT0gXCIjXCIgJiYgc3RyZWFtLm1hdGNoKC8gKlxcWyAqXFxbLykpXG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5VbnBhcnNlZCk7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfSBlbHNlIGlmIChjaCA9PSAnXCInKSB7XG4gICAgc3RyZWFtLnNraXBUbygvXCIvKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCIkXCIpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1skX2EtejAtOUEtWlxcLns6XS8pO1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvfS8pO1xuICAgIHN0YXRlLmJlZm9yZVBhcmFtcyA9IHRydWU7XG4gICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICB9IGVsc2UgaWYgKGlzT3BlcmF0b3JDaGFyLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGlzT3BlcmF0b3JDaGFyKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkX3t9XFx4YTEtXFx1ZmZmZl0vKTtcbiAgICB2YXIgd29yZCA9IHN0cmVhbS5jdXJyZW50KCkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoa2V5d29yZHMgJiYga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkpXG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgaWYgKGZ1bmN0aW9ucyAmJiBmdW5jdGlvbnMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkpIHtcbiAgICAgIHN0YXRlLmJlZm9yZVBhcmFtcyA9IHRydWU7XG4gICAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIG5leHQsIGVuZCA9IGZhbHNlO1xuICAgIHdoaWxlICgobmV4dCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChuZXh0ID09IHF1b3RlICYmICFlc2NhcGVkKSB7XG4gICAgICAgIGVuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIGlmIChlbmQpIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9O1xufVxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG1heWJlRW5kID0gZmFsc2UsIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiI1wiICYmIG1heWJlRW5kKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuZnVuY3Rpb24gdG9rZW5VbnBhcnNlZChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBtYXliZUVuZCA9IDAsIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiI1wiICYmIG1heWJlRW5kID09IDIpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChjaCA9PSBcIl1cIilcbiAgICAgIG1heWJlRW5kKys7XG4gICAgZWxzZSBpZiAoY2ggIT0gXCIgXCIpXG4gICAgICBtYXliZUVuZCA9IDA7XG4gIH1cbiAgcmV0dXJuIFwibWV0YVwiO1xufVxuZXhwb3J0IGNvbnN0IHRjbCA9IHtcbiAgbmFtZTogXCJ0Y2xcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICBiZWZvcmVQYXJhbXM6IGZhbHNlLFxuICAgICAgaW5QYXJhbXM6IGZhbHNlXG4gICAgfTtcbiAgfSxcbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wifVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9