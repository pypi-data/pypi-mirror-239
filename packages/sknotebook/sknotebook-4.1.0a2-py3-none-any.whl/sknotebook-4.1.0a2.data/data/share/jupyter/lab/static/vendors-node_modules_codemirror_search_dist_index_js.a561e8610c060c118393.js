"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_search_dist_index_js"],{

/***/ "../node_modules/@codemirror/search/dist/index.js":
/*!********************************************************!*\
  !*** ../node_modules/@codemirror/search/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RegExpCursor": () => (/* binding */ RegExpCursor),
/* harmony export */   "SearchCursor": () => (/* binding */ SearchCursor),
/* harmony export */   "SearchQuery": () => (/* binding */ SearchQuery),
/* harmony export */   "closeSearchPanel": () => (/* binding */ closeSearchPanel),
/* harmony export */   "findNext": () => (/* binding */ findNext),
/* harmony export */   "findPrevious": () => (/* binding */ findPrevious),
/* harmony export */   "getSearchQuery": () => (/* binding */ getSearchQuery),
/* harmony export */   "gotoLine": () => (/* binding */ gotoLine),
/* harmony export */   "highlightSelectionMatches": () => (/* binding */ highlightSelectionMatches),
/* harmony export */   "openSearchPanel": () => (/* binding */ openSearchPanel),
/* harmony export */   "replaceAll": () => (/* binding */ replaceAll),
/* harmony export */   "replaceNext": () => (/* binding */ replaceNext),
/* harmony export */   "search": () => (/* binding */ search),
/* harmony export */   "searchKeymap": () => (/* binding */ searchKeymap),
/* harmony export */   "searchPanelOpen": () => (/* binding */ searchPanelOpen),
/* harmony export */   "selectMatches": () => (/* binding */ selectMatches),
/* harmony export */   "selectNextOccurrence": () => (/* binding */ selectNextOccurrence),
/* harmony export */   "selectSelectionMatches": () => (/* binding */ selectSelectionMatches),
/* harmony export */   "setSearchQuery": () => (/* binding */ setSearchQuery)
/* harmony export */ });
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @codemirror/view */ "webpack/sharing/consume/default/@codemirror/view/@codemirror/view");
/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_codemirror_view__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @codemirror/state */ "webpack/sharing/consume/default/@codemirror/state/@codemirror/state");
/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crelt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! crelt */ "../node_modules/crelt/index.es.js");




const basicNormalize = typeof String.prototype.normalize == "function"
    ? x => x.normalize("NFKD") : x => x;
/**
A search cursor provides an iterator over text matches in a
document.
*/
class SearchCursor {
    /**
    Create a text cursor. The query is the search string, `from` to
    `to` provides the region to search.
    
    When `normalize` is given, it will be called, on both the query
    string and the content it is matched against, before comparing.
    You can, for example, create a case-insensitive search by
    passing `s => s.toLowerCase()`.
    
    Text is always normalized with
    [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
    (when supported).
    */
    constructor(text, query, from = 0, to = text.length, normalize, test) {
        this.test = test;
        /**
        The current match (only holds a meaningful value after
        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when
        `done` is false).
        */
        this.value = { from: 0, to: 0 };
        /**
        Whether the end of the iterated region has been reached.
        */
        this.done = false;
        this.matches = [];
        this.buffer = "";
        this.bufferPos = 0;
        this.iter = text.iterRange(from, to);
        this.bufferStart = from;
        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;
        this.query = this.normalize(query);
    }
    peek() {
        if (this.bufferPos == this.buffer.length) {
            this.bufferStart += this.buffer.length;
            this.iter.next();
            if (this.iter.done)
                return -1;
            this.bufferPos = 0;
            this.buffer = this.iter.value;
        }
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointAt)(this.buffer, this.bufferPos);
    }
    /**
    Look for the next match. Updates the iterator's
    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
    at least once before using the cursor.
    */
    next() {
        while (this.matches.length)
            this.matches.pop();
        return this.nextOverlapping();
    }
    /**
    The `next` method will ignore matches that partially overlap a
    previous match. This method behaves like `next`, but includes
    such matches.
    */
    nextOverlapping() {
        for (;;) {
            let next = this.peek();
            if (next < 0) {
                this.done = true;
                return this;
            }
            let str = (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.fromCodePoint)(next), start = this.bufferStart + this.bufferPos;
            this.bufferPos += (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.codePointSize)(next);
            let norm = this.normalize(str);
            for (let i = 0, pos = start;; i++) {
                let code = norm.charCodeAt(i);
                let match = this.match(code, pos);
                if (match) {
                    this.value = match;
                    return this;
                }
                if (i == norm.length - 1)
                    break;
                if (pos == start && i < str.length && str.charCodeAt(i) == code)
                    pos++;
            }
        }
    }
    match(code, pos) {
        let match = null;
        for (let i = 0; i < this.matches.length; i += 2) {
            let index = this.matches[i], keep = false;
            if (this.query.charCodeAt(index) == code) {
                if (index == this.query.length - 1) {
                    match = { from: this.matches[i + 1], to: pos + 1 };
                }
                else {
                    this.matches[i]++;
                    keep = true;
                }
            }
            if (!keep) {
                this.matches.splice(i, 2);
                i -= 2;
            }
        }
        if (this.query.charCodeAt(0) == code) {
            if (this.query.length == 1)
                match = { from: pos, to: pos + 1 };
            else
                this.matches.push(1, pos);
        }
        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferPos))
            match = null;
        return match;
    }
}
if (typeof Symbol != "undefined")
    SearchCursor.prototype[Symbol.iterator] = function () { return this; };

const empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec("") };
const baseFlags = "gm" + (/x/.unicode == null ? "" : "u");
/**
This class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)
but searches for a regular expression pattern instead of a plain
string.
*/
class RegExpCursor {
    /**
    Create a cursor that will search the given range in the given
    document. `query` should be the raw pattern (as you'd pass it to
    `new RegExp`).
    */
    constructor(text, query, options, from = 0, to = text.length) {
        this.text = text;
        this.to = to;
        this.curLine = "";
        /**
        Set to `true` when the cursor has reached the end of the search
        range.
        */
        this.done = false;
        /**
        Will contain an object with the extent of the match and the
        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)
        sucessfully finds a match.
        */
        this.value = empty;
        if (/\\[sWDnr]|\n|\r|\[\^/.test(query))
            return new MultilineRegExpCursor(text, query, options, from, to);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.iter = text.iter();
        let startLine = text.lineAt(from);
        this.curLineStart = startLine.from;
        this.matchPos = toCharEnd(text, from);
        this.getLine(this.curLineStart);
    }
    getLine(skip) {
        this.iter.next(skip);
        if (this.iter.lineBreak) {
            this.curLine = "";
        }
        else {
            this.curLine = this.iter.value;
            if (this.curLineStart + this.curLine.length > this.to)
                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);
            this.iter.next();
        }
    }
    nextLine() {
        this.curLineStart = this.curLineStart + this.curLine.length + 1;
        if (this.curLineStart > this.to)
            this.curLine = "";
        else
            this.getLine(0);
    }
    /**
    Move to the next match, if there is one.
    */
    next() {
        for (let off = this.matchPos - this.curLineStart;;) {
            this.re.lastIndex = off;
            let match = this.matchPos <= this.to && this.re.exec(this.curLine);
            if (match) {
                let from = this.curLineStart + match.index, to = from + match[0].length;
                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                if (from == this.curLineStart + this.curLine.length)
                    this.nextLine();
                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {
                    this.value = { from, to, match };
                    return this;
                }
                off = this.matchPos - this.curLineStart;
            }
            else if (this.curLineStart + this.curLine.length < this.to) {
                this.nextLine();
                off = 0;
            }
            else {
                this.done = true;
                return this;
            }
        }
    }
}
const flattened = /*@__PURE__*/new WeakMap();
// Reusable (partially) flattened document strings
class FlattenedDoc {
    constructor(from, text) {
        this.from = from;
        this.text = text;
    }
    get to() { return this.from + this.text.length; }
    static get(doc, from, to) {
        let cached = flattened.get(doc);
        if (!cached || cached.from >= to || cached.to <= from) {
            let flat = new FlattenedDoc(from, doc.sliceString(from, to));
            flattened.set(doc, flat);
            return flat;
        }
        if (cached.from == from && cached.to == to)
            return cached;
        let { text, from: cachedFrom } = cached;
        if (cachedFrom > from) {
            text = doc.sliceString(from, cachedFrom) + text;
            cachedFrom = from;
        }
        if (cached.to < to)
            text += doc.sliceString(cached.to, to);
        flattened.set(doc, new FlattenedDoc(cachedFrom, text));
        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));
    }
}
class MultilineRegExpCursor {
    constructor(text, query, options, from, to) {
        this.text = text;
        this.to = to;
        this.done = false;
        this.value = empty;
        this.matchPos = toCharEnd(text, from);
        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? "i" : ""));
        this.test = options === null || options === void 0 ? void 0 : options.test;
        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));
    }
    chunkEnd(pos) {
        return pos >= this.to ? this.to : this.text.lineAt(pos).to;
    }
    next() {
        for (;;) {
            let off = this.re.lastIndex = this.matchPos - this.flat.from;
            let match = this.re.exec(this.flat.text);
            // Skip empty matches directly after the last match
            if (match && !match[0] && match.index == off) {
                this.re.lastIndex = off + 1;
                match = this.re.exec(this.flat.text);
            }
            if (match) {
                let from = this.flat.from + match.index, to = from + match[0].length;
                // If a match goes almost to the end of a noncomplete chunk, try
                // again, since it'll likely be able to match more
                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&
                    (!this.test || this.test(from, to, match))) {
                    this.value = { from, to, match };
                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));
                    return this;
                }
            }
            if (this.flat.to == this.to) {
                this.done = true;
                return this;
            }
            // Grow the flattened doc
            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
        }
    }
}
if (typeof Symbol != "undefined") {
    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =
        function () { return this; };
}
function validRegExp(source) {
    try {
        new RegExp(source, baseFlags);
        return true;
    }
    catch (_a) {
        return false;
    }
}
function toCharEnd(text, pos) {
    if (pos >= text.length)
        return pos;
    let line = text.lineAt(pos), next;
    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)
        pos++;
    return pos;
}

function createLineDialog(view) {
    let input = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("input", { class: "cm-textfield", name: "line" });
    let dom = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("form", {
        class: "cm-gotoLine",
        onkeydown: (event) => {
            if (event.keyCode == 27) { // Escape
                event.preventDefault();
                view.dispatch({ effects: dialogEffect.of(false) });
                view.focus();
            }
            else if (event.keyCode == 13) { // Enter
                event.preventDefault();
                go();
            }
        },
        onsubmit: (event) => {
            event.preventDefault();
            go();
        }
    }, (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("label", view.state.phrase("Go to line"), ": ", input), " ", (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("button", { class: "cm-button", type: "submit" }, view.state.phrase("go")));
    function go() {
        let match = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(input.value);
        if (!match)
            return;
        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);
        let [, sign, ln, cl, percent] = match;
        let col = cl ? +cl.slice(1) : 0;
        let line = ln ? +ln : startLine.number;
        if (ln && percent) {
            let pc = line / 100;
            if (sign)
                pc = pc * (sign == "-" ? -1 : 1) + (startLine.number / state.doc.lines);
            line = Math.round(state.doc.lines * pc);
        }
        else if (ln && sign) {
            line = line * (sign == "-" ? -1 : 1) + startLine.number;
        }
        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));
        view.dispatch({
            effects: dialogEffect.of(false),
            selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),
            scrollIntoView: true
        });
        view.focus();
    }
    return { dom };
}
const dialogEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const dialogField = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create() { return true; },
    update(value, tr) {
        for (let e of tr.effects)
            if (e.is(dialogEffect))
                value = e.value;
        return value;
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.showPanel.from(f, val => val ? createLineDialog : null)
});
/**
Command that shows a dialog asking the user for a line number, and
when a valid position is provided, moves the cursor to that line.

Supports line numbers, relative line offsets prefixed with `+` or
`-`, document percentages suffixed with `%`, and an optional
column position by adding `:` and a second number after the line
number.
*/
const gotoLine = view => {
    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.getPanel)(view, createLineDialog);
    if (!panel) {
        let effects = [dialogEffect.of(true)];
        if (view.state.field(dialogField, false) == null)
            effects.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of([dialogField, baseTheme$1]));
        view.dispatch({ effects });
        panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.getPanel)(view, createLineDialog);
    }
    if (panel)
        panel.dom.querySelector("input").focus();
    return true;
};
const baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.baseTheme({
    ".cm-panel.cm-gotoLine": {
        padding: "2px 6px 4px",
        "& label": { fontSize: "80%" }
    }
});

const defaultHighlightOptions = {
    highlightWordAroundCursor: false,
    minSelectionLength: 1,
    maxMatches: 100,
    wholeWords: false
};
const highlightConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({
    combine(options) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(options, defaultHighlightOptions, {
            highlightWordAroundCursor: (a, b) => a || b,
            minSelectionLength: Math.min,
            maxMatches: Math.min
        });
    }
});
/**
This extension highlights text that matches the selection. It uses
the `"cm-selectionMatch"` class for the highlighting. When
`highlightWordAroundCursor` is enabled, the word at the cursor
itself will be highlighted with `"cm-selectionMatch-main"`.
*/
function highlightSelectionMatches(options) {
    let ext = [defaultTheme, matchHighlighter];
    if (options)
        ext.push(highlightConfig.of(options));
    return ext;
}
const matchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.mark({ class: "cm-selectionMatch" });
const mainMatchDeco = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
// Whether the characters directly outside the given positions are non-word characters
function insideWordBoundaries(check, state, from, to) {
    return (from == 0 || check(state.sliceDoc(from - 1, from)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&
        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);
}
// Whether the characters directly at the given positions are word characters
function insideWord(check, state, from, to) {
    return check(state.sliceDoc(from, from + 1)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word
        && check(state.sliceDoc(to - 1, to)) == _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word;
}
const matchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.ViewPlugin.fromClass(class {
    constructor(view) {
        this.decorations = this.getDeco(view);
    }
    update(update) {
        if (update.selectionSet || update.docChanged || update.viewportChanged)
            this.decorations = this.getDeco(update.view);
    }
    getDeco(view) {
        let conf = view.state.facet(highlightConfig);
        let { state } = view, sel = state.selection;
        if (sel.ranges.length > 1)
            return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.none;
        let range = sel.main, query, check = null;
        if (range.empty) {
            if (!conf.highlightWordAroundCursor)
                return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.none;
            let word = state.wordAt(range.head);
            if (!word)
                return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.none;
            check = state.charCategorizer(range.head);
            query = state.sliceDoc(word.from, word.to);
        }
        else {
            let len = range.to - range.from;
            if (len < conf.minSelectionLength || len > 200)
                return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.none;
            if (conf.wholeWords) {
                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?
                check = state.charCategorizer(range.head);
                if (!(insideWordBoundaries(check, state, range.from, range.to)
                    && insideWord(check, state, range.from, range.to)))
                    return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.none;
            }
            else {
                query = state.sliceDoc(range.from, range.to).trim();
                if (!query)
                    return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.none;
            }
        }
        let deco = [];
        for (let part of view.visibleRanges) {
            let cursor = new SearchCursor(state.doc, query, part.from, part.to);
            while (!cursor.next().done) {
                let { from, to } = cursor.value;
                if (!check || insideWordBoundaries(check, state, from, to)) {
                    if (range.empty && from <= range.from && to >= range.to)
                        deco.push(mainMatchDeco.range(from, to));
                    else if (from >= range.to || to <= range.from)
                        deco.push(matchDeco.range(from, to));
                    if (deco.length > conf.maxMatches)
                        return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.none;
                }
            }
        }
        return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.set(deco);
    }
}, {
    decorations: v => v.decorations
});
const defaultTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.baseTheme({
    ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
    ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
});
// Select the words around the cursors.
const selectWord = ({ state, dispatch }) => {
    let { selection } = state;
    let newSel = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.cursor(range.head)), selection.mainIndex);
    if (newSel.eq(selection))
        return false;
    dispatch(state.update({ selection: newSel }));
    return true;
};
// Find next occurrence of query relative to last cursor. Wrap around
// the document if there are no more matches.
function findNextOccurrence(state, query) {
    let { main, ranges } = state.selection;
    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;
    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {
        cursor.next();
        if (cursor.done) {
            if (cycled)
                return null;
            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));
            cycled = true;
        }
        else {
            if (cycled && ranges.some(r => r.from == cursor.value.from))
                continue;
            if (fullWord) {
                let word = state.wordAt(cursor.value.from);
                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)
                    continue;
            }
            return cursor.value;
        }
    }
}
/**
Select next occurrence of the current selection. Expand selection
to the surrounding word when the selection is empty.
*/
const selectNextOccurrence = ({ state, dispatch }) => {
    let { ranges } = state.selection;
    if (ranges.some(sel => sel.from === sel.to))
        return selectWord({ state, dispatch });
    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);
    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))
        return false;
    let range = findNextOccurrence(state, searchedText);
    if (!range)
        return false;
    dispatch(state.update({
        selection: state.selection.addRange(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(range.from, range.to), false),
        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.scrollIntoView(range.to)
    }));
    return true;
};

const searchConfigFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Facet.define({
    combine(configs) {
        return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.combineConfig)(configs, {
            top: false,
            caseSensitive: false,
            literal: false,
            wholeWord: false,
            createPanel: view => new SearchPanel(view),
            scrollToMatch: range => _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.scrollIntoView(range)
        });
    }
});
/**
Add search state to the editor configuration, and optionally
configure the search extension.
([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically
enable this if it isn't already on).
*/
function search(config) {
    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;
}
/**
A search query. Part of the editor's search state.
*/
class SearchQuery {
    /**
    Create a query object.
    */
    constructor(config) {
        this.search = config.search;
        this.caseSensitive = !!config.caseSensitive;
        this.literal = !!config.literal;
        this.regexp = !!config.regexp;
        this.replace = config.replace || "";
        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));
        this.unquoted = this.unquote(this.search);
        this.wholeWord = !!config.wholeWord;
    }
    /**
    @internal
    */
    unquote(text) {
        return this.literal ? text :
            text.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "\t" : "\\");
    }
    /**
    Compare this query to another query.
    */
    eq(other) {
        return this.search == other.search && this.replace == other.replace &&
            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&
            this.wholeWord == other.wholeWord;
    }
    /**
    @internal
    */
    create() {
        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);
    }
    /**
    Get a search cursor for this query, searching through the given
    range in the given state.
    */
    getCursor(state, from = 0, to) {
        let st = state.doc ? state : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorState.create({ doc: state });
        if (to == null)
            to = st.doc.length;
        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);
    }
}
class QueryType {
    constructor(spec) {
        this.spec = spec;
    }
}
function stringCursor(spec, state, from, to) {
    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);
}
function stringWordTest(doc, categorizer) {
    return (from, to, buf, bufPos) => {
        if (bufPos > from || bufPos + buf.length < to) {
            bufPos = Math.max(0, from - 2);
            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));
        }
        return (categorizer(charBefore(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||
            categorizer(charAfter(buf, from - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&
            (categorizer(charAfter(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||
                categorizer(charBefore(buf, to - bufPos)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);
    };
}
class StringQuery extends QueryType {
    constructor(spec) {
        super(spec);
    }
    nextMatch(state, curFrom, curTo) {
        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();
        if (cursor.done)
            cursor = stringCursor(this.spec, state, 0, curFrom).nextOverlapping();
        return cursor.done ? null : cursor.value;
    }
    // Searching in reverse is, rather than implementing inverted search
    // cursor, done by scanning chunk after chunk forward.
    prevMatchInRange(state, from, to) {
        for (let pos = to;;) {
            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);
            let cursor = stringCursor(this.spec, state, start, pos), range = null;
            while (!cursor.nextOverlapping().done)
                range = cursor.value;
            if (range)
                return range;
            if (start == from)
                return null;
            pos -= 10000 /* FindPrev.ChunkSize */;
        }
    }
    prevMatch(state, curFrom, curTo) {
        return this.prevMatchInRange(state, 0, curFrom) ||
            this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }
    matchAll(state, limit) {
        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(state, from, to, add) {
        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
}
function regexpCursor(spec, state, from, to) {
    return new RegExpCursor(state.doc, spec.search, {
        ignoreCase: !spec.caseSensitive,
        test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined
    }, from, to);
}
function charBefore(str, index) {
    return str.slice((0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index, false), index);
}
function charAfter(str, index) {
    return str.slice(index, (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.findClusterBreak)(str, index));
}
function regexpWordTest(categorizer) {
    return (_from, _to, match) => !match[0].length ||
        (categorizer(charBefore(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||
            categorizer(charAfter(match.input, match.index)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word) &&
            (categorizer(charAfter(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word ||
                categorizer(charBefore(match.input, match.index + match[0].length)) != _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.CharCategory.Word);
}
class RegExpQuery extends QueryType {
    nextMatch(state, curFrom, curTo) {
        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();
        if (cursor.done)
            cursor = regexpCursor(this.spec, state, 0, curFrom).next();
        return cursor.done ? null : cursor.value;
    }
    prevMatchInRange(state, from, to) {
        for (let size = 1;; size++) {
            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);
            let cursor = regexpCursor(this.spec, state, start, to), range = null;
            while (!cursor.next().done)
                range = cursor.value;
            if (range && (start == from || range.from > start + 10))
                return range;
            if (start == from)
                return null;
        }
    }
    prevMatch(state, curFrom, curTo) {
        return this.prevMatchInRange(state, 0, curFrom) ||
            this.prevMatchInRange(state, curTo, state.doc.length);
    }
    getReplacement(result) {
        return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (m, i) => i == "$" ? "$"
            : i == "&" ? result.match[0]
                : i != "0" && +i < result.match.length ? result.match[i]
                    : m));
    }
    matchAll(state, limit) {
        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];
        while (!cursor.next().done) {
            if (ranges.length >= limit)
                return null;
            ranges.push(cursor.value);
        }
        return ranges;
    }
    highlight(state, from, to, add) {
        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));
        while (!cursor.next().done)
            add(cursor.value.from, cursor.value.to);
    }
}
/**
A state effect that updates the current search query. Note that
this only has an effect if the search state has been initialized
(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or
by running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least
once).
*/
const setSearchQuery = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const togglePanel = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.define();
const searchState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateField.define({
    create(state) {
        return new SearchState(defaultQuery(state).create(), null);
    },
    update(value, tr) {
        for (let effect of tr.effects) {
            if (effect.is(setSearchQuery))
                value = new SearchState(effect.value.create(), value.panel);
            else if (effect.is(togglePanel))
                value = new SearchState(value.query, effect.value ? createSearchPanel : null);
        }
        return value;
    },
    provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.showPanel.from(f, val => val.panel)
});
/**
Get the current search query from an editor state.
*/
function getSearchQuery(state) {
    let curState = state.field(searchState, false);
    return curState ? curState.query.spec : defaultQuery(state);
}
/**
Query whether the search panel is open in the given editor state.
*/
function searchPanelOpen(state) {
    var _a;
    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;
}
class SearchState {
    constructor(query, panel) {
        this.query = query;
        this.panel = panel;
    }
}
const matchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.mark({ class: "cm-searchMatch" }), selectedMatchMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.mark({ class: "cm-searchMatch cm-searchMatch-selected" });
const searchHighlighter = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.ViewPlugin.fromClass(class {
    constructor(view) {
        this.view = view;
        this.decorations = this.highlight(view.state.field(searchState));
    }
    update(update) {
        let state = update.state.field(searchState);
        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)
            this.decorations = this.highlight(state);
    }
    highlight({ query, panel }) {
        if (!panel || !query.spec.valid)
            return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration.none;
        let { view } = this;
        let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.RangeSetBuilder();
        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {
            let { from, to } = ranges[i];
            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)
                to = ranges[++i].to;
            query.highlight(view.state, from, to, (from, to) => {
                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);
                builder.add(from, to, selected ? selectedMatchMark : matchMark);
            });
        }
        return builder.finish();
    }
}, {
    decorations: v => v.decorations
});
function searchCommand(f) {
    return view => {
        let state = view.state.field(searchState, false);
        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);
    };
}
/**
Open the search panel if it isn't already open, and move the
selection to the first match after the current main selection.
Will wrap around to the start of the document when it reaches the
end.
*/
const findNext = /*@__PURE__*/searchCommand((view, { query }) => {
    let { to } = view.state.selection.main;
    let next = query.nextMatch(view.state, to, to);
    if (!next)
        return false;
    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from, next.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
        selection,
        effects: [announceMatch(view, next), config.scrollToMatch(selection.main)],
        userEvent: "select.search"
    });
    return true;
});
/**
Move the selection to the previous instance of the search query,
before the current main selection. Will wrap past the start
of the document to start searching at the end again.
*/
const findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {
    let { state } = view, { from } = state.selection.main;
    let prev = query.prevMatch(state, from, from);
    if (!prev)
        return false;
    let selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(prev.from, prev.to);
    let config = view.state.facet(searchConfigFacet);
    view.dispatch({
        selection,
        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main)],
        userEvent: "select.search"
    });
    return true;
});
/**
Select all instances of the search query.
*/
const selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {
    let ranges = query.matchAll(view.state, 1000);
    if (!ranges || !ranges.length)
        return false;
    view.dispatch({
        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges.map(r => _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(r.from, r.to))),
        userEvent: "select.search.matches"
    });
    return true;
});
/**
Select all instances of the currently selected text.
*/
const selectSelectionMatches = ({ state, dispatch }) => {
    let sel = state.selection;
    if (sel.ranges.length > 1 || sel.main.empty)
        return false;
    let { from, to } = sel.main;
    let ranges = [], main = 0;
    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {
        if (ranges.length > 1000)
            return false;
        if (cur.value.from == from)
            main = ranges.length;
        ranges.push(_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.range(cur.value.from, cur.value.to));
    }
    dispatch(state.update({
        selection: _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.create(ranges, main),
        userEvent: "select.search.matches"
    }));
    return true;
};
/**
Replace the current match of the search query.
*/
const replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {
    let { state } = view, { from, to } = state.selection.main;
    if (state.readOnly)
        return false;
    let next = query.nextMatch(state, from, from);
    if (!next)
        return false;
    let changes = [], selection, replacement;
    let effects = [];
    if (next.from == from && next.to == to) {
        replacement = state.toText(query.getReplacement(next));
        changes.push({ from: next.from, to: next.to, insert: replacement });
        next = query.nextMatch(state, next.from, next.to);
        effects.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.announce.of(state.phrase("replaced match on line $", state.doc.lineAt(from).number) + "."));
    }
    if (next) {
        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;
        selection = _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.EditorSelection.single(next.from - off, next.to - off);
        effects.push(announceMatch(view, next));
        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main));
    }
    view.dispatch({
        changes, selection, effects,
        userEvent: "input.replace"
    });
    return true;
});
/**
Replace all instances of the search query with the given
replacement.
*/
const replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {
    if (view.state.readOnly)
        return false;
    let changes = query.matchAll(view.state, 1e9).map(match => {
        let { from, to } = match;
        return { from, to, insert: query.getReplacement(match) };
    });
    if (!changes.length)
        return false;
    let announceText = view.state.phrase("replaced $ matches", changes.length) + ".";
    view.dispatch({
        changes,
        effects: _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.announce.of(announceText),
        userEvent: "input.replace.all"
    });
    return true;
});
function createSearchPanel(view) {
    return view.state.facet(searchConfigFacet).createPanel(view);
}
function defaultQuery(state, fallback) {
    var _a, _b, _c, _d;
    let sel = state.selection.main;
    let selText = sel.empty || sel.to > sel.from + 100 ? "" : state.sliceDoc(sel.from, sel.to);
    if (fallback && !selText)
        return fallback;
    let config = state.facet(searchConfigFacet);
    return new SearchQuery({
        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\n/g, "\\n"),
        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,
        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,
        wholeWord: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _d !== void 0 ? _d : config.wholeWord
    });
}
/**
Make sure the search panel is open and focused.
*/
const openSearchPanel = view => {
    let state = view.state.field(searchState, false);
    if (state && state.panel) {
        let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.getPanel)(view, createSearchPanel);
        if (!panel)
            return false;
        let searchInput = panel.dom.querySelector("[main-field]");
        if (searchInput && searchInput != view.root.activeElement) {
            let query = defaultQuery(view.state, state.query.spec);
            if (query.valid)
                view.dispatch({ effects: setSearchQuery.of(query) });
            searchInput.focus();
            searchInput.select();
        }
    }
    else {
        view.dispatch({ effects: [
                togglePanel.of(true),
                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : _codemirror_state__WEBPACK_IMPORTED_MODULE_1__.StateEffect.appendConfig.of(searchExtensions)
            ] });
    }
    return true;
};
/**
Close the search panel.
*/
const closeSearchPanel = view => {
    let state = view.state.field(searchState, false);
    if (!state || !state.panel)
        return false;
    let panel = (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.getPanel)(view, createSearchPanel);
    if (panel && panel.dom.contains(view.root.activeElement))
        view.focus();
    view.dispatch({ effects: togglePanel.of(false) });
    return true;
};
/**
Default search-related key bindings.

 - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)
 - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)
 - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)
 - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)
 - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)
*/
const searchKeymap = [
    { key: "Mod-f", run: openSearchPanel, scope: "editor search-panel" },
    { key: "F3", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Mod-g", run: findNext, shift: findPrevious, scope: "editor search-panel", preventDefault: true },
    { key: "Escape", run: closeSearchPanel, scope: "editor search-panel" },
    { key: "Mod-Shift-l", run: selectSelectionMatches },
    { key: "Alt-g", run: gotoLine },
    { key: "Mod-d", run: selectNextOccurrence, preventDefault: true },
];
class SearchPanel {
    constructor(view) {
        this.view = view;
        let query = this.query = view.state.field(searchState).query.spec;
        this.commit = this.commit.bind(this);
        this.searchField = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("input", {
            value: query.search,
            placeholder: phrase(view, "Find"),
            "aria-label": phrase(view, "Find"),
            class: "cm-textfield",
            name: "search",
            form: "",
            "main-field": "true",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.replaceField = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("input", {
            value: query.replace,
            placeholder: phrase(view, "Replace"),
            "aria-label": phrase(view, "Replace"),
            class: "cm-textfield",
            name: "replace",
            form: "",
            onchange: this.commit,
            onkeyup: this.commit
        });
        this.caseField = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("input", {
            type: "checkbox",
            name: "case",
            form: "",
            checked: query.caseSensitive,
            onchange: this.commit
        });
        this.reField = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("input", {
            type: "checkbox",
            name: "re",
            form: "",
            checked: query.regexp,
            onchange: this.commit
        });
        this.wordField = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("input", {
            type: "checkbox",
            name: "word",
            form: "",
            checked: query.wholeWord,
            onchange: this.commit
        });
        function button(name, onclick, content) {
            return (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("button", { class: "cm-button", name, onclick, type: "button" }, content);
        }
        this.dom = (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("div", { onkeydown: (e) => this.keydown(e), class: "cm-search" }, [
            this.searchField,
            button("next", () => findNext(view), [phrase(view, "next")]),
            button("prev", () => findPrevious(view), [phrase(view, "previous")]),
            button("select", () => selectMatches(view), [phrase(view, "all")]),
            (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("label", null, [this.caseField, phrase(view, "match case")]),
            (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("label", null, [this.reField, phrase(view, "regexp")]),
            (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("label", null, [this.wordField, phrase(view, "by word")]),
            ...view.state.readOnly ? [] : [
                (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("br"),
                this.replaceField,
                button("replace", () => replaceNext(view), [phrase(view, "replace")]),
                button("replaceAll", () => replaceAll(view), [phrase(view, "replace all")])
            ],
            (0,crelt__WEBPACK_IMPORTED_MODULE_2__["default"])("button", {
                name: "close",
                onclick: () => closeSearchPanel(view),
                "aria-label": phrase(view, "close"),
                type: "button"
            }, ["Ã—"])
        ]);
    }
    commit() {
        let query = new SearchQuery({
            search: this.searchField.value,
            caseSensitive: this.caseField.checked,
            regexp: this.reField.checked,
            wholeWord: this.wordField.checked,
            replace: this.replaceField.value,
        });
        if (!query.eq(this.query)) {
            this.query = query;
            this.view.dispatch({ effects: setSearchQuery.of(query) });
        }
    }
    keydown(e) {
        if ((0,_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.runScopeHandlers)(this.view, e, "search-panel")) {
            e.preventDefault();
        }
        else if (e.keyCode == 13 && e.target == this.searchField) {
            e.preventDefault();
            (e.shiftKey ? findPrevious : findNext)(this.view);
        }
        else if (e.keyCode == 13 && e.target == this.replaceField) {
            e.preventDefault();
            replaceNext(this.view);
        }
    }
    update(update) {
        for (let tr of update.transactions)
            for (let effect of tr.effects) {
                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))
                    this.setQuery(effect.value);
            }
    }
    setQuery(query) {
        this.query = query;
        this.searchField.value = query.search;
        this.replaceField.value = query.replace;
        this.caseField.checked = query.caseSensitive;
        this.reField.checked = query.regexp;
        this.wordField.checked = query.wholeWord;
    }
    mount() {
        this.searchField.select();
    }
    get pos() { return 80; }
    get top() { return this.view.state.facet(searchConfigFacet).top; }
}
function phrase(view, phrase) { return view.state.phrase(phrase); }
const AnnounceMargin = 30;
const Break = /[\s\.,:;?!]/;
function announceMatch(view, { from, to }) {
    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;
    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);
    let text = view.state.sliceDoc(start, end);
    if (start != line.from) {
        for (let i = 0; i < AnnounceMargin; i++)
            if (!Break.test(text[i + 1]) && Break.test(text[i])) {
                text = text.slice(i);
                break;
            }
    }
    if (end != lineEnd) {
        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)
            if (!Break.test(text[i - 1]) && Break.test(text[i])) {
                text = text.slice(0, i);
                break;
            }
    }
    return _codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.announce.of(`${view.state.phrase("current match")}. ${text} ${view.state.phrase("on line")} ${line.number}.`);
}
const baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView.baseTheme({
    ".cm-panel.cm-search": {
        padding: "2px 6px 4px",
        position: "relative",
        "& [name=close]": {
            position: "absolute",
            top: "0",
            right: "4px",
            backgroundColor: "inherit",
            border: "none",
            font: "inherit",
            padding: 0,
            margin: 0
        },
        "& input, & button, & label": {
            margin: ".2em .6em .2em 0"
        },
        "& input[type=checkbox]": {
            marginRight: ".2em"
        },
        "& label": {
            fontSize: "80%",
            whiteSpace: "pre"
        }
    },
    "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
    "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
    "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
    "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
});
const searchExtensions = [
    searchState,
    /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_1__.Prec.lowest(searchHighlighter),
    baseTheme
];




/***/ }),

/***/ "../node_modules/crelt/index.es.js":
/*!*****************************************!*\
  !*** ../node_modules/crelt/index.es.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ crelt)
/* harmony export */ });
function crelt() {
  var elt = arguments[0]
  if (typeof elt == "string") elt = document.createElement(elt)
  var i = 1, next = arguments[1]
  if (next && typeof next == "object" && next.nodeType == null && !Array.isArray(next)) {
    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {
      var value = next[name]
      if (typeof value == "string") elt.setAttribute(name, value)
      else if (value != null) elt[name] = value
    }
    i++
  }
  for (; i < arguments.length; i++) add(elt, arguments[i])
  return elt
}

function add(elt, child) {
  if (typeof child == "string") {
    elt.appendChild(document.createTextNode(child))
  } else if (child == null) {
  } else if (child.nodeType != null) {
    elt.appendChild(child)
  } else if (Array.isArray(child)) {
    for (var i = 0; i < child.length; i++) add(elt, child[i])
  } else {
    throw new RangeError("Unsupported child node: " + child)
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9zZWFyY2hfZGlzdF9pbmRleF9qcy5hNTYxZTg2MTBjMDYwYzExODM5My5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkc7QUFDcUc7QUFDMUw7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdFQUFhO0FBQ25DLDhCQUE4QixnRUFBYTtBQUMzQztBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IseUJBQXlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVELGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSx1QkFBdUI7QUFDdkIsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxrQ0FBa0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0VBQXNCLElBQUksbUNBQW1DLElBQUksTUFBTSxFQUFFLDhCQUE4QixFQUFFLFlBQVk7QUFDaEk7QUFDQSwrQkFBK0Isa0VBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLDhCQUE4QjtBQUM5RCwrQkFBK0IsOEJBQThCO0FBQzdELHlDQUF5Qyw4QkFBOEI7QUFDdkUsd0NBQXdDO0FBQ3hDLENBQUM7QUFDRDtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFXO0FBQzVCO0FBQ0E7O0FBRWdUOzs7Ozs7Ozs7Ozs7Ozs7QUN0ckNqUztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLGtCQUFrQjtBQUN0QyxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9zZWFyY2gvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL2NyZWx0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNob3dQYW5lbCwgRWRpdG9yVmlldywgZ2V0UGFuZWwsIERlY29yYXRpb24sIFZpZXdQbHVnaW4sIHJ1blNjb3BlSGFuZGxlcnMgfSBmcm9tICdAY29kZW1pcnJvci92aWV3JztcbmltcG9ydCB7IGNvZGVQb2ludEF0LCBmcm9tQ29kZVBvaW50LCBjb2RlUG9pbnRTaXplLCBTdGF0ZUVmZmVjdCwgU3RhdGVGaWVsZCwgRWRpdG9yU2VsZWN0aW9uLCBGYWNldCwgY29tYmluZUNvbmZpZywgQ2hhckNhdGVnb3J5LCBSYW5nZVNldEJ1aWxkZXIsIFByZWMsIEVkaXRvclN0YXRlLCBmaW5kQ2x1c3RlckJyZWFrIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IGVsdCBmcm9tICdjcmVsdCc7XG5cbmNvbnN0IGJhc2ljTm9ybWFsaXplID0gdHlwZW9mIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplID09IFwiZnVuY3Rpb25cIlxuICAgID8geCA9PiB4Lm5vcm1hbGl6ZShcIk5GS0RcIikgOiB4ID0+IHg7XG4vKipcbkEgc2VhcmNoIGN1cnNvciBwcm92aWRlcyBhbiBpdGVyYXRvciBvdmVyIHRleHQgbWF0Y2hlcyBpbiBhXG5kb2N1bWVudC5cbiovXG5jbGFzcyBTZWFyY2hDdXJzb3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgY3Vyc29yLiBUaGUgcXVlcnkgaXMgdGhlIHNlYXJjaCBzdHJpbmcsIGBmcm9tYCB0b1xuICAgIGB0b2AgcHJvdmlkZXMgdGhlIHJlZ2lvbiB0byBzZWFyY2guXG4gICAgXG4gICAgV2hlbiBgbm9ybWFsaXplYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBjYWxsZWQsIG9uIGJvdGggdGhlIHF1ZXJ5XG4gICAgc3RyaW5nIGFuZCB0aGUgY29udGVudCBpdCBpcyBtYXRjaGVkIGFnYWluc3QsIGJlZm9yZSBjb21wYXJpbmcuXG4gICAgWW91IGNhbiwgZm9yIGV4YW1wbGUsIGNyZWF0ZSBhIGNhc2UtaW5zZW5zaXRpdmUgc2VhcmNoIGJ5XG4gICAgcGFzc2luZyBgcyA9PiBzLnRvTG93ZXJDYXNlKClgLlxuICAgIFxuICAgIFRleHQgaXMgYWx3YXlzIG5vcm1hbGl6ZWQgd2l0aFxuICAgIFtgLm5vcm1hbGl6ZShcIk5GS0RcIilgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvbm9ybWFsaXplKVxuICAgICh3aGVuIHN1cHBvcnRlZCkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCBxdWVyeSwgZnJvbSA9IDAsIHRvID0gdGV4dC5sZW5ndGgsIG5vcm1hbGl6ZSwgdGVzdCkge1xuICAgICAgICB0aGlzLnRlc3QgPSB0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGN1cnJlbnQgbWF0Y2ggKG9ubHkgaG9sZHMgYSBtZWFuaW5nZnVsIHZhbHVlIGFmdGVyXG4gICAgICAgIFtgbmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvci5uZXh0KSBoYXMgYmVlbiBjYWxsZWQgYW5kIHdoZW5cbiAgICAgICAgYGRvbmVgIGlzIGZhbHNlKS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbTogMCwgdG86IDAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgIFdoZXRoZXIgdGhlIGVuZCBvZiB0aGUgaXRlcmF0ZWQgcmVnaW9uIGhhcyBiZWVuIHJlYWNoZWQuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBbXTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XG4gICAgICAgIHRoaXMuaXRlciA9IHRleHQuaXRlclJhbmdlKGZyb20sIHRvKTtcbiAgICAgICAgdGhpcy5idWZmZXJTdGFydCA9IGZyb207XG4gICAgICAgIHRoaXMubm9ybWFsaXplID0gbm9ybWFsaXplID8geCA9PiBub3JtYWxpemUoYmFzaWNOb3JtYWxpemUoeCkpIDogYmFzaWNOb3JtYWxpemU7XG4gICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLm5vcm1hbGl6ZShxdWVyeSk7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlclBvcyA9PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyU3RhcnQgKz0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5pdGVyLm5leHQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLml0ZXIuZG9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvcyA9IDA7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuaXRlci52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZVBvaW50QXQodGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyUG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgdGhlIG5leHQgbWF0Y2guIFVwZGF0ZXMgdGhlIGl0ZXJhdG9yJ3NcbiAgICBbYHZhbHVlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guU2VhcmNoQ3Vyc29yLnZhbHVlKSBhbmRcbiAgICBbYGRvbmVgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5TZWFyY2hDdXJzb3IuZG9uZSkgcHJvcGVydGllcy4gU2hvdWxkIGJlIGNhbGxlZFxuICAgIGF0IGxlYXN0IG9uY2UgYmVmb3JlIHVzaW5nIHRoZSBjdXJzb3IuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICB3aGlsZSAodGhpcy5tYXRjaGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBgbmV4dGAgbWV0aG9kIHdpbGwgaWdub3JlIG1hdGNoZXMgdGhhdCBwYXJ0aWFsbHkgb3ZlcmxhcCBhXG4gICAgcHJldmlvdXMgbWF0Y2guIFRoaXMgbWV0aG9kIGJlaGF2ZXMgbGlrZSBgbmV4dGAsIGJ1dCBpbmNsdWRlc1xuICAgIHN1Y2ggbWF0Y2hlcy5cbiAgICAqL1xuICAgIG5leHRPdmVybGFwcGluZygpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgc3RyID0gZnJvbUNvZGVQb2ludChuZXh0KSwgc3RhcnQgPSB0aGlzLmJ1ZmZlclN0YXJ0ICsgdGhpcy5idWZmZXJQb3M7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlclBvcyArPSBjb2RlUG9pbnRTaXplKG5leHQpO1xuICAgICAgICAgICAgbGV0IG5vcm0gPSB0aGlzLm5vcm1hbGl6ZShzdHIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IHN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGUgPSBub3JtLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5tYXRjaChjb2RlLCBwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBub3JtLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gc3RhcnQgJiYgaSA8IHN0ci5sZW5ndGggJiYgc3RyLmNoYXJDb2RlQXQoaSkgPT0gY29kZSlcbiAgICAgICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWF0Y2goY29kZSwgcG9zKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXRjaGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm1hdGNoZXNbaV0sIGtlZXAgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoaW5kZXgpID09IGNvZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5xdWVyeS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0geyBmcm9tOiB0aGlzLm1hdGNoZXNbaSArIDFdLCB0bzogcG9zICsgMSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaGVzW2ldKys7XG4gICAgICAgICAgICAgICAgICAgIGtlZXAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgha2VlcCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hlcy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgICAgICAgaSAtPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5LmNoYXJDb2RlQXQoMCkgPT0gY29kZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucXVlcnkubGVuZ3RoID09IDEpXG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB7IGZyb206IHBvcywgdG86IHBvcyArIDEgfTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGNoZXMucHVzaCgxLCBwb3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRjaCAmJiB0aGlzLnRlc3QgJiYgIXRoaXMudGVzdChtYXRjaC5mcm9tLCBtYXRjaC50bywgdGhpcy5idWZmZXIsIHRoaXMuYnVmZmVyUG9zKSlcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sICE9IFwidW5kZWZpbmVkXCIpXG4gICAgU2VhcmNoQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuY29uc3QgZW1wdHkgPSB7IGZyb206IC0xLCB0bzogLTEsIG1hdGNoOiAvKkBfX1BVUkVfXyovLy4qLy5leGVjKFwiXCIpIH07XG5jb25zdCBiYXNlRmxhZ3MgPSBcImdtXCIgKyAoL3gvLnVuaWNvZGUgPT0gbnVsbCA/IFwiXCIgOiBcInVcIik7XG4vKipcblRoaXMgY2xhc3MgaXMgc2ltaWxhciB0byBbYFNlYXJjaEN1cnNvcmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLlNlYXJjaEN1cnNvcilcbmJ1dCBzZWFyY2hlcyBmb3IgYSByZWd1bGFyIGV4cHJlc3Npb24gcGF0dGVybiBpbnN0ZWFkIG9mIGEgcGxhaW5cbnN0cmluZy5cbiovXG5jbGFzcyBSZWdFeHBDdXJzb3Ige1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGN1cnNvciB0aGF0IHdpbGwgc2VhcmNoIHRoZSBnaXZlbiByYW5nZSBpbiB0aGUgZ2l2ZW5cbiAgICBkb2N1bWVudC4gYHF1ZXJ5YCBzaG91bGQgYmUgdGhlIHJhdyBwYXR0ZXJuIChhcyB5b3UnZCBwYXNzIGl0IHRvXG4gICAgYG5ldyBSZWdFeHBgKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRleHQsIHF1ZXJ5LCBvcHRpb25zLCBmcm9tID0gMCwgdG8gPSB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XG4gICAgICAgIC8qKlxuICAgICAgICBTZXQgdG8gYHRydWVgIHdoZW4gdGhlIGN1cnNvciBoYXMgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBzZWFyY2hcbiAgICAgICAgcmFuZ2UuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgV2lsbCBjb250YWluIGFuIG9iamVjdCB3aXRoIHRoZSBleHRlbnQgb2YgdGhlIG1hdGNoIGFuZCB0aGVcbiAgICAgICAgbWF0Y2ggb2JqZWN0IHdoZW4gW2BuZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guUmVnRXhwQ3Vyc29yLm5leHQpXG4gICAgICAgIHN1Y2Vzc2Z1bGx5IGZpbmRzIGEgbWF0Y2guXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWUgPSBlbXB0eTtcbiAgICAgICAgaWYgKC9cXFxcW3NXRG5yXXxcXG58XFxyfFxcW1xcXi8udGVzdChxdWVyeSkpXG4gICAgICAgICAgICByZXR1cm4gbmV3IE11bHRpbGluZVJlZ0V4cEN1cnNvcih0ZXh0LCBxdWVyeSwgb3B0aW9ucywgZnJvbSwgdG8pO1xuICAgICAgICB0aGlzLnJlID0gbmV3IFJlZ0V4cChxdWVyeSwgYmFzZUZsYWdzICsgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaWdub3JlQ2FzZSkgPyBcImlcIiA6IFwiXCIpKTtcbiAgICAgICAgdGhpcy50ZXN0ID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRlc3Q7XG4gICAgICAgIHRoaXMuaXRlciA9IHRleHQuaXRlcigpO1xuICAgICAgICBsZXQgc3RhcnRMaW5lID0gdGV4dC5saW5lQXQoZnJvbSk7XG4gICAgICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gc3RhcnRMaW5lLmZyb207XG4gICAgICAgIHRoaXMubWF0Y2hQb3MgPSB0b0NoYXJFbmQodGV4dCwgZnJvbSk7XG4gICAgICAgIHRoaXMuZ2V0TGluZSh0aGlzLmN1ckxpbmVTdGFydCk7XG4gICAgfVxuICAgIGdldExpbmUoc2tpcCkge1xuICAgICAgICB0aGlzLml0ZXIubmV4dChza2lwKTtcbiAgICAgICAgaWYgKHRoaXMuaXRlci5saW5lQnJlYWspIHtcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLml0ZXIudmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoID4gdGhpcy50bylcbiAgICAgICAgICAgICAgICB0aGlzLmN1ckxpbmUgPSB0aGlzLmN1ckxpbmUuc2xpY2UoMCwgdGhpcy50byAtIHRoaXMuY3VyTGluZVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuaXRlci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV4dExpbmUoKSB7XG4gICAgICAgIHRoaXMuY3VyTGluZVN0YXJ0ID0gdGhpcy5jdXJMaW5lU3RhcnQgKyB0aGlzLmN1ckxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgaWYgKHRoaXMuY3VyTGluZVN0YXJ0ID4gdGhpcy50bylcbiAgICAgICAgICAgIHRoaXMuY3VyTGluZSA9IFwiXCI7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZ2V0TGluZSgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGUgbmV4dCBtYXRjaCwgaWYgdGhlcmUgaXMgb25lLlxuICAgICovXG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yIChsZXQgb2ZmID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuY3VyTGluZVN0YXJ0OzspIHtcbiAgICAgICAgICAgIHRoaXMucmUubGFzdEluZGV4ID0gb2ZmO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5tYXRjaFBvcyA8PSB0aGlzLnRvICYmIHRoaXMucmUuZXhlYyh0aGlzLmN1ckxpbmUpO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSB0aGlzLmN1ckxpbmVTdGFydCArIG1hdGNoLmluZGV4LCB0byA9IGZyb20gKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0aGlzLnRleHQsIHRvICsgKGZyb20gPT0gdG8gPyAxIDogMCkpO1xuICAgICAgICAgICAgICAgIGlmIChmcm9tID09IHRoaXMuY3VyTGluZVN0YXJ0ICsgdGhpcy5jdXJMaW5lLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgIGlmICgoZnJvbSA8IHRvIHx8IGZyb20gPiB0aGlzLnZhbHVlLnRvKSAmJiAoIXRoaXMudGVzdCB8fCB0aGlzLnRlc3QoZnJvbSwgdG8sIG1hdGNoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHsgZnJvbSwgdG8sIG1hdGNoIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmYgPSB0aGlzLm1hdGNoUG9zIC0gdGhpcy5jdXJMaW5lU3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmN1ckxpbmVTdGFydCArIHRoaXMuY3VyTGluZS5sZW5ndGggPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGluZSgpO1xuICAgICAgICAgICAgICAgIG9mZiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgZmxhdHRlbmVkID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vLyBSZXVzYWJsZSAocGFydGlhbGx5KSBmbGF0dGVuZWQgZG9jdW1lbnQgc3RyaW5nc1xuY2xhc3MgRmxhdHRlbmVkRG9jIHtcbiAgICBjb25zdHJ1Y3Rvcihmcm9tLCB0ZXh0KSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuZnJvbSArIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBzdGF0aWMgZ2V0KGRvYywgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IGZsYXR0ZW5lZC5nZXQoZG9jKTtcbiAgICAgICAgaWYgKCFjYWNoZWQgfHwgY2FjaGVkLmZyb20gPj0gdG8gfHwgY2FjaGVkLnRvIDw9IGZyb20pIHtcbiAgICAgICAgICAgIGxldCBmbGF0ID0gbmV3IEZsYXR0ZW5lZERvYyhmcm9tLCBkb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIGZsYXR0ZW5lZC5zZXQoZG9jLCBmbGF0KTtcbiAgICAgICAgICAgIHJldHVybiBmbGF0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWQuZnJvbSA9PSBmcm9tICYmIGNhY2hlZC50byA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIGxldCB7IHRleHQsIGZyb206IGNhY2hlZEZyb20gfSA9IGNhY2hlZDtcbiAgICAgICAgaWYgKGNhY2hlZEZyb20gPiBmcm9tKSB7XG4gICAgICAgICAgICB0ZXh0ID0gZG9jLnNsaWNlU3RyaW5nKGZyb20sIGNhY2hlZEZyb20pICsgdGV4dDtcbiAgICAgICAgICAgIGNhY2hlZEZyb20gPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWNoZWQudG8gPCB0bylcbiAgICAgICAgICAgIHRleHQgKz0gZG9jLnNsaWNlU3RyaW5nKGNhY2hlZC50bywgdG8pO1xuICAgICAgICBmbGF0dGVuZWQuc2V0KGRvYywgbmV3IEZsYXR0ZW5lZERvYyhjYWNoZWRGcm9tLCB0ZXh0KSk7XG4gICAgICAgIHJldHVybiBuZXcgRmxhdHRlbmVkRG9jKGZyb20sIHRleHQuc2xpY2UoZnJvbSAtIGNhY2hlZEZyb20sIHRvIC0gY2FjaGVkRnJvbSkpO1xuICAgIH1cbn1cbmNsYXNzIE11bHRpbGluZVJlZ0V4cEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgcXVlcnksIG9wdGlvbnMsIGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlbXB0eTtcbiAgICAgICAgdGhpcy5tYXRjaFBvcyA9IHRvQ2hhckVuZCh0ZXh0LCBmcm9tKTtcbiAgICAgICAgdGhpcy5yZSA9IG5ldyBSZWdFeHAocXVlcnksIGJhc2VGbGFncyArICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmlnbm9yZUNhc2UpID8gXCJpXCIgOiBcIlwiKSk7XG4gICAgICAgIHRoaXMudGVzdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXN0O1xuICAgICAgICB0aGlzLmZsYXQgPSBGbGF0dGVuZWREb2MuZ2V0KHRleHQsIGZyb20sIHRoaXMuY2h1bmtFbmQoZnJvbSArIDUwMDAgLyogQ2h1bmsuQmFzZSAqLykpO1xuICAgIH1cbiAgICBjaHVua0VuZChwb3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcyA+PSB0aGlzLnRvID8gdGhpcy50byA6IHRoaXMudGV4dC5saW5lQXQocG9zKS50bztcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IG9mZiA9IHRoaXMucmUubGFzdEluZGV4ID0gdGhpcy5tYXRjaFBvcyAtIHRoaXMuZmxhdC5mcm9tO1xuICAgICAgICAgICAgbGV0IG1hdGNoID0gdGhpcy5yZS5leGVjKHRoaXMuZmxhdC50ZXh0KTtcbiAgICAgICAgICAgIC8vIFNraXAgZW1wdHkgbWF0Y2hlcyBkaXJlY3RseSBhZnRlciB0aGUgbGFzdCBtYXRjaFxuICAgICAgICAgICAgaWYgKG1hdGNoICYmICFtYXRjaFswXSAmJiBtYXRjaC5pbmRleCA9PSBvZmYpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlLmxhc3RJbmRleCA9IG9mZiArIDE7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLnJlLmV4ZWModGhpcy5mbGF0LnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSB0aGlzLmZsYXQuZnJvbSArIG1hdGNoLmluZGV4LCB0byA9IGZyb20gKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBtYXRjaCBnb2VzIGFsbW9zdCB0byB0aGUgZW5kIG9mIGEgbm9uY29tcGxldGUgY2h1bmssIHRyeVxuICAgICAgICAgICAgICAgIC8vIGFnYWluLCBzaW5jZSBpdCdsbCBsaWtlbHkgYmUgYWJsZSB0byBtYXRjaCBtb3JlXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLmZsYXQudG8gPj0gdGhpcy50byB8fCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCA8PSB0aGlzLmZsYXQudGV4dC5sZW5ndGggLSAxMCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCF0aGlzLnRlc3QgfHwgdGhpcy50ZXN0KGZyb20sIHRvLCBtYXRjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7IGZyb20sIHRvLCBtYXRjaCB9O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoUG9zID0gdG9DaGFyRW5kKHRoaXMudGV4dCwgdG8gKyAoZnJvbSA9PSB0byA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZsYXQudG8gPT0gdGhpcy50bykge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHcm93IHRoZSBmbGF0dGVuZWQgZG9jXG4gICAgICAgICAgICB0aGlzLmZsYXQgPSBGbGF0dGVuZWREb2MuZ2V0KHRoaXMudGV4dCwgdGhpcy5mbGF0LmZyb20sIHRoaXMuY2h1bmtFbmQodGhpcy5mbGF0LmZyb20gKyB0aGlzLmZsYXQudGV4dC5sZW5ndGggKiAyKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5pZiAodHlwZW9mIFN5bWJvbCAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgUmVnRXhwQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gTXVsdGlsaW5lUmVnRXhwQ3Vyc29yLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID1cbiAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkUmVnRXhwKHNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAoc291cmNlLCBiYXNlRmxhZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b0NoYXJFbmQodGV4dCwgcG9zKSB7XG4gICAgaWYgKHBvcyA+PSB0ZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBsZXQgbGluZSA9IHRleHQubGluZUF0KHBvcyksIG5leHQ7XG4gICAgd2hpbGUgKHBvcyA8IGxpbmUudG8gJiYgKG5leHQgPSBsaW5lLnRleHQuY2hhckNvZGVBdChwb3MgLSBsaW5lLmZyb20pKSA+PSAweERDMDAgJiYgbmV4dCA8IDB4RTAwMClcbiAgICAgICAgcG9zKys7XG4gICAgcmV0dXJuIHBvcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGluZURpYWxvZyh2aWV3KSB7XG4gICAgbGV0IGlucHV0ID0gZWx0KFwiaW5wdXRcIiwgeyBjbGFzczogXCJjbS10ZXh0ZmllbGRcIiwgbmFtZTogXCJsaW5lXCIgfSk7XG4gICAgbGV0IGRvbSA9IGVsdChcImZvcm1cIiwge1xuICAgICAgICBjbGFzczogXCJjbS1nb3RvTGluZVwiLFxuICAgICAgICBvbmtleWRvd246IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogZGlhbG9nRWZmZWN0Lm9mKGZhbHNlKSB9KTtcbiAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXlDb2RlID09IDEzKSB7IC8vIEVudGVyXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBnbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbnN1Ym1pdDogKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZ28oKTtcbiAgICAgICAgfVxuICAgIH0sIGVsdChcImxhYmVsXCIsIHZpZXcuc3RhdGUucGhyYXNlKFwiR28gdG8gbGluZVwiKSwgXCI6IFwiLCBpbnB1dCksIFwiIFwiLCBlbHQoXCJidXR0b25cIiwgeyBjbGFzczogXCJjbS1idXR0b25cIiwgdHlwZTogXCJzdWJtaXRcIiB9LCB2aWV3LnN0YXRlLnBocmFzZShcImdvXCIpKSk7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IC9eKFsrLV0pPyhcXGQrKT8oOlxcZCspPyglKT8kLy5leGVjKGlucHV0LnZhbHVlKTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHN0YXJ0TGluZSA9IHN0YXRlLmRvYy5saW5lQXQoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCk7XG4gICAgICAgIGxldCBbLCBzaWduLCBsbiwgY2wsIHBlcmNlbnRdID0gbWF0Y2g7XG4gICAgICAgIGxldCBjb2wgPSBjbCA/ICtjbC5zbGljZSgxKSA6IDA7XG4gICAgICAgIGxldCBsaW5lID0gbG4gPyArbG4gOiBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICBpZiAobG4gJiYgcGVyY2VudCkge1xuICAgICAgICAgICAgbGV0IHBjID0gbGluZSAvIDEwMDtcbiAgICAgICAgICAgIGlmIChzaWduKVxuICAgICAgICAgICAgICAgIHBjID0gcGMgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyAoc3RhcnRMaW5lLm51bWJlciAvIHN0YXRlLmRvYy5saW5lcyk7XG4gICAgICAgICAgICBsaW5lID0gTWF0aC5yb3VuZChzdGF0ZS5kb2MubGluZXMgKiBwYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG4gJiYgc2lnbikge1xuICAgICAgICAgICAgbGluZSA9IGxpbmUgKiAoc2lnbiA9PSBcIi1cIiA/IC0xIDogMSkgKyBzdGFydExpbmUubnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkb2NMaW5lID0gc3RhdGUuZG9jLmxpbmUoTWF0aC5tYXgoMSwgTWF0aC5taW4oc3RhdGUuZG9jLmxpbmVzLCBsaW5lKSkpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIGVmZmVjdHM6IGRpYWxvZ0VmZmVjdC5vZihmYWxzZSksXG4gICAgICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IoZG9jTGluZS5mcm9tICsgTWF0aC5tYXgoMCwgTWF0aC5taW4oY29sLCBkb2NMaW5lLmxlbmd0aCkpKSxcbiAgICAgICAgICAgIHNjcm9sbEludG9WaWV3OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgfVxuICAgIHJldHVybiB7IGRvbSB9O1xufVxuY29uc3QgZGlhbG9nRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3QgZGlhbG9nRmllbGQgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZSgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZS5pcyhkaWFsb2dFZmZlY3QpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgcHJvdmlkZTogZiA9PiBzaG93UGFuZWwuZnJvbShmLCB2YWwgPT4gdmFsID8gY3JlYXRlTGluZURpYWxvZyA6IG51bGwpXG59KTtcbi8qKlxuQ29tbWFuZCB0aGF0IHNob3dzIGEgZGlhbG9nIGFza2luZyB0aGUgdXNlciBmb3IgYSBsaW5lIG51bWJlciwgYW5kXG53aGVuIGEgdmFsaWQgcG9zaXRpb24gaXMgcHJvdmlkZWQsIG1vdmVzIHRoZSBjdXJzb3IgdG8gdGhhdCBsaW5lLlxuXG5TdXBwb3J0cyBsaW5lIG51bWJlcnMsIHJlbGF0aXZlIGxpbmUgb2Zmc2V0cyBwcmVmaXhlZCB3aXRoIGArYCBvclxuYC1gLCBkb2N1bWVudCBwZXJjZW50YWdlcyBzdWZmaXhlZCB3aXRoIGAlYCwgYW5kIGFuIG9wdGlvbmFsXG5jb2x1bW4gcG9zaXRpb24gYnkgYWRkaW5nIGA6YCBhbmQgYSBzZWNvbmQgbnVtYmVyIGFmdGVyIHRoZSBsaW5lXG5udW1iZXIuXG4qL1xuY29uc3QgZ290b0xpbmUgPSB2aWV3ID0+IHtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVMaW5lRGlhbG9nKTtcbiAgICBpZiAoIXBhbmVsKSB7XG4gICAgICAgIGxldCBlZmZlY3RzID0gW2RpYWxvZ0VmZmVjdC5vZih0cnVlKV07XG4gICAgICAgIGlmICh2aWV3LnN0YXRlLmZpZWxkKGRpYWxvZ0ZpZWxkLCBmYWxzZSkgPT0gbnVsbClcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoW2RpYWxvZ0ZpZWxkLCBiYXNlVGhlbWUkMV0pKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgICAgIHBhbmVsID0gZ2V0UGFuZWwodmlldywgY3JlYXRlTGluZURpYWxvZyk7XG4gICAgfVxuICAgIGlmIChwYW5lbClcbiAgICAgICAgcGFuZWwuZG9tLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFwiKS5mb2N1cygpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IGJhc2VUaGVtZSQxID0gLypAX19QVVJFX18qL0VkaXRvclZpZXcuYmFzZVRoZW1lKHtcbiAgICBcIi5jbS1wYW5lbC5jbS1nb3RvTGluZVwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDZweCA0cHhcIixcbiAgICAgICAgXCImIGxhYmVsXCI6IHsgZm9udFNpemU6IFwiODAlXCIgfVxuICAgIH1cbn0pO1xuXG5jb25zdCBkZWZhdWx0SGlnaGxpZ2h0T3B0aW9ucyA9IHtcbiAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiBmYWxzZSxcbiAgICBtaW5TZWxlY3Rpb25MZW5ndGg6IDEsXG4gICAgbWF4TWF0Y2hlczogMTAwLFxuICAgIHdob2xlV29yZHM6IGZhbHNlXG59O1xuY29uc3QgaGlnaGxpZ2h0Q29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBjb21iaW5lQ29uZmlnKG9wdGlvbnMsIGRlZmF1bHRIaWdobGlnaHRPcHRpb25zLCB7XG4gICAgICAgICAgICBoaWdobGlnaHRXb3JkQXJvdW5kQ3Vyc29yOiAoYSwgYikgPT4gYSB8fCBiLFxuICAgICAgICAgICAgbWluU2VsZWN0aW9uTGVuZ3RoOiBNYXRoLm1pbixcbiAgICAgICAgICAgIG1heE1hdGNoZXM6IE1hdGgubWluXG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG5UaGlzIGV4dGVuc2lvbiBoaWdobGlnaHRzIHRleHQgdGhhdCBtYXRjaGVzIHRoZSBzZWxlY3Rpb24uIEl0IHVzZXNcbnRoZSBgXCJjbS1zZWxlY3Rpb25NYXRjaFwiYCBjbGFzcyBmb3IgdGhlIGhpZ2hsaWdodGluZy4gV2hlblxuYGhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3JgIGlzIGVuYWJsZWQsIHRoZSB3b3JkIGF0IHRoZSBjdXJzb3Jcbml0c2VsZiB3aWxsIGJlIGhpZ2hsaWdodGVkIHdpdGggYFwiY20tc2VsZWN0aW9uTWF0Y2gtbWFpblwiYC5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRTZWxlY3Rpb25NYXRjaGVzKG9wdGlvbnMpIHtcbiAgICBsZXQgZXh0ID0gW2RlZmF1bHRUaGVtZSwgbWF0Y2hIaWdobGlnaHRlcl07XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodENvbmZpZy5vZihvcHRpb25zKSk7XG4gICAgcmV0dXJuIGV4dDtcbn1cbmNvbnN0IG1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaFwiIH0pO1xuY29uc3QgbWFpbk1hdGNoRGVjbyA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWxlY3Rpb25NYXRjaCBjbS1zZWxlY3Rpb25NYXRjaC1tYWluXCIgfSk7XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IG91dHNpZGUgdGhlIGdpdmVuIHBvc2l0aW9ucyBhcmUgbm9uLXdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCBmcm9tLCB0bykge1xuICAgIHJldHVybiAoZnJvbSA9PSAwIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20gLSAxLCBmcm9tKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQpICYmXG4gICAgICAgICh0byA9PSBzdGF0ZS5kb2MubGVuZ3RoIHx8IGNoZWNrKHN0YXRlLnNsaWNlRG9jKHRvLCB0byArIDEpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG59XG4vLyBXaGV0aGVyIHRoZSBjaGFyYWN0ZXJzIGRpcmVjdGx5IGF0IHRoZSBnaXZlbiBwb3NpdGlvbnMgYXJlIHdvcmQgY2hhcmFjdGVyc1xuZnVuY3Rpb24gaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIGNoZWNrKHN0YXRlLnNsaWNlRG9jKGZyb20sIGZyb20gKyAxKSkgPT0gQ2hhckNhdGVnb3J5LldvcmRcbiAgICAgICAgJiYgY2hlY2soc3RhdGUuc2xpY2VEb2ModG8gLSAxLCB0bykpID09IENoYXJDYXRlZ29yeS5Xb3JkO1xufVxuY29uc3QgbWF0Y2hIaWdobGlnaHRlciA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHZpZXcpO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGlmICh1cGRhdGUuc2VsZWN0aW9uU2V0IHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpXG4gICAgICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5nZXREZWNvKHVwZGF0ZS52aWV3KTtcbiAgICB9XG4gICAgZ2V0RGVjbyh2aWV3KSB7XG4gICAgICAgIGxldCBjb25mID0gdmlldy5zdGF0ZS5mYWNldChoaWdobGlnaHRDb25maWcpO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdmlldywgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc2VsLnJhbmdlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IHJhbmdlID0gc2VsLm1haW4sIHF1ZXJ5LCBjaGVjayA9IG51bGw7XG4gICAgICAgIGlmIChyYW5nZS5lbXB0eSkge1xuICAgICAgICAgICAgaWYgKCFjb25mLmhpZ2hsaWdodFdvcmRBcm91bmRDdXJzb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpO1xuICAgICAgICAgICAgaWYgKCF3b3JkKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBjaGVjayA9IHN0YXRlLmNoYXJDYXRlZ29yaXplcihyYW5nZS5oZWFkKTtcbiAgICAgICAgICAgIHF1ZXJ5ID0gc3RhdGUuc2xpY2VEb2Mod29yZC5mcm9tLCB3b3JkLnRvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBsZW4gPSByYW5nZS50byAtIHJhbmdlLmZyb207XG4gICAgICAgICAgICBpZiAobGVuIDwgY29uZi5taW5TZWxlY3Rpb25MZW5ndGggfHwgbGVuID4gMjAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICBpZiAoY29uZi53aG9sZVdvcmRzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnkgPSBzdGF0ZS5zbGljZURvYyhyYW5nZS5mcm9tLCByYW5nZS50byk7IC8vIFRPRE86IGFsbG93IGFuZCBpbmNsdWRlIGxlYWRpbmcvdHJhaWxpbmcgc3BhY2U/XG4gICAgICAgICAgICAgICAgY2hlY2sgPSBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIocmFuZ2UuaGVhZCk7XG4gICAgICAgICAgICAgICAgaWYgKCEoaW5zaWRlV29yZEJvdW5kYXJpZXMoY2hlY2ssIHN0YXRlLCByYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgJiYgaW5zaWRlV29yZChjaGVjaywgc3RhdGUsIHJhbmdlLmZyb20sIHJhbmdlLnRvKSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBxdWVyeSA9IHN0YXRlLnNsaWNlRG9jKHJhbmdlLmZyb20sIHJhbmdlLnRvKS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFxdWVyeSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVjbyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIHZpZXcudmlzaWJsZVJhbmdlcykge1xuICAgICAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcGFydC5mcm9tLCBwYXJ0LnRvKTtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWNoZWNrIHx8IGluc2lkZVdvcmRCb3VuZGFyaWVzKGNoZWNrLCBzdGF0ZSwgZnJvbSwgdG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbXB0eSAmJiBmcm9tIDw9IHJhbmdlLmZyb20gJiYgdG8gPj0gcmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWFpbk1hdGNoRGVjby5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmcm9tID49IHJhbmdlLnRvIHx8IHRvIDw9IHJhbmdlLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvLnB1c2gobWF0Y2hEZWNvLnJhbmdlKGZyb20sIHRvKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWNvLmxlbmd0aCA+IGNvbmYubWF4TWF0Y2hlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvKTtcbiAgICB9XG59LCB7XG4gICAgZGVjb3JhdGlvbnM6IHYgPT4gdi5kZWNvcmF0aW9uc1xufSk7XG5jb25zdCBkZWZhdWx0VGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiM5OWZmNzc4MFwiIH0sXG4gICAgXCIuY20tc2VhcmNoTWF0Y2ggLmNtLXNlbGVjdGlvbk1hdGNoXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcInRyYW5zcGFyZW50XCIgfVxufSk7XG4vLyBTZWxlY3QgdGhlIHdvcmRzIGFyb3VuZCB0aGUgY3Vyc29ycy5cbmNvbnN0IHNlbGVjdFdvcmQgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgbGV0IG5ld1NlbCA9IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUoc2VsZWN0aW9uLnJhbmdlcy5tYXAocmFuZ2UgPT4gc3RhdGUud29yZEF0KHJhbmdlLmhlYWQpIHx8IEVkaXRvclNlbGVjdGlvbi5jdXJzb3IocmFuZ2UuaGVhZCkpLCBzZWxlY3Rpb24ubWFpbkluZGV4KTtcbiAgICBpZiAobmV3U2VsLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoeyBzZWxlY3Rpb246IG5ld1NlbCB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCBuZXh0IG9jY3VycmVuY2Ugb2YgcXVlcnkgcmVsYXRpdmUgdG8gbGFzdCBjdXJzb3IuIFdyYXAgYXJvdW5kXG4vLyB0aGUgZG9jdW1lbnQgaWYgdGhlcmUgYXJlIG5vIG1vcmUgbWF0Y2hlcy5cbmZ1bmN0aW9uIGZpbmROZXh0T2NjdXJyZW5jZShzdGF0ZSwgcXVlcnkpIHtcbiAgICBsZXQgeyBtYWluLCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBsZXQgd29yZCA9IHN0YXRlLndvcmRBdChtYWluLmhlYWQpLCBmdWxsV29yZCA9IHdvcmQgJiYgd29yZC5mcm9tID09IG1haW4uZnJvbSAmJiB3b3JkLnRvID09IG1haW4udG87XG4gICAgZm9yIChsZXQgY3ljbGVkID0gZmFsc2UsIGN1cnNvciA9IG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBxdWVyeSwgcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50byk7Oykge1xuICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChjeWNsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjdXJzb3IgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgcXVlcnksIDAsIE1hdGgubWF4KDAsIHJhbmdlc1tyYW5nZXMubGVuZ3RoIC0gMV0uZnJvbSAtIDEpKTtcbiAgICAgICAgICAgIGN5Y2xlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3ljbGVkICYmIHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGN1cnNvci52YWx1ZS5mcm9tKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChmdWxsV29yZCkge1xuICAgICAgICAgICAgICAgIGxldCB3b3JkID0gc3RhdGUud29yZEF0KGN1cnNvci52YWx1ZS5mcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmQgfHwgd29yZC5mcm9tICE9IGN1cnNvci52YWx1ZS5mcm9tIHx8IHdvcmQudG8gIT0gY3Vyc29yLnZhbHVlLnRvKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcblNlbGVjdCBuZXh0IG9jY3VycmVuY2Ugb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLiBFeHBhbmQgc2VsZWN0aW9uXG50byB0aGUgc3Vycm91bmRpbmcgd29yZCB3aGVuIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkuXG4qL1xuY29uc3Qgc2VsZWN0TmV4dE9jY3VycmVuY2UgPSAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCB7IHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChyYW5nZXMuc29tZShzZWwgPT4gc2VsLmZyb20gPT09IHNlbC50bykpXG4gICAgICAgIHJldHVybiBzZWxlY3RXb3JkKHsgc3RhdGUsIGRpc3BhdGNoIH0pO1xuICAgIGxldCBzZWFyY2hlZFRleHQgPSBzdGF0ZS5zbGljZURvYyhyYW5nZXNbMF0uZnJvbSwgcmFuZ2VzWzBdLnRvKTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gc3RhdGUuc2xpY2VEb2Moci5mcm9tLCByLnRvKSAhPSBzZWFyY2hlZFRleHQpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHJhbmdlID0gZmluZE5leHRPY2N1cnJlbmNlKHN0YXRlLCBzZWFyY2hlZFRleHQpO1xuICAgIGlmICghcmFuZ2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IHN0YXRlLnNlbGVjdGlvbi5hZGRSYW5nZShFZGl0b3JTZWxlY3Rpb24ucmFuZ2UocmFuZ2UuZnJvbSwgcmFuZ2UudG8pLCBmYWxzZSksXG4gICAgICAgIGVmZmVjdHM6IEVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcocmFuZ2UudG8pXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2VhcmNoQ29uZmlnRmFjZXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKGNvbmZpZ3MpIHtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVDb25maWcoY29uZmlncywge1xuICAgICAgICAgICAgdG9wOiBmYWxzZSxcbiAgICAgICAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbGl0ZXJhbDogZmFsc2UsXG4gICAgICAgICAgICB3aG9sZVdvcmQ6IGZhbHNlLFxuICAgICAgICAgICAgY3JlYXRlUGFuZWw6IHZpZXcgPT4gbmV3IFNlYXJjaFBhbmVsKHZpZXcpLFxuICAgICAgICAgICAgc2Nyb2xsVG9NYXRjaDogcmFuZ2UgPT4gRWRpdG9yVmlldy5zY3JvbGxJbnRvVmlldyhyYW5nZSlcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG4vKipcbkFkZCBzZWFyY2ggc3RhdGUgdG8gdGhlIGVkaXRvciBjb25maWd1cmF0aW9uLCBhbmQgb3B0aW9uYWxseVxuY29uZmlndXJlIHRoZSBzZWFyY2ggZXh0ZW5zaW9uLlxuKFtgb3BlblNlYXJjaFBhbmVsYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2gub3BlblNlYXJjaFBhbmVsKSB3aWxsIGF1dG9tYXRpY2FsbHlcbmVuYWJsZSB0aGlzIGlmIGl0IGlzbid0IGFscmVhZHkgb24pLlxuKi9cbmZ1bmN0aW9uIHNlYXJjaChjb25maWcpIHtcbiAgICByZXR1cm4gY29uZmlnID8gW3NlYXJjaENvbmZpZ0ZhY2V0Lm9mKGNvbmZpZyksIHNlYXJjaEV4dGVuc2lvbnNdIDogc2VhcmNoRXh0ZW5zaW9ucztcbn1cbi8qKlxuQSBzZWFyY2ggcXVlcnkuIFBhcnQgb2YgdGhlIGVkaXRvcidzIHNlYXJjaCBzdGF0ZS5cbiovXG5jbGFzcyBTZWFyY2hRdWVyeSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcXVlcnkgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gY29uZmlnLnNlYXJjaDtcbiAgICAgICAgdGhpcy5jYXNlU2Vuc2l0aXZlID0gISFjb25maWcuY2FzZVNlbnNpdGl2ZTtcbiAgICAgICAgdGhpcy5saXRlcmFsID0gISFjb25maWcubGl0ZXJhbDtcbiAgICAgICAgdGhpcy5yZWdleHAgPSAhIWNvbmZpZy5yZWdleHA7XG4gICAgICAgIHRoaXMucmVwbGFjZSA9IGNvbmZpZy5yZXBsYWNlIHx8IFwiXCI7XG4gICAgICAgIHRoaXMudmFsaWQgPSAhIXRoaXMuc2VhcmNoICYmICghdGhpcy5yZWdleHAgfHwgdmFsaWRSZWdFeHAodGhpcy5zZWFyY2gpKTtcbiAgICAgICAgdGhpcy51bnF1b3RlZCA9IHRoaXMudW5xdW90ZSh0aGlzLnNlYXJjaCk7XG4gICAgICAgIHRoaXMud2hvbGVXb3JkID0gISFjb25maWcud2hvbGVXb3JkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVucXVvdGUodGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXRlcmFsID8gdGV4dCA6XG4gICAgICAgICAgICB0ZXh0LnJlcGxhY2UoL1xcXFwoW25ydFxcXFxdKS9nLCAoXywgY2gpID0+IGNoID09IFwiblwiID8gXCJcXG5cIiA6IGNoID09IFwiclwiID8gXCJcXHJcIiA6IGNoID09IFwidFwiID8gXCJcXHRcIiA6IFwiXFxcXFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIHF1ZXJ5IHRvIGFub3RoZXIgcXVlcnkuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2ggPT0gb3RoZXIuc2VhcmNoICYmIHRoaXMucmVwbGFjZSA9PSBvdGhlci5yZXBsYWNlICYmXG4gICAgICAgICAgICB0aGlzLmNhc2VTZW5zaXRpdmUgPT0gb3RoZXIuY2FzZVNlbnNpdGl2ZSAmJiB0aGlzLnJlZ2V4cCA9PSBvdGhlci5yZWdleHAgJiZcbiAgICAgICAgICAgIHRoaXMud2hvbGVXb3JkID09IG90aGVyLndob2xlV29yZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cCA/IG5ldyBSZWdFeHBRdWVyeSh0aGlzKSA6IG5ldyBTdHJpbmdRdWVyeSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgc2VhcmNoIGN1cnNvciBmb3IgdGhpcyBxdWVyeSwgc2VhcmNoaW5nIHRocm91Z2ggdGhlIGdpdmVuXG4gICAgcmFuZ2UgaW4gdGhlIGdpdmVuIHN0YXRlLlxuICAgICovXG4gICAgZ2V0Q3Vyc29yKHN0YXRlLCBmcm9tID0gMCwgdG8pIHtcbiAgICAgICAgbGV0IHN0ID0gc3RhdGUuZG9jID8gc3RhdGUgOiBFZGl0b3JTdGF0ZS5jcmVhdGUoeyBkb2M6IHN0YXRlIH0pO1xuICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgIHRvID0gc3QuZG9jLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnZXhwID8gcmVnZXhwQ3Vyc29yKHRoaXMsIHN0LCBmcm9tLCB0bykgOiBzdHJpbmdDdXJzb3IodGhpcywgc3QsIGZyb20sIHRvKTtcbiAgICB9XG59XG5jbGFzcyBRdWVyeVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICB9XG59XG5mdW5jdGlvbiBzdHJpbmdDdXJzb3Ioc3BlYywgc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hDdXJzb3Ioc3RhdGUuZG9jLCBzcGVjLnVucXVvdGVkLCBmcm9tLCB0bywgc3BlYy5jYXNlU2Vuc2l0aXZlID8gdW5kZWZpbmVkIDogeCA9PiB4LnRvTG93ZXJDYXNlKCksIHNwZWMud2hvbGVXb3JkID8gc3RyaW5nV29yZFRlc3Qoc3RhdGUuZG9jLCBzdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZCkpIDogdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1dvcmRUZXN0KGRvYywgY2F0ZWdvcml6ZXIpIHtcbiAgICByZXR1cm4gKGZyb20sIHRvLCBidWYsIGJ1ZlBvcykgPT4ge1xuICAgICAgICBpZiAoYnVmUG9zID4gZnJvbSB8fCBidWZQb3MgKyBidWYubGVuZ3RoIDwgdG8pIHtcbiAgICAgICAgICAgIGJ1ZlBvcyA9IE1hdGgubWF4KDAsIGZyb20gLSAyKTtcbiAgICAgICAgICAgIGJ1ZiA9IGRvYy5zbGljZVN0cmluZyhidWZQb3MsIE1hdGgubWluKGRvYy5sZW5ndGgsIHRvICsgMikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoY2F0ZWdvcml6ZXIoY2hhckJlZm9yZShidWYsIGZyb20gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCB8fFxuICAgICAgICAgICAgY2F0ZWdvcml6ZXIoY2hhckFmdGVyKGJ1ZiwgZnJvbSAtIGJ1ZlBvcykpICE9IENoYXJDYXRlZ29yeS5Xb3JkKSAmJlxuICAgICAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJBZnRlcihidWYsIHRvIC0gYnVmUG9zKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQmVmb3JlKGJ1ZiwgdG8gLSBidWZQb3MpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCk7XG4gICAgfTtcbn1cbmNsYXNzIFN0cmluZ1F1ZXJ5IGV4dGVuZHMgUXVlcnlUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKHNwZWMpO1xuICAgIH1cbiAgICBuZXh0TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpLm5leHRPdmVybGFwcGluZygpO1xuICAgICAgICBpZiAoY3Vyc29yLmRvbmUpXG4gICAgICAgICAgICBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgY3VyRnJvbSkubmV4dE92ZXJsYXBwaW5nKCk7XG4gICAgICAgIHJldHVybiBjdXJzb3IuZG9uZSA/IG51bGwgOiBjdXJzb3IudmFsdWU7XG4gICAgfVxuICAgIC8vIFNlYXJjaGluZyBpbiByZXZlcnNlIGlzLCByYXRoZXIgdGhhbiBpbXBsZW1lbnRpbmcgaW52ZXJ0ZWQgc2VhcmNoXG4gICAgLy8gY3Vyc29yLCBkb25lIGJ5IHNjYW5uaW5nIGNodW5rIGFmdGVyIGNodW5rIGZvcndhcmQuXG4gICAgcHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdG87Oykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgoZnJvbSwgcG9zIC0gMTAwMDAgLyogRmluZFByZXYuQ2h1bmtTaXplICovIC0gdGhpcy5zcGVjLnVucXVvdGVkLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIHN0YXJ0LCBwb3MpLCByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0T3ZlcmxhcHBpbmcoKS5kb25lKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIGlmIChzdGFydCA9PSBmcm9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcG9zIC09IDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIDAsIGN1ckZyb20pIHx8XG4gICAgICAgICAgICB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0UmVwbGFjZW1lbnQoX3Jlc3VsdCkgeyByZXR1cm4gdGhpcy5zcGVjLnVucXVvdGUodGhpcy5zcGVjLnJlcGxhY2UpOyB9XG4gICAgbWF0Y2hBbGwoc3RhdGUsIGxpbWl0KSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSBzdHJpbmdDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgMCwgc3RhdGUuZG9jLmxlbmd0aCksIHJhbmdlcyA9IFtdO1xuICAgICAgICB3aGlsZSAoIWN1cnNvci5uZXh0KCkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gbGltaXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByYW5nZXMucHVzaChjdXJzb3IudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYW5nZXM7XG4gICAgfVxuICAgIGhpZ2hsaWdodChzdGF0ZSwgZnJvbSwgdG8sIGFkZCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gc3RyaW5nQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIE1hdGgubWF4KDAsIGZyb20gLSB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoKSwgTWF0aC5taW4odG8gKyB0aGlzLnNwZWMudW5xdW90ZWQubGVuZ3RoLCBzdGF0ZS5kb2MubGVuZ3RoKSk7XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgYWRkKGN1cnNvci52YWx1ZS5mcm9tLCBjdXJzb3IudmFsdWUudG8pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZ2V4cEN1cnNvcihzcGVjLCBzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cEN1cnNvcihzdGF0ZS5kb2MsIHNwZWMuc2VhcmNoLCB7XG4gICAgICAgIGlnbm9yZUNhc2U6ICFzcGVjLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgIHRlc3Q6IHNwZWMud2hvbGVXb3JkID8gcmVnZXhwV29yZFRlc3Qoc3RhdGUuY2hhckNhdGVnb3JpemVyKHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKSA6IHVuZGVmaW5lZFxuICAgIH0sIGZyb20sIHRvKTtcbn1cbmZ1bmN0aW9uIGNoYXJCZWZvcmUoc3RyLCBpbmRleCkge1xuICAgIHJldHVybiBzdHIuc2xpY2UoZmluZENsdXN0ZXJCcmVhayhzdHIsIGluZGV4LCBmYWxzZSksIGluZGV4KTtcbn1cbmZ1bmN0aW9uIGNoYXJBZnRlcihzdHIsIGluZGV4KSB7XG4gICAgcmV0dXJuIHN0ci5zbGljZShpbmRleCwgZmluZENsdXN0ZXJCcmVhayhzdHIsIGluZGV4KSk7XG59XG5mdW5jdGlvbiByZWdleHBXb3JkVGVzdChjYXRlZ29yaXplcikge1xuICAgIHJldHVybiAoX2Zyb20sIF90bywgbWF0Y2gpID0+ICFtYXRjaFswXS5sZW5ndGggfHxcbiAgICAgICAgKGNhdGVnb3JpemVyKGNoYXJCZWZvcmUobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4KSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgIGNhdGVnb3JpemVyKGNoYXJBZnRlcihtYXRjaC5pbnB1dCwgbWF0Y2guaW5kZXgpKSAhPSBDaGFyQ2F0ZWdvcnkuV29yZCkgJiZcbiAgICAgICAgICAgIChjYXRlZ29yaXplcihjaGFyQWZ0ZXIobWF0Y2guaW5wdXQsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSkgIT0gQ2hhckNhdGVnb3J5LldvcmQgfHxcbiAgICAgICAgICAgICAgICBjYXRlZ29yaXplcihjaGFyQmVmb3JlKG1hdGNoLmlucHV0LCBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCkpICE9IENoYXJDYXRlZ29yeS5Xb3JkKTtcbn1cbmNsYXNzIFJlZ0V4cFF1ZXJ5IGV4dGVuZHMgUXVlcnlUeXBlIHtcbiAgICBuZXh0TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIGxldCBjdXJzb3IgPSByZWdleHBDdXJzb3IodGhpcy5zcGVjLCBzdGF0ZSwgY3VyVG8sIHN0YXRlLmRvYy5sZW5ndGgpLm5leHQoKTtcbiAgICAgICAgaWYgKGN1cnNvci5kb25lKVxuICAgICAgICAgICAgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIGN1ckZyb20pLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIGN1cnNvci5kb25lID8gbnVsbCA6IGN1cnNvci52YWx1ZTtcbiAgICB9XG4gICAgcHJldk1hdGNoSW5SYW5nZShzdGF0ZSwgZnJvbSwgdG8pIHtcbiAgICAgICAgZm9yIChsZXQgc2l6ZSA9IDE7OyBzaXplKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IE1hdGgubWF4KGZyb20sIHRvIC0gc2l6ZSAqIDEwMDAwIC8qIEZpbmRQcmV2LkNodW5rU2l6ZSAqLyk7XG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIHN0YXJ0LCB0byksIHJhbmdlID0gbnVsbDtcbiAgICAgICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgICAgIHJhbmdlID0gY3Vyc29yLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHJhbmdlICYmIChzdGFydCA9PSBmcm9tIHx8IHJhbmdlLmZyb20gPiBzdGFydCArIDEwKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT0gZnJvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcmV2TWF0Y2goc3RhdGUsIGN1ckZyb20sIGN1clRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIDAsIGN1ckZyb20pIHx8XG4gICAgICAgICAgICB0aGlzLnByZXZNYXRjaEluUmFuZ2Uoc3RhdGUsIGN1clRvLCBzdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0UmVwbGFjZW1lbnQocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMudW5xdW90ZSh0aGlzLnNwZWMucmVwbGFjZS5yZXBsYWNlKC9cXCQoWyQmXFxkK10pL2csIChtLCBpKSA9PiBpID09IFwiJFwiID8gXCIkXCJcbiAgICAgICAgICAgIDogaSA9PSBcIiZcIiA/IHJlc3VsdC5tYXRjaFswXVxuICAgICAgICAgICAgICAgIDogaSAhPSBcIjBcIiAmJiAraSA8IHJlc3VsdC5tYXRjaC5sZW5ndGggPyByZXN1bHQubWF0Y2hbaV1cbiAgICAgICAgICAgICAgICAgICAgOiBtKSk7XG4gICAgfVxuICAgIG1hdGNoQWxsKHN0YXRlLCBsaW1pdCkge1xuICAgICAgICBsZXQgY3Vyc29yID0gcmVnZXhwQ3Vyc29yKHRoaXMuc3BlYywgc3RhdGUsIDAsIHN0YXRlLmRvYy5sZW5ndGgpLCByYW5nZXMgPSBbXTtcbiAgICAgICAgd2hpbGUgKCFjdXJzb3IubmV4dCgpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoID49IGxpbWl0KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goY3Vyc29yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH1cbiAgICBoaWdobGlnaHQoc3RhdGUsIGZyb20sIHRvLCBhZGQpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHJlZ2V4cEN1cnNvcih0aGlzLnNwZWMsIHN0YXRlLCBNYXRoLm1heCgwLCBmcm9tIC0gMjUwIC8qIFJlZ0V4cC5IaWdobGlnaHRNYXJnaW4gKi8pLCBNYXRoLm1pbih0byArIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovLCBzdGF0ZS5kb2MubGVuZ3RoKSk7XG4gICAgICAgIHdoaWxlICghY3Vyc29yLm5leHQoKS5kb25lKVxuICAgICAgICAgICAgYWRkKGN1cnNvci52YWx1ZS5mcm9tLCBjdXJzb3IudmFsdWUudG8pO1xuICAgIH1cbn1cbi8qKlxuQSBzdGF0ZSBlZmZlY3QgdGhhdCB1cGRhdGVzIHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeS4gTm90ZSB0aGF0XG50aGlzIG9ubHkgaGFzIGFuIGVmZmVjdCBpZiB0aGUgc2VhcmNoIHN0YXRlIGhhcyBiZWVuIGluaXRpYWxpemVkXG4oYnkgaW5jbHVkaW5nIFtgc2VhcmNoYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guc2VhcmNoKSBpbiB5b3VyIGNvbmZpZ3VyYXRpb24gb3JcbmJ5IHJ1bm5pbmcgW2BvcGVuU2VhcmNoUGFuZWxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3NlYXJjaC5vcGVuU2VhcmNoUGFuZWwpIGF0IGxlYXN0XG5vbmNlKS5cbiovXG5jb25zdCBzZXRTZWFyY2hRdWVyeSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoKTtcbmNvbnN0IHRvZ2dsZVBhbmVsID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSgpO1xuY29uc3Qgc2VhcmNoU3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVGaWVsZC5kZWZpbmUoe1xuICAgIGNyZWF0ZShzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlYXJjaFN0YXRlKGRlZmF1bHRRdWVyeShzdGF0ZSkuY3JlYXRlKCksIG51bGwpO1xuICAgIH0sXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGVmZmVjdC5pcyhzZXRTZWFyY2hRdWVyeSkpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgU2VhcmNoU3RhdGUoZWZmZWN0LnZhbHVlLmNyZWF0ZSgpLCB2YWx1ZS5wYW5lbCk7XG4gICAgICAgICAgICBlbHNlIGlmIChlZmZlY3QuaXModG9nZ2xlUGFuZWwpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gbmV3IFNlYXJjaFN0YXRlKHZhbHVlLnF1ZXJ5LCBlZmZlY3QudmFsdWUgPyBjcmVhdGVTZWFyY2hQYW5lbCA6IG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIHByb3ZpZGU6IGYgPT4gc2hvd1BhbmVsLmZyb20oZiwgdmFsID0+IHZhbC5wYW5lbClcbn0pO1xuLyoqXG5HZXQgdGhlIGN1cnJlbnQgc2VhcmNoIHF1ZXJ5IGZyb20gYW4gZWRpdG9yIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIGdldFNlYXJjaFF1ZXJ5KHN0YXRlKSB7XG4gICAgbGV0IGN1clN0YXRlID0gc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gY3VyU3RhdGUgPyBjdXJTdGF0ZS5xdWVyeS5zcGVjIDogZGVmYXVsdFF1ZXJ5KHN0YXRlKTtcbn1cbi8qKlxuUXVlcnkgd2hldGhlciB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gaW4gdGhlIGdpdmVuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiBzZWFyY2hQYW5lbE9wZW4oc3RhdGUpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSBzdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFuZWwpICE9IG51bGw7XG59XG5jbGFzcyBTZWFyY2hTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IocXVlcnksIHBhbmVsKSB7XG4gICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgdGhpcy5wYW5lbCA9IHBhbmVsO1xuICAgIH1cbn1cbmNvbnN0IG1hdGNoTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWFyY2hNYXRjaFwiIH0pLCBzZWxlY3RlZE1hdGNoTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1zZWFyY2hNYXRjaCBjbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiIH0pO1xuY29uc3Qgc2VhcmNoSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcpIHtcbiAgICAgICAgdGhpcy52aWV3ID0gdmlldztcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuaGlnaGxpZ2h0KHZpZXcuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpKTtcbiAgICB9XG4gICAgdXBkYXRlKHVwZGF0ZSkge1xuICAgICAgICBsZXQgc3RhdGUgPSB1cGRhdGUuc3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpO1xuICAgICAgICBpZiAoc3RhdGUgIT0gdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoc2VhcmNoU3RhdGUpIHx8IHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS5zZWxlY3Rpb25TZXQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmhpZ2hsaWdodChzdGF0ZSk7XG4gICAgfVxuICAgIGhpZ2hsaWdodCh7IHF1ZXJ5LCBwYW5lbCB9KSB7XG4gICAgICAgIGlmICghcGFuZWwgfHwgIXF1ZXJ5LnNwZWMudmFsaWQpXG4gICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgICAgICBsZXQgeyB2aWV3IH0gPSB0aGlzO1xuICAgICAgICBsZXQgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXIoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHJhbmdlcyA9IHZpZXcudmlzaWJsZVJhbmdlcywgbCA9IHJhbmdlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICB3aGlsZSAoaSA8IGwgLSAxICYmIHRvID4gcmFuZ2VzW2kgKyAxXS5mcm9tIC0gMiAqIDI1MCAvKiBSZWdFeHAuSGlnaGxpZ2h0TWFyZ2luICovKVxuICAgICAgICAgICAgICAgIHRvID0gcmFuZ2VzWysraV0udG87XG4gICAgICAgICAgICBxdWVyeS5oaWdobGlnaHQodmlldy5zdGF0ZSwgZnJvbSwgdG8sIChmcm9tLCB0bykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcy5zb21lKHIgPT4gci5mcm9tID09IGZyb20gJiYgci50byA9PSB0byk7XG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoZnJvbSwgdG8sIHNlbGVjdGVkID8gc2VsZWN0ZWRNYXRjaE1hcmsgOiBtYXRjaE1hcmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkZXIuZmluaXNoKCk7XG4gICAgfVxufSwge1xuICAgIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pO1xuZnVuY3Rpb24gc2VhcmNoQ29tbWFuZChmKSB7XG4gICAgcmV0dXJuIHZpZXcgPT4ge1xuICAgICAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZSAmJiBzdGF0ZS5xdWVyeS5zcGVjLnZhbGlkID8gZih2aWV3LCBzdGF0ZSkgOiBvcGVuU2VhcmNoUGFuZWwodmlldyk7XG4gICAgfTtcbn1cbi8qKlxuT3BlbiB0aGUgc2VhcmNoIHBhbmVsIGlmIGl0IGlzbid0IGFscmVhZHkgb3BlbiwgYW5kIG1vdmUgdGhlXG5zZWxlY3Rpb24gdG8gdGhlIGZpcnN0IG1hdGNoIGFmdGVyIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLlxuV2lsbCB3cmFwIGFyb3VuZCB0byB0aGUgc3RhcnQgb2YgdGhlIGRvY3VtZW50IHdoZW4gaXQgcmVhY2hlcyB0aGVcbmVuZC5cbiovXG5jb25zdCBmaW5kTmV4dCA9IC8qQF9fUFVSRV9fKi9zZWFyY2hDb21tYW5kKCh2aWV3LCB7IHF1ZXJ5IH0pID0+IHtcbiAgICBsZXQgeyB0byB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBsZXQgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaCh2aWV3LnN0YXRlLCB0bywgdG8pO1xuICAgIGlmICghbmV4dClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKG5leHQuZnJvbSwgbmV4dC50byk7XG4gICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGVmZmVjdHM6IFthbm5vdW5jZU1hdGNoKHZpZXcsIG5leHQpLCBjb25maWcuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbildLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBwcmV2aW91cyBpbnN0YW5jZSBvZiB0aGUgc2VhcmNoIHF1ZXJ5LFxuYmVmb3JlIHRoZSBjdXJyZW50IG1haW4gc2VsZWN0aW9uLiBXaWxsIHdyYXAgcGFzdCB0aGUgc3RhcnRcbm9mIHRoZSBkb2N1bWVudCB0byBzdGFydCBzZWFyY2hpbmcgYXQgdGhlIGVuZCBhZ2Fpbi5cbiovXG5jb25zdCBmaW5kUHJldmlvdXMgPSAvKkBfX1BVUkVfXyovc2VhcmNoQ29tbWFuZCgodmlldywgeyBxdWVyeSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIHsgZnJvbSB9ID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHByZXYgPSBxdWVyeS5wcmV2TWF0Y2goc3RhdGUsIGZyb20sIGZyb20pO1xuICAgIGlmICghcHJldilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBzZWxlY3Rpb24gPSBFZGl0b3JTZWxlY3Rpb24uc2luZ2xlKHByZXYuZnJvbSwgcHJldi50byk7XG4gICAgbGV0IGNvbmZpZyA9IHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIGVmZmVjdHM6IFthbm5vdW5jZU1hdGNoKHZpZXcsIHByZXYpLCBjb25maWcuc2Nyb2xsVG9NYXRjaChzZWxlY3Rpb24ubWFpbildLFxuICAgICAgICB1c2VyRXZlbnQ6IFwic2VsZWN0LnNlYXJjaFwiXG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59KTtcbi8qKlxuU2VsZWN0IGFsbCBpbnN0YW5jZXMgb2YgdGhlIHNlYXJjaCBxdWVyeS5cbiovXG5jb25zdCBzZWxlY3RNYXRjaGVzID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCByYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxMDAwKTtcbiAgICBpZiAoIXJhbmdlcyB8fCAhcmFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHZpZXcuZGlzcGF0Y2goe1xuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLm1hcChyID0+IEVkaXRvclNlbGVjdGlvbi5yYW5nZShyLmZyb20sIHIudG8pKSksXG4gICAgICAgIHVzZXJFdmVudDogXCJzZWxlY3Quc2VhcmNoLm1hdGNoZXNcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblNlbGVjdCBhbGwgaW5zdGFuY2VzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dC5cbiovXG5jb25zdCBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwucmFuZ2VzLmxlbmd0aCA+IDEgfHwgc2VsLm1haW4uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBmcm9tLCB0byB9ID0gc2VsLm1haW47XG4gICAgbGV0IHJhbmdlcyA9IFtdLCBtYWluID0gMDtcbiAgICBmb3IgKGxldCBjdXIgPSBuZXcgU2VhcmNoQ3Vyc29yKHN0YXRlLmRvYywgc3RhdGUuc2xpY2VEb2MoZnJvbSwgdG8pKTsgIWN1ci5uZXh0KCkuZG9uZTspIHtcbiAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPiAxMDAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoY3VyLnZhbHVlLmZyb20gPT0gZnJvbSlcbiAgICAgICAgICAgIG1haW4gPSByYW5nZXMubGVuZ3RoO1xuICAgICAgICByYW5nZXMucHVzaChFZGl0b3JTZWxlY3Rpb24ucmFuZ2UoY3VyLnZhbHVlLmZyb20sIGN1ci52YWx1ZS50bykpO1xuICAgIH1cbiAgICBkaXNwYXRjaChzdGF0ZS51cGRhdGUoe1xuICAgICAgICBzZWxlY3Rpb246IEVkaXRvclNlbGVjdGlvbi5jcmVhdGUocmFuZ2VzLCBtYWluKSxcbiAgICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5zZWFyY2gubWF0Y2hlc1wiXG4gICAgfSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuUmVwbGFjZSB0aGUgY3VycmVudCBtYXRjaCBvZiB0aGUgc2VhcmNoIHF1ZXJ5LlxuKi9cbmNvbnN0IHJlcGxhY2VOZXh0ID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICBpZiAoc3RhdGUucmVhZE9ubHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgZnJvbSwgZnJvbSk7XG4gICAgaWYgKCFuZXh0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBbXSwgc2VsZWN0aW9uLCByZXBsYWNlbWVudDtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGlmIChuZXh0LmZyb20gPT0gZnJvbSAmJiBuZXh0LnRvID09IHRvKSB7XG4gICAgICAgIHJlcGxhY2VtZW50ID0gc3RhdGUudG9UZXh0KHF1ZXJ5LmdldFJlcGxhY2VtZW50KG5leHQpKTtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbmV4dC5mcm9tLCB0bzogbmV4dC50bywgaW5zZXJ0OiByZXBsYWNlbWVudCB9KTtcbiAgICAgICAgbmV4dCA9IHF1ZXJ5Lm5leHRNYXRjaChzdGF0ZSwgbmV4dC5mcm9tLCBuZXh0LnRvKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKEVkaXRvclZpZXcuYW5ub3VuY2Uub2Yoc3RhdGUucGhyYXNlKFwicmVwbGFjZWQgbWF0Y2ggb24gbGluZSAkXCIsIHN0YXRlLmRvYy5saW5lQXQoZnJvbSkubnVtYmVyKSArIFwiLlwiKSk7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICAgIGxldCBvZmYgPSBjaGFuZ2VzLmxlbmd0aCA9PSAwIHx8IGNoYW5nZXNbMF0uZnJvbSA+PSBuZXh0LnRvID8gMCA6IG5leHQudG8gLSBuZXh0LmZyb20gLSByZXBsYWNlbWVudC5sZW5ndGg7XG4gICAgICAgIHNlbGVjdGlvbiA9IEVkaXRvclNlbGVjdGlvbi5zaW5nbGUobmV4dC5mcm9tIC0gb2ZmLCBuZXh0LnRvIC0gb2ZmKTtcbiAgICAgICAgZWZmZWN0cy5wdXNoKGFubm91bmNlTWF0Y2godmlldywgbmV4dCkpO1xuICAgICAgICBlZmZlY3RzLnB1c2goc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLnNjcm9sbFRvTWF0Y2goc2VsZWN0aW9uLm1haW4pKTtcbiAgICB9XG4gICAgdmlldy5kaXNwYXRjaCh7XG4gICAgICAgIGNoYW5nZXMsIHNlbGVjdGlvbiwgZWZmZWN0cyxcbiAgICAgICAgdXNlckV2ZW50OiBcImlucHV0LnJlcGxhY2VcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG4vKipcblJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2VhcmNoIHF1ZXJ5IHdpdGggdGhlIGdpdmVuXG5yZXBsYWNlbWVudC5cbiovXG5jb25zdCByZXBsYWNlQWxsID0gLypAX19QVVJFX18qL3NlYXJjaENvbW1hbmQoKHZpZXcsIHsgcXVlcnkgfSkgPT4ge1xuICAgIGlmICh2aWV3LnN0YXRlLnJlYWRPbmx5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGNoYW5nZXMgPSBxdWVyeS5tYXRjaEFsbCh2aWV3LnN0YXRlLCAxZTkpLm1hcChtYXRjaCA9PiB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBtYXRjaDtcbiAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8sIGluc2VydDogcXVlcnkuZ2V0UmVwbGFjZW1lbnQobWF0Y2gpIH07XG4gICAgfSk7XG4gICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhbm5vdW5jZVRleHQgPSB2aWV3LnN0YXRlLnBocmFzZShcInJlcGxhY2VkICQgbWF0Y2hlc1wiLCBjaGFuZ2VzLmxlbmd0aCkgKyBcIi5cIjtcbiAgICB2aWV3LmRpc3BhdGNoKHtcbiAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgZWZmZWN0czogRWRpdG9yVmlldy5hbm5vdW5jZS5vZihhbm5vdW5jZVRleHQpLFxuICAgICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucmVwbGFjZS5hbGxcIlxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVTZWFyY2hQYW5lbCh2aWV3KSB7XG4gICAgcmV0dXJuIHZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLmNyZWF0ZVBhbmVsKHZpZXcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFF1ZXJ5KHN0YXRlLCBmYWxsYmFjaykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgbGV0IHNlbFRleHQgPSBzZWwuZW1wdHkgfHwgc2VsLnRvID4gc2VsLmZyb20gKyAxMDAgPyBcIlwiIDogc3RhdGUuc2xpY2VEb2Moc2VsLmZyb20sIHNlbC50byk7XG4gICAgaWYgKGZhbGxiYWNrICYmICFzZWxUZXh0KVxuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgbGV0IGNvbmZpZyA9IHN0YXRlLmZhY2V0KHNlYXJjaENvbmZpZ0ZhY2V0KTtcbiAgICByZXR1cm4gbmV3IFNlYXJjaFF1ZXJ5KHtcbiAgICAgICAgc2VhcmNoOiAoKF9hID0gZmFsbGJhY2sgPT09IG51bGwgfHwgZmFsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZhbGxiYWNrLmxpdGVyYWwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZy5saXRlcmFsKSA/IHNlbFRleHQgOiBzZWxUZXh0LnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLFxuICAgICAgICBjYXNlU2Vuc2l0aXZlOiAoX2IgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2suY2FzZVNlbnNpdGl2ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY29uZmlnLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgIGxpdGVyYWw6IChfYyA9IGZhbGxiYWNrID09PSBudWxsIHx8IGZhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYWxsYmFjay5saXRlcmFsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb25maWcubGl0ZXJhbCxcbiAgICAgICAgd2hvbGVXb3JkOiAoX2QgPSBmYWxsYmFjayA9PT0gbnVsbCB8fCBmYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmFsbGJhY2sud2hvbGVXb3JkKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBjb25maWcud2hvbGVXb3JkXG4gICAgfSk7XG59XG4vKipcbk1ha2Ugc3VyZSB0aGUgc2VhcmNoIHBhbmVsIGlzIG9wZW4gYW5kIGZvY3VzZWQuXG4qL1xuY29uc3Qgb3BlblNlYXJjaFBhbmVsID0gdmlldyA9PiB7XG4gICAgbGV0IHN0YXRlID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSwgZmFsc2UpO1xuICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5wYW5lbCkge1xuICAgICAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgICAgIGlmICghcGFuZWwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzZWFyY2hJbnB1dCA9IHBhbmVsLmRvbS5xdWVyeVNlbGVjdG9yKFwiW21haW4tZmllbGRdXCIpO1xuICAgICAgICBpZiAoc2VhcmNoSW5wdXQgJiYgc2VhcmNoSW5wdXQgIT0gdmlldy5yb290LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBxdWVyeSA9IGRlZmF1bHRRdWVyeSh2aWV3LnN0YXRlLCBzdGF0ZS5xdWVyeS5zcGVjKTtcbiAgICAgICAgICAgIGlmIChxdWVyeS52YWxpZClcbiAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogc2V0U2VhcmNoUXVlcnkub2YocXVlcnkpIH0pO1xuICAgICAgICAgICAgc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgIHNlYXJjaElucHV0LnNlbGVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogW1xuICAgICAgICAgICAgICAgIHRvZ2dsZVBhbmVsLm9mKHRydWUpLFxuICAgICAgICAgICAgICAgIHN0YXRlID8gc2V0U2VhcmNoUXVlcnkub2YoZGVmYXVsdFF1ZXJ5KHZpZXcuc3RhdGUsIHN0YXRlLnF1ZXJ5LnNwZWMpKSA6IFN0YXRlRWZmZWN0LmFwcGVuZENvbmZpZy5vZihzZWFyY2hFeHRlbnNpb25zKVxuICAgICAgICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5DbG9zZSB0aGUgc2VhcmNoIHBhbmVsLlxuKi9cbmNvbnN0IGNsb3NlU2VhcmNoUGFuZWwgPSB2aWV3ID0+IHtcbiAgICBsZXQgc3RhdGUgPSB2aWV3LnN0YXRlLmZpZWxkKHNlYXJjaFN0YXRlLCBmYWxzZSk7XG4gICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUucGFuZWwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgcGFuZWwgPSBnZXRQYW5lbCh2aWV3LCBjcmVhdGVTZWFyY2hQYW5lbCk7XG4gICAgaWYgKHBhbmVsICYmIHBhbmVsLmRvbS5jb250YWlucyh2aWV3LnJvb3QuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdG9nZ2xlUGFuZWwub2YoZmFsc2UpIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuRGVmYXVsdCBzZWFyY2gtcmVsYXRlZCBrZXkgYmluZGluZ3MuXG5cbiAtIE1vZC1mOiBbYG9wZW5TZWFyY2hQYW5lbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLm9wZW5TZWFyY2hQYW5lbClcbiAtIEYzLCBNb2QtZzogW2BmaW5kTmV4dGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmROZXh0KVxuIC0gU2hpZnQtRjMsIFNoaWZ0LU1vZC1nOiBbYGZpbmRQcmV2aW91c2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLmZpbmRQcmV2aW91cylcbiAtIEFsdC1nOiBbYGdvdG9MaW5lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzZWFyY2guZ290b0xpbmUpXG4gLSBNb2QtZDogW2BzZWxlY3ROZXh0T2NjdXJyZW5jZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc2VhcmNoLnNlbGVjdE5leHRPY2N1cnJlbmNlKVxuKi9cbmNvbnN0IHNlYXJjaEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJNb2QtZlwiLCBydW46IG9wZW5TZWFyY2hQYW5lbCwgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiIH0sXG4gICAgeyBrZXk6IFwiRjNcIiwgcnVuOiBmaW5kTmV4dCwgc2hpZnQ6IGZpbmRQcmV2aW91cywgc2NvcGU6IFwiZWRpdG9yIHNlYXJjaC1wYW5lbFwiLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICAgIHsga2V5OiBcIk1vZC1nXCIsIHJ1bjogZmluZE5leHQsIHNoaWZ0OiBmaW5kUHJldmlvdXMsIHNjb3BlOiBcImVkaXRvciBzZWFyY2gtcGFuZWxcIiwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBjbG9zZVNlYXJjaFBhbmVsLCBzY29wZTogXCJlZGl0b3Igc2VhcmNoLXBhbmVsXCIgfSxcbiAgICB7IGtleTogXCJNb2QtU2hpZnQtbFwiLCBydW46IHNlbGVjdFNlbGVjdGlvbk1hdGNoZXMgfSxcbiAgICB7IGtleTogXCJBbHQtZ1wiLCBydW46IGdvdG9MaW5lIH0sXG4gICAgeyBrZXk6IFwiTW9kLWRcIiwgcnVuOiBzZWxlY3ROZXh0T2NjdXJyZW5jZSwgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbl07XG5jbGFzcyBTZWFyY2hQYW5lbCB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICBsZXQgcXVlcnkgPSB0aGlzLnF1ZXJ5ID0gdmlldy5zdGF0ZS5maWVsZChzZWFyY2hTdGF0ZSkucXVlcnkuc3BlYztcbiAgICAgICAgdGhpcy5jb21taXQgPSB0aGlzLmNvbW1pdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5LnNlYXJjaCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBwaHJhc2UodmlldywgXCJGaW5kXCIpLFxuICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcIkZpbmRcIiksXG4gICAgICAgICAgICBjbGFzczogXCJjbS10ZXh0ZmllbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwic2VhcmNoXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgXCJtYWluLWZpZWxkXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0LFxuICAgICAgICAgICAgb25rZXl1cDogdGhpcy5jb21taXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVwbGFjZUZpZWxkID0gZWx0KFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHF1ZXJ5LnJlcGxhY2UsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogcGhyYXNlKHZpZXcsIFwiUmVwbGFjZVwiKSxcbiAgICAgICAgICAgIFwiYXJpYS1sYWJlbFwiOiBwaHJhc2UodmlldywgXCJSZXBsYWNlXCIpLFxuICAgICAgICAgICAgY2xhc3M6IFwiY20tdGV4dGZpZWxkXCIsXG4gICAgICAgICAgICBuYW1lOiBcInJlcGxhY2VcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBvbmNoYW5nZTogdGhpcy5jb21taXQsXG4gICAgICAgICAgICBvbmtleXVwOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYXNlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcImNhc2VcIixcbiAgICAgICAgICAgIGZvcm06IFwiXCIsXG4gICAgICAgICAgICBjaGVja2VkOiBxdWVyeS5jYXNlU2Vuc2l0aXZlLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlRmllbGQgPSBlbHQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgICB0eXBlOiBcImNoZWNrYm94XCIsXG4gICAgICAgICAgICBuYW1lOiBcInJlXCIsXG4gICAgICAgICAgICBmb3JtOiBcIlwiLFxuICAgICAgICAgICAgY2hlY2tlZDogcXVlcnkucmVnZXhwLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHRoaXMuY29tbWl0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmRGaWVsZCA9IGVsdChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcbiAgICAgICAgICAgIG5hbWU6IFwid29yZFwiLFxuICAgICAgICAgICAgZm9ybTogXCJcIixcbiAgICAgICAgICAgIGNoZWNrZWQ6IHF1ZXJ5Lndob2xlV29yZCxcbiAgICAgICAgICAgIG9uY2hhbmdlOiB0aGlzLmNvbW1pdFxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gYnV0dG9uKG5hbWUsIG9uY2xpY2ssIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbHQoXCJidXR0b25cIiwgeyBjbGFzczogXCJjbS1idXR0b25cIiwgbmFtZSwgb25jbGljaywgdHlwZTogXCJidXR0b25cIiB9LCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvbSA9IGVsdChcImRpdlwiLCB7IG9ua2V5ZG93bjogKGUpID0+IHRoaXMua2V5ZG93bihlKSwgY2xhc3M6IFwiY20tc2VhcmNoXCIgfSwgW1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hGaWVsZCxcbiAgICAgICAgICAgIGJ1dHRvbihcIm5leHRcIiwgKCkgPT4gZmluZE5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJuZXh0XCIpXSksXG4gICAgICAgICAgICBidXR0b24oXCJwcmV2XCIsICgpID0+IGZpbmRQcmV2aW91cyh2aWV3KSwgW3BocmFzZSh2aWV3LCBcInByZXZpb3VzXCIpXSksXG4gICAgICAgICAgICBidXR0b24oXCJzZWxlY3RcIiwgKCkgPT4gc2VsZWN0TWF0Y2hlcyh2aWV3KSwgW3BocmFzZSh2aWV3LCBcImFsbFwiKV0pLFxuICAgICAgICAgICAgZWx0KFwibGFiZWxcIiwgbnVsbCwgW3RoaXMuY2FzZUZpZWxkLCBwaHJhc2UodmlldywgXCJtYXRjaCBjYXNlXCIpXSksXG4gICAgICAgICAgICBlbHQoXCJsYWJlbFwiLCBudWxsLCBbdGhpcy5yZUZpZWxkLCBwaHJhc2UodmlldywgXCJyZWdleHBcIildKSxcbiAgICAgICAgICAgIGVsdChcImxhYmVsXCIsIG51bGwsIFt0aGlzLndvcmRGaWVsZCwgcGhyYXNlKHZpZXcsIFwiYnkgd29yZFwiKV0pLFxuICAgICAgICAgICAgLi4udmlldy5zdGF0ZS5yZWFkT25seSA/IFtdIDogW1xuICAgICAgICAgICAgICAgIGVsdChcImJyXCIpLFxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUZpZWxkLFxuICAgICAgICAgICAgICAgIGJ1dHRvbihcInJlcGxhY2VcIiwgKCkgPT4gcmVwbGFjZU5leHQodmlldyksIFtwaHJhc2UodmlldywgXCJyZXBsYWNlXCIpXSksXG4gICAgICAgICAgICAgICAgYnV0dG9uKFwicmVwbGFjZUFsbFwiLCAoKSA9PiByZXBsYWNlQWxsKHZpZXcpLCBbcGhyYXNlKHZpZXcsIFwicmVwbGFjZSBhbGxcIildKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGVsdChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgICAgIG9uY2xpY2s6ICgpID0+IGNsb3NlU2VhcmNoUGFuZWwodmlldyksXG4gICAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsXCI6IHBocmFzZSh2aWV3LCBcImNsb3NlXCIpLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgICAgICAgICAgIH0sIFtcIsOXXCJdKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBsZXQgcXVlcnkgPSBuZXcgU2VhcmNoUXVlcnkoe1xuICAgICAgICAgICAgc2VhcmNoOiB0aGlzLnNlYXJjaEZpZWxkLnZhbHVlLFxuICAgICAgICAgICAgY2FzZVNlbnNpdGl2ZTogdGhpcy5jYXNlRmllbGQuY2hlY2tlZCxcbiAgICAgICAgICAgIHJlZ2V4cDogdGhpcy5yZUZpZWxkLmNoZWNrZWQsXG4gICAgICAgICAgICB3aG9sZVdvcmQ6IHRoaXMud29yZEZpZWxkLmNoZWNrZWQsXG4gICAgICAgICAgICByZXBsYWNlOiB0aGlzLnJlcGxhY2VGaWVsZC52YWx1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcXVlcnkuZXEodGhpcy5xdWVyeSkpIHtcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHNldFNlYXJjaFF1ZXJ5Lm9mKHF1ZXJ5KSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBrZXlkb3duKGUpIHtcbiAgICAgICAgaWYgKHJ1blNjb3BlSGFuZGxlcnModGhpcy52aWV3LCBlLCBcInNlYXJjaC1wYW5lbFwiKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PSAxMyAmJiBlLnRhcmdldCA9PSB0aGlzLnNlYXJjaEZpZWxkKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAoZS5zaGlmdEtleSA/IGZpbmRQcmV2aW91cyA6IGZpbmROZXh0KSh0aGlzLnZpZXcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGUua2V5Q29kZSA9PSAxMyAmJiBlLnRhcmdldCA9PSB0aGlzLnJlcGxhY2VGaWVsZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVwbGFjZU5leHQodGhpcy52aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGZvciAobGV0IHRyIG9mIHVwZGF0ZS50cmFuc2FjdGlvbnMpXG4gICAgICAgICAgICBmb3IgKGxldCBlZmZlY3Qgb2YgdHIuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgIGlmIChlZmZlY3QuaXMoc2V0U2VhcmNoUXVlcnkpICYmICFlZmZlY3QudmFsdWUuZXEodGhpcy5xdWVyeSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UXVlcnkoZWZmZWN0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgc2V0UXVlcnkocXVlcnkpIHtcbiAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICB0aGlzLnNlYXJjaEZpZWxkLnZhbHVlID0gcXVlcnkuc2VhcmNoO1xuICAgICAgICB0aGlzLnJlcGxhY2VGaWVsZC52YWx1ZSA9IHF1ZXJ5LnJlcGxhY2U7XG4gICAgICAgIHRoaXMuY2FzZUZpZWxkLmNoZWNrZWQgPSBxdWVyeS5jYXNlU2Vuc2l0aXZlO1xuICAgICAgICB0aGlzLnJlRmllbGQuY2hlY2tlZCA9IHF1ZXJ5LnJlZ2V4cDtcbiAgICAgICAgdGhpcy53b3JkRmllbGQuY2hlY2tlZCA9IHF1ZXJ5Lndob2xlV29yZDtcbiAgICB9XG4gICAgbW91bnQoKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoRmllbGQuc2VsZWN0KCk7XG4gICAgfVxuICAgIGdldCBwb3MoKSB7IHJldHVybiA4MDsgfVxuICAgIGdldCB0b3AoKSB7IHJldHVybiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoc2VhcmNoQ29uZmlnRmFjZXQpLnRvcDsgfVxufVxuZnVuY3Rpb24gcGhyYXNlKHZpZXcsIHBocmFzZSkgeyByZXR1cm4gdmlldy5zdGF0ZS5waHJhc2UocGhyYXNlKTsgfVxuY29uc3QgQW5ub3VuY2VNYXJnaW4gPSAzMDtcbmNvbnN0IEJyZWFrID0gL1tcXHNcXC4sOjs/IV0vO1xuZnVuY3Rpb24gYW5ub3VuY2VNYXRjaCh2aWV3LCB7IGZyb20sIHRvIH0pIHtcbiAgICBsZXQgbGluZSA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdChmcm9tKSwgbGluZUVuZCA9IHZpZXcuc3RhdGUuZG9jLmxpbmVBdCh0bykudG87XG4gICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgobGluZS5mcm9tLCBmcm9tIC0gQW5ub3VuY2VNYXJnaW4pLCBlbmQgPSBNYXRoLm1pbihsaW5lRW5kLCB0byArIEFubm91bmNlTWFyZ2luKTtcbiAgICBsZXQgdGV4dCA9IHZpZXcuc3RhdGUuc2xpY2VEb2Moc3RhcnQsIGVuZCk7XG4gICAgaWYgKHN0YXJ0ICE9IGxpbmUuZnJvbSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEFubm91bmNlTWFyZ2luOyBpKyspXG4gICAgICAgICAgICBpZiAoIUJyZWFrLnRlc3QodGV4dFtpICsgMV0pICYmIEJyZWFrLnRlc3QodGV4dFtpXSkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZCAhPSBsaW5lRW5kKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0ZXh0Lmxlbmd0aCAtIDE7IGkgPiB0ZXh0Lmxlbmd0aCAtIEFubm91bmNlTWFyZ2luOyBpLS0pXG4gICAgICAgICAgICBpZiAoIUJyZWFrLnRlc3QodGV4dFtpIC0gMV0pICYmIEJyZWFrLnRlc3QodGV4dFtpXSkpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYCR7dmlldy5zdGF0ZS5waHJhc2UoXCJjdXJyZW50IG1hdGNoXCIpfS4gJHt0ZXh0fSAke3ZpZXcuc3RhdGUucGhyYXNlKFwib24gbGluZVwiKX0gJHtsaW5lLm51bWJlcn0uYCk7XG59XG5jb25zdCBiYXNlVGhlbWUgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLXBhbmVsLmNtLXNlYXJjaFwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMnB4IDZweCA0cHhcIixcbiAgICAgICAgcG9zaXRpb246IFwicmVsYXRpdmVcIixcbiAgICAgICAgXCImIFtuYW1lPWNsb3NlXVwiOiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgICAgICAgdG9wOiBcIjBcIixcbiAgICAgICAgICAgIHJpZ2h0OiBcIjRweFwiLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIGJvcmRlcjogXCJub25lXCIsXG4gICAgICAgICAgICBmb250OiBcImluaGVyaXRcIixcbiAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGlucHV0LCAmIGJ1dHRvbiwgJiBsYWJlbFwiOiB7XG4gICAgICAgICAgICBtYXJnaW46IFwiLjJlbSAuNmVtIC4yZW0gMFwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiJiBpbnB1dFt0eXBlPWNoZWNrYm94XVwiOiB7XG4gICAgICAgICAgICBtYXJnaW5SaWdodDogXCIuMmVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCImIGxhYmVsXCI6IHtcbiAgICAgICAgICAgIGZvbnRTaXplOiBcIjgwJVwiLFxuICAgICAgICAgICAgd2hpdGVTcGFjZTogXCJwcmVcIlxuICAgICAgICB9XG4gICAgfSxcbiAgICBcIiZsaWdodCAuY20tc2VhcmNoTWF0Y2hcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZmYwMDU0XCIgfSxcbiAgICBcIiZkYXJrIC5jbS1zZWFyY2hNYXRjaFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDBmZmZmOGFcIiB9LFxuICAgIFwiJmxpZ2h0IC5jbS1zZWFyY2hNYXRjaC1zZWxlY3RlZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjZmY2YTAwNTRcIiB9LFxuICAgIFwiJmRhcmsgLmNtLXNlYXJjaE1hdGNoLXNlbGVjdGVkXCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiNmZjAwZmY4YVwiIH1cbn0pO1xuY29uc3Qgc2VhcmNoRXh0ZW5zaW9ucyA9IFtcbiAgICBzZWFyY2hTdGF0ZSxcbiAgICAvKkBfX1BVUkVfXyovUHJlYy5sb3dlc3Qoc2VhcmNoSGlnaGxpZ2h0ZXIpLFxuICAgIGJhc2VUaGVtZVxuXTtcblxuZXhwb3J0IHsgUmVnRXhwQ3Vyc29yLCBTZWFyY2hDdXJzb3IsIFNlYXJjaFF1ZXJ5LCBjbG9zZVNlYXJjaFBhbmVsLCBmaW5kTmV4dCwgZmluZFByZXZpb3VzLCBnZXRTZWFyY2hRdWVyeSwgZ290b0xpbmUsIGhpZ2hsaWdodFNlbGVjdGlvbk1hdGNoZXMsIG9wZW5TZWFyY2hQYW5lbCwgcmVwbGFjZUFsbCwgcmVwbGFjZU5leHQsIHNlYXJjaCwgc2VhcmNoS2V5bWFwLCBzZWFyY2hQYW5lbE9wZW4sIHNlbGVjdE1hdGNoZXMsIHNlbGVjdE5leHRPY2N1cnJlbmNlLCBzZWxlY3RTZWxlY3Rpb25NYXRjaGVzLCBzZXRTZWFyY2hRdWVyeSB9O1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlbHQoKSB7XG4gIHZhciBlbHQgPSBhcmd1bWVudHNbMF1cbiAgaWYgKHR5cGVvZiBlbHQgPT0gXCJzdHJpbmdcIikgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbHQpXG4gIHZhciBpID0gMSwgbmV4dCA9IGFyZ3VtZW50c1sxXVxuICBpZiAobmV4dCAmJiB0eXBlb2YgbmV4dCA9PSBcIm9iamVjdFwiICYmIG5leHQubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbmV4dCkgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXh0LCBuYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0gbmV4dFtuYW1lXVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSBlbHQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKVxuICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkgZWx0W25hbWVdID0gdmFsdWVcbiAgICB9XG4gICAgaSsrXG4gIH1cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFkZChlbHQsIGFyZ3VtZW50c1tpXSlcbiAgcmV0dXJuIGVsdFxufVxuXG5mdW5jdGlvbiBhZGQoZWx0LCBjaGlsZCkge1xuICBpZiAodHlwZW9mIGNoaWxkID09IFwic3RyaW5nXCIpIHtcbiAgICBlbHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQpKVxuICB9IGVsc2UgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgfSBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSAhPSBudWxsKSB7XG4gICAgZWx0LmFwcGVuZENoaWxkKGNoaWxkKVxuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGQpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZC5sZW5ndGg7IGkrKykgYWRkKGVsdCwgY2hpbGRbaV0pXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbnN1cHBvcnRlZCBjaGlsZCBub2RlOiBcIiArIGNoaWxkKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=