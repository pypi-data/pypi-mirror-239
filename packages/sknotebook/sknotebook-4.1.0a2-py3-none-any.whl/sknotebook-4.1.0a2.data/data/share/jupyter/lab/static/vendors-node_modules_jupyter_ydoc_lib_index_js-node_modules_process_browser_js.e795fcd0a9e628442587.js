(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter_ydoc_lib_index_js-node_modules_process_browser_js"],{

/***/ "../node_modules/@jupyter/ydoc/lib/api.js":
/*!************************************************!*\
  !*** ../node_modules/@jupyter/ydoc/lib/api.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

//# sourceMappingURL=api.js.map

/***/ }),

/***/ "../node_modules/@jupyter/ydoc/lib/awareness.js":
/*!******************************************************!*\
  !*** ../node_modules/@jupyter/ydoc/lib/awareness.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

//# sourceMappingURL=awareness.js.map

/***/ }),

/***/ "../node_modules/@jupyter/ydoc/lib/index.js":
/*!**************************************************!*\
  !*** ../node_modules/@jupyter/ydoc/lib/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YBaseCell": () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YBaseCell),
/* harmony export */   "YCodeCell": () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YCodeCell),
/* harmony export */   "YDocument": () => (/* reexport safe */ _ydocument_js__WEBPACK_IMPORTED_MODULE_4__.YDocument),
/* harmony export */   "YFile": () => (/* reexport safe */ _yfile_js__WEBPACK_IMPORTED_MODULE_5__.YFile),
/* harmony export */   "YMarkdownCell": () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YMarkdownCell),
/* harmony export */   "YNotebook": () => (/* reexport safe */ _ynotebook_js__WEBPACK_IMPORTED_MODULE_6__.YNotebook),
/* harmony export */   "YRawCell": () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.YRawCell),
/* harmony export */   "convertYMapEventToMapChange": () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.convertYMapEventToMapChange),
/* harmony export */   "createMutex": () => (/* reexport safe */ _utils_js__WEBPACK_IMPORTED_MODULE_1__.createMutex),
/* harmony export */   "createStandaloneCell": () => (/* reexport safe */ _ycell_js__WEBPACK_IMPORTED_MODULE_7__.createStandaloneCell)
/* harmony export */ });
/* harmony import */ var _api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api.js */ "../node_modules/@jupyter/ydoc/lib/api.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ "../node_modules/@jupyter/ydoc/lib/utils.js");
/* harmony import */ var _awareness_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./awareness.js */ "../node_modules/@jupyter/ydoc/lib/awareness.js");
/* harmony import */ var _ytext_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ytext.js */ "../node_modules/@jupyter/ydoc/lib/ytext.js");
/* harmony import */ var _ydocument_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ydocument.js */ "../node_modules/@jupyter/ydoc/lib/ydocument.js");
/* harmony import */ var _yfile_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./yfile.js */ "../node_modules/@jupyter/ydoc/lib/yfile.js");
/* harmony import */ var _ynotebook_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ynotebook.js */ "../node_modules/@jupyter/ydoc/lib/ynotebook.js");
/* harmony import */ var _ycell_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ycell.js */ "../node_modules/@jupyter/ydoc/lib/ycell.js");
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
/**
 * @packageDocumentation
 * @module ydoc
 */








//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/@jupyter/ydoc/lib/utils.js":
/*!**************************************************!*\
  !*** ../node_modules/@jupyter/ydoc/lib/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "convertYMapEventToMapChange": () => (/* binding */ convertYMapEventToMapChange),
/* harmony export */   "createMutex": () => (/* binding */ createMutex)
/* harmony export */ });
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/
function convertYMapEventToMapChange(event) {
    let changes = new Map();
    event.changes.keys.forEach((event, key) => {
        changes.set(key, {
            action: event.action,
            oldValue: event.oldValue,
            newValue: this.ymeta.get(key)
        });
    });
    return changes;
}
/**
 * Creates a mutual exclude function with the following property:
 *
 * ```js
 * const mutex = createMutex()
 * mutex(() => {
 *   // This function is immediately executed
 *   mutex(() => {
 *     // This function is not executed, as the mutex is already active.
 *   })
 * })
 * ```
 */
const createMutex = () => {
    let token = true;
    return (f) => {
        if (token) {
            token = false;
            try {
                f();
            }
            finally {
                token = true;
            }
        }
    };
};
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../node_modules/@jupyter/ydoc/lib/ycell.js":
/*!**************************************************!*\
  !*** ../node_modules/@jupyter/ydoc/lib/ycell.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YBaseCell": () => (/* binding */ YBaseCell),
/* harmony export */   "YCodeCell": () => (/* binding */ YCodeCell),
/* harmony export */   "YMarkdownCell": () => (/* binding */ YMarkdownCell),
/* harmony export */   "YRawCell": () => (/* binding */ YRawCell),
/* harmony export */   "createCell": () => (/* binding */ createCell),
/* harmony export */   "createCellModelFromSharedType": () => (/* binding */ createCellModelFromSharedType),
/* harmony export */   "createStandaloneCell": () => (/* binding */ createStandaloneCell)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/awareness */ "../node_modules/y-protocols/awareness.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_3__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/




/**
 * Create a new shared cell model given the YJS shared type.
 */
const createCellModelFromSharedType = (type, options = {}) => {
    switch (type.get('cell_type')) {
        case 'code':
            return new YCodeCell(type, type.get('source'), type.get('outputs'), options);
        case 'markdown':
            return new YMarkdownCell(type, type.get('source'), options);
        case 'raw':
            return new YRawCell(type, type.get('source'), options);
        default:
            throw new Error('Found unknown cell type');
    }
};
/**
 * Create a new cell that can be inserted in an existing shared model.
 *
 * If no notebook is specified the cell will be standalone.
 *
 * @param cell Cell JSON representation
 * @param notebook Notebook to which the cell will be added
 */
const createCell = (cell, notebook) => {
    var _a, _b;
    const ymodel = new yjs__WEBPACK_IMPORTED_MODULE_3__.Map();
    const ysource = new yjs__WEBPACK_IMPORTED_MODULE_3__.Text();
    const ymetadata = new yjs__WEBPACK_IMPORTED_MODULE_3__.Map();
    ymodel.set('source', ysource);
    ymodel.set('metadata', ymetadata);
    ymodel.set('cell_type', cell.cell_type);
    ymodel.set('id', (_a = cell.id) !== null && _a !== void 0 ? _a : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.UUID.uuid4());
    let ycell;
    switch (cell.cell_type) {
        case 'markdown': {
            ycell = new YMarkdownCell(ymodel, ysource, { notebook }, ymetadata);
            if (cell.attachments != null) {
                ycell.setAttachments(cell.attachments);
            }
            break;
        }
        case 'code': {
            const youtputs = new yjs__WEBPACK_IMPORTED_MODULE_3__.Array();
            ymodel.set('outputs', youtputs);
            ycell = new YCodeCell(ymodel, ysource, youtputs, {
                notebook
            }, ymetadata);
            const cCell = cell;
            ycell.execution_count = (_b = cCell.execution_count) !== null && _b !== void 0 ? _b : null;
            if (cCell.outputs) {
                ycell.setOutputs(cCell.outputs);
            }
            break;
        }
        default: {
            // raw
            ycell = new YRawCell(ymodel, ysource, { notebook }, ymetadata);
            if (cell.attachments) {
                ycell.setAttachments(cell.attachments);
            }
            break;
        }
    }
    if (cell.metadata != null) {
        ycell.setMetadata(cell.metadata);
    }
    if (cell.source != null) {
        ycell.setSource(typeof cell.source === 'string' ? cell.source : cell.source.join(''));
    }
    return ycell;
};
/**
 * Create a new cell that cannot be inserted in an existing shared model.
 *
 * @param cell Cell JSON representation
 */
const createStandaloneCell = (cell) => createCell(cell);
class YBaseCell {
    /**
     * Create a new YCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static create(id) {
        return createCell({ id, cell_type: this.prototype.cell_type });
    }
    /**
     * Base cell constructor
     *
     * ### Notes
     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``
     *
     * The ``ysource`` is needed because ``ymodel.get('source')`` will
     * not return the real source if the model is not yet attached to
     * a document. Requesting it explicitly allows to introspect a non-empty
     * source before the cell is attached to the document.
     *
     * @param ymodel Cell map
     * @param ysource Cell source
     * @param options \{ notebook?: The notebook the cell is attached to \}
     * @param ymetadata Cell metadata
     */
    constructor(ymodel, ysource, options = {}, ymetadata) {
        /**
         * Handle a change to the ymodel.
         */
        this._modelObserver = (events) => {
            this._changed.emit(this.getChanges(events));
        };
        this._metadataChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        /**
         * The notebook that this cell belongs to.
         */
        this._notebook = null;
        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._isDisposed = false;
        this._undoManager = null;
        this.ymodel = ymodel;
        this._ysource = ysource;
        this._ymetadata = ymetadata !== null && ymetadata !== void 0 ? ymetadata : this.ymodel.get('metadata');
        this._prevSourceLength = ysource ? ysource.length : 0;
        this._notebook = null;
        this._awareness = null;
        this._undoManager = null;
        if (options.notebook) {
            this._notebook = options.notebook;
            // We cannot create a undo manager with the cell not yet attached in the notebook
            // so we defer that to the notebook insertCell method
        }
        else {
            // Standalone cell
            const doc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc();
            doc.getArray().insert(0, [this.ymodel]);
            this._awareness = new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__.Awareness(doc);
            this._undoManager = new yjs__WEBPACK_IMPORTED_MODULE_3__.UndoManager([this.ymodel], {
                trackedOrigins: new Set([this])
            });
        }
        this.ymodel.observeDeep(this._modelObserver);
    }
    /**
     * Cell notebook awareness or null if the cell is standalone.
     */
    get awareness() {
        var _a, _b, _c;
        return (_c = (_a = this._awareness) !== null && _a !== void 0 ? _a : (_b = this.notebook) === null || _b === void 0 ? void 0 : _b.awareness) !== null && _c !== void 0 ? _c : null;
    }
    /**
     * The type of the cell.
     */
    get cell_type() {
        throw new Error('A YBaseCell must not be constructed');
    }
    /**
     * The changed signal.
     */
    get changed() {
        return this._changed;
    }
    /**
     * Signal emitted when the cell is disposed.
     */
    get disposed() {
        return this._disposed;
    }
    /**
     * Cell id
     */
    get id() {
        return this.getId();
    }
    /**
     * Whether the model has been disposed or not.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Whether the cell is standalone or not.
     *
     * If the cell is standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    get isStandalone() {
        return this._notebook !== null;
    }
    /**
     * Cell metadata.
     *
     * #### Notes
     * You should prefer to access and modify the specific key of interest.
     */
    get metadata() {
        return this.getMetadata();
    }
    set metadata(v) {
        this.setMetadata(v);
    }
    /**
     * Signal triggered when the cell metadata changes.
     */
    get metadataChanged() {
        return this._metadataChanged;
    }
    /**
     * The notebook that this cell belongs to.
     */
    get notebook() {
        return this._notebook;
    }
    /**
     * Cell input content.
     */
    get source() {
        return this.getSource();
    }
    set source(v) {
        this.setSource(v);
    }
    /**
     * The cell undo manager.
     */
    get undoManager() {
        var _a;
        if (!this.notebook) {
            return this._undoManager;
        }
        return ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.disableDocumentWideUndoRedo)
            ? this._undoManager
            : this.notebook.undoManager;
    }
    /**
     * Defer setting the undo manager as it requires the
     * cell to be attached to the notebook Y document.
     */
    setUndoManager() {
        if (this._undoManager) {
            throw new Error('The cell undo manager is already set.');
        }
        if (this._notebook && this._notebook.disableDocumentWideUndoRedo) {
            this._undoManager = new yjs__WEBPACK_IMPORTED_MODULE_3__.UndoManager([this.ymodel], {
                trackedOrigins: new Set([this])
            });
        }
    }
    get ysource() {
        return this._ysource;
    }
    /**
     * Whether the object can undo changes.
     */
    canUndo() {
        return !!this.undoManager && this.undoManager.undoStack.length > 0;
    }
    /**
     * Whether the object can redo changes.
     */
    canRedo() {
        return !!this.undoManager && this.undoManager.redoStack.length > 0;
    }
    /**
     * Clear the change stack.
     */
    clearUndoHistory() {
        var _a;
        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.clear();
    }
    /**
     * Undo an operation.
     */
    undo() {
        var _a;
        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.undo();
    }
    /**
     * Redo an operation.
     */
    redo() {
        var _a;
        (_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.redo();
    }
    /**
     * Dispose of the resources.
     */
    dispose() {
        var _a;
        if (this._isDisposed)
            return;
        this._isDisposed = true;
        this.ymodel.unobserveDeep(this._modelObserver);
        if (this._awareness) {
            // A new document is created for standalone cell.
            const doc = this._awareness.doc;
            this._awareness.destroy();
            doc.destroy();
        }
        if (this._undoManager) {
            // Be sure to not destroy the document undo manager.
            if (this._undoManager === ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.undoManager)) {
                this._undoManager = null;
            }
            else {
                this._undoManager.destroy();
            }
        }
        this._disposed.emit();
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);
    }
    /**
     * Get cell id.
     *
     * @returns Cell id
     */
    getId() {
        return this.ymodel.get('id');
    }
    /**
     * Gets cell's source.
     *
     * @returns Cell's source.
     */
    getSource() {
        return this.ysource.toString();
    }
    /**
     * Sets cell's source.
     *
     * @param value: New source.
     */
    setSource(value) {
        this.transact(() => {
            this.ysource.delete(0, this.ysource.length);
            this.ysource.insert(0, value);
        });
        // @todo Do we need proper replace semantic? This leads to issues in editor bindings because they don't switch source.
        // this.ymodel.set('source', new Y.Text(value));
    }
    /**
     * Replace content from `start' to `end` with `value`.
     *
     * @param start: The start index of the range to replace (inclusive).
     *
     * @param end: The end index of the range to replace (exclusive).
     *
     * @param value: New source (optional).
     */
    updateSource(start, end, value = '') {
        this.transact(() => {
            const ysource = this.ysource;
            // insert and then delete.
            // This ensures that the cursor position is adjusted after the replaced content.
            ysource.insert(start, value);
            ysource.delete(start + value.length, end - start);
        });
    }
    /**
     * Delete a metadata cell.
     *
     * @param key The key to delete
     */
    deleteMetadata(key) {
        if (typeof this.getMetadata(key) === 'undefined') {
            return;
        }
        this.transact(() => {
            this._ymetadata.delete(key);
            const jupyter = this.getMetadata('jupyter');
            if (key === 'collapsed' && jupyter) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                const { outputs_hidden, ...others } = jupyter;
                if (Object.keys(others).length === 0) {
                    this._ymetadata.delete('jupyter');
                }
                else {
                    this._ymetadata.set('jupyter', others);
                }
            }
            else if (key === 'jupyter') {
                this._ymetadata.delete('collapsed');
            }
        }, false);
    }
    getMetadata(key) {
        const metadata = this._ymetadata;
        // Transiently the metadata can be missing - like during destruction
        if (metadata === undefined) {
            return undefined;
        }
        if (typeof key === 'string') {
            const value = metadata.get(key);
            return typeof value === 'undefined'
                ? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`
                : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata.get(key));
        }
        else {
            return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata.toJSON());
        }
    }
    setMetadata(metadata, value) {
        var _a, _b;
        if (typeof metadata === 'string') {
            if (typeof value === 'undefined') {
                throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);
            }
            const key = metadata;
            // Only set metadata if we change something to avoid infinite
            // loop of signal changes.
            if (_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual((_a = this.getMetadata(key)) !== null && _a !== void 0 ? _a : null, value)) {
                return;
            }
            this.transact(() => {
                var _a;
                this._ymetadata.set(key, value);
                if (key === 'collapsed') {
                    const jupyter = ((_a = this.getMetadata('jupyter')) !== null && _a !== void 0 ? _a : {});
                    if (jupyter.outputs_hidden !== value) {
                        this.setMetadata('jupyter', {
                            ...jupyter,
                            outputs_hidden: value
                        });
                    }
                }
                else if (key === 'jupyter') {
                    const isHidden = value['outputs_hidden'];
                    if (typeof isHidden !== 'undefined') {
                        if (this.getMetadata('collapsed') !== isHidden) {
                            this.setMetadata('collapsed', isHidden);
                        }
                    }
                    else {
                        this.deleteMetadata('collapsed');
                    }
                }
            }, false);
        }
        else {
            const clone = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata);
            if (clone.collapsed != null) {
                clone.jupyter = clone.jupyter || {};
                clone.jupyter.outputs_hidden = clone.collapsed;
            }
            else if (((_b = clone === null || clone === void 0 ? void 0 : clone.jupyter) === null || _b === void 0 ? void 0 : _b.outputs_hidden) != null) {
                clone.collapsed = clone.jupyter.outputs_hidden;
            }
            if (!_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(clone, this.getMetadata())) {
                this.transact(() => {
                    for (const [key, value] of Object.entries(clone)) {
                        this._ymetadata.set(key, value);
                    }
                }, false);
            }
        }
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return {
            id: this.getId(),
            cell_type: this.cell_type,
            source: this.getSource(),
            metadata: this.getMetadata()
        };
    }
    /**
     * Perform a transaction. While the function f is called, all changes to the shared
     * document are bundled into a single event.
     *
     * @param f Transaction to execute
     * @param undoable Whether to track the change in the action history or not (default `true`)
     */
    transact(f, undoable = true) {
        !this.notebook || this.notebook.disableDocumentWideUndoRedo
            ? this.ymodel.doc == null
                ? f()
                : this.ymodel.doc.transact(f, undoable ? this : null)
            : this.notebook.transact(f, undoable);
    }
    /**
     * Extract changes from YJS events
     *
     * @param events YJS events
     * @returns Cell changes
     */
    getChanges(events) {
        const changes = {};
        const sourceEvent = events.find(event => event.target === this.ymodel.get('source'));
        if (sourceEvent) {
            changes.sourceChange = sourceEvent.changes.delta;
        }
        const metadataEvents = events.find(event => event.target === this._ymetadata);
        if (metadataEvents) {
            changes.metadataChange = metadataEvents.changes.keys;
            metadataEvents.changes.keys.forEach((change, key) => {
                switch (change.action) {
                    case 'add':
                        this._metadataChanged.emit({
                            key,
                            newValue: this._ymetadata.get(key),
                            type: 'add'
                        });
                        break;
                    case 'delete':
                        this._metadataChanged.emit({
                            key,
                            oldValue: change.oldValue,
                            type: 'remove'
                        });
                        break;
                    case 'update':
                        {
                            const newValue = this._ymetadata.get(key);
                            const oldValue = change.oldValue;
                            let equal = true;
                            if (typeof oldValue == 'object' && typeof newValue == 'object') {
                                equal = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(oldValue, newValue);
                            }
                            else {
                                equal = oldValue === newValue;
                            }
                            if (!equal) {
                                this._metadataChanged.emit({
                                    key,
                                    type: 'change',
                                    oldValue,
                                    newValue
                                });
                            }
                        }
                        break;
                }
            });
        }
        const modelEvent = events.find(event => event.target === this.ymodel);
        // The model allows us to replace the complete source with a new string. We express this in the Delta format
        // as a replace of the complete string.
        const ysource = this.ymodel.get('source');
        if (modelEvent && modelEvent.keysChanged.has('source')) {
            changes.sourceChange = [
                { delete: this._prevSourceLength },
                { insert: ysource.toString() }
            ];
        }
        this._prevSourceLength = ysource.length;
        return changes;
    }
}
/**
 * Shareable code cell.
 */
class YCodeCell extends YBaseCell {
    /**
     * Create a new YCodeCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static create(id) {
        return super.create(id);
    }
    /**
     * Code cell constructor
     *
     * ### Notes
     * Don't use the constructor directly - prefer using ``YNotebook.insertCell``
     *
     * The ``ysource`` is needed because ``ymodel.get('source')`` will
     * not return the real source if the model is not yet attached to
     * a document. Requesting it explicitly allows to introspect a non-empty
     * source before the cell is attached to the document.
     *
     * @param ymodel Cell map
     * @param ysource Cell source
     * @param youtputs Code cell outputs
     * @param options \{ notebook?: The notebook the cell is attached to \}
     * @param ymetadata Cell metadata
     */
    constructor(ymodel, ysource, youtputs, options = {}, ymetadata) {
        super(ymodel, ysource, options, ymetadata);
        this._youtputs = youtputs;
    }
    /**
     * The type of the cell.
     */
    get cell_type() {
        return 'code';
    }
    /**
     * The code cell's prompt number. Will be null if the cell has not been run.
     */
    get execution_count() {
        return this.ymodel.get('execution_count') || null;
    }
    set execution_count(count) {
        // Do not use `this.execution_count`. When initializing the
        // cell, we need to set execution_count to `null` if we compare
        // using `this.execution_count` it will return `null` and we will
        // never initialize it
        if (this.ymodel.get('execution_count') !== count) {
            this.transact(() => {
                this.ymodel.set('execution_count', count);
            }, false);
        }
    }
    /**
     * Cell outputs.
     */
    get outputs() {
        return this.getOutputs();
    }
    set outputs(v) {
        this.setOutputs(v);
    }
    /**
     * Execution, display, or stream outputs.
     */
    getOutputs() {
        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(this._youtputs.toArray());
    }
    /**
     * Replace all outputs.
     */
    setOutputs(outputs) {
        this.transact(() => {
            this._youtputs.delete(0, this._youtputs.length);
            this._youtputs.insert(0, outputs);
        }, false);
    }
    /**
     * Replace content from `start' to `end` with `outputs`.
     *
     * @param start: The start index of the range to replace (inclusive).
     *
     * @param end: The end index of the range to replace (exclusive).
     *
     * @param outputs: New outputs (optional).
     */
    updateOutputs(start, end, outputs = []) {
        const fin = end < this._youtputs.length ? end - start : this._youtputs.length - start;
        this.transact(() => {
            this._youtputs.delete(start, fin);
            this._youtputs.insert(start, outputs);
        }, false);
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return {
            ...super.toJSON(),
            outputs: this.getOutputs(),
            execution_count: this.execution_count
        };
    }
    /**
     * Extract changes from YJS events
     *
     * @param events YJS events
     * @returns Cell changes
     */
    getChanges(events) {
        const changes = super.getChanges(events);
        const outputEvent = events.find(event => event.target === this.ymodel.get('outputs'));
        if (outputEvent) {
            changes.outputsChange = outputEvent.changes.delta;
        }
        const modelEvent = events.find(event => event.target === this.ymodel);
        if (modelEvent && modelEvent.keysChanged.has('execution_count')) {
            const change = modelEvent.changes.keys.get('execution_count');
            changes.executionCountChange = {
                oldValue: change.oldValue,
                newValue: this.ymodel.get('execution_count')
            };
        }
        return changes;
    }
}
class YAttachmentCell extends YBaseCell {
    /**
     * Cell attachments
     */
    get attachments() {
        return this.getAttachments();
    }
    set attachments(v) {
        this.setAttachments(v);
    }
    /**
     * Gets the cell attachments.
     *
     * @returns The cell attachments.
     */
    getAttachments() {
        return this.ymodel.get('attachments');
    }
    /**
     * Sets the cell attachments
     *
     * @param attachments: The cell attachments.
     */
    setAttachments(attachments) {
        this.transact(() => {
            if (attachments == null) {
                this.ymodel.delete('attachments');
            }
            else {
                this.ymodel.set('attachments', attachments);
            }
        }, false);
    }
    /**
     * Extract changes from YJS events
     *
     * @param events YJS events
     * @returns Cell changes
     */
    getChanges(events) {
        const changes = super.getChanges(events);
        const modelEvent = events.find(event => event.target === this.ymodel);
        if (modelEvent && modelEvent.keysChanged.has('attachments')) {
            const change = modelEvent.changes.keys.get('attachments');
            changes.executionCountChange = {
                oldValue: change.oldValue,
                newValue: this.ymodel.get('attachments')
            };
        }
        return changes;
    }
}
/**
 * Shareable raw cell.
 */
class YRawCell extends YAttachmentCell {
    /**
     * Create a new YRawCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static create(id) {
        return super.create(id);
    }
    /**
     * String identifying the type of cell.
     */
    get cell_type() {
        return 'raw';
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return {
            id: this.getId(),
            cell_type: 'raw',
            source: this.getSource(),
            metadata: this.getMetadata(),
            attachments: this.getAttachments()
        };
    }
}
/**
 * Shareable markdown cell.
 */
class YMarkdownCell extends YAttachmentCell {
    /**
     * Create a new YMarkdownCell that works standalone. It cannot be
     * inserted into a YNotebook because the Yjs model is already
     * attached to an anonymous Y.Doc instance.
     */
    static create(id) {
        return super.create(id);
    }
    /**
     * String identifying the type of cell.
     */
    get cell_type() {
        return 'markdown';
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        return {
            id: this.getId(),
            cell_type: 'markdown',
            source: this.getSource(),
            metadata: this.getMetadata(),
            attachments: this.getAttachments()
        };
    }
}
//# sourceMappingURL=ycell.js.map

/***/ }),

/***/ "../node_modules/@jupyter/ydoc/lib/ydocument.js":
/*!******************************************************!*\
  !*** ../node_modules/@jupyter/ydoc/lib/ydocument.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YDocument": () => (/* binding */ YDocument)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-protocols/awareness */ "../node_modules/y-protocols/awareness.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_3__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/




/**
 * Generic shareable document.
 */
class YDocument {
    constructor(options) {
        var _a;
        /**
         * Handle a change to the ystate.
         */
        this.onStateChanged = (event) => {
            const stateChange = new Array();
            event.keysChanged.forEach(key => {
                const change = event.changes.keys.get(key);
                if (change) {
                    stateChange.push({
                        name: key,
                        oldValue: change.oldValue,
                        newValue: this.ystate.get(key)
                    });
                }
            });
            this._changed.emit({ stateChange });
        };
        this._changed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._isDisposed = false;
        this._disposed = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        this._ydoc = (_a = options === null || options === void 0 ? void 0 : options.ydoc) !== null && _a !== void 0 ? _a : new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc();
        this._ystate = this._ydoc.getMap('state');
        this._undoManager = new yjs__WEBPACK_IMPORTED_MODULE_3__.UndoManager([], {
            trackedOrigins: new Set([this]),
            doc: this._ydoc
        });
        this._awareness = new y_protocols_awareness__WEBPACK_IMPORTED_MODULE_2__.Awareness(this._ydoc);
        this._ystate.observe(this.onStateChanged);
    }
    /**
     * YJS document.
     */
    get ydoc() {
        return this._ydoc;
    }
    /**
     * Shared state
     */
    get ystate() {
        return this._ystate;
    }
    /**
     * YJS document undo manager
     */
    get undoManager() {
        return this._undoManager;
    }
    /**
     * Shared awareness
     */
    get awareness() {
        return this._awareness;
    }
    /**
     * The changed signal.
     */
    get changed() {
        return this._changed;
    }
    /**
     * A signal emitted when the document is disposed.
     */
    get disposed() {
        return this._disposed;
    }
    /**
     * Whether the document is disposed or not.
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Document state
     */
    get state() {
        return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(this.ystate.toJSON());
    }
    /**
     * Whether the object can undo changes.
     */
    canUndo() {
        return this.undoManager.undoStack.length > 0;
    }
    /**
     * Whether the object can redo changes.
     */
    canRedo() {
        return this.undoManager.redoStack.length > 0;
    }
    /**
     * Dispose of the resources.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.ystate.unobserve(this.onStateChanged);
        this.awareness.destroy();
        this.undoManager.destroy();
        this.ydoc.destroy();
        this._disposed.emit();
        _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal.clearData(this);
    }
    /**
     * Get the value for a state attribute
     *
     * @param key Key to get
     */
    getState(key) {
        const value = this.ystate.get(key);
        return typeof value === 'undefined'
            ? value
            : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(value);
    }
    /**
     * Set the value of a state attribute
     *
     * @param key Key to set
     * @param value New attribute value
     */
    setState(key, value) {
        if (!_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(this.ystate.get(key), value)) {
            this.ystate.set(key, value);
        }
    }
    /**
     * Undo an operation.
     */
    undo() {
        this.undoManager.undo();
    }
    /**
     * Redo an operation.
     */
    redo() {
        this.undoManager.redo();
    }
    /**
     * Clear the change stack.
     */
    clearUndoHistory() {
        this.undoManager.clear();
    }
    /**
     * Perform a transaction. While the function f is called, all changes to the shared
     * document are bundled into a single event.
     */
    transact(f, undoable = true) {
        this.ydoc.transact(f, undoable ? this : null);
    }
}
//# sourceMappingURL=ydocument.js.map

/***/ }),

/***/ "../node_modules/@jupyter/ydoc/lib/yfile.js":
/*!**************************************************!*\
  !*** ../node_modules/@jupyter/ydoc/lib/yfile.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YFile": () => (/* binding */ YFile)
/* harmony export */ });
/* harmony import */ var _ydocument_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ydocument.js */ "../node_modules/@jupyter/ydoc/lib/ydocument.js");
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

/**
 * Shareable text file.
 */
class YFile extends _ydocument_js__WEBPACK_IMPORTED_MODULE_0__.YDocument {
    /**
     * Create a new file
     *
     * #### Notes
     * The document is empty and must be populated
     */
    constructor() {
        super();
        /**
         * Document version
         */
        this.version = '1.0.0';
        /**
         * YJS file text.
         */
        this.ysource = this.ydoc.getText('source');
        /**
         * Handle a change to the ymodel.
         */
        this._modelObserver = (event) => {
            this._changed.emit({ sourceChange: event.changes.delta });
        };
        this.undoManager.addToScope(this.ysource);
        this.ysource.observe(this._modelObserver);
    }
    /**
     * Creates a standalone YFile
     */
    static create() {
        return new YFile();
    }
    /**
     * File text
     */
    get source() {
        return this.getSource();
    }
    set source(v) {
        this.setSource(v);
    }
    /**
     * Dispose of the resources.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this.ysource.unobserve(this._modelObserver);
        super.dispose();
    }
    /**
     * Get the file text.
     *
     * @returns File text.
     */
    getSource() {
        return this.ysource.toString();
    }
    /**
     * Set the file text.
     *
     * @param value New text
     */
    setSource(value) {
        this.transact(() => {
            const ytext = this.ysource;
            ytext.delete(0, ytext.length);
            ytext.insert(0, value);
        });
    }
    /**
     * Replace content from `start' to `end` with `value`.
     *
     * @param start: The start index of the range to replace (inclusive).
     * @param end: The end index of the range to replace (exclusive).
     * @param value: New source (optional).
     */
    updateSource(start, end, value = '') {
        this.transact(() => {
            const ysource = this.ysource;
            // insert and then delete.
            // This ensures that the cursor position is adjusted after the replaced content.
            ysource.insert(start, value);
            ysource.delete(start + value.length, end - start);
        });
    }
}
//# sourceMappingURL=yfile.js.map

/***/ }),

/***/ "../node_modules/@jupyter/ydoc/lib/ynotebook.js":
/*!******************************************************!*\
  !*** ../node_modules/@jupyter/ydoc/lib/ynotebook.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "YNotebook": () => (/* binding */ YNotebook)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _ydocument_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ydocument.js */ "../node_modules/@jupyter/ydoc/lib/ydocument.js");
/* harmony import */ var _ycell_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ycell.js */ "../node_modules/@jupyter/ydoc/lib/ycell.js");
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/





/**
 * Shared implementation of the Shared Document types.
 *
 * Shared cells can be inserted into a SharedNotebook.
 * Shared cells only start emitting events when they are connected to a SharedNotebook.
 *
 * "Standalone" cells must not be inserted into a (Shared)Notebook.
 * Standalone cells emit events immediately after they have been created, but they must not
 * be included into a (Shared)Notebook.
 */
class YNotebook extends _ydocument_js__WEBPACK_IMPORTED_MODULE_3__.YDocument {
    /**
     * Create a new notebook
     *
     * #### Notes
     * The document is empty and must be populated
     *
     * @param options
     */
    constructor(options = {}) {
        var _a;
        super();
        /**
         * Document version
         */
        this.version = '1.0.0';
        /**
         * YJS map for the notebook metadata
         */
        this.ymeta = this.ydoc.getMap('meta');
        /**
         * Handle a change to the ystate.
         */
        this._onMetaChanged = (events) => {
            const metadataEvents = events.find(event => event.target === this.ymeta.get('metadata'));
            if (metadataEvents) {
                const metadataChange = metadataEvents.changes.keys;
                const ymetadata = this.ymeta.get('metadata');
                metadataEvents.changes.keys.forEach((change, key) => {
                    switch (change.action) {
                        case 'add':
                            this._metadataChanged.emit({
                                key,
                                type: 'add',
                                newValue: ymetadata.get(key)
                            });
                            break;
                        case 'delete':
                            this._metadataChanged.emit({
                                key,
                                type: 'remove',
                                oldValue: change.oldValue
                            });
                            break;
                        case 'update':
                            {
                                const newValue = ymetadata.get(key);
                                const oldValue = change.oldValue;
                                let equal = true;
                                if (typeof oldValue == 'object' && typeof newValue == 'object') {
                                    equal = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(oldValue, newValue);
                                }
                                else {
                                    equal = oldValue === newValue;
                                }
                                if (!equal) {
                                    this._metadataChanged.emit({
                                        key,
                                        type: 'change',
                                        oldValue,
                                        newValue
                                    });
                                }
                            }
                            break;
                    }
                });
                this._changed.emit({ metadataChange });
            }
            const metaEvent = events.find(event => event.target === this.ymeta);
            if (!metaEvent) {
                return;
            }
            if (metaEvent.keysChanged.has('metadata')) {
                // Handle metadata change when adding/removing the YMap
                const change = metaEvent.changes.keys.get('metadata');
                if ((change === null || change === void 0 ? void 0 : change.action) === 'add' && !change.oldValue) {
                    const metadataChange = new Map();
                    for (const key of Object.keys(this.metadata)) {
                        metadataChange.set(key, {
                            action: 'add',
                            oldValue: undefined
                        });
                        this._metadataChanged.emit({
                            key,
                            type: 'add',
                            newValue: this.getMetadata(key)
                        });
                    }
                    this._changed.emit({ metadataChange });
                }
            }
            if (metaEvent.keysChanged.has('nbformat')) {
                const change = metaEvent.changes.keys.get('nbformat');
                const nbformatChanged = {
                    key: 'nbformat',
                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,
                    newValue: this.nbformat
                };
                this._changed.emit({ nbformatChanged });
            }
            if (metaEvent.keysChanged.has('nbformat_minor')) {
                const change = metaEvent.changes.keys.get('nbformat_minor');
                const nbformatChanged = {
                    key: 'nbformat_minor',
                    oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,
                    newValue: this.nbformat_minor
                };
                this._changed.emit({ nbformatChanged });
            }
        };
        /**
         * Handle a change to the list of cells.
         */
        this._onYCellsChanged = (event) => {
            // update the type cell mapping by iterating through the added/removed types
            event.changes.added.forEach(item => {
                const type = item.content.type;
                if (!this._ycellMapping.has(type)) {
                    const c = (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCellModelFromSharedType)(type, { notebook: this });
                    c.setUndoManager();
                    this._ycellMapping.set(type, c);
                }
            });
            event.changes.deleted.forEach(item => {
                const type = item.content.type;
                const model = this._ycellMapping.get(type);
                if (model) {
                    model.dispose();
                    this._ycellMapping.delete(type);
                }
            });
            let index = 0;
            // this reflects the event.changes.delta, but replaces the content of delta.insert with ycells
            const cellsChange = [];
            event.changes.delta.forEach((d) => {
                if (d.insert != null) {
                    const insertedCells = d.insert.map((ycell) => this._ycellMapping.get(ycell));
                    cellsChange.push({ insert: insertedCells });
                    this.cells.splice(index, 0, ...insertedCells);
                    index += d.insert.length;
                }
                else if (d.delete != null) {
                    cellsChange.push(d);
                    this.cells.splice(index, d.delete);
                }
                else if (d.retain != null) {
                    cellsChange.push(d);
                    index += d.retain;
                }
            });
            this._changed.emit({
                cellsChange: cellsChange
            });
        };
        this._metadataChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_1__.Signal(this);
        /**
         * Internal Yjs cells list
         */
        this._ycells = this.ydoc.getArray('cells');
        this._ycellMapping = new WeakMap();
        this._disableDocumentWideUndoRedo =
            (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : false;
        this.cells = this._ycells.toArray().map(ycell => {
            if (!this._ycellMapping.has(ycell)) {
                this._ycellMapping.set(ycell, (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCellModelFromSharedType)(ycell, { notebook: this }));
            }
            return this._ycellMapping.get(ycell);
        });
        this.undoManager.addToScope(this._ycells);
        this._ycells.observe(this._onYCellsChanged);
        this.ymeta.observeDeep(this._onMetaChanged);
    }
    /**
     * Creates a standalone YNotebook
     *
     * Note: This method is useful when we need to initialize
     * the YNotebook from the JavaScript side.
     */
    static create(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const ynotebook = new YNotebook({
            disableDocumentWideUndoRedo: (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : false
        });
        const data = {
            cells: (_c = (_b = options.data) === null || _b === void 0 ? void 0 : _b.cells) !== null && _c !== void 0 ? _c : [],
            nbformat: (_e = (_d = options.data) === null || _d === void 0 ? void 0 : _d.nbformat) !== null && _e !== void 0 ? _e : 4,
            nbformat_minor: (_g = (_f = options.data) === null || _f === void 0 ? void 0 : _f.nbformat_minor) !== null && _g !== void 0 ? _g : 5,
            metadata: (_j = (_h = options.data) === null || _h === void 0 ? void 0 : _h.metadata) !== null && _j !== void 0 ? _j : {}
        };
        ynotebook.fromJSON(data);
        return ynotebook;
    }
    /**
     * Wether the undo/redo logic should be
     * considered on the full document across all cells.
     *
     * Default: false
     */
    get disableDocumentWideUndoRedo() {
        return this._disableDocumentWideUndoRedo;
    }
    /**
     * Notebook metadata
     */
    get metadata() {
        return this.getMetadata();
    }
    set metadata(v) {
        this.setMetadata(v);
    }
    /**
     * Signal triggered when a metadata changes.
     */
    get metadataChanged() {
        return this._metadataChanged;
    }
    /**
     * nbformat major version
     */
    get nbformat() {
        return this.ymeta.get('nbformat');
    }
    set nbformat(value) {
        this.transact(() => {
            this.ymeta.set('nbformat', value);
        }, false);
    }
    /**
     * nbformat minor version
     */
    get nbformat_minor() {
        return this.ymeta.get('nbformat_minor');
    }
    set nbformat_minor(value) {
        this.transact(() => {
            this.ymeta.set('nbformat_minor', value);
        }, false);
    }
    /**
     * Dispose of the resources.
     */
    dispose() {
        if (this.isDisposed) {
            return;
        }
        this._ycells.unobserve(this._onYCellsChanged);
        this.ymeta.unobserveDeep(this._onMetaChanged);
        super.dispose();
    }
    /**
     * Get a shared cell by index.
     *
     * @param index: Cell's position.
     *
     * @returns The requested shared cell.
     */
    getCell(index) {
        return this.cells[index];
    }
    /**
     * Add a shared cell at the notebook bottom.
     *
     * @param cell Cell to add.
     *
     * @returns The added cell.
     */
    addCell(cell) {
        return this.insertCell(this._ycells.length, cell);
    }
    /**
     * Insert a shared cell into a specific position.
     *
     * @param index: Cell's position.
     * @param cell: Cell to insert.
     *
     * @returns The inserted cell.
     */
    insertCell(index, cell) {
        return this.insertCells(index, [cell])[0];
    }
    /**
     * Insert a list of shared cells into a specific position.
     *
     * @param index: Position to insert the cells.
     * @param cells: Array of shared cells to insert.
     *
     * @returns The inserted cells.
     */
    insertCells(index, cells) {
        const yCells = cells.map(c => {
            const cell = (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCell)(c, this);
            this._ycellMapping.set(cell.ymodel, cell);
            return cell;
        });
        this.transact(() => {
            this._ycells.insert(index, yCells.map(cell => cell.ymodel));
        });
        yCells.forEach(c => {
            c.setUndoManager();
        });
        return yCells;
    }
    /**
     * Move a cell.
     *
     * @param fromIndex: Index of the cell to move.
     * @param toIndex: New position of the cell.
     */
    moveCell(fromIndex, toIndex) {
        this.moveCells(fromIndex, toIndex);
    }
    /**
     * Move cells.
     *
     * @param fromIndex: Index of the first cells to move.
     * @param toIndex: New position of the first cell (in the current array).
     * @param n: Number of cells to move (default 1)
     */
    moveCells(fromIndex, toIndex, n = 1) {
        // FIXME we need to use yjs move feature to preserve undo history
        const clones = new Array(n)
            .fill(true)
            .map((_, idx) => this.getCell(fromIndex + idx).toJSON());
        this.transact(() => {
            this._ycells.delete(fromIndex, n);
            this._ycells.insert(fromIndex > toIndex ? toIndex : toIndex - n + 1, clones.map(clone => (0,_ycell_js__WEBPACK_IMPORTED_MODULE_4__.createCell)(clone, this).ymodel));
        });
    }
    /**
     * Remove a cell.
     *
     * @param index: Index of the cell to remove.
     */
    deleteCell(index) {
        this.deleteCellRange(index, index + 1);
    }
    /**
     * Remove a range of cells.
     *
     * @param from: The start index of the range to remove (inclusive).
     * @param to: The end index of the range to remove (exclusive).
     */
    deleteCellRange(from, to) {
        // Cells will be removed from the mapping in the model event listener.
        this.transact(() => {
            this._ycells.delete(from, to - from);
        });
    }
    /**
     * Delete a metadata notebook.
     *
     * @param key The key to delete
     */
    deleteMetadata(key) {
        if (typeof this.getMetadata(key) === 'undefined') {
            return;
        }
        const allMetadata = this.metadata;
        delete allMetadata[key];
        this.setMetadata(allMetadata);
    }
    getMetadata(key) {
        const ymetadata = this.ymeta.get('metadata');
        // Transiently the metadata can be missing - like during destruction
        if (ymetadata === undefined) {
            return undefined;
        }
        if (typeof key === 'string') {
            const value = ymetadata.get(key);
            return typeof value === 'undefined'
                ? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`
                : _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(value);
        }
        else {
            return _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(ymetadata.toJSON());
        }
    }
    setMetadata(metadata, value) {
        var _a;
        if (typeof metadata === 'string') {
            if (typeof value === 'undefined') {
                throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);
            }
            if (_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual((_a = this.getMetadata(metadata)) !== null && _a !== void 0 ? _a : null, value)) {
                return;
            }
            const update = {};
            update[metadata] = value;
            this.updateMetadata(update);
        }
        else {
            if (!this.metadata || !_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepEqual(this.metadata, metadata)) {
                const clone = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(metadata);
                const ymetadata = this.ymeta.get('metadata');
                // Transiently the metadata can be missing - like during destruction
                if (ymetadata === undefined) {
                    return undefined;
                }
                this.transact(() => {
                    ymetadata.clear();
                    for (const [key, value] of Object.entries(clone)) {
                        ymetadata.set(key, value);
                    }
                });
            }
        }
    }
    /**
     * Updates the metadata associated with the notebook.
     *
     * @param value: Metadata's attribute to update.
     */
    updateMetadata(value) {
        // TODO: Maybe modify only attributes instead of replacing the whole metadata?
        const clone = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.JSONExt.deepCopy(value);
        const ymetadata = this.ymeta.get('metadata');
        // Transiently the metadata can be missing - like during destruction
        if (ymetadata === undefined) {
            return undefined;
        }
        this.transact(() => {
            for (const [key, value] of Object.entries(clone)) {
                ymetadata.set(key, value);
            }
        });
    }
    /**
     * Override the notebook with a JSON-serialized document.
     *
     * @param value The notebook
     */
    fromJSON(value) {
        this.transact(() => {
            this.nbformat = value.nbformat;
            this.nbformat_minor = value.nbformat_minor;
            const metadata = value.metadata;
            if (metadata['orig_nbformat'] !== undefined) {
                delete metadata['orig_nbformat'];
            }
            if (!this.metadata) {
                const ymetadata = new yjs__WEBPACK_IMPORTED_MODULE_2__.Map();
                for (const [key, value] of Object.entries(metadata)) {
                    ymetadata.set(key, value);
                }
                this.ymeta.set('metadata', ymetadata);
            }
            else {
                this.metadata = metadata;
            }
            const useId = value.nbformat === 4 && value.nbformat_minor >= 5;
            const ycells = value.cells.map(cell => {
                if (!useId) {
                    delete cell.id;
                }
                return cell;
            });
            this.insertCells(this.cells.length, ycells);
            this.deleteCellRange(0, this.cells.length);
        });
    }
    /**
     * Serialize the model to JSON.
     */
    toJSON() {
        // strip cell ids if we have notebook format 4.0-4.4
        const pruneCellId = this.nbformat === 4 && this.nbformat_minor <= 4;
        return {
            metadata: this.metadata,
            nbformat_minor: this.nbformat_minor,
            nbformat: this.nbformat,
            cells: this.cells.map(c => {
                const raw = c.toJSON();
                if (pruneCellId) {
                    delete raw.id;
                }
                return raw;
            })
        };
    }
}
//# sourceMappingURL=ynotebook.js.map

/***/ }),

/***/ "../node_modules/@jupyter/ydoc/lib/ytext.js":
/*!**************************************************!*\
  !*** ../node_modules/@jupyter/ydoc/lib/ytext.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* -----------------------------------------------------------------------------
| Copyright (c) Jupyter Development Team.
| Distributed under the terms of the Modified BSD License.
|----------------------------------------------------------------------------*/

//# sourceMappingURL=ytext.js.map

/***/ }),

/***/ "../node_modules/process/browser.js":
/*!******************************************!*\
  !*** ../node_modules/process/browser.js ***!
  \******************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../node_modules/y-protocols/awareness.js":
/*!************************************************!*\
  !*** ../node_modules/y-protocols/awareness.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Awareness": () => (/* binding */ Awareness),
/* harmony export */   "applyAwarenessUpdate": () => (/* binding */ applyAwarenessUpdate),
/* harmony export */   "encodeAwarenessUpdate": () => (/* binding */ encodeAwarenessUpdate),
/* harmony export */   "modifyAwarenessUpdate": () => (/* binding */ modifyAwarenessUpdate),
/* harmony export */   "outdatedTimeout": () => (/* binding */ outdatedTimeout),
/* harmony export */   "removeAwarenessStates": () => (/* binding */ removeAwarenessStates)
/* harmony export */ });
/* harmony import */ var lib0_encoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/encoding */ "../node_modules/lib0/encoding.js");
/* harmony import */ var lib0_decoding__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lib0/decoding */ "../node_modules/lib0/decoding.js");
/* harmony import */ var lib0_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/time */ "../node_modules/lib0/time.js");
/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lib0/math */ "../node_modules/lib0/math.js");
/* harmony import */ var lib0_observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/observable */ "../node_modules/lib0/observable.js");
/* harmony import */ var lib0_function__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/function */ "../node_modules/lib0/function.js");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ "webpack/sharing/consume/default/yjs/yjs");
/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(yjs__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @module awareness-protocol
 */







 // eslint-disable-line

const outdatedTimeout = 30000

/**
 * @typedef {Object} MetaClientState
 * @property {number} MetaClientState.clock
 * @property {number} MetaClientState.lastUpdated unix timestamp
 */

/**
 * The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information
 * (cursor, username, status, ..). Each client can update its own local state and listen to state changes of
 * remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.
 *
 * Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override
 * its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is
 * applied if the known state of that client is older than the new state (`clock < newClock`). If a client thinks that
 * a remote client is offline, it may propagate a message with
 * `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a
 * message is received, and the known clock of that client equals the received clock, it will override the state with `null`.
 *
 * Before a client disconnects, it should propagate a `null` state with an updated clock.
 *
 * Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.
 *
 * @extends {Observable<string>}
 */
class Awareness extends lib0_observable__WEBPACK_IMPORTED_MODULE_1__.Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor (doc) {
    super()
    this.doc = doc
    /**
     * @type {number}
     */
    this.clientID = doc.clientID
    /**
     * Maps from client id to client state
     * @type {Map<number, Object<string, any>>}
     */
    this.states = new Map()
    /**
     * @type {Map<number, MetaClientState>}
     */
    this.meta = new Map()
    this._checkInterval = /** @type {any} */ (setInterval(() => {
      const now = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
      if (this.getLocalState() !== null && (outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {
        // renew local clock
        this.setLocalState(this.getLocalState())
      }
      /**
       * @type {Array<number>}
       */
      const remove = []
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid)
        }
      })
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, 'timeout')
      }
    }, lib0_math__WEBPACK_IMPORTED_MODULE_3__.floor(outdatedTimeout / 10)))
    doc.on('destroy', () => {
      this.destroy()
    })
    this.setLocalState({})
  }

  destroy () {
    this.emit('destroy', [this])
    this.setLocalState(null)
    super.destroy()
    clearInterval(this._checkInterval)
  }

  /**
   * @return {Object<string,any>|null}
   */
  getLocalState () {
    return this.states.get(this.clientID) || null
  }

  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState (state) {
    const clientID = this.clientID
    const currLocalMeta = this.meta.get(clientID)
    const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1
    const prevState = this.states.get(clientID)
    if (state === null) {
      this.states.delete(clientID)
    } else {
      this.states.set(clientID, state)
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
    })
    const added = []
    const updated = []
    const filteredUpdated = []
    const removed = []
    if (state === null) {
      removed.push(clientID)
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID)
      }
    } else {
      updated.push(clientID)
      if (!lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID)
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])
    }
    this.emit('update', [{ added, updated, removed }, 'local'])
  }

  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField (field, value) {
    const state = this.getLocalState()
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      })
    }
  }

  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates () {
    return this.states
  }
}

/**
 * Mark (remote) clients as inactive and remove them from the list of active peers.
 * This change will be propagated to remote clients.
 *
 * @param {Awareness} awareness
 * @param {Array<number>} clients
 * @param {any} origin
 */
const removeAwarenessStates = (awareness, clients, origin) => {
  const removed = []
  for (let i = 0; i < clients.length; i++) {
    const clientID = clients[i]
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID)
      if (clientID === awareness.clientID) {
        const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
        })
      }
      removed.push(clientID)
    }
  }
  if (removed.length > 0) {
    awareness.emit('change', [{ added: [], updated: [], removed }, origin])
    awareness.emit('update', [{ added: [], updated: [], removed }, origin])
  }
}

/**
 * @param {Awareness} awareness
 * @param {Array<number>} clients
 * @return {Uint8Array}
 */
const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.createEncoder()
  lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, len)
  for (let i = 0; i < len; i++) {
    const clientID = clients[i]
    const state = states.get(clientID) || null
    const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clientID)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clock)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarString(encoder, JSON.stringify(state))
  }
  return lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder)
}

/**
 * Modify the content of an awareness update before re-encoding it to an awareness update.
 *
 * This might be useful when you have a central server that wants to ensure that clients
 * cant hijack somebody elses identity.
 *
 * @param {Uint8Array} update
 * @param {function(any):any} modify
 * @return {Uint8Array}
 */
const modifyAwarenessUpdate = (update, modify) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.createDecoder(update)
  const encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.createEncoder()
  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
  lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, len)
  for (let i = 0; i < len; i++) {
    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarString(decoder))
    const modifiedState = modify(state)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clientID)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarUint(encoder, clock)
    lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.writeVarString(encoder, JSON.stringify(modifiedState))
  }
  return lib0_encoding__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder)
}

/**
 * @param {Awareness} awareness
 * @param {Uint8Array} update
 * @param {any} origin This will be added to the emitted change event
 */
const applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.createDecoder(update)
  const timestamp = lib0_time__WEBPACK_IMPORTED_MODULE_2__.getUnixTime()
  const added = []
  const updated = []
  const filteredUpdated = []
  const removed = []
  const len = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
  for (let i = 0; i < len; i++) {
    const clientID = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    let clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarUint(decoder)
    const state = JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_6__.readVarString(decoder))
    const clientMeta = awareness.meta.get(clientID)
    const prevState = awareness.states.get(clientID)
    const currClock = clientMeta === undefined ? 0 : clientMeta.clock
    if (currClock < clock || (currClock === clock && state === null && awareness.states.has(clientID))) {
      if (state === null) {
        // never let a remote client remove this local state
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          // remote client removed the local state. Do not remote state. Broadcast a message indicating
          // that this client still exists by increasing the clock
          clock++
        } else {
          awareness.states.delete(clientID)
        }
      } else {
        awareness.states.set(clientID, state)
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      })
      if (clientMeta === undefined && state !== null) {
        added.push(clientID)
      } else if (clientMeta !== undefined && state === null) {
        removed.push(clientID)
      } else if (state !== null) {
        if (!lib0_function__WEBPACK_IMPORTED_MODULE_4__.equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID)
        }
        updated.push(clientID)
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit('change', [{
      added, updated: filteredUpdated, removed
    }, origin])
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit('update', [{
      added, updated, removed
    }, origin])
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlcl95ZG9jX2xpYl9pbmRleF9qcy1ub2RlX21vZHVsZXNfcHJvY2Vzc19icm93c2VyX2pzLmU3OTVmY2QwYTllNjI4NDQyNTg3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNVO0FBQ1Y7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDVTtBQUNWOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDeUI7QUFDRTtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDa0U7QUFDakc7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixJQUFJO0FBQ0o7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNrRDtBQUNQO0FBQ087QUFDekI7QUFDekI7QUFDQTtBQUNBO0FBQ08seURBQXlEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVCQUF1QixvQ0FBSztBQUM1Qix3QkFBd0IscUNBQU07QUFDOUIsMEJBQTBCLG9DQUFLO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSx5REFBVTtBQUMvRTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsVUFBVTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsc0NBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxVQUFVO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBeUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxxREFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxREFBTTtBQUNsQyw2QkFBNkIscURBQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0NBQUs7QUFDakM7QUFDQSxrQ0FBa0MsNERBQVM7QUFDM0Msb0NBQW9DLDRDQUFhO0FBQ2pEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNENBQWE7QUFDakQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBZ0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2h5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDRDtBQUNPO0FBQ3pCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixpQ0FBaUMsYUFBYTtBQUM5QztBQUNBLDRCQUE0QixxREFBTTtBQUNsQztBQUNBLDZCQUE2QixxREFB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFVO0FBQ25DO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLHFEQUFVO0FBQy9HLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVELGtCQUFrQiwrREFBZ0I7QUFDbEM7QUFDQTtBQUNBLG1CQUFtQiwrREFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFVBQVUsdUJBQXVCO0FBQzNGO0FBQ0EsZ0JBQWdCLGdFQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnRUFBaUI7QUFDcEQsOEJBQThCLCtEQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrREFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvQ0FBSztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDcGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ1U7QUFDVjs7Ozs7Ozs7OztBQ0xBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZMN0I7QUFDQTtBQUNBOztBQUV5QztBQUNBO0FBQ1I7QUFDQTtBQUNXO0FBQ1Y7QUFDVjs7QUFFakI7O0FBRVA7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhEQUE4RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDTyx3QkFBd0IsdURBQVU7QUFDekM7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDLGtCQUFrQixrREFBZ0I7QUFDbEMscUZBQXFGLHFCQUFxQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSyxFQUFFLDRDQUFVO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQWdCO0FBQ25DLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsV0FBVyx1REFBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwwQ0FBMEM7QUFDdkU7QUFDQSwyQkFBMkIseUJBQXlCO0FBQ3BEOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsS0FBSztBQUNoQjtBQUNPO0FBQ1A7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGlCQUFpQjtBQUNwRDtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFnQjtBQUN2QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakUsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsZUFBZTtBQUMxQixZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0Esa0JBQWtCLHdEQUFzQjtBQUN4QyxFQUFFLHVEQUFxQjtBQUN2QixrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QyxJQUFJLHVEQUFxQjtBQUN6QixJQUFJLHVEQUFxQjtBQUN6QixJQUFJLHlEQUF1QjtBQUMzQjtBQUNBLFNBQVMsdURBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixXQUFXLG1CQUFtQjtBQUM5QixZQUFZO0FBQ1o7QUFDTztBQUNQLGtCQUFrQix3REFBc0I7QUFDeEMsa0JBQWtCLHdEQUFzQjtBQUN4QyxjQUFjLHNEQUFvQjtBQUNsQyxFQUFFLHVEQUFxQjtBQUN2QixrQkFBa0IsU0FBUztBQUMzQixxQkFBcUIsc0RBQW9CO0FBQ3pDLGtCQUFrQixzREFBb0I7QUFDdEMsNkJBQTZCLHdEQUFzQjtBQUNuRDtBQUNBLElBQUksdURBQXFCO0FBQ3pCLElBQUksdURBQXFCO0FBQ3pCLElBQUkseURBQXVCO0FBQzNCO0FBQ0EsU0FBUyx1REFBcUI7QUFDOUI7O0FBRUE7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsS0FBSztBQUNoQjtBQUNPO0FBQ1Asa0JBQWtCLHdEQUFzQjtBQUN4QyxvQkFBb0Isa0RBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzREFBb0I7QUFDbEMsa0JBQWtCLFNBQVM7QUFDM0IscUJBQXFCLHNEQUFvQjtBQUN6QyxnQkFBZ0Isc0RBQW9CO0FBQ3BDLDZCQUE2Qix3REFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1IsYUFBYSx1REFBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGp1cHl0ZXIveWRvYy9saWIvYXBpLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGp1cHl0ZXIveWRvYy9saWIvYXdhcmVuZXNzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGp1cHl0ZXIveWRvYy9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9AanVweXRlci95ZG9jL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0BqdXB5dGVyL3lkb2MvbGliL3ljZWxsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGp1cHl0ZXIveWRvYy9saWIveWRvY3VtZW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGp1cHl0ZXIveWRvYy9saWIveWZpbGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9AanVweXRlci95ZG9jL2xpYi95bm90ZWJvb2suanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9AanVweXRlci95ZG9jL2xpYi95dGV4dC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL3ktcHJvdG9jb2xzL2F3YXJlbmVzcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCIvLyBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG5leHBvcnQge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hd2FyZW5lc3MuanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSB5ZG9jXG4gKi9cbmV4cG9ydCAqIGZyb20gJy4vYXBpLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9hd2FyZW5lc3MuanMnO1xuZXhwb3J0ICogZnJvbSAnLi95dGV4dC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3lkb2N1bWVudC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL3lmaWxlLmpzJztcbmV4cG9ydCAqIGZyb20gJy4veW5vdGVib29rLmpzJztcbmV4cG9ydCB7IFlCYXNlQ2VsbCwgWVJhd0NlbGwsIFlNYXJrZG93bkNlbGwsIFlDb2RlQ2VsbCwgY3JlYXRlU3RhbmRhbG9uZUNlbGwgfSBmcm9tICcuL3ljZWxsLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IENvcHlyaWdodCAoYykgSnVweXRlciBEZXZlbG9wbWVudCBUZWFtLlxufCBEaXN0cmlidXRlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1vZGlmaWVkIEJTRCBMaWNlbnNlLlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRZTWFwRXZlbnRUb01hcENoYW5nZShldmVudCkge1xuICAgIGxldCBjaGFuZ2VzID0gbmV3IE1hcCgpO1xuICAgIGV2ZW50LmNoYW5nZXMua2V5cy5mb3JFYWNoKChldmVudCwga2V5KSA9PiB7XG4gICAgICAgIGNoYW5nZXMuc2V0KGtleSwge1xuICAgICAgICAgICAgYWN0aW9uOiBldmVudC5hY3Rpb24sXG4gICAgICAgICAgICBvbGRWYWx1ZTogZXZlbnQub2xkVmFsdWUsXG4gICAgICAgICAgICBuZXdWYWx1ZTogdGhpcy55bWV0YS5nZXQoa2V5KVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0eTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbXV0ZXggPSBjcmVhdGVNdXRleCgpXG4gKiBtdXRleCgoKSA9PiB7XG4gKiAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgaW1tZWRpYXRlbHkgZXhlY3V0ZWRcbiAqICAgbXV0ZXgoKCkgPT4ge1xuICogICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkLCBhcyB0aGUgbXV0ZXggaXMgYWxyZWFkeSBhY3RpdmUuXG4gKiAgIH0pXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNdXRleCA9ICgpID0+IHtcbiAgICBsZXQgdG9rZW4gPSB0cnVlO1xuICAgIHJldHVybiAoZikgPT4ge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRva2VuID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRva2VuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBKU09ORXh0LCBVVUlEIH0gZnJvbSAnQGx1bWluby9jb3JldXRpbHMnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuaW1wb3J0IHsgQXdhcmVuZXNzIH0gZnJvbSAneS1wcm90b2NvbHMvYXdhcmVuZXNzJztcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IHNoYXJlZCBjZWxsIG1vZGVsIGdpdmVuIHRoZSBZSlMgc2hhcmVkIHR5cGUuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVDZWxsTW9kZWxGcm9tU2hhcmVkVHlwZSA9ICh0eXBlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUuZ2V0KCdjZWxsX3R5cGUnKSkge1xuICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgWUNvZGVDZWxsKHR5cGUsIHR5cGUuZ2V0KCdzb3VyY2UnKSwgdHlwZS5nZXQoJ291dHB1dHMnKSwgb3B0aW9ucyk7XG4gICAgICAgIGNhc2UgJ21hcmtkb3duJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgWU1hcmtkb3duQ2VsbCh0eXBlLCB0eXBlLmdldCgnc291cmNlJyksIG9wdGlvbnMpO1xuICAgICAgICBjYXNlICdyYXcnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBZUmF3Q2VsbCh0eXBlLCB0eXBlLmdldCgnc291cmNlJyksIG9wdGlvbnMpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1bmtub3duIGNlbGwgdHlwZScpO1xuICAgIH1cbn07XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBjZWxsIHRoYXQgY2FuIGJlIGluc2VydGVkIGluIGFuIGV4aXN0aW5nIHNoYXJlZCBtb2RlbC5cbiAqXG4gKiBJZiBubyBub3RlYm9vayBpcyBzcGVjaWZpZWQgdGhlIGNlbGwgd2lsbCBiZSBzdGFuZGFsb25lLlxuICpcbiAqIEBwYXJhbSBjZWxsIENlbGwgSlNPTiByZXByZXNlbnRhdGlvblxuICogQHBhcmFtIG5vdGVib29rIE5vdGVib29rIHRvIHdoaWNoIHRoZSBjZWxsIHdpbGwgYmUgYWRkZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUNlbGwgPSAoY2VsbCwgbm90ZWJvb2spID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHltb2RlbCA9IG5ldyBZLk1hcCgpO1xuICAgIGNvbnN0IHlzb3VyY2UgPSBuZXcgWS5UZXh0KCk7XG4gICAgY29uc3QgeW1ldGFkYXRhID0gbmV3IFkuTWFwKCk7XG4gICAgeW1vZGVsLnNldCgnc291cmNlJywgeXNvdXJjZSk7XG4gICAgeW1vZGVsLnNldCgnbWV0YWRhdGEnLCB5bWV0YWRhdGEpO1xuICAgIHltb2RlbC5zZXQoJ2NlbGxfdHlwZScsIGNlbGwuY2VsbF90eXBlKTtcbiAgICB5bW9kZWwuc2V0KCdpZCcsIChfYSA9IGNlbGwuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFVVSUQudXVpZDQoKSk7XG4gICAgbGV0IHljZWxsO1xuICAgIHN3aXRjaCAoY2VsbC5jZWxsX3R5cGUpIHtcbiAgICAgICAgY2FzZSAnbWFya2Rvd24nOiB7XG4gICAgICAgICAgICB5Y2VsbCA9IG5ldyBZTWFya2Rvd25DZWxsKHltb2RlbCwgeXNvdXJjZSwgeyBub3RlYm9vayB9LCB5bWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKGNlbGwuYXR0YWNobWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHljZWxsLnNldEF0dGFjaG1lbnRzKGNlbGwuYXR0YWNobWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29kZSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHlvdXRwdXRzID0gbmV3IFkuQXJyYXkoKTtcbiAgICAgICAgICAgIHltb2RlbC5zZXQoJ291dHB1dHMnLCB5b3V0cHV0cyk7XG4gICAgICAgICAgICB5Y2VsbCA9IG5ldyBZQ29kZUNlbGwoeW1vZGVsLCB5c291cmNlLCB5b3V0cHV0cywge1xuICAgICAgICAgICAgICAgIG5vdGVib29rXG4gICAgICAgICAgICB9LCB5bWV0YWRhdGEpO1xuICAgICAgICAgICAgY29uc3QgY0NlbGwgPSBjZWxsO1xuICAgICAgICAgICAgeWNlbGwuZXhlY3V0aW9uX2NvdW50ID0gKF9iID0gY0NlbGwuZXhlY3V0aW9uX2NvdW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgICAgICAgICAgaWYgKGNDZWxsLm91dHB1dHMpIHtcbiAgICAgICAgICAgICAgICB5Y2VsbC5zZXRPdXRwdXRzKGNDZWxsLm91dHB1dHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgLy8gcmF3XG4gICAgICAgICAgICB5Y2VsbCA9IG5ldyBZUmF3Q2VsbCh5bW9kZWwsIHlzb3VyY2UsIHsgbm90ZWJvb2sgfSwgeW1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChjZWxsLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAgICAgeWNlbGwuc2V0QXR0YWNobWVudHMoY2VsbC5hdHRhY2htZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2VsbC5tZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHljZWxsLnNldE1ldGFkYXRhKGNlbGwubWV0YWRhdGEpO1xuICAgIH1cbiAgICBpZiAoY2VsbC5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICB5Y2VsbC5zZXRTb3VyY2UodHlwZW9mIGNlbGwuc291cmNlID09PSAnc3RyaW5nJyA/IGNlbGwuc291cmNlIDogY2VsbC5zb3VyY2Uuam9pbignJykpO1xuICAgIH1cbiAgICByZXR1cm4geWNlbGw7XG59O1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgY2VsbCB0aGF0IGNhbm5vdCBiZSBpbnNlcnRlZCBpbiBhbiBleGlzdGluZyBzaGFyZWQgbW9kZWwuXG4gKlxuICogQHBhcmFtIGNlbGwgQ2VsbCBKU09OIHJlcHJlc2VudGF0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTdGFuZGFsb25lQ2VsbCA9IChjZWxsKSA9PiBjcmVhdGVDZWxsKGNlbGwpO1xuZXhwb3J0IGNsYXNzIFlCYXNlQ2VsbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFlDZWxsIHRoYXQgd29ya3Mgc3RhbmRhbG9uZS4gSXQgY2Fubm90IGJlXG4gICAgICogaW5zZXJ0ZWQgaW50byBhIFlOb3RlYm9vayBiZWNhdXNlIHRoZSBZanMgbW9kZWwgaXMgYWxyZWFkeVxuICAgICAqIGF0dGFjaGVkIHRvIGFuIGFub255bW91cyBZLkRvYyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGlkKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDZWxsKHsgaWQsIGNlbGxfdHlwZTogdGhpcy5wcm90b3R5cGUuY2VsbF90eXBlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCYXNlIGNlbGwgY29uc3RydWN0b3JcbiAgICAgKlxuICAgICAqICMjIyBOb3Rlc1xuICAgICAqIERvbid0IHVzZSB0aGUgY29uc3RydWN0b3IgZGlyZWN0bHkgLSBwcmVmZXIgdXNpbmcgYGBZTm90ZWJvb2suaW5zZXJ0Q2VsbGBgXG4gICAgICpcbiAgICAgKiBUaGUgYGB5c291cmNlYGAgaXMgbmVlZGVkIGJlY2F1c2UgYGB5bW9kZWwuZ2V0KCdzb3VyY2UnKWBgIHdpbGxcbiAgICAgKiBub3QgcmV0dXJuIHRoZSByZWFsIHNvdXJjZSBpZiB0aGUgbW9kZWwgaXMgbm90IHlldCBhdHRhY2hlZCB0b1xuICAgICAqIGEgZG9jdW1lbnQuIFJlcXVlc3RpbmcgaXQgZXhwbGljaXRseSBhbGxvd3MgdG8gaW50cm9zcGVjdCBhIG5vbi1lbXB0eVxuICAgICAqIHNvdXJjZSBiZWZvcmUgdGhlIGNlbGwgaXMgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHltb2RlbCBDZWxsIG1hcFxuICAgICAqIEBwYXJhbSB5c291cmNlIENlbGwgc291cmNlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgXFx7IG5vdGVib29rPzogVGhlIG5vdGVib29rIHRoZSBjZWxsIGlzIGF0dGFjaGVkIHRvIFxcfVxuICAgICAqIEBwYXJhbSB5bWV0YWRhdGEgQ2VsbCBtZXRhZGF0YVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHltb2RlbCwgeXNvdXJjZSwgb3B0aW9ucyA9IHt9LCB5bWV0YWRhdGEpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZSBhIGNoYW5nZSB0byB0aGUgeW1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbW9kZWxPYnNlcnZlciA9IChldmVudHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQuZW1pdCh0aGlzLmdldENoYW5nZXMoZXZlbnRzKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbm90ZWJvb2sgdGhhdCB0aGlzIGNlbGwgYmVsb25ncyB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25vdGVib29rID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhbmdlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl91bmRvTWFuYWdlciA9IG51bGw7XG4gICAgICAgIHRoaXMueW1vZGVsID0geW1vZGVsO1xuICAgICAgICB0aGlzLl95c291cmNlID0geXNvdXJjZTtcbiAgICAgICAgdGhpcy5feW1ldGFkYXRhID0geW1ldGFkYXRhICE9PSBudWxsICYmIHltZXRhZGF0YSAhPT0gdm9pZCAwID8geW1ldGFkYXRhIDogdGhpcy55bW9kZWwuZ2V0KCdtZXRhZGF0YScpO1xuICAgICAgICB0aGlzLl9wcmV2U291cmNlTGVuZ3RoID0geXNvdXJjZSA/IHlzb3VyY2UubGVuZ3RoIDogMDtcbiAgICAgICAgdGhpcy5fbm90ZWJvb2sgPSBudWxsO1xuICAgICAgICB0aGlzLl9hd2FyZW5lc3MgPSBudWxsO1xuICAgICAgICB0aGlzLl91bmRvTWFuYWdlciA9IG51bGw7XG4gICAgICAgIGlmIChvcHRpb25zLm5vdGVib29rKSB7XG4gICAgICAgICAgICB0aGlzLl9ub3RlYm9vayA9IG9wdGlvbnMubm90ZWJvb2s7XG4gICAgICAgICAgICAvLyBXZSBjYW5ub3QgY3JlYXRlIGEgdW5kbyBtYW5hZ2VyIHdpdGggdGhlIGNlbGwgbm90IHlldCBhdHRhY2hlZCBpbiB0aGUgbm90ZWJvb2tcbiAgICAgICAgICAgIC8vIHNvIHdlIGRlZmVyIHRoYXQgdG8gdGhlIG5vdGVib29rIGluc2VydENlbGwgbWV0aG9kXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTdGFuZGFsb25lIGNlbGxcbiAgICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBZLkRvYygpO1xuICAgICAgICAgICAgZG9jLmdldEFycmF5KCkuaW5zZXJ0KDAsIFt0aGlzLnltb2RlbF0pO1xuICAgICAgICAgICAgdGhpcy5fYXdhcmVuZXNzID0gbmV3IEF3YXJlbmVzcyhkb2MpO1xuICAgICAgICAgICAgdGhpcy5fdW5kb01hbmFnZXIgPSBuZXcgWS5VbmRvTWFuYWdlcihbdGhpcy55bW9kZWxdLCB7XG4gICAgICAgICAgICAgICAgdHJhY2tlZE9yaWdpbnM6IG5ldyBTZXQoW3RoaXNdKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55bW9kZWwub2JzZXJ2ZURlZXAodGhpcy5fbW9kZWxPYnNlcnZlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENlbGwgbm90ZWJvb2sgYXdhcmVuZXNzIG9yIG51bGwgaWYgdGhlIGNlbGwgaXMgc3RhbmRhbG9uZS5cbiAgICAgKi9cbiAgICBnZXQgYXdhcmVuZXNzKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIChfYyA9IChfYSA9IHRoaXMuX2F3YXJlbmVzcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gdGhpcy5ub3RlYm9vaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmF3YXJlbmVzcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGNlbGwuXG4gICAgICovXG4gICAgZ2V0IGNlbGxfdHlwZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIFlCYXNlQ2VsbCBtdXN0IG5vdCBiZSBjb25zdHJ1Y3RlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2hhbmdlZCBzaWduYWwuXG4gICAgICovXG4gICAgZ2V0IGNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBjZWxsIGlzIGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIGdldCBkaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc3Bvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDZWxsIGlkXG4gICAgICovXG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRJZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBoYXMgYmVlbiBkaXNwb3NlZCBvciBub3QuXG4gICAgICovXG4gICAgZ2V0IGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Rpc3Bvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBjZWxsIGlzIHN0YW5kYWxvbmUgb3Igbm90LlxuICAgICAqXG4gICAgICogSWYgdGhlIGNlbGwgaXMgc3RhbmRhbG9uZS4gSXQgY2Fubm90IGJlXG4gICAgICogaW5zZXJ0ZWQgaW50byBhIFlOb3RlYm9vayBiZWNhdXNlIHRoZSBZanMgbW9kZWwgaXMgYWxyZWFkeVxuICAgICAqIGF0dGFjaGVkIHRvIGFuIGFub255bW91cyBZLkRvYyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXQgaXNTdGFuZGFsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbm90ZWJvb2sgIT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENlbGwgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiAjIyMjIE5vdGVzXG4gICAgICogWW91IHNob3VsZCBwcmVmZXIgdG8gYWNjZXNzIGFuZCBtb2RpZnkgdGhlIHNwZWNpZmljIGtleSBvZiBpbnRlcmVzdC5cbiAgICAgKi9cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKCk7XG4gICAgfVxuICAgIHNldCBtZXRhZGF0YSh2KSB7XG4gICAgICAgIHRoaXMuc2V0TWV0YWRhdGEodik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25hbCB0cmlnZ2VyZWQgd2hlbiB0aGUgY2VsbCBtZXRhZGF0YSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGdldCBtZXRhZGF0YUNoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YUNoYW5nZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBub3RlYm9vayB0aGF0IHRoaXMgY2VsbCBiZWxvbmdzIHRvLlxuICAgICAqL1xuICAgIGdldCBub3RlYm9vaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vdGVib29rO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDZWxsIGlucHV0IGNvbnRlbnQuXG4gICAgICovXG4gICAgZ2V0IHNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlKCk7XG4gICAgfVxuICAgIHNldCBzb3VyY2Uodikge1xuICAgICAgICB0aGlzLnNldFNvdXJjZSh2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNlbGwgdW5kbyBtYW5hZ2VyLlxuICAgICAqL1xuICAgIGdldCB1bmRvTWFuYWdlcigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMubm90ZWJvb2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91bmRvTWFuYWdlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMubm90ZWJvb2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNhYmxlRG9jdW1lbnRXaWRlVW5kb1JlZG8pXG4gICAgICAgICAgICA/IHRoaXMuX3VuZG9NYW5hZ2VyXG4gICAgICAgICAgICA6IHRoaXMubm90ZWJvb2sudW5kb01hbmFnZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlZmVyIHNldHRpbmcgdGhlIHVuZG8gbWFuYWdlciBhcyBpdCByZXF1aXJlcyB0aGVcbiAgICAgKiBjZWxsIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBub3RlYm9vayBZIGRvY3VtZW50LlxuICAgICAqL1xuICAgIHNldFVuZG9NYW5hZ2VyKCkge1xuICAgICAgICBpZiAodGhpcy5fdW5kb01hbmFnZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNlbGwgdW5kbyBtYW5hZ2VyIGlzIGFscmVhZHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9ub3RlYm9vayAmJiB0aGlzLl9ub3RlYm9vay5kaXNhYmxlRG9jdW1lbnRXaWRlVW5kb1JlZG8pIHtcbiAgICAgICAgICAgIHRoaXMuX3VuZG9NYW5hZ2VyID0gbmV3IFkuVW5kb01hbmFnZXIoW3RoaXMueW1vZGVsXSwge1xuICAgICAgICAgICAgICAgIHRyYWNrZWRPcmlnaW5zOiBuZXcgU2V0KFt0aGlzXSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB5c291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feXNvdXJjZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgb2JqZWN0IGNhbiB1bmRvIGNoYW5nZXMuXG4gICAgICovXG4gICAgY2FuVW5kbygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy51bmRvTWFuYWdlciAmJiB0aGlzLnVuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBvYmplY3QgY2FuIHJlZG8gY2hhbmdlcy5cbiAgICAgKi9cbiAgICBjYW5SZWRvKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnVuZG9NYW5hZ2VyICYmIHRoaXMudW5kb01hbmFnZXIucmVkb1N0YWNrLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjaGFuZ2Ugc3RhY2suXG4gICAgICovXG4gICAgY2xlYXJVbmRvSGlzdG9yeSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnVuZG9NYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5kbyBhbiBvcGVyYXRpb24uXG4gICAgICovXG4gICAgdW5kbygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnVuZG9NYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5kbygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWRvIGFuIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICByZWRvKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMudW5kb01hbmFnZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWRvKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgdGhlIHJlc291cmNlcy5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy55bW9kZWwudW5vYnNlcnZlRGVlcCh0aGlzLl9tb2RlbE9ic2VydmVyKTtcbiAgICAgICAgaWYgKHRoaXMuX2F3YXJlbmVzcykge1xuICAgICAgICAgICAgLy8gQSBuZXcgZG9jdW1lbnQgaXMgY3JlYXRlZCBmb3Igc3RhbmRhbG9uZSBjZWxsLlxuICAgICAgICAgICAgY29uc3QgZG9jID0gdGhpcy5fYXdhcmVuZXNzLmRvYztcbiAgICAgICAgICAgIHRoaXMuX2F3YXJlbmVzcy5kZXN0cm95KCk7XG4gICAgICAgICAgICBkb2MuZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl91bmRvTWFuYWdlcikge1xuICAgICAgICAgICAgLy8gQmUgc3VyZSB0byBub3QgZGVzdHJveSB0aGUgZG9jdW1lbnQgdW5kbyBtYW5hZ2VyLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3VuZG9NYW5hZ2VyID09PSAoKF9hID0gdGhpcy5ub3RlYm9vaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVuZG9NYW5hZ2VyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuZG9NYW5hZ2VyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuZG9NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwb3NlZC5lbWl0KCk7XG4gICAgICAgIFNpZ25hbC5jbGVhckRhdGEodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBjZWxsIGlkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQ2VsbCBpZFxuICAgICAqL1xuICAgIGdldElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55bW9kZWwuZ2V0KCdpZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNlbGwncyBzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBDZWxsJ3Mgc291cmNlLlxuICAgICAqL1xuICAgIGdldFNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueXNvdXJjZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGNlbGwncyBzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWU6IE5ldyBzb3VyY2UuXG4gICAgICovXG4gICAgc2V0U291cmNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy55c291cmNlLmRlbGV0ZSgwLCB0aGlzLnlzb3VyY2UubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMueXNvdXJjZS5pbnNlcnQoMCwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQHRvZG8gRG8gd2UgbmVlZCBwcm9wZXIgcmVwbGFjZSBzZW1hbnRpYz8gVGhpcyBsZWFkcyB0byBpc3N1ZXMgaW4gZWRpdG9yIGJpbmRpbmdzIGJlY2F1c2UgdGhleSBkb24ndCBzd2l0Y2ggc291cmNlLlxuICAgICAgICAvLyB0aGlzLnltb2RlbC5zZXQoJ3NvdXJjZScsIG5ldyBZLlRleHQodmFsdWUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSBjb250ZW50IGZyb20gYHN0YXJ0JyB0byBgZW5kYCB3aXRoIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQ6IFRoZSBzdGFydCBpbmRleCBvZiB0aGUgcmFuZ2UgdG8gcmVwbGFjZSAoaW5jbHVzaXZlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmQ6IFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIHRvIHJlcGxhY2UgKGV4Y2x1c2l2ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWU6IE5ldyBzb3VyY2UgKG9wdGlvbmFsKS5cbiAgICAgKi9cbiAgICB1cGRhdGVTb3VyY2Uoc3RhcnQsIGVuZCwgdmFsdWUgPSAnJykge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHlzb3VyY2UgPSB0aGlzLnlzb3VyY2U7XG4gICAgICAgICAgICAvLyBpbnNlcnQgYW5kIHRoZW4gZGVsZXRlLlxuICAgICAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGN1cnNvciBwb3NpdGlvbiBpcyBhZGp1c3RlZCBhZnRlciB0aGUgcmVwbGFjZWQgY29udGVudC5cbiAgICAgICAgICAgIHlzb3VyY2UuaW5zZXJ0KHN0YXJ0LCB2YWx1ZSk7XG4gICAgICAgICAgICB5c291cmNlLmRlbGV0ZShzdGFydCArIHZhbHVlLmxlbmd0aCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGEgbWV0YWRhdGEgY2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBkZWxldGVcbiAgICAgKi9cbiAgICBkZWxldGVNZXRhZGF0YShrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdldE1ldGFkYXRhKGtleSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl95bWV0YWRhdGEuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICBjb25zdCBqdXB5dGVyID0gdGhpcy5nZXRNZXRhZGF0YSgnanVweXRlcicpO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NvbGxhcHNlZCcgJiYganVweXRlcikge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgICAgICAgICAgICBjb25zdCB7IG91dHB1dHNfaGlkZGVuLCAuLi5vdGhlcnMgfSA9IGp1cHl0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG90aGVycykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ltZXRhZGF0YS5kZWxldGUoJ2p1cHl0ZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ltZXRhZGF0YS5zZXQoJ2p1cHl0ZXInLCBvdGhlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2p1cHl0ZXInKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feW1ldGFkYXRhLmRlbGV0ZSgnY29sbGFwc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gICAgZ2V0TWV0YWRhdGEoa2V5KSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gdGhpcy5feW1ldGFkYXRhO1xuICAgICAgICAvLyBUcmFuc2llbnRseSB0aGUgbWV0YWRhdGEgY2FuIGJlIG1pc3NpbmcgLSBsaWtlIGR1cmluZyBkZXN0cnVjdGlvblxuICAgICAgICBpZiAobWV0YWRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWV0YWRhdGEuZ2V0KGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkIC8vIHVuZGVmaW5lZCBpcyBjb252ZXJ0ZWQgdG8gYHt9YCBieSBgSlNPTkV4dC5kZWVwQ29weWBcbiAgICAgICAgICAgICAgICA6IEpTT05FeHQuZGVlcENvcHkobWV0YWRhdGEuZ2V0KGtleSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT05FeHQuZGVlcENvcHkobWV0YWRhdGEudG9KU09OKCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE1ldGFkYXRhKG1ldGFkYXRhLCB2YWx1ZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNZXRhZGF0YSB2YWx1ZSBmb3IgJHttZXRhZGF0YX0gY2Fubm90IGJlICd1bmRlZmluZWQnOyB1c2UgZGVsZXRlTWV0YWRhdGEuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBtZXRhZGF0YTtcbiAgICAgICAgICAgIC8vIE9ubHkgc2V0IG1ldGFkYXRhIGlmIHdlIGNoYW5nZSBzb21ldGhpbmcgdG8gYXZvaWQgaW5maW5pdGVcbiAgICAgICAgICAgIC8vIGxvb3Agb2Ygc2lnbmFsIGNoYW5nZXMuXG4gICAgICAgICAgICBpZiAoSlNPTkV4dC5kZWVwRXF1YWwoKF9hID0gdGhpcy5nZXRNZXRhZGF0YShrZXkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdGhpcy5feW1ldGFkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAnY29sbGFwc2VkJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBqdXB5dGVyID0gKChfYSA9IHRoaXMuZ2V0TWV0YWRhdGEoJ2p1cHl0ZXInKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoanVweXRlci5vdXRwdXRzX2hpZGRlbiAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0TWV0YWRhdGEoJ2p1cHl0ZXInLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uanVweXRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRzX2hpZGRlbjogdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ2p1cHl0ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzSGlkZGVuID0gdmFsdWVbJ291dHB1dHNfaGlkZGVuJ107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXNIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRNZXRhZGF0YSgnY29sbGFwc2VkJykgIT09IGlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRNZXRhZGF0YSgnY29sbGFwc2VkJywgaXNIaWRkZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWxldGVNZXRhZGF0YSgnY29sbGFwc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjbG9uZSA9IEpTT05FeHQuZGVlcENvcHkobWV0YWRhdGEpO1xuICAgICAgICAgICAgaWYgKGNsb25lLmNvbGxhcHNlZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUuanVweXRlciA9IGNsb25lLmp1cHl0ZXIgfHwge307XG4gICAgICAgICAgICAgICAgY2xvbmUuanVweXRlci5vdXRwdXRzX2hpZGRlbiA9IGNsb25lLmNvbGxhcHNlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgoX2IgPSBjbG9uZSA9PT0gbnVsbCB8fCBjbG9uZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xvbmUuanVweXRlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm91dHB1dHNfaGlkZGVuKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xvbmUuY29sbGFwc2VkID0gY2xvbmUuanVweXRlci5vdXRwdXRzX2hpZGRlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSlNPTkV4dC5kZWVwRXF1YWwoY2xvbmUsIHRoaXMuZ2V0TWV0YWRhdGEoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2xvbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl95bWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZSB0aGUgbW9kZWwgdG8gSlNPTi5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5nZXRJZCgpLFxuICAgICAgICAgICAgY2VsbF90eXBlOiB0aGlzLmNlbGxfdHlwZSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLmdldE1ldGFkYXRhKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhIHRyYW5zYWN0aW9uLiBXaGlsZSB0aGUgZnVuY3Rpb24gZiBpcyBjYWxsZWQsIGFsbCBjaGFuZ2VzIHRvIHRoZSBzaGFyZWRcbiAgICAgKiBkb2N1bWVudCBhcmUgYnVuZGxlZCBpbnRvIGEgc2luZ2xlIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGYgVHJhbnNhY3Rpb24gdG8gZXhlY3V0ZVxuICAgICAqIEBwYXJhbSB1bmRvYWJsZSBXaGV0aGVyIHRvIHRyYWNrIHRoZSBjaGFuZ2UgaW4gdGhlIGFjdGlvbiBoaXN0b3J5IG9yIG5vdCAoZGVmYXVsdCBgdHJ1ZWApXG4gICAgICovXG4gICAgdHJhbnNhY3QoZiwgdW5kb2FibGUgPSB0cnVlKSB7XG4gICAgICAgICF0aGlzLm5vdGVib29rIHx8IHRoaXMubm90ZWJvb2suZGlzYWJsZURvY3VtZW50V2lkZVVuZG9SZWRvXG4gICAgICAgICAgICA/IHRoaXMueW1vZGVsLmRvYyA9PSBudWxsXG4gICAgICAgICAgICAgICAgPyBmKClcbiAgICAgICAgICAgICAgICA6IHRoaXMueW1vZGVsLmRvYy50cmFuc2FjdChmLCB1bmRvYWJsZSA/IHRoaXMgOiBudWxsKVxuICAgICAgICAgICAgOiB0aGlzLm5vdGVib29rLnRyYW5zYWN0KGYsIHVuZG9hYmxlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXh0cmFjdCBjaGFuZ2VzIGZyb20gWUpTIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50cyBZSlMgZXZlbnRzXG4gICAgICogQHJldHVybnMgQ2VsbCBjaGFuZ2VzXG4gICAgICovXG4gICAgZ2V0Q2hhbmdlcyhldmVudHMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHt9O1xuICAgICAgICBjb25zdCBzb3VyY2VFdmVudCA9IGV2ZW50cy5maW5kKGV2ZW50ID0+IGV2ZW50LnRhcmdldCA9PT0gdGhpcy55bW9kZWwuZ2V0KCdzb3VyY2UnKSk7XG4gICAgICAgIGlmIChzb3VyY2VFdmVudCkge1xuICAgICAgICAgICAgY2hhbmdlcy5zb3VyY2VDaGFuZ2UgPSBzb3VyY2VFdmVudC5jaGFuZ2VzLmRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhRXZlbnRzID0gZXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLl95bWV0YWRhdGEpO1xuICAgICAgICBpZiAobWV0YWRhdGFFdmVudHMpIHtcbiAgICAgICAgICAgIGNoYW5nZXMubWV0YWRhdGFDaGFuZ2UgPSBtZXRhZGF0YUV2ZW50cy5jaGFuZ2VzLmtleXM7XG4gICAgICAgICAgICBtZXRhZGF0YUV2ZW50cy5jaGFuZ2VzLmtleXMuZm9yRWFjaCgoY2hhbmdlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZS5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IHRoaXMuX3ltZXRhZGF0YS5nZXQoa2V5KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYWRkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGNoYW5nZS5vbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuX3ltZXRhZGF0YS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGNoYW5nZS5vbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZXF1YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2xkVmFsdWUgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG5ld1ZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsID0gSlNPTkV4dC5kZWVwRXF1YWwob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsID0gb2xkVmFsdWUgPT09IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdjaGFuZ2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbEV2ZW50ID0gZXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLnltb2RlbCk7XG4gICAgICAgIC8vIFRoZSBtb2RlbCBhbGxvd3MgdXMgdG8gcmVwbGFjZSB0aGUgY29tcGxldGUgc291cmNlIHdpdGggYSBuZXcgc3RyaW5nLiBXZSBleHByZXNzIHRoaXMgaW4gdGhlIERlbHRhIGZvcm1hdFxuICAgICAgICAvLyBhcyBhIHJlcGxhY2Ugb2YgdGhlIGNvbXBsZXRlIHN0cmluZy5cbiAgICAgICAgY29uc3QgeXNvdXJjZSA9IHRoaXMueW1vZGVsLmdldCgnc291cmNlJyk7XG4gICAgICAgIGlmIChtb2RlbEV2ZW50ICYmIG1vZGVsRXZlbnQua2V5c0NoYW5nZWQuaGFzKCdzb3VyY2UnKSkge1xuICAgICAgICAgICAgY2hhbmdlcy5zb3VyY2VDaGFuZ2UgPSBbXG4gICAgICAgICAgICAgICAgeyBkZWxldGU6IHRoaXMuX3ByZXZTb3VyY2VMZW5ndGggfSxcbiAgICAgICAgICAgICAgICB7IGluc2VydDogeXNvdXJjZS50b1N0cmluZygpIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldlNvdXJjZUxlbmd0aCA9IHlzb3VyY2UubGVuZ3RoO1xuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG59XG4vKipcbiAqIFNoYXJlYWJsZSBjb2RlIGNlbGwuXG4gKi9cbmV4cG9ydCBjbGFzcyBZQ29kZUNlbGwgZXh0ZW5kcyBZQmFzZUNlbGwge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBZQ29kZUNlbGwgdGhhdCB3b3JrcyBzdGFuZGFsb25lLiBJdCBjYW5ub3QgYmVcbiAgICAgKiBpbnNlcnRlZCBpbnRvIGEgWU5vdGVib29rIGJlY2F1c2UgdGhlIFlqcyBtb2RlbCBpcyBhbHJlYWR5XG4gICAgICogYXR0YWNoZWQgdG8gYW4gYW5vbnltb3VzIFkuRG9jIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoaWQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZShpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvZGUgY2VsbCBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogIyMjIE5vdGVzXG4gICAgICogRG9uJ3QgdXNlIHRoZSBjb25zdHJ1Y3RvciBkaXJlY3RseSAtIHByZWZlciB1c2luZyBgYFlOb3RlYm9vay5pbnNlcnRDZWxsYGBcbiAgICAgKlxuICAgICAqIFRoZSBgYHlzb3VyY2VgYCBpcyBuZWVkZWQgYmVjYXVzZSBgYHltb2RlbC5nZXQoJ3NvdXJjZScpYGAgd2lsbFxuICAgICAqIG5vdCByZXR1cm4gdGhlIHJlYWwgc291cmNlIGlmIHRoZSBtb2RlbCBpcyBub3QgeWV0IGF0dGFjaGVkIHRvXG4gICAgICogYSBkb2N1bWVudC4gUmVxdWVzdGluZyBpdCBleHBsaWNpdGx5IGFsbG93cyB0byBpbnRyb3NwZWN0IGEgbm9uLWVtcHR5XG4gICAgICogc291cmNlIGJlZm9yZSB0aGUgY2VsbCBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geW1vZGVsIENlbGwgbWFwXG4gICAgICogQHBhcmFtIHlzb3VyY2UgQ2VsbCBzb3VyY2VcbiAgICAgKiBAcGFyYW0geW91dHB1dHMgQ29kZSBjZWxsIG91dHB1dHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBcXHsgbm90ZWJvb2s/OiBUaGUgbm90ZWJvb2sgdGhlIGNlbGwgaXMgYXR0YWNoZWQgdG8gXFx9XG4gICAgICogQHBhcmFtIHltZXRhZGF0YSBDZWxsIG1ldGFkYXRhXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeW1vZGVsLCB5c291cmNlLCB5b3V0cHV0cywgb3B0aW9ucyA9IHt9LCB5bWV0YWRhdGEpIHtcbiAgICAgICAgc3VwZXIoeW1vZGVsLCB5c291cmNlLCBvcHRpb25zLCB5bWV0YWRhdGEpO1xuICAgICAgICB0aGlzLl95b3V0cHV0cyA9IHlvdXRwdXRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgY2VsbC5cbiAgICAgKi9cbiAgICBnZXQgY2VsbF90eXBlKCkge1xuICAgICAgICByZXR1cm4gJ2NvZGUnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29kZSBjZWxsJ3MgcHJvbXB0IG51bWJlci4gV2lsbCBiZSBudWxsIGlmIHRoZSBjZWxsIGhhcyBub3QgYmVlbiBydW4uXG4gICAgICovXG4gICAgZ2V0IGV4ZWN1dGlvbl9jb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueW1vZGVsLmdldCgnZXhlY3V0aW9uX2NvdW50JykgfHwgbnVsbDtcbiAgICB9XG4gICAgc2V0IGV4ZWN1dGlvbl9jb3VudChjb3VudCkge1xuICAgICAgICAvLyBEbyBub3QgdXNlIGB0aGlzLmV4ZWN1dGlvbl9jb3VudGAuIFdoZW4gaW5pdGlhbGl6aW5nIHRoZVxuICAgICAgICAvLyBjZWxsLCB3ZSBuZWVkIHRvIHNldCBleGVjdXRpb25fY291bnQgdG8gYG51bGxgIGlmIHdlIGNvbXBhcmVcbiAgICAgICAgLy8gdXNpbmcgYHRoaXMuZXhlY3V0aW9uX2NvdW50YCBpdCB3aWxsIHJldHVybiBgbnVsbGAgYW5kIHdlIHdpbGxcbiAgICAgICAgLy8gbmV2ZXIgaW5pdGlhbGl6ZSBpdFxuICAgICAgICBpZiAodGhpcy55bW9kZWwuZ2V0KCdleGVjdXRpb25fY291bnQnKSAhPT0gY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMueW1vZGVsLnNldCgnZXhlY3V0aW9uX2NvdW50JywgY291bnQpO1xuICAgICAgICAgICAgfSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENlbGwgb3V0cHV0cy5cbiAgICAgKi9cbiAgICBnZXQgb3V0cHV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T3V0cHV0cygpO1xuICAgIH1cbiAgICBzZXQgb3V0cHV0cyh2KSB7XG4gICAgICAgIHRoaXMuc2V0T3V0cHV0cyh2KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0aW9uLCBkaXNwbGF5LCBvciBzdHJlYW0gb3V0cHV0cy5cbiAgICAgKi9cbiAgICBnZXRPdXRwdXRzKCkge1xuICAgICAgICByZXR1cm4gSlNPTkV4dC5kZWVwQ29weSh0aGlzLl95b3V0cHV0cy50b0FycmF5KCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIGFsbCBvdXRwdXRzLlxuICAgICAqL1xuICAgIHNldE91dHB1dHMob3V0cHV0cykge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3lvdXRwdXRzLmRlbGV0ZSgwLCB0aGlzLl95b3V0cHV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5feW91dHB1dHMuaW5zZXJ0KDAsIG91dHB1dHMpO1xuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxhY2UgY29udGVudCBmcm9tIGBzdGFydCcgdG8gYGVuZGAgd2l0aCBgb3V0cHV0c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhcnQ6IFRoZSBzdGFydCBpbmRleCBvZiB0aGUgcmFuZ2UgdG8gcmVwbGFjZSAoaW5jbHVzaXZlKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBlbmQ6IFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIHRvIHJlcGxhY2UgKGV4Y2x1c2l2ZSkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3V0cHV0czogTmV3IG91dHB1dHMgKG9wdGlvbmFsKS5cbiAgICAgKi9cbiAgICB1cGRhdGVPdXRwdXRzKHN0YXJ0LCBlbmQsIG91dHB1dHMgPSBbXSkge1xuICAgICAgICBjb25zdCBmaW4gPSBlbmQgPCB0aGlzLl95b3V0cHV0cy5sZW5ndGggPyBlbmQgLSBzdGFydCA6IHRoaXMuX3lvdXRwdXRzLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3lvdXRwdXRzLmRlbGV0ZShzdGFydCwgZmluKTtcbiAgICAgICAgICAgIHRoaXMuX3lvdXRwdXRzLmluc2VydChzdGFydCwgb3V0cHV0cyk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtb2RlbCB0byBKU09OLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnN1cGVyLnRvSlNPTigpLFxuICAgICAgICAgICAgb3V0cHV0czogdGhpcy5nZXRPdXRwdXRzKCksXG4gICAgICAgICAgICBleGVjdXRpb25fY291bnQ6IHRoaXMuZXhlY3V0aW9uX2NvdW50XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4dHJhY3QgY2hhbmdlcyBmcm9tIFlKUyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudHMgWUpTIGV2ZW50c1xuICAgICAqIEByZXR1cm5zIENlbGwgY2hhbmdlc1xuICAgICAqL1xuICAgIGdldENoYW5nZXMoZXZlbnRzKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBzdXBlci5nZXRDaGFuZ2VzKGV2ZW50cyk7XG4gICAgICAgIGNvbnN0IG91dHB1dEV2ZW50ID0gZXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLnltb2RlbC5nZXQoJ291dHB1dHMnKSk7XG4gICAgICAgIGlmIChvdXRwdXRFdmVudCkge1xuICAgICAgICAgICAgY2hhbmdlcy5vdXRwdXRzQ2hhbmdlID0gb3V0cHV0RXZlbnQuY2hhbmdlcy5kZWx0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtb2RlbEV2ZW50ID0gZXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLnltb2RlbCk7XG4gICAgICAgIGlmIChtb2RlbEV2ZW50ICYmIG1vZGVsRXZlbnQua2V5c0NoYW5nZWQuaGFzKCdleGVjdXRpb25fY291bnQnKSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gbW9kZWxFdmVudC5jaGFuZ2VzLmtleXMuZ2V0KCdleGVjdXRpb25fY291bnQnKTtcbiAgICAgICAgICAgIGNoYW5nZXMuZXhlY3V0aW9uQ291bnRDaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IGNoYW5nZS5vbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogdGhpcy55bW9kZWwuZ2V0KCdleGVjdXRpb25fY291bnQnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG59XG5jbGFzcyBZQXR0YWNobWVudENlbGwgZXh0ZW5kcyBZQmFzZUNlbGwge1xuICAgIC8qKlxuICAgICAqIENlbGwgYXR0YWNobWVudHNcbiAgICAgKi9cbiAgICBnZXQgYXR0YWNobWVudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEF0dGFjaG1lbnRzKCk7XG4gICAgfVxuICAgIHNldCBhdHRhY2htZW50cyh2KSB7XG4gICAgICAgIHRoaXMuc2V0QXR0YWNobWVudHModik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNlbGwgYXR0YWNobWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY2VsbCBhdHRhY2htZW50cy5cbiAgICAgKi9cbiAgICBnZXRBdHRhY2htZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueW1vZGVsLmdldCgnYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2VsbCBhdHRhY2htZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIGF0dGFjaG1lbnRzOiBUaGUgY2VsbCBhdHRhY2htZW50cy5cbiAgICAgKi9cbiAgICBzZXRBdHRhY2htZW50cyhhdHRhY2htZW50cykge1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChhdHRhY2htZW50cyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy55bW9kZWwuZGVsZXRlKCdhdHRhY2htZW50cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy55bW9kZWwuc2V0KCdhdHRhY2htZW50cycsIGF0dGFjaG1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0IGNoYW5nZXMgZnJvbSBZSlMgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRzIFlKUyBldmVudHNcbiAgICAgKiBAcmV0dXJucyBDZWxsIGNoYW5nZXNcbiAgICAgKi9cbiAgICBnZXRDaGFuZ2VzKGV2ZW50cykge1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gc3VwZXIuZ2V0Q2hhbmdlcyhldmVudHMpO1xuICAgICAgICBjb25zdCBtb2RlbEV2ZW50ID0gZXZlbnRzLmZpbmQoZXZlbnQgPT4gZXZlbnQudGFyZ2V0ID09PSB0aGlzLnltb2RlbCk7XG4gICAgICAgIGlmIChtb2RlbEV2ZW50ICYmIG1vZGVsRXZlbnQua2V5c0NoYW5nZWQuaGFzKCdhdHRhY2htZW50cycpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBtb2RlbEV2ZW50LmNoYW5nZXMua2V5cy5nZXQoJ2F0dGFjaG1lbnRzJyk7XG4gICAgICAgICAgICBjaGFuZ2VzLmV4ZWN1dGlvbkNvdW50Q2hhbmdlID0ge1xuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBjaGFuZ2Uub2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IHRoaXMueW1vZGVsLmdldCgnYXR0YWNobWVudHMnKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG59XG4vKipcbiAqIFNoYXJlYWJsZSByYXcgY2VsbC5cbiAqL1xuZXhwb3J0IGNsYXNzIFlSYXdDZWxsIGV4dGVuZHMgWUF0dGFjaG1lbnRDZWxsIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgWVJhd0NlbGwgdGhhdCB3b3JrcyBzdGFuZGFsb25lLiBJdCBjYW5ub3QgYmVcbiAgICAgKiBpbnNlcnRlZCBpbnRvIGEgWU5vdGVib29rIGJlY2F1c2UgdGhlIFlqcyBtb2RlbCBpcyBhbHJlYWR5XG4gICAgICogYXR0YWNoZWQgdG8gYW4gYW5vbnltb3VzIFkuRG9jIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoaWQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZShpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmluZyBpZGVudGlmeWluZyB0aGUgdHlwZSBvZiBjZWxsLlxuICAgICAqL1xuICAgIGdldCBjZWxsX3R5cGUoKSB7XG4gICAgICAgIHJldHVybiAncmF3JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtb2RlbCB0byBKU09OLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmdldElkKCksXG4gICAgICAgICAgICBjZWxsX3R5cGU6ICdyYXcnLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmdldFNvdXJjZSgpLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMuZ2V0TWV0YWRhdGEoKSxcbiAgICAgICAgICAgIGF0dGFjaG1lbnRzOiB0aGlzLmdldEF0dGFjaG1lbnRzKClcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKipcbiAqIFNoYXJlYWJsZSBtYXJrZG93biBjZWxsLlxuICovXG5leHBvcnQgY2xhc3MgWU1hcmtkb3duQ2VsbCBleHRlbmRzIFlBdHRhY2htZW50Q2VsbCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IFlNYXJrZG93bkNlbGwgdGhhdCB3b3JrcyBzdGFuZGFsb25lLiBJdCBjYW5ub3QgYmVcbiAgICAgKiBpbnNlcnRlZCBpbnRvIGEgWU5vdGVib29rIGJlY2F1c2UgdGhlIFlqcyBtb2RlbCBpcyBhbHJlYWR5XG4gICAgICogYXR0YWNoZWQgdG8gYW4gYW5vbnltb3VzIFkuRG9jIGluc3RhbmNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoaWQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZShpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmluZyBpZGVudGlmeWluZyB0aGUgdHlwZSBvZiBjZWxsLlxuICAgICAqL1xuICAgIGdldCBjZWxsX3R5cGUoKSB7XG4gICAgICAgIHJldHVybiAnbWFya2Rvd24nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIG1vZGVsIHRvIEpTT04uXG4gICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuZ2V0SWQoKSxcbiAgICAgICAgICAgIGNlbGxfdHlwZTogJ21hcmtkb3duJyxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5nZXRTb3VyY2UoKSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLmdldE1ldGFkYXRhKCksXG4gICAgICAgICAgICBhdHRhY2htZW50czogdGhpcy5nZXRBdHRhY2htZW50cygpXG4gICAgICAgIH07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eWNlbGwuanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBKU09ORXh0IH0gZnJvbSAnQGx1bWluby9jb3JldXRpbHMnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuaW1wb3J0IHsgQXdhcmVuZXNzIH0gZnJvbSAneS1wcm90b2NvbHMvYXdhcmVuZXNzJztcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJztcbi8qKlxuICogR2VuZXJpYyBzaGFyZWFibGUgZG9jdW1lbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBZRG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIGEgY2hhbmdlIHRvIHRoZSB5c3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uU3RhdGVDaGFuZ2VkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZUNoYW5nZSA9IG5ldyBBcnJheSgpO1xuICAgICAgICAgICAgZXZlbnQua2V5c0NoYW5nZWQuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGV2ZW50LmNoYW5nZXMua2V5cy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlQ2hhbmdlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGNoYW5nZS5vbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiB0aGlzLnlzdGF0ZS5nZXQoa2V5KVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQuZW1pdCh7IHN0YXRlQ2hhbmdlIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jaGFuZ2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kaXNwb3NlZCA9IG5ldyBTaWduYWwodGhpcyk7XG4gICAgICAgIHRoaXMuX3lkb2MgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMueWRvYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmV3IFkuRG9jKCk7XG4gICAgICAgIHRoaXMuX3lzdGF0ZSA9IHRoaXMuX3lkb2MuZ2V0TWFwKCdzdGF0ZScpO1xuICAgICAgICB0aGlzLl91bmRvTWFuYWdlciA9IG5ldyBZLlVuZG9NYW5hZ2VyKFtdLCB7XG4gICAgICAgICAgICB0cmFja2VkT3JpZ2luczogbmV3IFNldChbdGhpc10pLFxuICAgICAgICAgICAgZG9jOiB0aGlzLl95ZG9jXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hd2FyZW5lc3MgPSBuZXcgQXdhcmVuZXNzKHRoaXMuX3lkb2MpO1xuICAgICAgICB0aGlzLl95c3RhdGUub2JzZXJ2ZSh0aGlzLm9uU3RhdGVDaGFuZ2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogWUpTIGRvY3VtZW50LlxuICAgICAqL1xuICAgIGdldCB5ZG9jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5feWRvYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hhcmVkIHN0YXRlXG4gICAgICovXG4gICAgZ2V0IHlzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3lzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogWUpTIGRvY3VtZW50IHVuZG8gbWFuYWdlclxuICAgICAqL1xuICAgIGdldCB1bmRvTWFuYWdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VuZG9NYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaGFyZWQgYXdhcmVuZXNzXG4gICAgICovXG4gICAgZ2V0IGF3YXJlbmVzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F3YXJlbmVzcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNoYW5nZWQgc2lnbmFsLlxuICAgICAqL1xuICAgIGdldCBjaGFuZ2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBzaWduYWwgZW1pdHRlZCB3aGVuIHRoZSBkb2N1bWVudCBpcyBkaXNwb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgZGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgZG9jdW1lbnQgaXMgZGlzcG9zZWQgb3Igbm90LlxuICAgICAqL1xuICAgIGdldCBpc0Rpc3Bvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNEaXNwb3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG9jdW1lbnQgc3RhdGVcbiAgICAgKi9cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBKU09ORXh0LmRlZXBDb3B5KHRoaXMueXN0YXRlLnRvSlNPTigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgb2JqZWN0IGNhbiB1bmRvIGNoYW5nZXMuXG4gICAgICovXG4gICAgY2FuVW5kbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIG9iamVjdCBjYW4gcmVkbyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGNhblJlZG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnVuZG9NYW5hZ2VyLnJlZG9TdGFjay5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy55c3RhdGUudW5vYnNlcnZlKHRoaXMub25TdGF0ZUNoYW5nZWQpO1xuICAgICAgICB0aGlzLmF3YXJlbmVzcy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudW5kb01hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnlkb2MuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLl9kaXNwb3NlZC5lbWl0KCk7XG4gICAgICAgIFNpZ25hbC5jbGVhckRhdGEodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgdmFsdWUgZm9yIGEgc3RhdGUgYXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5IEtleSB0byBnZXRcbiAgICAgKi9cbiAgICBnZXRTdGF0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnlzdGF0ZS5nZXQoa2V5KTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gdmFsdWVcbiAgICAgICAgICAgIDogSlNPTkV4dC5kZWVwQ29weSh2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdmFsdWUgb2YgYSBzdGF0ZSBhdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgS2V5IHRvIHNldFxuICAgICAqIEBwYXJhbSB2YWx1ZSBOZXcgYXR0cmlidXRlIHZhbHVlXG4gICAgICovXG4gICAgc2V0U3RhdGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIUpTT05FeHQuZGVlcEVxdWFsKHRoaXMueXN0YXRlLmdldChrZXkpLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMueXN0YXRlLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbmRvIGFuIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICB1bmRvKCkge1xuICAgICAgICB0aGlzLnVuZG9NYW5hZ2VyLnVuZG8oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVkbyBhbiBvcGVyYXRpb24uXG4gICAgICovXG4gICAgcmVkbygpIHtcbiAgICAgICAgdGhpcy51bmRvTWFuYWdlci5yZWRvKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHRoZSBjaGFuZ2Ugc3RhY2suXG4gICAgICovXG4gICAgY2xlYXJVbmRvSGlzdG9yeSgpIHtcbiAgICAgICAgdGhpcy51bmRvTWFuYWdlci5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGEgdHJhbnNhY3Rpb24uIFdoaWxlIHRoZSBmdW5jdGlvbiBmIGlzIGNhbGxlZCwgYWxsIGNoYW5nZXMgdG8gdGhlIHNoYXJlZFxuICAgICAqIGRvY3VtZW50IGFyZSBidW5kbGVkIGludG8gYSBzaW5nbGUgZXZlbnQuXG4gICAgICovXG4gICAgdHJhbnNhY3QoZiwgdW5kb2FibGUgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMueWRvYy50cmFuc2FjdChmLCB1bmRvYWJsZSA/IHRoaXMgOiBudWxsKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD15ZG9jdW1lbnQuanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBZRG9jdW1lbnQgfSBmcm9tICcuL3lkb2N1bWVudC5qcyc7XG4vKipcbiAqIFNoYXJlYWJsZSB0ZXh0IGZpbGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBZRmlsZSBleHRlbmRzIFlEb2N1bWVudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGZpbGVcbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZG9jdW1lbnQgaXMgZW1wdHkgYW5kIG11c3QgYmUgcG9wdWxhdGVkXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb2N1bWVudCB2ZXJzaW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAnMS4wLjAnO1xuICAgICAgICAvKipcbiAgICAgICAgICogWUpTIGZpbGUgdGV4dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueXNvdXJjZSA9IHRoaXMueWRvYy5nZXRUZXh0KCdzb3VyY2UnKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZSBhIGNoYW5nZSB0byB0aGUgeW1vZGVsLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbW9kZWxPYnNlcnZlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHsgc291cmNlQ2hhbmdlOiBldmVudC5jaGFuZ2VzLmRlbHRhIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuZG9NYW5hZ2VyLmFkZFRvU2NvcGUodGhpcy55c291cmNlKTtcbiAgICAgICAgdGhpcy55c291cmNlLm9ic2VydmUodGhpcy5fbW9kZWxPYnNlcnZlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFuZGFsb25lIFlGaWxlXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBZRmlsZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWxlIHRleHRcbiAgICAgKi9cbiAgICBnZXQgc291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UoKTtcbiAgICB9XG4gICAgc2V0IHNvdXJjZSh2KSB7XG4gICAgICAgIHRoaXMuc2V0U291cmNlKHYpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlIG9mIHRoZSByZXNvdXJjZXMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXNvdXJjZS51bm9ic2VydmUodGhpcy5fbW9kZWxPYnNlcnZlcik7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBmaWxlIHRleHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBGaWxlIHRleHQuXG4gICAgICovXG4gICAgZ2V0U291cmNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy55c291cmNlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZmlsZSB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIE5ldyB0ZXh0XG4gICAgICovXG4gICAgc2V0U291cmNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeXRleHQgPSB0aGlzLnlzb3VyY2U7XG4gICAgICAgICAgICB5dGV4dC5kZWxldGUoMCwgeXRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHl0ZXh0Lmluc2VydCgwLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIGNvbnRlbnQgZnJvbSBgc3RhcnQnIHRvIGBlbmRgIHdpdGggYHZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydDogVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSByYW5nZSB0byByZXBsYWNlIChpbmNsdXNpdmUpLlxuICAgICAqIEBwYXJhbSBlbmQ6IFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIHRvIHJlcGxhY2UgKGV4Y2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHZhbHVlOiBOZXcgc291cmNlIChvcHRpb25hbCkuXG4gICAgICovXG4gICAgdXBkYXRlU291cmNlKHN0YXJ0LCBlbmQsIHZhbHVlID0gJycpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB5c291cmNlID0gdGhpcy55c291cmNlO1xuICAgICAgICAgICAgLy8gaW5zZXJ0IGFuZCB0aGVuIGRlbGV0ZS5cbiAgICAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHRoZSBjdXJzb3IgcG9zaXRpb24gaXMgYWRqdXN0ZWQgYWZ0ZXIgdGhlIHJlcGxhY2VkIGNvbnRlbnQuXG4gICAgICAgICAgICB5c291cmNlLmluc2VydChzdGFydCwgdmFsdWUpO1xuICAgICAgICAgICAgeXNvdXJjZS5kZWxldGUoc3RhcnQgKyB2YWx1ZS5sZW5ndGgsIGVuZCAtIHN0YXJ0KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eWZpbGUuanMubWFwIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29weXJpZ2h0IChjKSBKdXB5dGVyIERldmVsb3BtZW50IFRlYW0uXG58IERpc3RyaWJ1dGVkIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTW9kaWZpZWQgQlNEIExpY2Vuc2UuXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBKU09ORXh0IH0gZnJvbSAnQGx1bWluby9jb3JldXRpbHMnO1xuaW1wb3J0IHsgU2lnbmFsIH0gZnJvbSAnQGx1bWluby9zaWduYWxpbmcnO1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnO1xuaW1wb3J0IHsgWURvY3VtZW50IH0gZnJvbSAnLi95ZG9jdW1lbnQuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ2VsbCwgY3JlYXRlQ2VsbE1vZGVsRnJvbVNoYXJlZFR5cGUgfSBmcm9tICcuL3ljZWxsLmpzJztcbi8qKlxuICogU2hhcmVkIGltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFyZWQgRG9jdW1lbnQgdHlwZXMuXG4gKlxuICogU2hhcmVkIGNlbGxzIGNhbiBiZSBpbnNlcnRlZCBpbnRvIGEgU2hhcmVkTm90ZWJvb2suXG4gKiBTaGFyZWQgY2VsbHMgb25seSBzdGFydCBlbWl0dGluZyBldmVudHMgd2hlbiB0aGV5IGFyZSBjb25uZWN0ZWQgdG8gYSBTaGFyZWROb3RlYm9vay5cbiAqXG4gKiBcIlN0YW5kYWxvbmVcIiBjZWxscyBtdXN0IG5vdCBiZSBpbnNlcnRlZCBpbnRvIGEgKFNoYXJlZClOb3RlYm9vay5cbiAqIFN0YW5kYWxvbmUgY2VsbHMgZW1pdCBldmVudHMgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gY3JlYXRlZCwgYnV0IHRoZXkgbXVzdCBub3RcbiAqIGJlIGluY2x1ZGVkIGludG8gYSAoU2hhcmVkKU5vdGVib29rLlxuICovXG5leHBvcnQgY2xhc3MgWU5vdGVib29rIGV4dGVuZHMgWURvY3VtZW50IHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm90ZWJvb2tcbiAgICAgKlxuICAgICAqICMjIyMgTm90ZXNcbiAgICAgKiBUaGUgZG9jdW1lbnQgaXMgZW1wdHkgYW5kIG11c3QgYmUgcG9wdWxhdGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEb2N1bWVudCB2ZXJzaW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlcnNpb24gPSAnMS4wLjAnO1xuICAgICAgICAvKipcbiAgICAgICAgICogWUpTIG1hcCBmb3IgdGhlIG5vdGVib29rIG1ldGFkYXRhXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnltZXRhID0gdGhpcy55ZG9jLmdldE1hcCgnbWV0YScpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIGEgY2hhbmdlIHRvIHRoZSB5c3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vbk1ldGFDaGFuZ2VkID0gKGV2ZW50cykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGFFdmVudHMgPSBldmVudHMuZmluZChldmVudCA9PiBldmVudC50YXJnZXQgPT09IHRoaXMueW1ldGEuZ2V0KCdtZXRhZGF0YScpKTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YUV2ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhQ2hhbmdlID0gbWV0YWRhdGFFdmVudHMuY2hhbmdlcy5rZXlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHltZXRhZGF0YSA9IHRoaXMueW1ldGEuZ2V0KCdtZXRhZGF0YScpO1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhRXZlbnRzLmNoYW5nZXMua2V5cy5mb3JFYWNoKChjaGFuZ2UsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZS5hY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0YWRhdGFDaGFuZ2VkLmVtaXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZTogeW1ldGFkYXRhLmdldChrZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IGNoYW5nZS5vbGRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXBkYXRlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0geW1ldGFkYXRhLmdldChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IGNoYW5nZS5vbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGVxdWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbGRWYWx1ZSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgbmV3VmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsID0gSlNPTkV4dC5kZWVwRXF1YWwob2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxdWFsID0gb2xkVmFsdWUgPT09IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXF1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGFkYXRhQ2hhbmdlZC5lbWl0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2NoYW5nZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZC5lbWl0KHsgbWV0YWRhdGFDaGFuZ2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXRhRXZlbnQgPSBldmVudHMuZmluZChldmVudCA9PiBldmVudC50YXJnZXQgPT09IHRoaXMueW1ldGEpO1xuICAgICAgICAgICAgaWYgKCFtZXRhRXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWV0YUV2ZW50LmtleXNDaGFuZ2VkLmhhcygnbWV0YWRhdGEnKSkge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBtZXRhZGF0YSBjaGFuZ2Ugd2hlbiBhZGRpbmcvcmVtb3ZpbmcgdGhlIFlNYXBcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFuZ2UgPSBtZXRhRXZlbnQuY2hhbmdlcy5rZXlzLmdldCgnbWV0YWRhdGEnKTtcbiAgICAgICAgICAgICAgICBpZiAoKGNoYW5nZSA9PT0gbnVsbCB8fCBjaGFuZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5nZS5hY3Rpb24pID09PSAnYWRkJyAmJiAhY2hhbmdlLm9sZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGFkYXRhQ2hhbmdlID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGFDaGFuZ2Uuc2V0KGtleSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2FkZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRhZGF0YUNoYW5nZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhZGQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiB0aGlzLmdldE1ldGFkYXRhKGtleSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQuZW1pdCh7IG1ldGFkYXRhQ2hhbmdlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhRXZlbnQua2V5c0NoYW5nZWQuaGFzKCduYmZvcm1hdCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gbWV0YUV2ZW50LmNoYW5nZXMua2V5cy5nZXQoJ25iZm9ybWF0Jyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmJmb3JtYXRDaGFuZ2VkID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICduYmZvcm1hdCcsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiAoY2hhbmdlID09PSBudWxsIHx8IGNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbmdlLm9sZFZhbHVlKSA/IGNoYW5nZS5vbGRWYWx1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IHRoaXMubmJmb3JtYXRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQuZW1pdCh7IG5iZm9ybWF0Q2hhbmdlZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXRhRXZlbnQua2V5c0NoYW5nZWQuaGFzKCduYmZvcm1hdF9taW5vcicpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gbWV0YUV2ZW50LmNoYW5nZXMua2V5cy5nZXQoJ25iZm9ybWF0X21pbm9yJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmJmb3JtYXRDaGFuZ2VkID0ge1xuICAgICAgICAgICAgICAgICAgICBrZXk6ICduYmZvcm1hdF9taW5vcicsXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlOiAoY2hhbmdlID09PSBudWxsIHx8IGNoYW5nZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbmdlLm9sZFZhbHVlKSA/IGNoYW5nZS5vbGRWYWx1ZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IHRoaXMubmJmb3JtYXRfbWlub3JcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQuZW1pdCh7IG5iZm9ybWF0Q2hhbmdlZCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZSBhIGNoYW5nZSB0byB0aGUgbGlzdCBvZiBjZWxscy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29uWUNlbGxzQ2hhbmdlZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSB0eXBlIGNlbGwgbWFwcGluZyBieSBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgYWRkZWQvcmVtb3ZlZCB0eXBlc1xuICAgICAgICAgICAgZXZlbnQuY2hhbmdlcy5hZGRlZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBpdGVtLmNvbnRlbnQudHlwZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3ljZWxsTWFwcGluZy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYyA9IGNyZWF0ZUNlbGxNb2RlbEZyb21TaGFyZWRUeXBlKHR5cGUsIHsgbm90ZWJvb2s6IHRoaXMgfSk7XG4gICAgICAgICAgICAgICAgICAgIGMuc2V0VW5kb01hbmFnZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feWNlbGxNYXBwaW5nLnNldCh0eXBlLCBjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGV2ZW50LmNoYW5nZXMuZGVsZXRlZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBpdGVtLmNvbnRlbnQudHlwZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX3ljZWxsTWFwcGluZy5nZXQodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5feWNlbGxNYXBwaW5nLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICAvLyB0aGlzIHJlZmxlY3RzIHRoZSBldmVudC5jaGFuZ2VzLmRlbHRhLCBidXQgcmVwbGFjZXMgdGhlIGNvbnRlbnQgb2YgZGVsdGEuaW5zZXJ0IHdpdGggeWNlbGxzXG4gICAgICAgICAgICBjb25zdCBjZWxsc0NoYW5nZSA9IFtdO1xuICAgICAgICAgICAgZXZlbnQuY2hhbmdlcy5kZWx0YS5mb3JFYWNoKChkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGQuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0ZWRDZWxscyA9IGQuaW5zZXJ0Lm1hcCgoeWNlbGwpID0+IHRoaXMuX3ljZWxsTWFwcGluZy5nZXQoeWNlbGwpKTtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHNDaGFuZ2UucHVzaCh7IGluc2VydDogaW5zZXJ0ZWRDZWxscyB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxscy5zcGxpY2UoaW5kZXgsIDAsIC4uLmluc2VydGVkQ2VsbHMpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBkLmluc2VydC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGQuZGVsZXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbHNDaGFuZ2UucHVzaChkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jZWxscy5zcGxpY2UoaW5kZXgsIGQuZGVsZXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZC5yZXRhaW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsc0NoYW5nZS5wdXNoKGQpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCArPSBkLnJldGFpbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgY2VsbHNDaGFuZ2U6IGNlbGxzQ2hhbmdlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fbWV0YWRhdGFDaGFuZ2VkID0gbmV3IFNpZ25hbCh0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEludGVybmFsIFlqcyBjZWxscyBsaXN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl95Y2VsbHMgPSB0aGlzLnlkb2MuZ2V0QXJyYXkoJ2NlbGxzJyk7XG4gICAgICAgIHRoaXMuX3ljZWxsTWFwcGluZyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuX2Rpc2FibGVEb2N1bWVudFdpZGVVbmRvUmVkbyA9XG4gICAgICAgICAgICAoX2EgPSBvcHRpb25zLmRpc2FibGVEb2N1bWVudFdpZGVVbmRvUmVkbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2U7XG4gICAgICAgIHRoaXMuY2VsbHMgPSB0aGlzLl95Y2VsbHMudG9BcnJheSgpLm1hcCh5Y2VsbCA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ljZWxsTWFwcGluZy5oYXMoeWNlbGwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5feWNlbGxNYXBwaW5nLnNldCh5Y2VsbCwgY3JlYXRlQ2VsbE1vZGVsRnJvbVNoYXJlZFR5cGUoeWNlbGwsIHsgbm90ZWJvb2s6IHRoaXMgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ljZWxsTWFwcGluZy5nZXQoeWNlbGwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51bmRvTWFuYWdlci5hZGRUb1Njb3BlKHRoaXMuX3ljZWxscyk7XG4gICAgICAgIHRoaXMuX3ljZWxscy5vYnNlcnZlKHRoaXMuX29uWUNlbGxzQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMueW1ldGEub2JzZXJ2ZURlZXAodGhpcy5fb25NZXRhQ2hhbmdlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzdGFuZGFsb25lIFlOb3RlYm9va1xuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBtZXRob2QgaXMgdXNlZnVsIHdoZW4gd2UgbmVlZCB0byBpbml0aWFsaXplXG4gICAgICogdGhlIFlOb3RlYm9vayBmcm9tIHRoZSBKYXZhU2NyaXB0IHNpZGUuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIGNvbnN0IHlub3RlYm9vayA9IG5ldyBZTm90ZWJvb2soe1xuICAgICAgICAgICAgZGlzYWJsZURvY3VtZW50V2lkZVVuZG9SZWRvOiAoX2EgPSBvcHRpb25zLmRpc2FibGVEb2N1bWVudFdpZGVVbmRvUmVkbykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBjZWxsczogKF9jID0gKF9iID0gb3B0aW9ucy5kYXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2VsbHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdLFxuICAgICAgICAgICAgbmJmb3JtYXQ6IChfZSA9IChfZCA9IG9wdGlvbnMuZGF0YSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm5iZm9ybWF0KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiA0LFxuICAgICAgICAgICAgbmJmb3JtYXRfbWlub3I6IChfZyA9IChfZiA9IG9wdGlvbnMuZGF0YSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLm5iZm9ybWF0X21pbm9yKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiA1LFxuICAgICAgICAgICAgbWV0YWRhdGE6IChfaiA9IChfaCA9IG9wdGlvbnMuZGF0YSkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLm1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiB7fVxuICAgICAgICB9O1xuICAgICAgICB5bm90ZWJvb2suZnJvbUpTT04oZGF0YSk7XG4gICAgICAgIHJldHVybiB5bm90ZWJvb2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdldGhlciB0aGUgdW5kby9yZWRvIGxvZ2ljIHNob3VsZCBiZVxuICAgICAqIGNvbnNpZGVyZWQgb24gdGhlIGZ1bGwgZG9jdW1lbnQgYWNyb3NzIGFsbCBjZWxscy5cbiAgICAgKlxuICAgICAqIERlZmF1bHQ6IGZhbHNlXG4gICAgICovXG4gICAgZ2V0IGRpc2FibGVEb2N1bWVudFdpZGVVbmRvUmVkbygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVEb2N1bWVudFdpZGVVbmRvUmVkbztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm90ZWJvb2sgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldE1ldGFkYXRhKCk7XG4gICAgfVxuICAgIHNldCBtZXRhZGF0YSh2KSB7XG4gICAgICAgIHRoaXMuc2V0TWV0YWRhdGEodik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25hbCB0cmlnZ2VyZWQgd2hlbiBhIG1ldGFkYXRhIGNoYW5nZXMuXG4gICAgICovXG4gICAgZ2V0IG1ldGFkYXRhQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhQ2hhbmdlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbmJmb3JtYXQgbWFqb3IgdmVyc2lvblxuICAgICAqL1xuICAgIGdldCBuYmZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueW1ldGEuZ2V0KCduYmZvcm1hdCcpO1xuICAgIH1cbiAgICBzZXQgbmJmb3JtYXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnltZXRhLnNldCgnbmJmb3JtYXQnLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogbmJmb3JtYXQgbWlub3IgdmVyc2lvblxuICAgICAqL1xuICAgIGdldCBuYmZvcm1hdF9taW5vcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueW1ldGEuZ2V0KCduYmZvcm1hdF9taW5vcicpO1xuICAgIH1cbiAgICBzZXQgbmJmb3JtYXRfbWlub3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnltZXRhLnNldCgnbmJmb3JtYXRfbWlub3InLCB2YWx1ZSk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiB0aGUgcmVzb3VyY2VzLlxuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl95Y2VsbHMudW5vYnNlcnZlKHRoaXMuX29uWUNlbGxzQ2hhbmdlZCk7XG4gICAgICAgIHRoaXMueW1ldGEudW5vYnNlcnZlRGVlcCh0aGlzLl9vbk1ldGFDaGFuZ2VkKTtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBzaGFyZWQgY2VsbCBieSBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleDogQ2VsbCdzIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIHJlcXVlc3RlZCBzaGFyZWQgY2VsbC5cbiAgICAgKi9cbiAgICBnZXRDZWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbGxzW2luZGV4XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgc2hhcmVkIGNlbGwgYXQgdGhlIG5vdGVib29rIGJvdHRvbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjZWxsIENlbGwgdG8gYWRkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGFkZGVkIGNlbGwuXG4gICAgICovXG4gICAgYWRkQ2VsbChjZWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc2VydENlbGwodGhpcy5feWNlbGxzLmxlbmd0aCwgY2VsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIHNoYXJlZCBjZWxsIGludG8gYSBzcGVjaWZpYyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleDogQ2VsbCdzIHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSBjZWxsOiBDZWxsIHRvIGluc2VydC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBpbnNlcnRlZCBjZWxsLlxuICAgICAqL1xuICAgIGluc2VydENlbGwoaW5kZXgsIGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0Q2VsbHMoaW5kZXgsIFtjZWxsXSlbMF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydCBhIGxpc3Qgb2Ygc2hhcmVkIGNlbGxzIGludG8gYSBzcGVjaWZpYyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbmRleDogUG9zaXRpb24gdG8gaW5zZXJ0IHRoZSBjZWxscy5cbiAgICAgKiBAcGFyYW0gY2VsbHM6IEFycmF5IG9mIHNoYXJlZCBjZWxscyB0byBpbnNlcnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgaW5zZXJ0ZWQgY2VsbHMuXG4gICAgICovXG4gICAgaW5zZXJ0Q2VsbHMoaW5kZXgsIGNlbGxzKSB7XG4gICAgICAgIGNvbnN0IHlDZWxscyA9IGNlbGxzLm1hcChjID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjcmVhdGVDZWxsKGMsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5feWNlbGxNYXBwaW5nLnNldChjZWxsLnltb2RlbCwgY2VsbCk7XG4gICAgICAgICAgICByZXR1cm4gY2VsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5feWNlbGxzLmluc2VydChpbmRleCwgeUNlbGxzLm1hcChjZWxsID0+IGNlbGwueW1vZGVsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB5Q2VsbHMuZm9yRWFjaChjID0+IHtcbiAgICAgICAgICAgIGMuc2V0VW5kb01hbmFnZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB5Q2VsbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmUgYSBjZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21JbmRleDogSW5kZXggb2YgdGhlIGNlbGwgdG8gbW92ZS5cbiAgICAgKiBAcGFyYW0gdG9JbmRleDogTmV3IHBvc2l0aW9uIG9mIHRoZSBjZWxsLlxuICAgICAqL1xuICAgIG1vdmVDZWxsKGZyb21JbmRleCwgdG9JbmRleCkge1xuICAgICAgICB0aGlzLm1vdmVDZWxscyhmcm9tSW5kZXgsIHRvSW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3ZlIGNlbGxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21JbmRleDogSW5kZXggb2YgdGhlIGZpcnN0IGNlbGxzIHRvIG1vdmUuXG4gICAgICogQHBhcmFtIHRvSW5kZXg6IE5ldyBwb3NpdGlvbiBvZiB0aGUgZmlyc3QgY2VsbCAoaW4gdGhlIGN1cnJlbnQgYXJyYXkpLlxuICAgICAqIEBwYXJhbSBuOiBOdW1iZXIgb2YgY2VsbHMgdG8gbW92ZSAoZGVmYXVsdCAxKVxuICAgICAqL1xuICAgIG1vdmVDZWxscyhmcm9tSW5kZXgsIHRvSW5kZXgsIG4gPSAxKSB7XG4gICAgICAgIC8vIEZJWE1FIHdlIG5lZWQgdG8gdXNlIHlqcyBtb3ZlIGZlYXR1cmUgdG8gcHJlc2VydmUgdW5kbyBoaXN0b3J5XG4gICAgICAgIGNvbnN0IGNsb25lcyA9IG5ldyBBcnJheShuKVxuICAgICAgICAgICAgLmZpbGwodHJ1ZSlcbiAgICAgICAgICAgIC5tYXAoKF8sIGlkeCkgPT4gdGhpcy5nZXRDZWxsKGZyb21JbmRleCArIGlkeCkudG9KU09OKCkpO1xuICAgICAgICB0aGlzLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3ljZWxscy5kZWxldGUoZnJvbUluZGV4LCBuKTtcbiAgICAgICAgICAgIHRoaXMuX3ljZWxscy5pbnNlcnQoZnJvbUluZGV4ID4gdG9JbmRleCA/IHRvSW5kZXggOiB0b0luZGV4IC0gbiArIDEsIGNsb25lcy5tYXAoY2xvbmUgPT4gY3JlYXRlQ2VsbChjbG9uZSwgdGhpcykueW1vZGVsKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBjZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGluZGV4OiBJbmRleCBvZiB0aGUgY2VsbCB0byByZW1vdmUuXG4gICAgICovXG4gICAgZGVsZXRlQ2VsbChpbmRleCkge1xuICAgICAgICB0aGlzLmRlbGV0ZUNlbGxSYW5nZShpbmRleCwgaW5kZXggKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgcmFuZ2Ugb2YgY2VsbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnJvbTogVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSByYW5nZSB0byByZW1vdmUgKGluY2x1c2l2ZSkuXG4gICAgICogQHBhcmFtIHRvOiBUaGUgZW5kIGluZGV4IG9mIHRoZSByYW5nZSB0byByZW1vdmUgKGV4Y2x1c2l2ZSkuXG4gICAgICovXG4gICAgZGVsZXRlQ2VsbFJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIC8vIENlbGxzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBtYXBwaW5nIGluIHRoZSBtb2RlbCBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgdGhpcy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl95Y2VsbHMuZGVsZXRlKGZyb20sIHRvIC0gZnJvbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgYSBtZXRhZGF0YSBub3RlYm9vay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSB0byBkZWxldGVcbiAgICAgKi9cbiAgICBkZWxldGVNZXRhZGF0YShrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmdldE1ldGFkYXRhKGtleSkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWxsTWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgICAgICBkZWxldGUgYWxsTWV0YWRhdGFba2V5XTtcbiAgICAgICAgdGhpcy5zZXRNZXRhZGF0YShhbGxNZXRhZGF0YSk7XG4gICAgfVxuICAgIGdldE1ldGFkYXRhKGtleSkge1xuICAgICAgICBjb25zdCB5bWV0YWRhdGEgPSB0aGlzLnltZXRhLmdldCgnbWV0YWRhdGEnKTtcbiAgICAgICAgLy8gVHJhbnNpZW50bHkgdGhlIG1ldGFkYXRhIGNhbiBiZSBtaXNzaW5nIC0gbGlrZSBkdXJpbmcgZGVzdHJ1Y3Rpb25cbiAgICAgICAgaWYgKHltZXRhZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB5bWV0YWRhdGEuZ2V0KGtleSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkIC8vIHVuZGVmaW5lZCBpcyBjb252ZXJ0ZWQgdG8gYHt9YCBieSBgSlNPTkV4dC5kZWVwQ29weWBcbiAgICAgICAgICAgICAgICA6IEpTT05FeHQuZGVlcENvcHkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIEpTT05FeHQuZGVlcENvcHkoeW1ldGFkYXRhLnRvSlNPTigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRNZXRhZGF0YShtZXRhZGF0YSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGFkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNZXRhZGF0YSB2YWx1ZSBmb3IgJHttZXRhZGF0YX0gY2Fubm90IGJlICd1bmRlZmluZWQnOyB1c2UgZGVsZXRlTWV0YWRhdGEuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSlNPTkV4dC5kZWVwRXF1YWwoKF9hID0gdGhpcy5nZXRNZXRhZGF0YShtZXRhZGF0YSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IHt9O1xuICAgICAgICAgICAgdXBkYXRlW21ldGFkYXRhXSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNZXRhZGF0YSh1cGRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1ldGFkYXRhIHx8ICFKU09ORXh0LmRlZXBFcXVhbCh0aGlzLm1ldGFkYXRhLCBtZXRhZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZSA9IEpTT05FeHQuZGVlcENvcHkobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHltZXRhZGF0YSA9IHRoaXMueW1ldGEuZ2V0KCdtZXRhZGF0YScpO1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zaWVudGx5IHRoZSBtZXRhZGF0YSBjYW4gYmUgbWlzc2luZyAtIGxpa2UgZHVyaW5nIGRlc3RydWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHltZXRhZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB5bWV0YWRhdGEuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2xvbmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5bWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBub3RlYm9vay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZTogTWV0YWRhdGEncyBhdHRyaWJ1dGUgdG8gdXBkYXRlLlxuICAgICAqL1xuICAgIHVwZGF0ZU1ldGFkYXRhKHZhbHVlKSB7XG4gICAgICAgIC8vIFRPRE86IE1heWJlIG1vZGlmeSBvbmx5IGF0dHJpYnV0ZXMgaW5zdGVhZCBvZiByZXBsYWNpbmcgdGhlIHdob2xlIG1ldGFkYXRhP1xuICAgICAgICBjb25zdCBjbG9uZSA9IEpTT05FeHQuZGVlcENvcHkodmFsdWUpO1xuICAgICAgICBjb25zdCB5bWV0YWRhdGEgPSB0aGlzLnltZXRhLmdldCgnbWV0YWRhdGEnKTtcbiAgICAgICAgLy8gVHJhbnNpZW50bHkgdGhlIG1ldGFkYXRhIGNhbiBiZSBtaXNzaW5nIC0gbGlrZSBkdXJpbmcgZGVzdHJ1Y3Rpb25cbiAgICAgICAgaWYgKHltZXRhZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoY2xvbmUpKSB7XG4gICAgICAgICAgICAgICAgeW1ldGFkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHRoZSBub3RlYm9vayB3aXRoIGEgSlNPTi1zZXJpYWxpemVkIGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBub3RlYm9va1xuICAgICAqL1xuICAgIGZyb21KU09OKHZhbHVlKSB7XG4gICAgICAgIHRoaXMudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5uYmZvcm1hdCA9IHZhbHVlLm5iZm9ybWF0O1xuICAgICAgICAgICAgdGhpcy5uYmZvcm1hdF9taW5vciA9IHZhbHVlLm5iZm9ybWF0X21pbm9yO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB2YWx1ZS5tZXRhZGF0YTtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YVsnb3JpZ19uYmZvcm1hdCddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWV0YWRhdGFbJ29yaWdfbmJmb3JtYXQnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5tZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHltZXRhZGF0YSA9IG5ldyBZLk1hcCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1ldGFkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICB5bWV0YWRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnltZXRhLnNldCgnbWV0YWRhdGEnLCB5bWV0YWRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdXNlSWQgPSB2YWx1ZS5uYmZvcm1hdCA9PT0gNCAmJiB2YWx1ZS5uYmZvcm1hdF9taW5vciA+PSA1O1xuICAgICAgICAgICAgY29uc3QgeWNlbGxzID0gdmFsdWUuY2VsbHMubWFwKGNlbGwgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdXNlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNlbGwuaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmluc2VydENlbGxzKHRoaXMuY2VsbHMubGVuZ3RoLCB5Y2VsbHMpO1xuICAgICAgICAgICAgdGhpcy5kZWxldGVDZWxsUmFuZ2UoMCwgdGhpcy5jZWxscy5sZW5ndGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBtb2RlbCB0byBKU09OLlxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgLy8gc3RyaXAgY2VsbCBpZHMgaWYgd2UgaGF2ZSBub3RlYm9vayBmb3JtYXQgNC4wLTQuNFxuICAgICAgICBjb25zdCBwcnVuZUNlbGxJZCA9IHRoaXMubmJmb3JtYXQgPT09IDQgJiYgdGhpcy5uYmZvcm1hdF9taW5vciA8PSA0O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0YWRhdGE6IHRoaXMubWV0YWRhdGEsXG4gICAgICAgICAgICBuYmZvcm1hdF9taW5vcjogdGhpcy5uYmZvcm1hdF9taW5vcixcbiAgICAgICAgICAgIG5iZm9ybWF0OiB0aGlzLm5iZm9ybWF0LFxuICAgICAgICAgICAgY2VsbHM6IHRoaXMuY2VsbHMubWFwKGMgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhdyA9IGMudG9KU09OKCk7XG4gICAgICAgICAgICAgICAgaWYgKHBydW5lQ2VsbElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByYXcuaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByYXc7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXlub3RlYm9vay5qcy5tYXAiLCIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBDb3B5cmlnaHQgKGMpIEp1cHl0ZXIgRGV2ZWxvcG1lbnQgVGVhbS5cbnwgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBNb2RpZmllZCBCU0QgTGljZW5zZS5cbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCB7fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXl0ZXh0LmpzLm1hcCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIEBtb2R1bGUgYXdhcmVuZXNzLXByb3RvY29sXG4gKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZSdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIGYgZnJvbSAnbGliMC9mdW5jdGlvbidcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmV4cG9ydCBjb25zdCBvdXRkYXRlZFRpbWVvdXQgPSAzMDAwMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFDbGllbnRTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5jbG9ja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5sYXN0VXBkYXRlZCB1bml4IHRpbWVzdGFtcFxuICovXG5cbi8qKlxuICogVGhlIEF3YXJlbmVzcyBjbGFzcyBpbXBsZW1lbnRzIGEgc2ltcGxlIHNoYXJlZCBzdGF0ZSBwcm90b2NvbCB0aGF0IGNhbiBiZSB1c2VkIGZvciBub24tcGVyc2lzdGVudCBkYXRhIGxpa2UgYXdhcmVuZXNzIGluZm9ybWF0aW9uXG4gKiAoY3Vyc29yLCB1c2VybmFtZSwgc3RhdHVzLCAuLikuIEVhY2ggY2xpZW50IGNhbiB1cGRhdGUgaXRzIG93biBsb2NhbCBzdGF0ZSBhbmQgbGlzdGVuIHRvIHN0YXRlIGNoYW5nZXMgb2ZcbiAqIHJlbW90ZSBjbGllbnRzLiBFdmVyeSBjbGllbnQgbWF5IHNldCBhIHN0YXRlIG9mIGEgcmVtb3RlIHBlZXIgdG8gYG51bGxgIHRvIG1hcmsgdGhlIGNsaWVudCBhcyBvZmZsaW5lLlxuICpcbiAqIEVhY2ggY2xpZW50IGlzIGlkZW50aWZpZWQgYnkgYSB1bmlxdWUgY2xpZW50IGlkIChzb21ldGhpbmcgd2UgYm9ycm93IGZyb20gYGRvYy5jbGllbnRJRGApLiBBIGNsaWVudCBjYW4gb3ZlcnJpZGVcbiAqIGl0cyBvd24gc3RhdGUgYnkgcHJvcGFnYXRpbmcgYSBtZXNzYWdlIHdpdGggYW4gaW5jcmVhc2luZyB0aW1lc3RhbXAgKGBjbG9ja2ApLiBJZiBzdWNoIGEgbWVzc2FnZSBpcyByZWNlaXZlZCwgaXQgaXNcbiAqIGFwcGxpZWQgaWYgdGhlIGtub3duIHN0YXRlIG9mIHRoYXQgY2xpZW50IGlzIG9sZGVyIHRoYW4gdGhlIG5ldyBzdGF0ZSAoYGNsb2NrIDwgbmV3Q2xvY2tgKS4gSWYgYSBjbGllbnQgdGhpbmtzIHRoYXRcbiAqIGEgcmVtb3RlIGNsaWVudCBpcyBvZmZsaW5lLCBpdCBtYXkgcHJvcGFnYXRlIGEgbWVzc2FnZSB3aXRoXG4gKiBgeyBjbG9jazogY3VycmVudENsaWVudENsb2NrLCBzdGF0ZTogbnVsbCwgY2xpZW50OiByZW1vdGVDbGllbnQgfWAuIElmIHN1Y2ggYVxuICogbWVzc2FnZSBpcyByZWNlaXZlZCwgYW5kIHRoZSBrbm93biBjbG9jayBvZiB0aGF0IGNsaWVudCBlcXVhbHMgdGhlIHJlY2VpdmVkIGNsb2NrLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBzdGF0ZSB3aXRoIGBudWxsYC5cbiAqXG4gKiBCZWZvcmUgYSBjbGllbnQgZGlzY29ubmVjdHMsIGl0IHNob3VsZCBwcm9wYWdhdGUgYSBgbnVsbGAgc3RhdGUgd2l0aCBhbiB1cGRhdGVkIGNsb2NrLlxuICpcbiAqIEF3YXJlbmVzcyBzdGF0ZXMgbXVzdCBiZSB1cGRhdGVkIGV2ZXJ5IDMwIHNlY29uZHMuIE90aGVyd2lzZSB0aGUgQXdhcmVuZXNzIGluc3RhbmNlIHdpbGwgZGVsZXRlIHRoZSBjbGllbnQgc3RhdGUuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNsYXNzIEF3YXJlbmVzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudElEID0gZG9jLmNsaWVudElEXG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudCBpZCB0byBjbGllbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgT2JqZWN0PHN0cmluZywgYW55Pj59XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgTWV0YUNsaWVudFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGlmICh0aGlzLmdldExvY2FsU3RhdGUoKSAhPT0gbnVsbCAmJiAob3V0ZGF0ZWRUaW1lb3V0IC8gMiA8PSBub3cgLSAvKiogQHR5cGUge3tsYXN0VXBkYXRlZDpudW1iZXJ9fSAqLyAodGhpcy5tZXRhLmdldCh0aGlzLmNsaWVudElEKSkubGFzdFVwZGF0ZWQpKSB7XG4gICAgICAgIC8vIHJlbmV3IGxvY2FsIGNsb2NrXG4gICAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh0aGlzLmdldExvY2FsU3RhdGUoKSlcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHJlbW92ZSA9IFtdXG4gICAgICB0aGlzLm1ldGEuZm9yRWFjaCgobWV0YSwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudGlkICE9PSB0aGlzLmNsaWVudElEICYmIG91dGRhdGVkVGltZW91dCA8PSBub3cgLSBtZXRhLmxhc3RVcGRhdGVkICYmIHRoaXMuc3RhdGVzLmhhcyhjbGllbnRpZCkpIHtcbiAgICAgICAgICByZW1vdmUucHVzaChjbGllbnRpZClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmIChyZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcywgcmVtb3ZlLCAndGltZW91dCcpXG4gICAgICB9XG4gICAgfSwgbWF0aC5mbG9vcihvdXRkYXRlZFRpbWVvdXQgLyAxMCkpKVxuICAgIGRvYy5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfSlcbiAgICB0aGlzLnNldExvY2FsU3RhdGUoe30pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBbdGhpc10pXG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja0ludGVydmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfVxuICAgKi9cbiAgZ2V0TG9jYWxTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmdldCh0aGlzLmNsaWVudElEKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH0gc3RhdGVcbiAgICovXG4gIHNldExvY2FsU3RhdGUgKHN0YXRlKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSB0aGlzLmNsaWVudElEXG4gICAgY29uc3QgY3VyckxvY2FsTWV0YSA9IHRoaXMubWV0YS5nZXQoY2xpZW50SUQpXG4gICAgY29uc3QgY2xvY2sgPSBjdXJyTG9jYWxNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY3VyckxvY2FsTWV0YS5jbG9jayArIDFcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlcy5nZXQoY2xpZW50SUQpXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgfVxuICAgIHRoaXMubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgIH0pXG4gICAgY29uc3QgYWRkZWQgPSBbXVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBbXVxuICAgIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdXG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfSBlbHNlIGlmIChwcmV2U3RhdGUgPT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgYWRkZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgaWYgKCFmLmVxdWFsaXR5RGVlcChwcmV2U3RhdGUsIHN0YXRlKSkge1xuICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gICAgfVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZUZpZWxkIChmaWVsZCwgdmFsdWUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0TG9jYWxTdGF0ZSgpXG4gICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNldExvY2FsU3RhdGUoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW2ZpZWxkXTogdmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge01hcDxudW1iZXIsT2JqZWN0PHN0cmluZyxhbnk+Pn1cbiAgICovXG4gIGdldFN0YXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzXG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrIChyZW1vdGUpIGNsaWVudHMgYXMgaW5hY3RpdmUgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHBlZXJzLlxuICogVGhpcyBjaGFuZ2Ugd2lsbCBiZSBwcm9wYWdhdGVkIHRvIHJlbW90ZSBjbGllbnRzLlxuICpcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHBhcmFtIHthbnl9IG9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzID0gKGF3YXJlbmVzcywgY2xpZW50cywgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IHJlbW92ZWQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV1cbiAgICBpZiAoYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSB7XG4gICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEKSB7XG4gICAgICAgIGNvbnN0IGN1ck1ldGEgPSAvKiogQHR5cGUge01ldGFDbGllbnRTdGF0ZX0gKi8gKGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCkpXG4gICAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICAgIGNsb2NrOiBjdXJNZXRhLmNsb2NrICsgMSxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogdGltZS5nZXRVbml4VGltZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKVxuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbeyBhZGRlZDogW10sIHVwZGF0ZWQ6IFtdLCByZW1vdmVkIH0sIG9yaWdpbl0pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVBd2FyZW5lc3NVcGRhdGUgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBzdGF0ZXMgPSBhd2FyZW5lc3Muc3RhdGVzKSA9PiB7XG4gIGNvbnN0IGxlbiA9IGNsaWVudHMubGVuZ3RoXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gY2xpZW50c1tpXVxuICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChjbGllbnRJRCkgfHwgbnVsbFxuICAgIGNvbnN0IGNsb2NrID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKS5jbG9ja1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKVxuICB9XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBNb2RpZnkgdGhlIGNvbnRlbnQgb2YgYW4gYXdhcmVuZXNzIHVwZGF0ZSBiZWZvcmUgcmUtZW5jb2RpbmcgaXQgdG8gYW4gYXdhcmVuZXNzIHVwZGF0ZS5cbiAqXG4gKiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIGEgY2VudHJhbCBzZXJ2ZXIgdGhhdCB3YW50cyB0byBlbnN1cmUgdGhhdCBjbGllbnRzXG4gKiBjYW50IGhpamFjayBzb21lYm9keSBlbHNlcyBpZGVudGl0eS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmFueX0gbW9kaWZ5XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgbW9kaWZ5QXdhcmVuZXNzVXBkYXRlID0gKHVwZGF0ZSwgbW9kaWZ5KSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBtb2RpZmllZFN0YXRlID0gbW9kaWZ5KHN0YXRlKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkobW9kaWZpZWRTdGF0ZSkpXG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gb3JpZ2luIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW1pdHRlZCBjaGFuZ2UgZXZlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5QXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgdXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKVxuICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgY29uc3QgYWRkZWQgPSBbXVxuICBjb25zdCB1cGRhdGVkID0gW11cbiAgY29uc3QgZmlsdGVyZWRVcGRhdGVkID0gW11cbiAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBjbGllbnRNZXRhID0gYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IHByZXZTdGF0ZSA9IGF3YXJlbmVzcy5zdGF0ZXMuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IGN1cnJDbG9jayA9IGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjbGllbnRNZXRhLmNsb2NrXG4gICAgaWYgKGN1cnJDbG9jayA8IGNsb2NrIHx8IChjdXJyQ2xvY2sgPT09IGNsb2NrICYmIHN0YXRlID09PSBudWxsICYmIGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBuZXZlciBsZXQgYSByZW1vdGUgY2xpZW50IHJlbW92ZSB0aGlzIGxvY2FsIHN0YXRlXG4gICAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEICYmIGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIHJlbW90ZSBjbGllbnQgcmVtb3ZlZCB0aGUgbG9jYWwgc3RhdGUuIERvIG5vdCByZW1vdGUgc3RhdGUuIEJyb2FkY2FzdCBhIG1lc3NhZ2UgaW5kaWNhdGluZ1xuICAgICAgICAgIC8vIHRoYXQgdGhpcyBjbGllbnQgc3RpbGwgZXhpc3RzIGJ5IGluY3JlYXNpbmcgdGhlIGNsb2NrXG4gICAgICAgICAgY2xvY2srK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgICB9XG4gICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgY2xvY2ssXG4gICAgICAgIGxhc3RVcGRhdGVkOiB0aW1lc3RhbXBcbiAgICAgIH0pXG4gICAgICBpZiAoY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKGNsaWVudE1ldGEgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghZi5lcXVhbGl0eURlZXAoc3RhdGUsIHByZXZTdGF0ZSkpIHtcbiAgICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCdjaGFuZ2UnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZFxuICAgIH0sIG9yaWdpbl0pXG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgdXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=