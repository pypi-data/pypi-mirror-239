"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_input_tex_js"],{

/***/ "../node_modules/mathjax-full/js/core/FindMath.js":
/*!********************************************************!*\
  !*** ../node_modules/mathjax-full/js/core/FindMath.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractFindMath = void 0;
var Options_js_1 = __webpack_require__(/*! ../util/Options.js */ "../node_modules/mathjax-full/js/util/Options.js");
var AbstractFindMath = (function () {
    function AbstractFindMath(options) {
        var CLASS = this.constructor;
        this.options = (0, Options_js_1.userOptions)((0, Options_js_1.defaultOptions)({}, CLASS.OPTIONS), options);
    }
    AbstractFindMath.OPTIONS = {};
    return AbstractFindMath;
}());
exports.AbstractFindMath = AbstractFindMath;
//# sourceMappingURL=FindMath.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/core/InputJax.js":
/*!********************************************************!*\
  !*** ../node_modules/mathjax-full/js/core/InputJax.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractInputJax = void 0;
var Options_js_1 = __webpack_require__(/*! ../util/Options.js */ "../node_modules/mathjax-full/js/util/Options.js");
var FunctionList_js_1 = __webpack_require__(/*! ../util/FunctionList.js */ "../node_modules/mathjax-full/js/util/FunctionList.js");
var AbstractInputJax = (function () {
    function AbstractInputJax(options) {
        if (options === void 0) { options = {}; }
        this.adaptor = null;
        this.mmlFactory = null;
        var CLASS = this.constructor;
        this.options = (0, Options_js_1.userOptions)((0, Options_js_1.defaultOptions)({}, CLASS.OPTIONS), options);
        this.preFilters = new FunctionList_js_1.FunctionList();
        this.postFilters = new FunctionList_js_1.FunctionList();
    }
    Object.defineProperty(AbstractInputJax.prototype, "name", {
        get: function () {
            return this.constructor.NAME;
        },
        enumerable: false,
        configurable: true
    });
    AbstractInputJax.prototype.setAdaptor = function (adaptor) {
        this.adaptor = adaptor;
    };
    AbstractInputJax.prototype.setMmlFactory = function (mmlFactory) {
        this.mmlFactory = mmlFactory;
    };
    AbstractInputJax.prototype.initialize = function () {
    };
    AbstractInputJax.prototype.reset = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
    };
    Object.defineProperty(AbstractInputJax.prototype, "processStrings", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    AbstractInputJax.prototype.findMath = function (_node, _options) {
        return [];
    };
    AbstractInputJax.prototype.executeFilters = function (filters, math, document, data) {
        var args = { math: math, document: document, data: data };
        filters.execute(args);
        return args.data;
    };
    AbstractInputJax.NAME = 'generic';
    AbstractInputJax.OPTIONS = {};
    return AbstractInputJax;
}());
exports.AbstractInputJax = AbstractInputJax;
//# sourceMappingURL=InputJax.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/core/MathItem.js":
/*!********************************************************!*\
  !*** ../node_modules/mathjax-full/js/core/MathItem.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.newState = exports.STATE = exports.AbstractMathItem = exports.protoItem = void 0;
function protoItem(open, math, close, n, start, end, display) {
    if (display === void 0) { display = null; }
    var item = { open: open, math: math, close: close,
        n: n, start: { n: start }, end: { n: end }, display: display };
    return item;
}
exports.protoItem = protoItem;
var AbstractMathItem = (function () {
    function AbstractMathItem(math, jax, display, start, end) {
        if (display === void 0) { display = true; }
        if (start === void 0) { start = { i: 0, n: 0, delim: '' }; }
        if (end === void 0) { end = { i: 0, n: 0, delim: '' }; }
        this.root = null;
        this.typesetRoot = null;
        this.metrics = {};
        this.inputData = {};
        this.outputData = {};
        this._state = exports.STATE.UNPROCESSED;
        this.math = math;
        this.inputJax = jax;
        this.display = display;
        this.start = start;
        this.end = end;
        this.root = null;
        this.typesetRoot = null;
        this.metrics = {};
        this.inputData = {};
        this.outputData = {};
    }
    Object.defineProperty(AbstractMathItem.prototype, "isEscaped", {
        get: function () {
            return this.display === null;
        },
        enumerable: false,
        configurable: true
    });
    AbstractMathItem.prototype.render = function (document) {
        document.renderActions.renderMath(this, document);
    };
    AbstractMathItem.prototype.rerender = function (document, start) {
        if (start === void 0) { start = exports.STATE.RERENDER; }
        if (this.state() >= start) {
            this.state(start - 1);
        }
        document.renderActions.renderMath(this, document, start);
    };
    AbstractMathItem.prototype.convert = function (document, end) {
        if (end === void 0) { end = exports.STATE.LAST; }
        document.renderActions.renderConvert(this, document, end);
    };
    AbstractMathItem.prototype.compile = function (document) {
        if (this.state() < exports.STATE.COMPILED) {
            this.root = this.inputJax.compile(this, document);
            this.state(exports.STATE.COMPILED);
        }
    };
    AbstractMathItem.prototype.typeset = function (document) {
        if (this.state() < exports.STATE.TYPESET) {
            this.typesetRoot = document.outputJax[this.isEscaped ? 'escaped' : 'typeset'](this, document);
            this.state(exports.STATE.TYPESET);
        }
    };
    AbstractMathItem.prototype.updateDocument = function (_document) { };
    AbstractMathItem.prototype.removeFromDocument = function (_restore) {
        if (_restore === void 0) { _restore = false; }
    };
    AbstractMathItem.prototype.setMetrics = function (em, ex, cwidth, lwidth, scale) {
        this.metrics = {
            em: em, ex: ex,
            containerWidth: cwidth,
            lineWidth: lwidth,
            scale: scale
        };
    };
    AbstractMathItem.prototype.state = function (state, restore) {
        if (state === void 0) { state = null; }
        if (restore === void 0) { restore = false; }
        if (state != null) {
            if (state < exports.STATE.INSERTED && this._state >= exports.STATE.INSERTED) {
                this.removeFromDocument(restore);
            }
            if (state < exports.STATE.TYPESET && this._state >= exports.STATE.TYPESET) {
                this.outputData = {};
            }
            if (state < exports.STATE.COMPILED && this._state >= exports.STATE.COMPILED) {
                this.inputData = {};
            }
            this._state = state;
        }
        return this._state;
    };
    AbstractMathItem.prototype.reset = function (restore) {
        if (restore === void 0) { restore = false; }
        this.state(exports.STATE.UNPROCESSED, restore);
    };
    return AbstractMathItem;
}());
exports.AbstractMathItem = AbstractMathItem;
exports.STATE = {
    UNPROCESSED: 0,
    FINDMATH: 10,
    COMPILED: 20,
    CONVERT: 100,
    METRICS: 110,
    RERENDER: 125,
    TYPESET: 150,
    INSERTED: 200,
    LAST: 10000
};
function newState(name, state) {
    if (name in exports.STATE) {
        throw Error('State ' + name + ' already exists');
    }
    exports.STATE[name] = state;
}
exports.newState = newState;
//# sourceMappingURL=MathItem.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/input/tex.js":
/*!****************************************************!*\
  !*** ../node_modules/mathjax-full/js/input/tex.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TeX = void 0;
var InputJax_js_1 = __webpack_require__(/*! ../core/InputJax.js */ "../node_modules/mathjax-full/js/core/InputJax.js");
var Options_js_1 = __webpack_require__(/*! ../util/Options.js */ "../node_modules/mathjax-full/js/util/Options.js");
var FindTeX_js_1 = __webpack_require__(/*! ./tex/FindTeX.js */ "../node_modules/mathjax-full/js/input/tex/FindTeX.js");
var FilterUtil_js_1 = __importDefault(__webpack_require__(/*! ./tex/FilterUtil.js */ "../node_modules/mathjax-full/js/input/tex/FilterUtil.js"));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ./tex/NodeUtil.js */ "../node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ./tex/TexParser.js */ "../node_modules/mathjax-full/js/input/tex/TexParser.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ./tex/TexError.js */ "../node_modules/mathjax-full/js/input/tex/TexError.js"));
var ParseOptions_js_1 = __importDefault(__webpack_require__(/*! ./tex/ParseOptions.js */ "../node_modules/mathjax-full/js/input/tex/ParseOptions.js"));
var Tags_js_1 = __webpack_require__(/*! ./tex/Tags.js */ "../node_modules/mathjax-full/js/input/tex/Tags.js");
var Configuration_js_1 = __webpack_require__(/*! ./tex/Configuration.js */ "../node_modules/mathjax-full/js/input/tex/Configuration.js");
__webpack_require__(/*! ./tex/base/BaseConfiguration.js */ "../node_modules/mathjax-full/js/input/tex/base/BaseConfiguration.js");
var TeX = (function (_super) {
    __extends(TeX, _super);
    function TeX(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        var _a = __read((0, Options_js_1.separateOptions)(options, TeX.OPTIONS, FindTeX_js_1.FindTeX.OPTIONS), 3), rest = _a[0], tex = _a[1], find = _a[2];
        _this = _super.call(this, tex) || this;
        _this.findTeX = _this.options['FindTeX'] || new FindTeX_js_1.FindTeX(find);
        var packages = _this.options.packages;
        var configuration = _this.configuration = TeX.configure(packages);
        var parseOptions = _this._parseOptions =
            new ParseOptions_js_1.default(configuration, [_this.options, Tags_js_1.TagsFactory.OPTIONS]);
        (0, Options_js_1.userOptions)(parseOptions.options, rest);
        configuration.config(_this);
        TeX.tags(parseOptions, configuration);
        _this.postFilters.add(FilterUtil_js_1.default.cleanSubSup, -6);
        _this.postFilters.add(FilterUtil_js_1.default.setInherited, -5);
        _this.postFilters.add(FilterUtil_js_1.default.moveLimits, -4);
        _this.postFilters.add(FilterUtil_js_1.default.cleanStretchy, -3);
        _this.postFilters.add(FilterUtil_js_1.default.cleanAttributes, -2);
        _this.postFilters.add(FilterUtil_js_1.default.combineRelations, -1);
        return _this;
    }
    TeX.configure = function (packages) {
        var configuration = new Configuration_js_1.ParserConfiguration(packages, ['tex']);
        configuration.init();
        return configuration;
    };
    TeX.tags = function (options, configuration) {
        Tags_js_1.TagsFactory.addTags(configuration.tags);
        Tags_js_1.TagsFactory.setDefault(options.options.tags);
        options.tags = Tags_js_1.TagsFactory.getDefault();
        options.tags.configuration = options;
    };
    TeX.prototype.setMmlFactory = function (mmlFactory) {
        _super.prototype.setMmlFactory.call(this, mmlFactory);
        this._parseOptions.nodeFactory.setMmlFactory(mmlFactory);
    };
    Object.defineProperty(TeX.prototype, "parseOptions", {
        get: function () {
            return this._parseOptions;
        },
        enumerable: false,
        configurable: true
    });
    TeX.prototype.reset = function (tag) {
        if (tag === void 0) { tag = 0; }
        this.parseOptions.tags.reset(tag);
    };
    TeX.prototype.compile = function (math, document) {
        this.parseOptions.clear();
        this.executeFilters(this.preFilters, math, document, this.parseOptions);
        var display = math.display;
        this.latex = math.math;
        var node;
        this.parseOptions.tags.startEquation(math);
        var globalEnv;
        try {
            var parser = new TexParser_js_1.default(this.latex, { display: display, isInner: false }, this.parseOptions);
            node = parser.mml();
            globalEnv = parser.stack.global;
        }
        catch (err) {
            if (!(err instanceof TexError_js_1.default)) {
                throw err;
            }
            this.parseOptions.error = true;
            node = this.options.formatError(this, err);
        }
        node = this.parseOptions.nodeFactory.create('node', 'math', [node]);
        if (globalEnv === null || globalEnv === void 0 ? void 0 : globalEnv.indentalign) {
            NodeUtil_js_1.default.setAttribute(node, 'indentalign', globalEnv.indentalign);
        }
        if (display) {
            NodeUtil_js_1.default.setAttribute(node, 'display', 'block');
        }
        this.parseOptions.tags.finishEquation(math);
        this.parseOptions.root = node;
        this.executeFilters(this.postFilters, math, document, this.parseOptions);
        this.mathNode = this.parseOptions.root;
        return this.mathNode;
    };
    TeX.prototype.findMath = function (strings) {
        return this.findTeX.findMath(strings);
    };
    TeX.prototype.formatError = function (err) {
        var message = err.message.replace(/\n.*/, '');
        return this.parseOptions.nodeFactory.create('error', message, err.id, this.latex);
    };
    TeX.NAME = 'TeX';
    TeX.OPTIONS = __assign(__assign({}, InputJax_js_1.AbstractInputJax.OPTIONS), { FindTeX: null, packages: ['base'], digits: /^(?:[0-9]+(?:\{,\}[0-9]{3})*(?:\.[0-9]*)?|\.[0-9]+)/, maxBuffer: 5 * 1024, formatError: function (jax, err) { return jax.formatError(err); } });
    return TeX;
}(InputJax_js_1.AbstractInputJax));
exports.TeX = TeX;
//# sourceMappingURL=tex.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/input/tex/FilterUtil.js":
/*!***************************************************************!*\
  !*** ../node_modules/mathjax-full/js/input/tex/FilterUtil.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var MmlNode_js_1 = __webpack_require__(/*! ../../core/MmlTree/MmlNode.js */ "../node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ./NodeUtil.js */ "../node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var FilterUtil;
(function (FilterUtil) {
    FilterUtil.cleanStretchy = function (arg) {
        var e_1, _a;
        var options = arg.data;
        try {
            for (var _b = __values(options.getList('fixStretchy')), _c = _b.next(); !_c.done; _c = _b.next()) {
                var mo = _c.value;
                if (NodeUtil_js_1.default.getProperty(mo, 'fixStretchy')) {
                    var symbol = NodeUtil_js_1.default.getForm(mo);
                    if (symbol && symbol[3] && symbol[3]['stretchy']) {
                        NodeUtil_js_1.default.setAttribute(mo, 'stretchy', false);
                    }
                    var parent_1 = mo.parent;
                    if (!NodeUtil_js_1.default.getTexClass(mo) && (!symbol || !symbol[2])) {
                        var texAtom = options.nodeFactory.create('node', 'TeXAtom', [mo]);
                        parent_1.replaceChild(texAtom, mo);
                        texAtom.inheritAttributesFrom(mo);
                    }
                    NodeUtil_js_1.default.removeProperties(mo, 'fixStretchy');
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    FilterUtil.cleanAttributes = function (arg) {
        var node = arg.data.root;
        node.walkTree(function (mml, _d) {
            var e_2, _a;
            var attribs = mml.attributes;
            if (!attribs) {
                return;
            }
            var keep = new Set((attribs.get('mjx-keep-attrs') || '').split(/ /));
            delete (attribs.getAllAttributes())['mjx-keep-attrs'];
            try {
                for (var _b = __values(attribs.getExplicitNames()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (!keep.has(key) && attribs.attributes[key] === mml.attributes.getInherited(key)) {
                        delete attribs.attributes[key];
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }, {});
    };
    FilterUtil.combineRelations = function (arg) {
        var e_3, _a, e_4, _b;
        var remove = [];
        try {
            for (var _c = __values(arg.data.getList('mo')), _e = _c.next(); !_e.done; _e = _c.next()) {
                var mo = _e.value;
                if (mo.getProperty('relationsCombined') || !mo.parent ||
                    (mo.parent && !NodeUtil_js_1.default.isType(mo.parent, 'mrow')) ||
                    NodeUtil_js_1.default.getTexClass(mo) !== MmlNode_js_1.TEXCLASS.REL) {
                    continue;
                }
                var mml = mo.parent;
                var m2 = void 0;
                var children = mml.childNodes;
                var next = children.indexOf(mo) + 1;
                var variantForm = NodeUtil_js_1.default.getProperty(mo, 'variantForm');
                while (next < children.length && (m2 = children[next]) &&
                    NodeUtil_js_1.default.isType(m2, 'mo') &&
                    NodeUtil_js_1.default.getTexClass(m2) === MmlNode_js_1.TEXCLASS.REL) {
                    if (variantForm === NodeUtil_js_1.default.getProperty(m2, 'variantForm') &&
                        _compareExplicit(mo, m2)) {
                        NodeUtil_js_1.default.appendChildren(mo, NodeUtil_js_1.default.getChildren(m2));
                        _copyExplicit(['stretchy', 'rspace'], mo, m2);
                        try {
                            for (var _f = (e_4 = void 0, __values(m2.getPropertyNames())), _g = _f.next(); !_g.done; _g = _f.next()) {
                                var name_1 = _g.value;
                                mo.setProperty(name_1, m2.getProperty(name_1));
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        children.splice(next, 1);
                        remove.push(m2);
                        m2.parent = null;
                        m2.setProperty('relationsCombined', true);
                    }
                    else {
                        if (mo.attributes.getExplicit('rspace') == null) {
                            NodeUtil_js_1.default.setAttribute(mo, 'rspace', '0pt');
                        }
                        if (m2.attributes.getExplicit('lspace') == null) {
                            NodeUtil_js_1.default.setAttribute(m2, 'lspace', '0pt');
                        }
                        break;
                    }
                }
                mo.attributes.setInherited('form', mo.getForms()[0]);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        arg.data.removeFromList('mo', remove);
    };
    var _copyExplicit = function (attrs, node1, node2) {
        var attr1 = node1.attributes;
        var attr2 = node2.attributes;
        attrs.forEach(function (x) {
            var attr = attr2.getExplicit(x);
            if (attr != null) {
                attr1.set(x, attr);
            }
        });
    };
    var _compareExplicit = function (node1, node2) {
        var e_5, _a;
        var filter = function (attr, space) {
            var exp = attr.getExplicitNames();
            return exp.filter(function (x) {
                return x !== space &&
                    (x !== 'stretchy' ||
                        attr.getExplicit('stretchy'));
            });
        };
        var attr1 = node1.attributes;
        var attr2 = node2.attributes;
        var exp1 = filter(attr1, 'lspace');
        var exp2 = filter(attr2, 'rspace');
        if (exp1.length !== exp2.length) {
            return false;
        }
        try {
            for (var exp1_1 = __values(exp1), exp1_1_1 = exp1_1.next(); !exp1_1_1.done; exp1_1_1 = exp1_1.next()) {
                var name_2 = exp1_1_1.value;
                if (attr1.getExplicit(name_2) !== attr2.getExplicit(name_2)) {
                    return false;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (exp1_1_1 && !exp1_1_1.done && (_a = exp1_1.return)) _a.call(exp1_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return true;
    };
    var _cleanSubSup = function (options, low, up) {
        var e_6, _a;
        var remove = [];
        try {
            for (var _b = __values(options.getList('m' + low + up)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var mml = _c.value;
                var children = mml.childNodes;
                if (children[mml[low]] && children[mml[up]]) {
                    continue;
                }
                var parent_2 = mml.parent;
                var newNode = (children[mml[low]] ?
                    options.nodeFactory.create('node', 'm' + low, [children[mml.base], children[mml[low]]]) :
                    options.nodeFactory.create('node', 'm' + up, [children[mml.base], children[mml[up]]]));
                NodeUtil_js_1.default.copyAttributes(mml, newNode);
                if (parent_2) {
                    parent_2.replaceChild(newNode, mml);
                }
                else {
                    options.root = newNode;
                }
                remove.push(mml);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
        options.removeFromList('m' + low + up, remove);
    };
    FilterUtil.cleanSubSup = function (arg) {
        var options = arg.data;
        if (options.error) {
            return;
        }
        _cleanSubSup(options, 'sub', 'sup');
        _cleanSubSup(options, 'under', 'over');
    };
    var _moveLimits = function (options, underover, subsup) {
        var e_7, _a;
        var remove = [];
        try {
            for (var _b = __values(options.getList(underover)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var mml = _c.value;
                if (mml.attributes.get('displaystyle')) {
                    continue;
                }
                var base = mml.childNodes[mml.base];
                var mo = base.coreMO();
                if (base.getProperty('movablelimits') && !mo.attributes.getExplicit('movablelimits')) {
                    var node = options.nodeFactory.create('node', subsup, mml.childNodes);
                    NodeUtil_js_1.default.copyAttributes(mml, node);
                    if (mml.parent) {
                        mml.parent.replaceChild(node, mml);
                    }
                    else {
                        options.root = node;
                    }
                    remove.push(mml);
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        options.removeFromList(underover, remove);
    };
    FilterUtil.moveLimits = function (arg) {
        var options = arg.data;
        _moveLimits(options, 'munderover', 'msubsup');
        _moveLimits(options, 'munder', 'msub');
        _moveLimits(options, 'mover', 'msup');
    };
    FilterUtil.setInherited = function (arg) {
        arg.data.root.setInheritedAttributes({}, arg.math['display'], 0, false);
    };
})(FilterUtil || (FilterUtil = {}));
exports["default"] = FilterUtil;
//# sourceMappingURL=FilterUtil.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/input/tex/FindTeX.js":
/*!************************************************************!*\
  !*** ../node_modules/mathjax-full/js/input/tex/FindTeX.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FindTeX = void 0;
var FindMath_js_1 = __webpack_require__(/*! ../../core/FindMath.js */ "../node_modules/mathjax-full/js/core/FindMath.js");
var string_js_1 = __webpack_require__(/*! ../../util/string.js */ "../node_modules/mathjax-full/js/util/string.js");
var MathItem_js_1 = __webpack_require__(/*! ../../core/MathItem.js */ "../node_modules/mathjax-full/js/core/MathItem.js");
var FindTeX = (function (_super) {
    __extends(FindTeX, _super);
    function FindTeX(options) {
        var _this = _super.call(this, options) || this;
        _this.getPatterns();
        return _this;
    }
    FindTeX.prototype.getPatterns = function () {
        var _this = this;
        var options = this.options;
        var starts = [], parts = [], subparts = [];
        this.end = {};
        this.env = this.sub = 0;
        var i = 1;
        options['inlineMath'].forEach(function (delims) { return _this.addPattern(starts, delims, false); });
        options['displayMath'].forEach(function (delims) { return _this.addPattern(starts, delims, true); });
        if (starts.length) {
            parts.push(starts.sort(string_js_1.sortLength).join('|'));
        }
        if (options['processEnvironments']) {
            parts.push('\\\\begin\\s*\\{([^}]*)\\}');
            this.env = i;
            i++;
        }
        if (options['processEscapes']) {
            subparts.push('\\\\([\\\\$])');
        }
        if (options['processRefs']) {
            subparts.push('(\\\\(?:eq)?ref\\s*\\{[^}]*\\})');
        }
        if (subparts.length) {
            parts.push('(' + subparts.join('|') + ')');
            this.sub = i;
        }
        this.start = new RegExp(parts.join('|'), 'g');
        this.hasPatterns = (parts.length > 0);
    };
    FindTeX.prototype.addPattern = function (starts, delims, display) {
        var _a = __read(delims, 2), open = _a[0], close = _a[1];
        starts.push((0, string_js_1.quotePattern)(open));
        this.end[open] = [close, display, this.endPattern(close)];
    };
    FindTeX.prototype.endPattern = function (end, endp) {
        return new RegExp((endp || (0, string_js_1.quotePattern)(end)) + '|\\\\(?:[a-zA-Z]|.)|[{}]', 'g');
    };
    FindTeX.prototype.findEnd = function (text, n, start, end) {
        var _a = __read(end, 3), close = _a[0], display = _a[1], pattern = _a[2];
        var i = pattern.lastIndex = start.index + start[0].length;
        var match, braces = 0;
        while ((match = pattern.exec(text))) {
            if ((match[1] || match[0]) === close && braces === 0) {
                return (0, MathItem_js_1.protoItem)(start[0], text.substr(i, match.index - i), match[0], n, start.index, match.index + match[0].length, display);
            }
            else if (match[0] === '{') {
                braces++;
            }
            else if (match[0] === '}' && braces) {
                braces--;
            }
        }
        return null;
    };
    FindTeX.prototype.findMathInString = function (math, n, text) {
        var start, match;
        this.start.lastIndex = 0;
        while ((start = this.start.exec(text))) {
            if (start[this.env] !== undefined && this.env) {
                var end = '\\\\end\\s*(\\{' + (0, string_js_1.quotePattern)(start[this.env]) + '\\})';
                match = this.findEnd(text, n, start, ['{' + start[this.env] + '}', true, this.endPattern(null, end)]);
                if (match) {
                    match.math = match.open + match.math + match.close;
                    match.open = match.close = '';
                }
            }
            else if (start[this.sub] !== undefined && this.sub) {
                var math_1 = start[this.sub];
                var end = start.index + start[this.sub].length;
                if (math_1.length === 2) {
                    match = (0, MathItem_js_1.protoItem)('', math_1.substr(1), '', n, start.index, end);
                }
                else {
                    match = (0, MathItem_js_1.protoItem)('', math_1, '', n, start.index, end, false);
                }
            }
            else {
                match = this.findEnd(text, n, start, this.end[start[0]]);
            }
            if (match) {
                math.push(match);
                this.start.lastIndex = match.end.n;
            }
        }
    };
    FindTeX.prototype.findMath = function (strings) {
        var math = [];
        if (this.hasPatterns) {
            for (var i = 0, m = strings.length; i < m; i++) {
                this.findMathInString(math, i, strings[i]);
            }
        }
        return math;
    };
    FindTeX.OPTIONS = {
        inlineMath: [
            ['\\(', '\\)']
        ],
        displayMath: [
            ['$$', '$$'],
            ['\\[', '\\]']
        ],
        processEscapes: true,
        processEnvironments: true,
        processRefs: true,
    };
    return FindTeX;
}(FindMath_js_1.AbstractFindMath));
exports.FindTeX = FindTeX;
//# sourceMappingURL=FindTeX.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX2lucHV0X3RleF9qcy5mZmJiZDZhOGY1NzNjNmZhOWNjNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsbUJBQW1CLG1CQUFPLENBQUMsMkVBQW9CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCO0FBQ3hCOzs7Ozs7Ozs7O0FDYmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCO0FBQ3hCLG1CQUFtQixtQkFBTyxDQUFDLDJFQUFvQjtBQUMvQyx3QkFBd0IsbUJBQU8sQ0FBQyxxRkFBeUI7QUFDekQ7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx3QkFBd0I7QUFDeEI7Ozs7Ozs7Ozs7QUN4RGE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsYUFBYSxHQUFHLHdCQUF3QixHQUFHLGlCQUFpQjtBQUMvRTtBQUNBLDhCQUE4QjtBQUM5QixpQkFBaUI7QUFDakIsdUJBQXVCLFVBQVUsU0FBUyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNB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Q2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxlQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9jb3JlL0ZpbmRNYXRoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvcmUvSW5wdXRKYXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvY29yZS9NYXRoSXRlbS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L0ZpbHRlclV0aWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L0ZpbmRUZVguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic3RyYWN0RmluZE1hdGggPSB2b2lkIDA7XG52YXIgT3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvT3B0aW9ucy5qc1wiKTtcbnZhciBBYnN0cmFjdEZpbmRNYXRoID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdEZpbmRNYXRoKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIENMQVNTID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gKDAsIE9wdGlvbnNfanNfMS51c2VyT3B0aW9ucykoKDAsIE9wdGlvbnNfanNfMS5kZWZhdWx0T3B0aW9ucykoe30sIENMQVNTLk9QVElPTlMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgQWJzdHJhY3RGaW5kTWF0aC5PUFRJT05TID0ge307XG4gICAgcmV0dXJuIEFic3RyYWN0RmluZE1hdGg7XG59KCkpO1xuZXhwb3J0cy5BYnN0cmFjdEZpbmRNYXRoID0gQWJzdHJhY3RGaW5kTWF0aDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpbmRNYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnN0cmFjdElucHV0SmF4ID0gdm9pZCAwO1xudmFyIE9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL09wdGlvbnMuanNcIik7XG52YXIgRnVuY3Rpb25MaXN0X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9GdW5jdGlvbkxpc3QuanNcIik7XG52YXIgQWJzdHJhY3RJbnB1dEpheCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RJbnB1dEpheChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMuYWRhcHRvciA9IG51bGw7XG4gICAgICAgIHRoaXMubW1sRmFjdG9yeSA9IG51bGw7XG4gICAgICAgIHZhciBDTEFTUyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICgwLCBPcHRpb25zX2pzXzEudXNlck9wdGlvbnMpKCgwLCBPcHRpb25zX2pzXzEuZGVmYXVsdE9wdGlvbnMpKHt9LCBDTEFTUy5PUFRJT05TKSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucHJlRmlsdGVycyA9IG5ldyBGdW5jdGlvbkxpc3RfanNfMS5GdW5jdGlvbkxpc3QoKTtcbiAgICAgICAgdGhpcy5wb3N0RmlsdGVycyA9IG5ldyBGdW5jdGlvbkxpc3RfanNfMS5GdW5jdGlvbkxpc3QoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0SW5wdXRKYXgucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLk5BTUU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBYnN0cmFjdElucHV0SmF4LnByb3RvdHlwZS5zZXRBZGFwdG9yID0gZnVuY3Rpb24gKGFkYXB0b3IpIHtcbiAgICAgICAgdGhpcy5hZGFwdG9yID0gYWRhcHRvcjtcbiAgICB9O1xuICAgIEFic3RyYWN0SW5wdXRKYXgucHJvdG90eXBlLnNldE1tbEZhY3RvcnkgPSBmdW5jdGlvbiAobW1sRmFjdG9yeSkge1xuICAgICAgICB0aGlzLm1tbEZhY3RvcnkgPSBtbWxGYWN0b3J5O1xuICAgIH07XG4gICAgQWJzdHJhY3RJbnB1dEpheC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuICAgIEFic3RyYWN0SW5wdXRKYXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIF9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdElucHV0SmF4LnByb3RvdHlwZSwgXCJwcm9jZXNzU3RyaW5nc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBYnN0cmFjdElucHV0SmF4LnByb3RvdHlwZS5maW5kTWF0aCA9IGZ1bmN0aW9uIChfbm9kZSwgX29wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgQWJzdHJhY3RJbnB1dEpheC5wcm90b3R5cGUuZXhlY3V0ZUZpbHRlcnMgPSBmdW5jdGlvbiAoZmlsdGVycywgbWF0aCwgZG9jdW1lbnQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB7IG1hdGg6IG1hdGgsIGRvY3VtZW50OiBkb2N1bWVudCwgZGF0YTogZGF0YSB9O1xuICAgICAgICBmaWx0ZXJzLmV4ZWN1dGUoYXJncyk7XG4gICAgICAgIHJldHVybiBhcmdzLmRhdGE7XG4gICAgfTtcbiAgICBBYnN0cmFjdElucHV0SmF4Lk5BTUUgPSAnZ2VuZXJpYyc7XG4gICAgQWJzdHJhY3RJbnB1dEpheC5PUFRJT05TID0ge307XG4gICAgcmV0dXJuIEFic3RyYWN0SW5wdXRKYXg7XG59KCkpO1xuZXhwb3J0cy5BYnN0cmFjdElucHV0SmF4ID0gQWJzdHJhY3RJbnB1dEpheDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlucHV0SmF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5uZXdTdGF0ZSA9IGV4cG9ydHMuU1RBVEUgPSBleHBvcnRzLkFic3RyYWN0TWF0aEl0ZW0gPSBleHBvcnRzLnByb3RvSXRlbSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHByb3RvSXRlbShvcGVuLCBtYXRoLCBjbG9zZSwgbiwgc3RhcnQsIGVuZCwgZGlzcGxheSkge1xuICAgIGlmIChkaXNwbGF5ID09PSB2b2lkIDApIHsgZGlzcGxheSA9IG51bGw7IH1cbiAgICB2YXIgaXRlbSA9IHsgb3Blbjogb3BlbiwgbWF0aDogbWF0aCwgY2xvc2U6IGNsb3NlLFxuICAgICAgICBuOiBuLCBzdGFydDogeyBuOiBzdGFydCB9LCBlbmQ6IHsgbjogZW5kIH0sIGRpc3BsYXk6IGRpc3BsYXkgfTtcbiAgICByZXR1cm4gaXRlbTtcbn1cbmV4cG9ydHMucHJvdG9JdGVtID0gcHJvdG9JdGVtO1xudmFyIEFic3RyYWN0TWF0aEl0ZW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0TWF0aEl0ZW0obWF0aCwgamF4LCBkaXNwbGF5LCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChkaXNwbGF5ID09PSB2b2lkIDApIHsgZGlzcGxheSA9IHRydWU7IH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSB7IGk6IDAsIG46IDAsIGRlbGltOiAnJyB9OyB9XG4gICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSB7IGk6IDAsIG46IDAsIGRlbGltOiAnJyB9OyB9XG4gICAgICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMudHlwZXNldFJvb3QgPSBudWxsO1xuICAgICAgICB0aGlzLm1ldHJpY3MgPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dERhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhID0ge307XG4gICAgICAgIHRoaXMuX3N0YXRlID0gZXhwb3J0cy5TVEFURS5VTlBST0NFU1NFRDtcbiAgICAgICAgdGhpcy5tYXRoID0gbWF0aDtcbiAgICAgICAgdGhpcy5pbnB1dEpheCA9IGpheDtcbiAgICAgICAgdGhpcy5kaXNwbGF5ID0gZGlzcGxheTtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICAgICAgdGhpcy5yb290ID0gbnVsbDtcbiAgICAgICAgdGhpcy50eXBlc2V0Um9vdCA9IG51bGw7XG4gICAgICAgIHRoaXMubWV0cmljcyA9IHt9O1xuICAgICAgICB0aGlzLmlucHV0RGF0YSA9IHt9O1xuICAgICAgICB0aGlzLm91dHB1dERhdGEgPSB7fTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0TWF0aEl0ZW0ucHJvdG90eXBlLCBcImlzRXNjYXBlZFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGxheSA9PT0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEFic3RyYWN0TWF0aEl0ZW0ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICBkb2N1bWVudC5yZW5kZXJBY3Rpb25zLnJlbmRlck1hdGgodGhpcywgZG9jdW1lbnQpO1xuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoSXRlbS5wcm90b3R5cGUucmVyZW5kZXIgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIHN0YXJ0KSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gZXhwb3J0cy5TVEFURS5SRVJFTkRFUjsgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSgpID49IHN0YXJ0KSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlKHN0YXJ0IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQucmVuZGVyQWN0aW9ucy5yZW5kZXJNYXRoKHRoaXMsIGRvY3VtZW50LCBzdGFydCk7XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhJdGVtLnByb3RvdHlwZS5jb252ZXJ0ID0gZnVuY3Rpb24gKGRvY3VtZW50LCBlbmQpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IGV4cG9ydHMuU1RBVEUuTEFTVDsgfVxuICAgICAgICBkb2N1bWVudC5yZW5kZXJBY3Rpb25zLnJlbmRlckNvbnZlcnQodGhpcywgZG9jdW1lbnQsIGVuZCk7XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhJdGVtLnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPCBleHBvcnRzLlNUQVRFLkNPTVBJTEVEKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLmlucHV0SmF4LmNvbXBpbGUodGhpcywgZG9jdW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZShleHBvcnRzLlNUQVRFLkNPTVBJTEVEKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoSXRlbS5wcm90b3R5cGUudHlwZXNldCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSgpIDwgZXhwb3J0cy5TVEFURS5UWVBFU0VUKSB7XG4gICAgICAgICAgICB0aGlzLnR5cGVzZXRSb290ID0gZG9jdW1lbnQub3V0cHV0SmF4W3RoaXMuaXNFc2NhcGVkID8gJ2VzY2FwZWQnIDogJ3R5cGVzZXQnXSh0aGlzLCBkb2N1bWVudCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlKGV4cG9ydHMuU1RBVEUuVFlQRVNFVCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0TWF0aEl0ZW0ucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50ID0gZnVuY3Rpb24gKF9kb2N1bWVudCkgeyB9O1xuICAgIEFic3RyYWN0TWF0aEl0ZW0ucHJvdG90eXBlLnJlbW92ZUZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uIChfcmVzdG9yZSkge1xuICAgICAgICBpZiAoX3Jlc3RvcmUgPT09IHZvaWQgMCkgeyBfcmVzdG9yZSA9IGZhbHNlOyB9XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhJdGVtLnByb3RvdHlwZS5zZXRNZXRyaWNzID0gZnVuY3Rpb24gKGVtLCBleCwgY3dpZHRoLCBsd2lkdGgsIHNjYWxlKSB7XG4gICAgICAgIHRoaXMubWV0cmljcyA9IHtcbiAgICAgICAgICAgIGVtOiBlbSwgZXg6IGV4LFxuICAgICAgICAgICAgY29udGFpbmVyV2lkdGg6IGN3aWR0aCxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogbHdpZHRoLFxuICAgICAgICAgICAgc2NhbGU6IHNjYWxlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhJdGVtLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgcmVzdG9yZSkge1xuICAgICAgICBpZiAoc3RhdGUgPT09IHZvaWQgMCkgeyBzdGF0ZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKHJlc3RvcmUgPT09IHZvaWQgMCkgeyByZXN0b3JlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA8IGV4cG9ydHMuU1RBVEUuSU5TRVJURUQgJiYgdGhpcy5fc3RhdGUgPj0gZXhwb3J0cy5TVEFURS5JTlNFUlRFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbURvY3VtZW50KHJlc3RvcmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlIDwgZXhwb3J0cy5TVEFURS5UWVBFU0VUICYmIHRoaXMuX3N0YXRlID49IGV4cG9ydHMuU1RBVEUuVFlQRVNFVCkge1xuICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0RGF0YSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlIDwgZXhwb3J0cy5TVEFURS5DT01QSUxFRCAmJiB0aGlzLl9zdGF0ZSA+PSBleHBvcnRzLlNUQVRFLkNPTVBJTEVEKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dERhdGEgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoSXRlbS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAocmVzdG9yZSkge1xuICAgICAgICBpZiAocmVzdG9yZSA9PT0gdm9pZCAwKSB7IHJlc3RvcmUgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnN0YXRlKGV4cG9ydHMuU1RBVEUuVU5QUk9DRVNTRUQsIHJlc3RvcmUpO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0TWF0aEl0ZW07XG59KCkpO1xuZXhwb3J0cy5BYnN0cmFjdE1hdGhJdGVtID0gQWJzdHJhY3RNYXRoSXRlbTtcbmV4cG9ydHMuU1RBVEUgPSB7XG4gICAgVU5QUk9DRVNTRUQ6IDAsXG4gICAgRklORE1BVEg6IDEwLFxuICAgIENPTVBJTEVEOiAyMCxcbiAgICBDT05WRVJUOiAxMDAsXG4gICAgTUVUUklDUzogMTEwLFxuICAgIFJFUkVOREVSOiAxMjUsXG4gICAgVFlQRVNFVDogMTUwLFxuICAgIElOU0VSVEVEOiAyMDAsXG4gICAgTEFTVDogMTAwMDBcbn07XG5mdW5jdGlvbiBuZXdTdGF0ZShuYW1lLCBzdGF0ZSkge1xuICAgIGlmIChuYW1lIGluIGV4cG9ydHMuU1RBVEUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1N0YXRlICcgKyBuYW1lICsgJyBhbHJlYWR5IGV4aXN0cycpO1xuICAgIH1cbiAgICBleHBvcnRzLlNUQVRFW25hbWVdID0gc3RhdGU7XG59XG5leHBvcnRzLm5ld1N0YXRlID0gbmV3U3RhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRoSXRlbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UZVggPSB2b2lkIDA7XG52YXIgSW5wdXRKYXhfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL0lucHV0SmF4LmpzXCIpO1xudmFyIE9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL09wdGlvbnMuanNcIik7XG52YXIgRmluZFRlWF9qc18xID0gcmVxdWlyZShcIi4vdGV4L0ZpbmRUZVguanNcIik7XG52YXIgRmlsdGVyVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RleC9GaWx0ZXJVdGlsLmpzXCIpKTtcbnZhciBOb2RlVXRpbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RleC9Ob2RlVXRpbC5qc1wiKSk7XG52YXIgVGV4UGFyc2VyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdGV4L1RleFBhcnNlci5qc1wiKSk7XG52YXIgVGV4RXJyb3JfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi90ZXgvVGV4RXJyb3IuanNcIikpO1xudmFyIFBhcnNlT3B0aW9uc19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3RleC9QYXJzZU9wdGlvbnMuanNcIikpO1xudmFyIFRhZ3NfanNfMSA9IHJlcXVpcmUoXCIuL3RleC9UYWdzLmpzXCIpO1xudmFyIENvbmZpZ3VyYXRpb25fanNfMSA9IHJlcXVpcmUoXCIuL3RleC9Db25maWd1cmF0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vdGV4L2Jhc2UvQmFzZUNvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgVGVYID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVYLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRlWChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCgoMCwgT3B0aW9uc19qc18xLnNlcGFyYXRlT3B0aW9ucykob3B0aW9ucywgVGVYLk9QVElPTlMsIEZpbmRUZVhfanNfMS5GaW5kVGVYLk9QVElPTlMpLCAzKSwgcmVzdCA9IF9hWzBdLCB0ZXggPSBfYVsxXSwgZmluZCA9IF9hWzJdO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRleCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZmluZFRlWCA9IF90aGlzLm9wdGlvbnNbJ0ZpbmRUZVgnXSB8fCBuZXcgRmluZFRlWF9qc18xLkZpbmRUZVgoZmluZCk7XG4gICAgICAgIHZhciBwYWNrYWdlcyA9IF90aGlzLm9wdGlvbnMucGFja2FnZXM7XG4gICAgICAgIHZhciBjb25maWd1cmF0aW9uID0gX3RoaXMuY29uZmlndXJhdGlvbiA9IFRlWC5jb25maWd1cmUocGFja2FnZXMpO1xuICAgICAgICB2YXIgcGFyc2VPcHRpb25zID0gX3RoaXMuX3BhcnNlT3B0aW9ucyA9XG4gICAgICAgICAgICBuZXcgUGFyc2VPcHRpb25zX2pzXzEuZGVmYXVsdChjb25maWd1cmF0aW9uLCBbX3RoaXMub3B0aW9ucywgVGFnc19qc18xLlRhZ3NGYWN0b3J5Lk9QVElPTlNdKTtcbiAgICAgICAgKDAsIE9wdGlvbnNfanNfMS51c2VyT3B0aW9ucykocGFyc2VPcHRpb25zLm9wdGlvbnMsIHJlc3QpO1xuICAgICAgICBjb25maWd1cmF0aW9uLmNvbmZpZyhfdGhpcyk7XG4gICAgICAgIFRlWC50YWdzKHBhcnNlT3B0aW9ucywgY29uZmlndXJhdGlvbik7XG4gICAgICAgIF90aGlzLnBvc3RGaWx0ZXJzLmFkZChGaWx0ZXJVdGlsX2pzXzEuZGVmYXVsdC5jbGVhblN1YlN1cCwgLTYpO1xuICAgICAgICBfdGhpcy5wb3N0RmlsdGVycy5hZGQoRmlsdGVyVXRpbF9qc18xLmRlZmF1bHQuc2V0SW5oZXJpdGVkLCAtNSk7XG4gICAgICAgIF90aGlzLnBvc3RGaWx0ZXJzLmFkZChGaWx0ZXJVdGlsX2pzXzEuZGVmYXVsdC5tb3ZlTGltaXRzLCAtNCk7XG4gICAgICAgIF90aGlzLnBvc3RGaWx0ZXJzLmFkZChGaWx0ZXJVdGlsX2pzXzEuZGVmYXVsdC5jbGVhblN0cmV0Y2h5LCAtMyk7XG4gICAgICAgIF90aGlzLnBvc3RGaWx0ZXJzLmFkZChGaWx0ZXJVdGlsX2pzXzEuZGVmYXVsdC5jbGVhbkF0dHJpYnV0ZXMsIC0yKTtcbiAgICAgICAgX3RoaXMucG9zdEZpbHRlcnMuYWRkKEZpbHRlclV0aWxfanNfMS5kZWZhdWx0LmNvbWJpbmVSZWxhdGlvbnMsIC0xKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUZVguY29uZmlndXJlID0gZnVuY3Rpb24gKHBhY2thZ2VzKSB7XG4gICAgICAgIHZhciBjb25maWd1cmF0aW9uID0gbmV3IENvbmZpZ3VyYXRpb25fanNfMS5QYXJzZXJDb25maWd1cmF0aW9uKHBhY2thZ2VzLCBbJ3RleCddKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pbml0KCk7XG4gICAgICAgIHJldHVybiBjb25maWd1cmF0aW9uO1xuICAgIH07XG4gICAgVGVYLnRhZ3MgPSBmdW5jdGlvbiAob3B0aW9ucywgY29uZmlndXJhdGlvbikge1xuICAgICAgICBUYWdzX2pzXzEuVGFnc0ZhY3RvcnkuYWRkVGFncyhjb25maWd1cmF0aW9uLnRhZ3MpO1xuICAgICAgICBUYWdzX2pzXzEuVGFnc0ZhY3Rvcnkuc2V0RGVmYXVsdChvcHRpb25zLm9wdGlvbnMudGFncyk7XG4gICAgICAgIG9wdGlvbnMudGFncyA9IFRhZ3NfanNfMS5UYWdzRmFjdG9yeS5nZXREZWZhdWx0KCk7XG4gICAgICAgIG9wdGlvbnMudGFncy5jb25maWd1cmF0aW9uID0gb3B0aW9ucztcbiAgICB9O1xuICAgIFRlWC5wcm90b3R5cGUuc2V0TW1sRmFjdG9yeSA9IGZ1bmN0aW9uIChtbWxGYWN0b3J5KSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2V0TW1sRmFjdG9yeS5jYWxsKHRoaXMsIG1tbEZhY3RvcnkpO1xuICAgICAgICB0aGlzLl9wYXJzZU9wdGlvbnMubm9kZUZhY3Rvcnkuc2V0TW1sRmFjdG9yeShtbWxGYWN0b3J5KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZVgucHJvdG90eXBlLCBcInBhcnNlT3B0aW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlT3B0aW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFRlWC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgICAgIGlmICh0YWcgPT09IHZvaWQgMCkgeyB0YWcgPSAwOyB9XG4gICAgICAgIHRoaXMucGFyc2VPcHRpb25zLnRhZ3MucmVzZXQodGFnKTtcbiAgICB9O1xuICAgIFRlWC5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChtYXRoLCBkb2N1bWVudCkge1xuICAgICAgICB0aGlzLnBhcnNlT3B0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLmV4ZWN1dGVGaWx0ZXJzKHRoaXMucHJlRmlsdGVycywgbWF0aCwgZG9jdW1lbnQsIHRoaXMucGFyc2VPcHRpb25zKTtcbiAgICAgICAgdmFyIGRpc3BsYXkgPSBtYXRoLmRpc3BsYXk7XG4gICAgICAgIHRoaXMubGF0ZXggPSBtYXRoLm1hdGg7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB0aGlzLnBhcnNlT3B0aW9ucy50YWdzLnN0YXJ0RXF1YXRpb24obWF0aCk7XG4gICAgICAgIHZhciBnbG9iYWxFbnY7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VyID0gbmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQodGhpcy5sYXRleCwgeyBkaXNwbGF5OiBkaXNwbGF5LCBpc0lubmVyOiBmYWxzZSB9LCB0aGlzLnBhcnNlT3B0aW9ucyk7XG4gICAgICAgICAgICBub2RlID0gcGFyc2VyLm1tbCgpO1xuICAgICAgICAgICAgZ2xvYmFsRW52ID0gcGFyc2VyLnN0YWNrLmdsb2JhbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBUZXhFcnJvcl9qc18xLmRlZmF1bHQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYXJzZU9wdGlvbnMuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMub3B0aW9ucy5mb3JtYXRFcnJvcih0aGlzLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSB0aGlzLnBhcnNlT3B0aW9ucy5ub2RlRmFjdG9yeS5jcmVhdGUoJ25vZGUnLCAnbWF0aCcsIFtub2RlXSk7XG4gICAgICAgIGlmIChnbG9iYWxFbnYgPT09IG51bGwgfHwgZ2xvYmFsRW52ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxFbnYuaW5kZW50YWxpZ24pIHtcbiAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUobm9kZSwgJ2luZGVudGFsaWduJywgZ2xvYmFsRW52LmluZGVudGFsaWduKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGxheSkge1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldEF0dHJpYnV0ZShub2RlLCAnZGlzcGxheScsICdibG9jaycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VPcHRpb25zLnRhZ3MuZmluaXNoRXF1YXRpb24obWF0aCk7XG4gICAgICAgIHRoaXMucGFyc2VPcHRpb25zLnJvb3QgPSBub2RlO1xuICAgICAgICB0aGlzLmV4ZWN1dGVGaWx0ZXJzKHRoaXMucG9zdEZpbHRlcnMsIG1hdGgsIGRvY3VtZW50LCB0aGlzLnBhcnNlT3B0aW9ucyk7XG4gICAgICAgIHRoaXMubWF0aE5vZGUgPSB0aGlzLnBhcnNlT3B0aW9ucy5yb290O1xuICAgICAgICByZXR1cm4gdGhpcy5tYXRoTm9kZTtcbiAgICB9O1xuICAgIFRlWC5wcm90b3R5cGUuZmluZE1hdGggPSBmdW5jdGlvbiAoc3RyaW5ncykge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kVGVYLmZpbmRNYXRoKHN0cmluZ3MpO1xuICAgIH07XG4gICAgVGVYLnByb3RvdHlwZS5mb3JtYXRFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSBlcnIubWVzc2FnZS5yZXBsYWNlKC9cXG4uKi8sICcnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcHRpb25zLm5vZGVGYWN0b3J5LmNyZWF0ZSgnZXJyb3InLCBtZXNzYWdlLCBlcnIuaWQsIHRoaXMubGF0ZXgpO1xuICAgIH07XG4gICAgVGVYLk5BTUUgPSAnVGVYJztcbiAgICBUZVguT1BUSU9OUyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBJbnB1dEpheF9qc18xLkFic3RyYWN0SW5wdXRKYXguT1BUSU9OUyksIHsgRmluZFRlWDogbnVsbCwgcGFja2FnZXM6IFsnYmFzZSddLCBkaWdpdHM6IC9eKD86WzAtOV0rKD86XFx7LFxcfVswLTldezN9KSooPzpcXC5bMC05XSopP3xcXC5bMC05XSspLywgbWF4QnVmZmVyOiA1ICogMTAyNCwgZm9ybWF0RXJyb3I6IGZ1bmN0aW9uIChqYXgsIGVycikgeyByZXR1cm4gamF4LmZvcm1hdEVycm9yKGVycik7IH0gfSk7XG4gICAgcmV0dXJuIFRlWDtcbn0oSW5wdXRKYXhfanNfMS5BYnN0cmFjdElucHV0SmF4KSk7XG5leHBvcnRzLlRlWCA9IFRlWDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNbWxOb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGUuanNcIik7XG52YXIgTm9kZVV0aWxfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Ob2RlVXRpbC5qc1wiKSk7XG52YXIgRmlsdGVyVXRpbDtcbihmdW5jdGlvbiAoRmlsdGVyVXRpbCkge1xuICAgIEZpbHRlclV0aWwuY2xlYW5TdHJldGNoeSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJnLmRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKG9wdGlvbnMuZ2V0TGlzdCgnZml4U3RyZXRjaHknKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW8gPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldFByb3BlcnR5KG1vLCAnZml4U3RyZXRjaHknKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ltYm9sID0gTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldEZvcm0obW8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3ltYm9sICYmIHN5bWJvbFszXSAmJiBzeW1ib2xbM11bJ3N0cmV0Y2h5J10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRBdHRyaWJ1dGUobW8sICdzdHJldGNoeScsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzEgPSBtby5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldFRleENsYXNzKG1vKSAmJiAoIXN5bWJvbCB8fCAhc3ltYm9sWzJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRleEF0b20gPSBvcHRpb25zLm5vZGVGYWN0b3J5LmNyZWF0ZSgnbm9kZScsICdUZVhBdG9tJywgW21vXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMS5yZXBsYWNlQ2hpbGQodGV4QXRvbSwgbW8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4QXRvbS5pbmhlcml0QXR0cmlidXRlc0Zyb20obW8pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5yZW1vdmVQcm9wZXJ0aWVzKG1vLCAnZml4U3RyZXRjaHknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsdGVyVXRpbC5jbGVhbkF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHZhciBub2RlID0gYXJnLmRhdGEucm9vdDtcbiAgICAgICAgbm9kZS53YWxrVHJlZShmdW5jdGlvbiAobW1sLCBfZCkge1xuICAgICAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgICAgICB2YXIgYXR0cmlicyA9IG1tbC5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtlZXAgPSBuZXcgU2V0KChhdHRyaWJzLmdldCgnbWp4LWtlZXAtYXR0cnMnKSB8fCAnJykuc3BsaXQoLyAvKSk7XG4gICAgICAgICAgICBkZWxldGUgKGF0dHJpYnMuZ2V0QWxsQXR0cmlidXRlcygpKVsnbWp4LWtlZXAtYXR0cnMnXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhhdHRyaWJzLmdldEV4cGxpY2l0TmFtZXMoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWtlZXAuaGFzKGtleSkgJiYgYXR0cmlicy5hdHRyaWJ1dGVzW2tleV0gPT09IG1tbC5hdHRyaWJ1dGVzLmdldEluaGVyaXRlZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlicy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHt9KTtcbiAgICB9O1xuICAgIEZpbHRlclV0aWwuY29tYmluZVJlbGF0aW9ucyA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIGVfMywgX2EsIGVfNCwgX2I7XG4gICAgICAgIHZhciByZW1vdmUgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMoYXJnLmRhdGEuZ2V0TGlzdCgnbW8nKSksIF9lID0gX2MubmV4dCgpOyAhX2UuZG9uZTsgX2UgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW8gPSBfZS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAobW8uZ2V0UHJvcGVydHkoJ3JlbGF0aW9uc0NvbWJpbmVkJykgfHwgIW1vLnBhcmVudCB8fFxuICAgICAgICAgICAgICAgICAgICAobW8ucGFyZW50ICYmICFOb2RlVXRpbF9qc18xLmRlZmF1bHQuaXNUeXBlKG1vLnBhcmVudCwgJ21yb3cnKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldFRleENsYXNzKG1vKSAhPT0gTW1sTm9kZV9qc18xLlRFWENMQVNTLlJFTCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1tbCA9IG1vLnBhcmVudDtcbiAgICAgICAgICAgICAgICB2YXIgbTIgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gbW1sLmNoaWxkTm9kZXM7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSBjaGlsZHJlbi5pbmRleE9mKG1vKSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhbnRGb3JtID0gTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldFByb3BlcnR5KG1vLCAndmFyaWFudEZvcm0nKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dCA8IGNoaWxkcmVuLmxlbmd0aCAmJiAobTIgPSBjaGlsZHJlbltuZXh0XSkgJiZcbiAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmlzVHlwZShtMiwgJ21vJykgJiZcbiAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldFRleENsYXNzKG0yKSA9PT0gTW1sTm9kZV9qc18xLlRFWENMQVNTLlJFTCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFudEZvcm0gPT09IE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRQcm9wZXJ0eShtMiwgJ3ZhcmlhbnRGb3JtJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb21wYXJlRXhwbGljaXQobW8sIG0yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmFwcGVuZENoaWxkcmVuKG1vLCBOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0Q2hpbGRyZW4obTIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb3B5RXhwbGljaXQoWydzdHJldGNoeScsICdyc3BhY2UnXSwgbW8sIG0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSAoZV80ID0gdm9pZCAwLCBfX3ZhbHVlcyhtMi5nZXRQcm9wZXJ0eU5hbWVzKCkpKSwgX2cgPSBfZi5uZXh0KCk7ICFfZy5kb25lOyBfZyA9IF9mLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gX2cudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vLnNldFByb3BlcnR5KG5hbWVfMSwgbTIuZ2V0UHJvcGVydHkobmFtZV8xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfZyAmJiAhX2cuZG9uZSAmJiAoX2IgPSBfZi5yZXR1cm4pKSBfYi5jYWxsKF9mKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKG5leHQsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2gobTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbTIucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0yLnNldFByb3BlcnR5KCdyZWxhdGlvbnNDb21iaW5lZCcsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vLmF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQoJ3JzcGFjZScpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXR0cmlidXRlKG1vLCAncnNwYWNlJywgJzBwdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0yLmF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQoJ2xzcGFjZScpID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuc2V0QXR0cmlidXRlKG0yLCAnbHNwYWNlJywgJzBwdCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW8uYXR0cmlidXRlcy5zZXRJbmhlcml0ZWQoJ2Zvcm0nLCBtby5nZXRGb3JtcygpWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9lICYmICFfZS5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGFyZy5kYXRhLnJlbW92ZUZyb21MaXN0KCdtbycsIHJlbW92ZSk7XG4gICAgfTtcbiAgICB2YXIgX2NvcHlFeHBsaWNpdCA9IGZ1bmN0aW9uIChhdHRycywgbm9kZTEsIG5vZGUyKSB7XG4gICAgICAgIHZhciBhdHRyMSA9IG5vZGUxLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBhdHRyMiA9IG5vZGUyLmF0dHJpYnV0ZXM7XG4gICAgICAgIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cjIuZ2V0RXhwbGljaXQoeCk7XG4gICAgICAgICAgICBpZiAoYXR0ciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cjEuc2V0KHgsIGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHZhciBfY29tcGFyZUV4cGxpY2l0ID0gZnVuY3Rpb24gKG5vZGUxLCBub2RlMikge1xuICAgICAgICB2YXIgZV81LCBfYTtcbiAgICAgICAgdmFyIGZpbHRlciA9IGZ1bmN0aW9uIChhdHRyLCBzcGFjZSkge1xuICAgICAgICAgICAgdmFyIGV4cCA9IGF0dHIuZ2V0RXhwbGljaXROYW1lcygpO1xuICAgICAgICAgICAgcmV0dXJuIGV4cC5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geCAhPT0gc3BhY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgKHggIT09ICdzdHJldGNoeScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIuZ2V0RXhwbGljaXQoJ3N0cmV0Y2h5JykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhdHRyMSA9IG5vZGUxLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBhdHRyMiA9IG5vZGUyLmF0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBleHAxID0gZmlsdGVyKGF0dHIxLCAnbHNwYWNlJyk7XG4gICAgICAgIHZhciBleHAyID0gZmlsdGVyKGF0dHIyLCAncnNwYWNlJyk7XG4gICAgICAgIGlmIChleHAxLmxlbmd0aCAhPT0gZXhwMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgZXhwMV8xID0gX192YWx1ZXMoZXhwMSksIGV4cDFfMV8xID0gZXhwMV8xLm5leHQoKTsgIWV4cDFfMV8xLmRvbmU7IGV4cDFfMV8xID0gZXhwMV8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzIgPSBleHAxXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cjEuZ2V0RXhwbGljaXQobmFtZV8yKSAhPT0gYXR0cjIuZ2V0RXhwbGljaXQobmFtZV8yKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwMV8xXzEgJiYgIWV4cDFfMV8xLmRvbmUgJiYgKF9hID0gZXhwMV8xLnJldHVybikpIF9hLmNhbGwoZXhwMV8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIHZhciBfY2xlYW5TdWJTdXAgPSBmdW5jdGlvbiAob3B0aW9ucywgbG93LCB1cCkge1xuICAgICAgICB2YXIgZV82LCBfYTtcbiAgICAgICAgdmFyIHJlbW92ZSA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhvcHRpb25zLmdldExpc3QoJ20nICsgbG93ICsgdXApKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtbWwgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBtbWwuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5bbW1sW2xvd11dICYmIGNoaWxkcmVuW21tbFt1cF1dKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50XzIgPSBtbWwucGFyZW50O1xuICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gKGNoaWxkcmVuW21tbFtsb3ddXSA/XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubm9kZUZhY3RvcnkuY3JlYXRlKCdub2RlJywgJ20nICsgbG93LCBbY2hpbGRyZW5bbW1sLmJhc2VdLCBjaGlsZHJlblttbWxbbG93XV1dKSA6XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubm9kZUZhY3RvcnkuY3JlYXRlKCdub2RlJywgJ20nICsgdXAsIFtjaGlsZHJlblttbWwuYmFzZV0sIGNoaWxkcmVuW21tbFt1cF1dXSkpO1xuICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5jb3B5QXR0cmlidXRlcyhtbWwsIG5ld05vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRfMikge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRfMi5yZXBsYWNlQ2hpbGQobmV3Tm9kZSwgbW1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucm9vdCA9IG5ld05vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW92ZS5wdXNoKG1tbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfNl8xKSB7IGVfNiA9IHsgZXJyb3I6IGVfNl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV82KSB0aHJvdyBlXzYuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnJlbW92ZUZyb21MaXN0KCdtJyArIGxvdyArIHVwLCByZW1vdmUpO1xuICAgIH07XG4gICAgRmlsdGVyVXRpbC5jbGVhblN1YlN1cCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmcuZGF0YTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfY2xlYW5TdWJTdXAob3B0aW9ucywgJ3N1YicsICdzdXAnKTtcbiAgICAgICAgX2NsZWFuU3ViU3VwKG9wdGlvbnMsICd1bmRlcicsICdvdmVyJyk7XG4gICAgfTtcbiAgICB2YXIgX21vdmVMaW1pdHMgPSBmdW5jdGlvbiAob3B0aW9ucywgdW5kZXJvdmVyLCBzdWJzdXApIHtcbiAgICAgICAgdmFyIGVfNywgX2E7XG4gICAgICAgIHZhciByZW1vdmUgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMob3B0aW9ucy5nZXRMaXN0KHVuZGVyb3ZlcikpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1tbCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChtbWwuYXR0cmlidXRlcy5nZXQoJ2Rpc3BsYXlzdHlsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYmFzZSA9IG1tbC5jaGlsZE5vZGVzW21tbC5iYXNlXTtcbiAgICAgICAgICAgICAgICB2YXIgbW8gPSBiYXNlLmNvcmVNTygpO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlLmdldFByb3BlcnR5KCdtb3ZhYmxlbGltaXRzJykgJiYgIW1vLmF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQoJ21vdmFibGVsaW1pdHMnKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZUZhY3RvcnkuY3JlYXRlKCdub2RlJywgc3Vic3VwLCBtbWwuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5jb3B5QXR0cmlidXRlcyhtbWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobW1sLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW1sLnBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgbW1sKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucm9vdCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2gobW1sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfN18xKSB7IGVfNyA9IHsgZXJyb3I6IGVfN18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV83KSB0aHJvdyBlXzcuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnJlbW92ZUZyb21MaXN0KHVuZGVyb3ZlciwgcmVtb3ZlKTtcbiAgICB9O1xuICAgIEZpbHRlclV0aWwubW92ZUxpbWl0cyA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmcuZGF0YTtcbiAgICAgICAgX21vdmVMaW1pdHMob3B0aW9ucywgJ211bmRlcm92ZXInLCAnbXN1YnN1cCcpO1xuICAgICAgICBfbW92ZUxpbWl0cyhvcHRpb25zLCAnbXVuZGVyJywgJ21zdWInKTtcbiAgICAgICAgX21vdmVMaW1pdHMob3B0aW9ucywgJ21vdmVyJywgJ21zdXAnKTtcbiAgICB9O1xuICAgIEZpbHRlclV0aWwuc2V0SW5oZXJpdGVkID0gZnVuY3Rpb24gKGFyZykge1xuICAgICAgICBhcmcuZGF0YS5yb290LnNldEluaGVyaXRlZEF0dHJpYnV0ZXMoe30sIGFyZy5tYXRoWydkaXNwbGF5J10sIDAsIGZhbHNlKTtcbiAgICB9O1xufSkoRmlsdGVyVXRpbCB8fCAoRmlsdGVyVXRpbCA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGaWx0ZXJVdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmlsdGVyVXRpbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbmRUZVggPSB2b2lkIDA7XG52YXIgRmluZE1hdGhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL0ZpbmRNYXRoLmpzXCIpO1xudmFyIHN0cmluZ19qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvc3RyaW5nLmpzXCIpO1xudmFyIE1hdGhJdGVtX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9NYXRoSXRlbS5qc1wiKTtcbnZhciBGaW5kVGVYID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmluZFRlWCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaW5kVGVYKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgb3B0aW9ucykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZ2V0UGF0dGVybnMoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGaW5kVGVYLnByb3RvdHlwZS5nZXRQYXR0ZXJucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHZhciBzdGFydHMgPSBbXSwgcGFydHMgPSBbXSwgc3VicGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbmQgPSB7fTtcbiAgICAgICAgdGhpcy5lbnYgPSB0aGlzLnN1YiA9IDA7XG4gICAgICAgIHZhciBpID0gMTtcbiAgICAgICAgb3B0aW9uc1snaW5saW5lTWF0aCddLmZvckVhY2goZnVuY3Rpb24gKGRlbGltcykgeyByZXR1cm4gX3RoaXMuYWRkUGF0dGVybihzdGFydHMsIGRlbGltcywgZmFsc2UpOyB9KTtcbiAgICAgICAgb3B0aW9uc1snZGlzcGxheU1hdGgnXS5mb3JFYWNoKGZ1bmN0aW9uIChkZWxpbXMpIHsgcmV0dXJuIF90aGlzLmFkZFBhdHRlcm4oc3RhcnRzLCBkZWxpbXMsIHRydWUpOyB9KTtcbiAgICAgICAgaWYgKHN0YXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goc3RhcnRzLnNvcnQoc3RyaW5nX2pzXzEuc29ydExlbmd0aCkuam9pbignfCcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uc1sncHJvY2Vzc0Vudmlyb25tZW50cyddKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdcXFxcXFxcXGJlZ2luXFxcXHMqXFxcXHsoW159XSopXFxcXH0nKTtcbiAgICAgICAgICAgIHRoaXMuZW52ID0gaTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uc1sncHJvY2Vzc0VzY2FwZXMnXSkge1xuICAgICAgICAgICAgc3VicGFydHMucHVzaCgnXFxcXFxcXFwoW1xcXFxcXFxcJF0pJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnNbJ3Byb2Nlc3NSZWZzJ10pIHtcbiAgICAgICAgICAgIHN1YnBhcnRzLnB1c2goJyhcXFxcXFxcXCg/OmVxKT9yZWZcXFxccypcXFxce1tefV0qXFxcXH0pJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YnBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFydHMucHVzaCgnKCcgKyBzdWJwYXJ0cy5qb2luKCd8JykgKyAnKScpO1xuICAgICAgICAgICAgdGhpcy5zdWIgPSBpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnQgPSBuZXcgUmVnRXhwKHBhcnRzLmpvaW4oJ3wnKSwgJ2cnKTtcbiAgICAgICAgdGhpcy5oYXNQYXR0ZXJucyA9IChwYXJ0cy5sZW5ndGggPiAwKTtcbiAgICB9O1xuICAgIEZpbmRUZVgucHJvdG90eXBlLmFkZFBhdHRlcm4gPSBmdW5jdGlvbiAoc3RhcnRzLCBkZWxpbXMsIGRpc3BsYXkpIHtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKGRlbGltcywgMiksIG9wZW4gPSBfYVswXSwgY2xvc2UgPSBfYVsxXTtcbiAgICAgICAgc3RhcnRzLnB1c2goKDAsIHN0cmluZ19qc18xLnF1b3RlUGF0dGVybikob3BlbikpO1xuICAgICAgICB0aGlzLmVuZFtvcGVuXSA9IFtjbG9zZSwgZGlzcGxheSwgdGhpcy5lbmRQYXR0ZXJuKGNsb3NlKV07XG4gICAgfTtcbiAgICBGaW5kVGVYLnByb3RvdHlwZS5lbmRQYXR0ZXJuID0gZnVuY3Rpb24gKGVuZCwgZW5kcCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCgoZW5kcCB8fCAoMCwgc3RyaW5nX2pzXzEucXVvdGVQYXR0ZXJuKShlbmQpKSArICd8XFxcXFxcXFwoPzpbYS16QS1aXXwuKXxbe31dJywgJ2cnKTtcbiAgICB9O1xuICAgIEZpbmRUZVgucHJvdG90eXBlLmZpbmRFbmQgPSBmdW5jdGlvbiAodGV4dCwgbiwgc3RhcnQsIGVuZCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoZW5kLCAzKSwgY2xvc2UgPSBfYVswXSwgZGlzcGxheSA9IF9hWzFdLCBwYXR0ZXJuID0gX2FbMl07XG4gICAgICAgIHZhciBpID0gcGF0dGVybi5sYXN0SW5kZXggPSBzdGFydC5pbmRleCArIHN0YXJ0WzBdLmxlbmd0aDtcbiAgICAgICAgdmFyIG1hdGNoLCBicmFjZXMgPSAwO1xuICAgICAgICB3aGlsZSAoKG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpKSkge1xuICAgICAgICAgICAgaWYgKChtYXRjaFsxXSB8fCBtYXRjaFswXSkgPT09IGNsb3NlICYmIGJyYWNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgTWF0aEl0ZW1fanNfMS5wcm90b0l0ZW0pKHN0YXJ0WzBdLCB0ZXh0LnN1YnN0cihpLCBtYXRjaC5pbmRleCAtIGkpLCBtYXRjaFswXSwgbiwgc3RhcnQuaW5kZXgsIG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoLCBkaXNwbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBicmFjZXMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdID09PSAnfScgJiYgYnJhY2VzKSB7XG4gICAgICAgICAgICAgICAgYnJhY2VzLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBGaW5kVGVYLnByb3RvdHlwZS5maW5kTWF0aEluU3RyaW5nID0gZnVuY3Rpb24gKG1hdGgsIG4sIHRleHQpIHtcbiAgICAgICAgdmFyIHN0YXJ0LCBtYXRjaDtcbiAgICAgICAgdGhpcy5zdGFydC5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoKHN0YXJ0ID0gdGhpcy5zdGFydC5leGVjKHRleHQpKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0W3RoaXMuZW52XSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZW52KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9ICdcXFxcXFxcXGVuZFxcXFxzKihcXFxceycgKyAoMCwgc3RyaW5nX2pzXzEucXVvdGVQYXR0ZXJuKShzdGFydFt0aGlzLmVudl0pICsgJ1xcXFx9KSc7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0aGlzLmZpbmRFbmQodGV4dCwgbiwgc3RhcnQsIFsneycgKyBzdGFydFt0aGlzLmVudl0gKyAnfScsIHRydWUsIHRoaXMuZW5kUGF0dGVybihudWxsLCBlbmQpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoLm1hdGggPSBtYXRjaC5vcGVuICsgbWF0Y2gubWF0aCArIG1hdGNoLmNsb3NlO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaC5vcGVuID0gbWF0Y2guY2xvc2UgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydFt0aGlzLnN1Yl0gIT09IHVuZGVmaW5lZCAmJiB0aGlzLnN1Yikge1xuICAgICAgICAgICAgICAgIHZhciBtYXRoXzEgPSBzdGFydFt0aGlzLnN1Yl07XG4gICAgICAgICAgICAgICAgdmFyIGVuZCA9IHN0YXJ0LmluZGV4ICsgc3RhcnRbdGhpcy5zdWJdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobWF0aF8xLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9ICgwLCBNYXRoSXRlbV9qc18xLnByb3RvSXRlbSkoJycsIG1hdGhfMS5zdWJzdHIoMSksICcnLCBuLCBzdGFydC5pbmRleCwgZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gKDAsIE1hdGhJdGVtX2pzXzEucHJvdG9JdGVtKSgnJywgbWF0aF8xLCAnJywgbiwgc3RhcnQuaW5kZXgsIGVuZCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1hdGNoID0gdGhpcy5maW5kRW5kKHRleHQsIG4sIHN0YXJ0LCB0aGlzLmVuZFtzdGFydFswXV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgbWF0aC5wdXNoKG1hdGNoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Lmxhc3RJbmRleCA9IG1hdGNoLmVuZC5uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBGaW5kVGVYLnByb3RvdHlwZS5maW5kTWF0aCA9IGZ1bmN0aW9uIChzdHJpbmdzKSB7XG4gICAgICAgIHZhciBtYXRoID0gW107XG4gICAgICAgIGlmICh0aGlzLmhhc1BhdHRlcm5zKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbSA9IHN0cmluZ3MubGVuZ3RoOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maW5kTWF0aEluU3RyaW5nKG1hdGgsIGksIHN0cmluZ3NbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRoO1xuICAgIH07XG4gICAgRmluZFRlWC5PUFRJT05TID0ge1xuICAgICAgICBpbmxpbmVNYXRoOiBbXG4gICAgICAgICAgICBbJ1xcXFwoJywgJ1xcXFwpJ11cbiAgICAgICAgXSxcbiAgICAgICAgZGlzcGxheU1hdGg6IFtcbiAgICAgICAgICAgIFsnJCQnLCAnJCQnXSxcbiAgICAgICAgICAgIFsnXFxcXFsnLCAnXFxcXF0nXVxuICAgICAgICBdLFxuICAgICAgICBwcm9jZXNzRXNjYXBlczogdHJ1ZSxcbiAgICAgICAgcHJvY2Vzc0Vudmlyb25tZW50czogdHJ1ZSxcbiAgICAgICAgcHJvY2Vzc1JlZnM6IHRydWUsXG4gICAgfTtcbiAgICByZXR1cm4gRmluZFRlWDtcbn0oRmluZE1hdGhfanNfMS5BYnN0cmFjdEZpbmRNYXRoKSk7XG5leHBvcnRzLkZpbmRUZVggPSBGaW5kVGVYO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmluZFRlWC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=