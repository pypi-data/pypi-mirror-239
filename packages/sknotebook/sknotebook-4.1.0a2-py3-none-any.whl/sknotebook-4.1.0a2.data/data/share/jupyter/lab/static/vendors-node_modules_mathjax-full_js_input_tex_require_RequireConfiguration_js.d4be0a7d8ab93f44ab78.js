"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_input_tex_require_RequireConfiguration_js"],{

/***/ "../node_modules/mathjax-full/js/components/global.js":
/*!************************************************************!*\
  !*** ../node_modules/mathjax-full/js/components/global.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MathJax = exports.combineWithMathJax = exports.combineDefaults = exports.combineConfig = exports.isObject = void 0;
var version_js_1 = __webpack_require__(/*! ./version.js */ "../node_modules/mathjax-full/js/components/version.js");
function isObject(x) {
    return typeof x === 'object' && x !== null;
}
exports.isObject = isObject;
function combineConfig(dst, src) {
    var e_1, _a;
    try {
        for (var _b = __values(Object.keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var id = _c.value;
            if (id === '__esModule')
                continue;
            if (isObject(dst[id]) && isObject(src[id]) &&
                !(src[id] instanceof Promise)) {
                combineConfig(dst[id], src[id]);
            }
            else if (src[id] !== null && src[id] !== undefined) {
                dst[id] = src[id];
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return dst;
}
exports.combineConfig = combineConfig;
function combineDefaults(dst, name, src) {
    var e_2, _a;
    if (!dst[name]) {
        dst[name] = {};
    }
    dst = dst[name];
    try {
        for (var _b = __values(Object.keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var id = _c.value;
            if (isObject(dst[id]) && isObject(src[id])) {
                combineDefaults(dst, id, src[id]);
            }
            else if (dst[id] == null && src[id] != null) {
                dst[id] = src[id];
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return dst;
}
exports.combineDefaults = combineDefaults;
function combineWithMathJax(config) {
    return combineConfig(exports.MathJax, config);
}
exports.combineWithMathJax = combineWithMathJax;
if (typeof __webpack_require__.g.MathJax === 'undefined') {
    __webpack_require__.g.MathJax = {};
}
if (!__webpack_require__.g.MathJax.version) {
    __webpack_require__.g.MathJax = {
        version: version_js_1.VERSION,
        _: {},
        config: __webpack_require__.g.MathJax
    };
}
exports.MathJax = __webpack_require__.g.MathJax;
//# sourceMappingURL=global.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/components/loader.js":
/*!************************************************************!*\
  !*** ../node_modules/mathjax-full/js/components/loader.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

var __dirname = "/";

var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var e_1, _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CONFIG = exports.MathJax = exports.Loader = exports.PathFilters = exports.PackageError = exports.Package = void 0;
var global_js_1 = __webpack_require__(/*! ./global.js */ "../node_modules/mathjax-full/js/components/global.js");
var package_js_1 = __webpack_require__(/*! ./package.js */ "../node_modules/mathjax-full/js/components/package.js");
var package_js_2 = __webpack_require__(/*! ./package.js */ "../node_modules/mathjax-full/js/components/package.js");
Object.defineProperty(exports, "Package", ({ enumerable: true, get: function () { return package_js_2.Package; } }));
Object.defineProperty(exports, "PackageError", ({ enumerable: true, get: function () { return package_js_2.PackageError; } }));
var FunctionList_js_1 = __webpack_require__(/*! ../util/FunctionList.js */ "../node_modules/mathjax-full/js/util/FunctionList.js");
exports.PathFilters = {
    source: function (data) {
        if (exports.CONFIG.source.hasOwnProperty(data.name)) {
            data.name = exports.CONFIG.source[data.name];
        }
        return true;
    },
    normalize: function (data) {
        var name = data.name;
        if (!name.match(/^(?:[a-z]+:\/)?\/|[a-z]:\\|\[/i)) {
            data.name = '[mathjax]/' + name.replace(/^\.\//, '');
        }
        if (data.addExtension && !name.match(/\.[^\/]+$/)) {
            data.name += '.js';
        }
        return true;
    },
    prefix: function (data) {
        var match;
        while ((match = data.name.match(/^\[([^\]]*)\]/))) {
            if (!exports.CONFIG.paths.hasOwnProperty(match[1]))
                break;
            data.name = exports.CONFIG.paths[match[1]] + data.name.substr(match[0].length);
        }
        return true;
    }
};
var Loader;
(function (Loader) {
    var VERSION = global_js_1.MathJax.version;
    Loader.versions = new Map();
    function ready() {
        var e_2, _a;
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        if (names.length === 0) {
            names = Array.from(package_js_1.Package.packages.keys());
        }
        var promises = [];
        try {
            for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
                var name_1 = names_1_1.value;
                var extension = package_js_1.Package.packages.get(name_1) || new package_js_1.Package(name_1, true);
                promises.push(extension.promise);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return Promise.all(promises);
    }
    Loader.ready = ready;
    function load() {
        var e_3, _a;
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        if (names.length === 0) {
            return Promise.resolve();
        }
        var promises = [];
        var _loop_1 = function (name_2) {
            var extension = package_js_1.Package.packages.get(name_2);
            if (!extension) {
                extension = new package_js_1.Package(name_2);
                extension.provides(exports.CONFIG.provides[name_2]);
            }
            extension.checkNoLoad();
            promises.push(extension.promise.then(function () {
                if (!exports.CONFIG.versionWarnings)
                    return;
                if (extension.isLoaded && !Loader.versions.has(package_js_1.Package.resolvePath(name_2))) {
                    console.warn("No version information available for component ".concat(name_2));
                }
            }));
        };
        try {
            for (var names_2 = __values(names), names_2_1 = names_2.next(); !names_2_1.done; names_2_1 = names_2.next()) {
                var name_2 = names_2_1.value;
                _loop_1(name_2);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (names_2_1 && !names_2_1.done && (_a = names_2.return)) _a.call(names_2);
            }
            finally { if (e_3) throw e_3.error; }
        }
        package_js_1.Package.loadAll();
        return Promise.all(promises);
    }
    Loader.load = load;
    function preLoad() {
        var e_4, _a;
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        try {
            for (var names_3 = __values(names), names_3_1 = names_3.next(); !names_3_1.done; names_3_1 = names_3.next()) {
                var name_3 = names_3_1.value;
                var extension = package_js_1.Package.packages.get(name_3);
                if (!extension) {
                    extension = new package_js_1.Package(name_3, true);
                    extension.provides(exports.CONFIG.provides[name_3]);
                }
                extension.loaded();
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (names_3_1 && !names_3_1.done && (_a = names_3.return)) _a.call(names_3);
            }
            finally { if (e_4) throw e_4.error; }
        }
    }
    Loader.preLoad = preLoad;
    function defaultReady() {
        if (typeof exports.MathJax.startup !== 'undefined') {
            exports.MathJax.config.startup.ready();
        }
    }
    Loader.defaultReady = defaultReady;
    function getRoot() {
        var root = __dirname + '/../../es5';
        if (typeof document !== 'undefined') {
            var script = document.currentScript || document.getElementById('MathJax-script');
            if (script) {
                root = script.src.replace(/\/[^\/]*$/, '');
            }
        }
        return root;
    }
    Loader.getRoot = getRoot;
    function checkVersion(name, version, _type) {
        Loader.versions.set(package_js_1.Package.resolvePath(name), VERSION);
        if (exports.CONFIG.versionWarnings && version !== VERSION) {
            console.warn("Component ".concat(name, " uses ").concat(version, " of MathJax; version in use is ").concat(VERSION));
            return true;
        }
        return false;
    }
    Loader.checkVersion = checkVersion;
    Loader.pathFilters = new FunctionList_js_1.FunctionList();
    Loader.pathFilters.add(exports.PathFilters.source, 0);
    Loader.pathFilters.add(exports.PathFilters.normalize, 10);
    Loader.pathFilters.add(exports.PathFilters.prefix, 20);
})(Loader = exports.Loader || (exports.Loader = {}));
exports.MathJax = global_js_1.MathJax;
if (typeof exports.MathJax.loader === 'undefined') {
    (0, global_js_1.combineDefaults)(exports.MathJax.config, 'loader', {
        paths: {
            mathjax: Loader.getRoot()
        },
        source: {},
        dependencies: {},
        provides: {},
        load: [],
        ready: Loader.defaultReady.bind(Loader),
        failed: function (error) { return console.log("MathJax(".concat(error.package || '?', "): ").concat(error.message)); },
        require: null,
        pathFilters: [],
        versionWarnings: true
    });
    (0, global_js_1.combineWithMathJax)({
        loader: Loader
    });
    try {
        for (var _b = __values(exports.MathJax.config.loader.pathFilters), _c = _b.next(); !_c.done; _c = _b.next()) {
            var filter = _c.value;
            if (Array.isArray(filter)) {
                Loader.pathFilters.add(filter[0], filter[1]);
            }
            else {
                Loader.pathFilters.add(filter);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
exports.CONFIG = exports.MathJax.config.loader;
//# sourceMappingURL=loader.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/components/package.js":
/*!*************************************************************!*\
  !*** ../node_modules/mathjax-full/js/components/package.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Package = exports.PackageError = void 0;
var loader_js_1 = __webpack_require__(/*! ./loader.js */ "../node_modules/mathjax-full/js/components/loader.js");
var PackageError = (function (_super) {
    __extends(PackageError, _super);
    function PackageError(message, name) {
        var _this = _super.call(this, message) || this;
        _this.package = name;
        return _this;
    }
    return PackageError;
}(Error));
exports.PackageError = PackageError;
var Package = (function () {
    function Package(name, noLoad) {
        if (noLoad === void 0) { noLoad = false; }
        this.isLoaded = false;
        this.isLoading = false;
        this.hasFailed = false;
        this.dependents = [];
        this.dependencies = [];
        this.dependencyCount = 0;
        this.provided = [];
        this.name = name;
        this.noLoad = noLoad;
        Package.packages.set(name, this);
        this.promise = this.makePromise(this.makeDependencies());
    }
    Object.defineProperty(Package.prototype, "canLoad", {
        get: function () {
            return this.dependencyCount === 0 && !this.noLoad && !this.isLoading && !this.hasFailed;
        },
        enumerable: false,
        configurable: true
    });
    Package.resolvePath = function (name, addExtension) {
        if (addExtension === void 0) { addExtension = true; }
        var data = { name: name, original: name, addExtension: addExtension };
        loader_js_1.Loader.pathFilters.execute(data);
        return data.name;
    };
    Package.loadAll = function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.packages.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var extension = _c.value;
                if (extension.canLoad) {
                    extension.load();
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    Package.prototype.makeDependencies = function () {
        var e_2, _a;
        var promises = [];
        var map = Package.packages;
        var noLoad = this.noLoad;
        var name = this.name;
        var dependencies = [];
        if (loader_js_1.CONFIG.dependencies.hasOwnProperty(name)) {
            dependencies.push.apply(dependencies, __spreadArray([], __read(loader_js_1.CONFIG.dependencies[name]), false));
        }
        else if (name !== 'core') {
            dependencies.push('core');
        }
        try {
            for (var dependencies_1 = __values(dependencies), dependencies_1_1 = dependencies_1.next(); !dependencies_1_1.done; dependencies_1_1 = dependencies_1.next()) {
                var dependent = dependencies_1_1.value;
                var extension = map.get(dependent) || new Package(dependent, noLoad);
                if (this.dependencies.indexOf(extension) < 0) {
                    extension.addDependent(this, noLoad);
                    this.dependencies.push(extension);
                    if (!extension.isLoaded) {
                        this.dependencyCount++;
                        promises.push(extension.promise);
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (dependencies_1_1 && !dependencies_1_1.done && (_a = dependencies_1.return)) _a.call(dependencies_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return promises;
    };
    Package.prototype.makePromise = function (promises) {
        var _this = this;
        var promise = new Promise((function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        }));
        var config = (loader_js_1.CONFIG[this.name] || {});
        if (config.ready) {
            promise = promise.then(function (_name) { return config.ready(_this.name); });
        }
        if (promises.length) {
            promises.push(promise);
            promise = Promise.all(promises).then(function (names) { return names.join(', '); });
        }
        if (config.failed) {
            promise.catch(function (message) { return config.failed(new PackageError(message, _this.name)); });
        }
        return promise;
    };
    Package.prototype.load = function () {
        if (!this.isLoaded && !this.isLoading && !this.noLoad) {
            this.isLoading = true;
            var url = Package.resolvePath(this.name);
            if (loader_js_1.CONFIG.require) {
                this.loadCustom(url);
            }
            else {
                this.loadScript(url);
            }
        }
    };
    Package.prototype.loadCustom = function (url) {
        var _this = this;
        try {
            var result = loader_js_1.CONFIG.require(url);
            if (result instanceof Promise) {
                result.then(function () { return _this.checkLoad(); })
                    .catch(function (err) { return _this.failed('Can\'t load "' + url + '"\n' + err.message.trim()); });
            }
            else {
                this.checkLoad();
            }
        }
        catch (err) {
            this.failed(err.message);
        }
    };
    Package.prototype.loadScript = function (url) {
        var _this = this;
        var script = document.createElement('script');
        script.src = url;
        script.charset = 'UTF-8';
        script.onload = function (_event) { return _this.checkLoad(); };
        script.onerror = function (_event) { return _this.failed('Can\'t load "' + url + '"'); };
        document.head.appendChild(script);
    };
    Package.prototype.loaded = function () {
        var e_3, _a, e_4, _b;
        this.isLoaded = true;
        this.isLoading = false;
        try {
            for (var _c = __values(this.dependents), _d = _c.next(); !_d.done; _d = _c.next()) {
                var dependent = _d.value;
                dependent.requirementSatisfied();
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_3) throw e_3.error; }
        }
        try {
            for (var _e = __values(this.provided), _f = _e.next(); !_f.done; _f = _e.next()) {
                var provided = _f.value;
                provided.loaded();
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_4) throw e_4.error; }
        }
        this.resolve(this.name);
    };
    Package.prototype.failed = function (message) {
        this.hasFailed = true;
        this.isLoading = false;
        this.reject(new PackageError(message, this.name));
    };
    Package.prototype.checkLoad = function () {
        var _this = this;
        var config = (loader_js_1.CONFIG[this.name] || {});
        var checkReady = config.checkReady || (function () { return Promise.resolve(); });
        checkReady().then(function () { return _this.loaded(); })
            .catch(function (message) { return _this.failed(message); });
    };
    Package.prototype.requirementSatisfied = function () {
        if (this.dependencyCount) {
            this.dependencyCount--;
            if (this.canLoad) {
                this.load();
            }
        }
    };
    Package.prototype.provides = function (names) {
        var e_5, _a;
        if (names === void 0) { names = []; }
        try {
            for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
                var name_1 = names_1_1.value;
                var provided = Package.packages.get(name_1);
                if (!provided) {
                    if (!loader_js_1.CONFIG.dependencies[name_1]) {
                        loader_js_1.CONFIG.dependencies[name_1] = [];
                    }
                    loader_js_1.CONFIG.dependencies[name_1].push(name_1);
                    provided = new Package(name_1, true);
                    provided.isLoading = true;
                }
                this.provided.push(provided);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
    };
    Package.prototype.addDependent = function (extension, noLoad) {
        this.dependents.push(extension);
        if (!noLoad) {
            this.checkNoLoad();
        }
    };
    Package.prototype.checkNoLoad = function () {
        var e_6, _a;
        if (this.noLoad) {
            this.noLoad = false;
            try {
                for (var _b = __values(this.dependencies), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var dependency = _c.value;
                    dependency.checkNoLoad();
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
    };
    Package.packages = new Map();
    return Package;
}());
exports.Package = Package;
//# sourceMappingURL=package.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/input/tex/require/RequireConfiguration.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/mathjax-full/js/input/tex/require/RequireConfiguration.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RequireConfiguration = exports.options = exports.RequireMethods = exports.RequireLoad = void 0;
var Configuration_js_1 = __webpack_require__(/*! ../Configuration.js */ "../node_modules/mathjax-full/js/input/tex/Configuration.js");
var SymbolMap_js_1 = __webpack_require__(/*! ../SymbolMap.js */ "../node_modules/mathjax-full/js/input/tex/SymbolMap.js");
var TexError_js_1 = __importDefault(__webpack_require__(/*! ../TexError.js */ "../node_modules/mathjax-full/js/input/tex/TexError.js"));
var global_js_1 = __webpack_require__(/*! ../../../components/global.js */ "../node_modules/mathjax-full/js/components/global.js");
var package_js_1 = __webpack_require__(/*! ../../../components/package.js */ "../node_modules/mathjax-full/js/components/package.js");
var loader_js_1 = __webpack_require__(/*! ../../../components/loader.js */ "../node_modules/mathjax-full/js/components/loader.js");
var mathjax_js_1 = __webpack_require__(/*! ../../../mathjax.js */ "../node_modules/mathjax-full/js/mathjax.js");
var Options_js_1 = __webpack_require__(/*! ../../../util/Options.js */ "../node_modules/mathjax-full/js/util/Options.js");
var MJCONFIG = global_js_1.MathJax.config;
function RegisterExtension(jax, name) {
    var _a;
    var require = jax.parseOptions.options.require;
    var required = jax.parseOptions.packageData.get('require').required;
    var extension = name.substr(require.prefix.length);
    if (required.indexOf(extension) < 0) {
        required.push(extension);
        RegisterDependencies(jax, loader_js_1.CONFIG.dependencies[name]);
        var handler = Configuration_js_1.ConfigurationHandler.get(extension);
        if (handler) {
            var options_1 = MJCONFIG[name] || {};
            if (handler.options && Object.keys(handler.options).length === 1 && handler.options[extension]) {
                options_1 = (_a = {}, _a[extension] = options_1, _a);
            }
            jax.configuration.add(extension, jax, options_1);
            var configured = jax.parseOptions.packageData.get('require').configured;
            if (handler.preprocessors.length && !configured.has(extension)) {
                configured.set(extension, true);
                mathjax_js_1.mathjax.retryAfter(Promise.resolve());
            }
        }
    }
}
function RegisterDependencies(jax, names) {
    var e_1, _a;
    if (names === void 0) { names = []; }
    var prefix = jax.parseOptions.options.require.prefix;
    try {
        for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
            var name_1 = names_1_1.value;
            if (name_1.substr(0, prefix.length) === prefix) {
                RegisterExtension(jax, name_1);
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
function RequireLoad(parser, name) {
    var options = parser.options.require;
    var allow = options.allow;
    var extension = (name.substr(0, 1) === '[' ? '' : options.prefix) + name;
    var allowed = (allow.hasOwnProperty(extension) ? allow[extension] :
        allow.hasOwnProperty(name) ? allow[name] : options.defaultAllow);
    if (!allowed) {
        throw new TexError_js_1.default('BadRequire', 'Extension "%1" is not allowed to be loaded', extension);
    }
    if (package_js_1.Package.packages.has(extension)) {
        RegisterExtension(parser.configuration.packageData.get('require').jax, extension);
    }
    else {
        mathjax_js_1.mathjax.retryAfter(loader_js_1.Loader.load(extension));
    }
}
exports.RequireLoad = RequireLoad;
function config(_config, jax) {
    jax.parseOptions.packageData.set('require', {
        jax: jax,
        required: __spreadArray([], __read(jax.options.packages), false),
        configured: new Map()
    });
    var options = jax.parseOptions.options.require;
    var prefix = options.prefix;
    if (prefix.match(/[^_a-zA-Z0-9]/)) {
        throw Error('Illegal characters used in \\require prefix');
    }
    if (!loader_js_1.CONFIG.paths[prefix]) {
        loader_js_1.CONFIG.paths[prefix] = '[mathjax]/input/tex/extensions';
    }
    options.prefix = '[' + prefix + ']/';
}
exports.RequireMethods = {
    Require: function (parser, name) {
        var required = parser.GetArgument(name);
        if (required.match(/[^_a-zA-Z0-9]/) || required === '') {
            throw new TexError_js_1.default('BadPackageName', 'Argument for %1 is not a valid package name', name);
        }
        RequireLoad(parser, required);
    }
};
exports.options = {
    require: {
        allow: (0, Options_js_1.expandable)({
            base: false,
            'all-packages': false,
            autoload: false,
            configmacros: false,
            tagformat: false,
            setoptions: false
        }),
        defaultAllow: true,
        prefix: 'tex'
    }
};
new SymbolMap_js_1.CommandMap('require', { require: 'Require' }, exports.RequireMethods);
exports.RequireConfiguration = Configuration_js_1.Configuration.create('require', { handler: { macro: ['require'] }, config: config, options: exports.options });
//# sourceMappingURL=RequireConfiguration.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX2lucHV0X3RleF9yZXF1aXJlX1JlcXVpcmVDb25maWd1cmF0aW9uX2pzLmQ0YmUwYTdkOGFiOTNmNDRhYjc4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWUsR0FBRywwQkFBMEIsR0FBRyx1QkFBdUIsR0FBRyxxQkFBcUIsR0FBRyxnQkFBZ0I7QUFDakgsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxVQUFVO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsV0FBVyxxQkFBTTtBQUNqQixJQUFJLHFCQUFNO0FBQ1Y7QUFDQSxLQUFLLHFCQUFNO0FBQ1gsSUFBSSxxQkFBTTtBQUNWO0FBQ0EsYUFBYTtBQUNiLGdCQUFnQixxQkFBTTtBQUN0QjtBQUNBO0FBQ0EsZUFBZSxHQUFHLHFCQUFNO0FBQ3hCOzs7Ozs7Ozs7OztBQ3ZGYTtBQUNiO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHdFQUF3RSxpQkFBaUI7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLG9CQUFvQjtBQUMvRCw0QkFBNEIsd0RBQXdELFdBQVcsb0JBQW9CLDRDQUE0QztBQUMvSiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvbXBvbmVudHMvZ2xvYmFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvbXBvbmVudHMvbG9hZGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvbXBvbmVudHMvcGFja2FnZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvcmVxdWlyZS9SZXF1aXJlQ29uZmlndXJhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF0aEpheCA9IGV4cG9ydHMuY29tYmluZVdpdGhNYXRoSmF4ID0gZXhwb3J0cy5jb21iaW5lRGVmYXVsdHMgPSBleHBvcnRzLmNvbWJpbmVDb25maWcgPSBleHBvcnRzLmlzT2JqZWN0ID0gdm9pZCAwO1xudmFyIHZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuL3ZlcnNpb24uanNcIik7XG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZnVuY3Rpb24gY29tYmluZUNvbmZpZyhkc3QsIHNyYykge1xuICAgIHZhciBlXzEsIF9hO1xuICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMoc3JjKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGlkID09PSAnX19lc01vZHVsZScpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoZHN0W2lkXSkgJiYgaXNPYmplY3Qoc3JjW2lkXSkgJiZcbiAgICAgICAgICAgICAgICAhKHNyY1tpZF0gaW5zdGFuY2VvZiBQcm9taXNlKSkge1xuICAgICAgICAgICAgICAgIGNvbWJpbmVDb25maWcoZHN0W2lkXSwgc3JjW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzcmNbaWRdICE9PSBudWxsICYmIHNyY1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRzdFtpZF0gPSBzcmNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gZHN0O1xufVxuZXhwb3J0cy5jb21iaW5lQ29uZmlnID0gY29tYmluZUNvbmZpZztcbmZ1bmN0aW9uIGNvbWJpbmVEZWZhdWx0cyhkc3QsIG5hbWUsIHNyYykge1xuICAgIHZhciBlXzIsIF9hO1xuICAgIGlmICghZHN0W25hbWVdKSB7XG4gICAgICAgIGRzdFtuYW1lXSA9IHt9O1xuICAgIH1cbiAgICBkc3QgPSBkc3RbbmFtZV07XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhzcmMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGlkID0gX2MudmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3QoZHN0W2lkXSkgJiYgaXNPYmplY3Qoc3JjW2lkXSkpIHtcbiAgICAgICAgICAgICAgICBjb21iaW5lRGVmYXVsdHMoZHN0LCBpZCwgc3JjW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkc3RbaWRdID09IG51bGwgJiYgc3JjW2lkXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZHN0W2lkXSA9IHNyY1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBkc3Q7XG59XG5leHBvcnRzLmNvbWJpbmVEZWZhdWx0cyA9IGNvbWJpbmVEZWZhdWx0cztcbmZ1bmN0aW9uIGNvbWJpbmVXaXRoTWF0aEpheChjb25maWcpIHtcbiAgICByZXR1cm4gY29tYmluZUNvbmZpZyhleHBvcnRzLk1hdGhKYXgsIGNvbmZpZyk7XG59XG5leHBvcnRzLmNvbWJpbmVXaXRoTWF0aEpheCA9IGNvbWJpbmVXaXRoTWF0aEpheDtcbmlmICh0eXBlb2YgZ2xvYmFsLk1hdGhKYXggPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZ2xvYmFsLk1hdGhKYXggPSB7fTtcbn1cbmlmICghZ2xvYmFsLk1hdGhKYXgudmVyc2lvbikge1xuICAgIGdsb2JhbC5NYXRoSmF4ID0ge1xuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uX2pzXzEuVkVSU0lPTixcbiAgICAgICAgXzoge30sXG4gICAgICAgIGNvbmZpZzogZ2xvYmFsLk1hdGhKYXhcbiAgICB9O1xufVxuZXhwb3J0cy5NYXRoSmF4ID0gZ2xvYmFsLk1hdGhKYXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nbG9iYWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgZV8xLCBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ09ORklHID0gZXhwb3J0cy5NYXRoSmF4ID0gZXhwb3J0cy5Mb2FkZXIgPSBleHBvcnRzLlBhdGhGaWx0ZXJzID0gZXhwb3J0cy5QYWNrYWdlRXJyb3IgPSBleHBvcnRzLlBhY2thZ2UgPSB2b2lkIDA7XG52YXIgZ2xvYmFsX2pzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWwuanNcIik7XG52YXIgcGFja2FnZV9qc18xID0gcmVxdWlyZShcIi4vcGFja2FnZS5qc1wiKTtcbnZhciBwYWNrYWdlX2pzXzIgPSByZXF1aXJlKFwiLi9wYWNrYWdlLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFja2FnZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFja2FnZV9qc18yLlBhY2thZ2U7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYWNrYWdlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhY2thZ2VfanNfMi5QYWNrYWdlRXJyb3I7IH0gfSk7XG52YXIgRnVuY3Rpb25MaXN0X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9GdW5jdGlvbkxpc3QuanNcIik7XG5leHBvcnRzLlBhdGhGaWx0ZXJzID0ge1xuICAgIHNvdXJjZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuQ09ORklHLnNvdXJjZS5oYXNPd25Qcm9wZXJ0eShkYXRhLm5hbWUpKSB7XG4gICAgICAgICAgICBkYXRhLm5hbWUgPSBleHBvcnRzLkNPTkZJRy5zb3VyY2VbZGF0YS5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIG5vcm1hbGl6ZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIGlmICghbmFtZS5tYXRjaCgvXig/OlthLXpdKzpcXC8pP1xcL3xbYS16XTpcXFxcfFxcWy9pKSkge1xuICAgICAgICAgICAgZGF0YS5uYW1lID0gJ1ttYXRoamF4XS8nICsgbmFtZS5yZXBsYWNlKC9eXFwuXFwvLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmFkZEV4dGVuc2lvbiAmJiAhbmFtZS5tYXRjaCgvXFwuW15cXC9dKyQvKSkge1xuICAgICAgICAgICAgZGF0YS5uYW1lICs9ICcuanMnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJlZml4OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBkYXRhLm5hbWUubWF0Y2goL15cXFsoW15cXF1dKilcXF0vKSkpIHtcbiAgICAgICAgICAgIGlmICghZXhwb3J0cy5DT05GSUcucGF0aHMuaGFzT3duUHJvcGVydHkobWF0Y2hbMV0pKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGF0YS5uYW1lID0gZXhwb3J0cy5DT05GSUcucGF0aHNbbWF0Y2hbMV1dICsgZGF0YS5uYW1lLnN1YnN0cihtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn07XG52YXIgTG9hZGVyO1xuKGZ1bmN0aW9uIChMb2FkZXIpIHtcbiAgICB2YXIgVkVSU0lPTiA9IGdsb2JhbF9qc18xLk1hdGhKYXgudmVyc2lvbjtcbiAgICBMb2FkZXIudmVyc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gcmVhZHkoKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbmFtZXMgPSBBcnJheS5mcm9tKHBhY2thZ2VfanNfMS5QYWNrYWdlLnBhY2thZ2VzLmtleXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lc18xID0gX192YWx1ZXMobmFtZXMpLCBuYW1lc18xXzEgPSBuYW1lc18xLm5leHQoKTsgIW5hbWVzXzFfMS5kb25lOyBuYW1lc18xXzEgPSBuYW1lc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBuYW1lc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHBhY2thZ2VfanNfMS5QYWNrYWdlLnBhY2thZ2VzLmdldChuYW1lXzEpIHx8IG5ldyBwYWNrYWdlX2pzXzEuUGFja2FnZShuYW1lXzEsIHRydWUpO1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goZXh0ZW5zaW9uLnByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXNfMV8xICYmICFuYW1lc18xXzEuZG9uZSAmJiAoX2EgPSBuYW1lc18xLnJldHVybikpIF9hLmNhbGwobmFtZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9XG4gICAgTG9hZGVyLnJlYWR5ID0gcmVhZHk7XG4gICAgZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG5hbWVfMikge1xuICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHBhY2thZ2VfanNfMS5QYWNrYWdlLnBhY2thZ2VzLmdldChuYW1lXzIpO1xuICAgICAgICAgICAgaWYgKCFleHRlbnNpb24pIHtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBuZXcgcGFja2FnZV9qc18xLlBhY2thZ2UobmFtZV8yKTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24ucHJvdmlkZXMoZXhwb3J0cy5DT05GSUcucHJvdmlkZXNbbmFtZV8yXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbnNpb24uY2hlY2tOb0xvYWQoKTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goZXh0ZW5zaW9uLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFleHBvcnRzLkNPTkZJRy52ZXJzaW9uV2FybmluZ3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLmlzTG9hZGVkICYmICFMb2FkZXIudmVyc2lvbnMuaGFzKHBhY2thZ2VfanNfMS5QYWNrYWdlLnJlc29sdmVQYXRoKG5hbWVfMikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5vIHZlcnNpb24gaW5mb3JtYXRpb24gYXZhaWxhYmxlIGZvciBjb21wb25lbnQgXCIuY29uY2F0KG5hbWVfMikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVzXzIgPSBfX3ZhbHVlcyhuYW1lcyksIG5hbWVzXzJfMSA9IG5hbWVzXzIubmV4dCgpOyAhbmFtZXNfMl8xLmRvbmU7IG5hbWVzXzJfMSA9IG5hbWVzXzIubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMiA9IG5hbWVzXzJfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBfbG9vcF8xKG5hbWVfMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lc18yXzEgJiYgIW5hbWVzXzJfMS5kb25lICYmIChfYSA9IG5hbWVzXzIucmV0dXJuKSkgX2EuY2FsbChuYW1lc18yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBwYWNrYWdlX2pzXzEuUGFja2FnZS5sb2FkQWxsKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfVxuICAgIExvYWRlci5sb2FkID0gbG9hZDtcbiAgICBmdW5jdGlvbiBwcmVMb2FkKCkge1xuICAgICAgICB2YXIgZV80LCBfYTtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBuYW1lc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lc18zID0gX192YWx1ZXMobmFtZXMpLCBuYW1lc18zXzEgPSBuYW1lc18zLm5leHQoKTsgIW5hbWVzXzNfMS5kb25lOyBuYW1lc18zXzEgPSBuYW1lc18zLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzMgPSBuYW1lc18zXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IHBhY2thZ2VfanNfMS5QYWNrYWdlLnBhY2thZ2VzLmdldChuYW1lXzMpO1xuICAgICAgICAgICAgICAgIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbiA9IG5ldyBwYWNrYWdlX2pzXzEuUGFja2FnZShuYW1lXzMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24ucHJvdmlkZXMoZXhwb3J0cy5DT05GSUcucHJvdmlkZXNbbmFtZV8zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4dGVuc2lvbi5sb2FkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzXzNfMSAmJiAhbmFtZXNfM18xLmRvbmUgJiYgKF9hID0gbmFtZXNfMy5yZXR1cm4pKSBfYS5jYWxsKG5hbWVzXzMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIExvYWRlci5wcmVMb2FkID0gcHJlTG9hZDtcbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZHkoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwb3J0cy5NYXRoSmF4LnN0YXJ0dXAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBleHBvcnRzLk1hdGhKYXguY29uZmlnLnN0YXJ0dXAucmVhZHkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBMb2FkZXIuZGVmYXVsdFJlYWR5ID0gZGVmYXVsdFJlYWR5O1xuICAgIGZ1bmN0aW9uIGdldFJvb3QoKSB7XG4gICAgICAgIHZhciByb290ID0gX19kaXJuYW1lICsgJy8uLi8uLi9lczUnO1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ01hdGhKYXgtc2NyaXB0Jyk7XG4gICAgICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IHNjcmlwdC5zcmMucmVwbGFjZSgvXFwvW15cXC9dKiQvLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIExvYWRlci5nZXRSb290ID0gZ2V0Um9vdDtcbiAgICBmdW5jdGlvbiBjaGVja1ZlcnNpb24obmFtZSwgdmVyc2lvbiwgX3R5cGUpIHtcbiAgICAgICAgTG9hZGVyLnZlcnNpb25zLnNldChwYWNrYWdlX2pzXzEuUGFja2FnZS5yZXNvbHZlUGF0aChuYW1lKSwgVkVSU0lPTik7XG4gICAgICAgIGlmIChleHBvcnRzLkNPTkZJRy52ZXJzaW9uV2FybmluZ3MgJiYgdmVyc2lvbiAhPT0gVkVSU0lPTikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ29tcG9uZW50IFwiLmNvbmNhdChuYW1lLCBcIiB1c2VzIFwiKS5jb25jYXQodmVyc2lvbiwgXCIgb2YgTWF0aEpheDsgdmVyc2lvbiBpbiB1c2UgaXMgXCIpLmNvbmNhdChWRVJTSU9OKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIExvYWRlci5jaGVja1ZlcnNpb24gPSBjaGVja1ZlcnNpb247XG4gICAgTG9hZGVyLnBhdGhGaWx0ZXJzID0gbmV3IEZ1bmN0aW9uTGlzdF9qc18xLkZ1bmN0aW9uTGlzdCgpO1xuICAgIExvYWRlci5wYXRoRmlsdGVycy5hZGQoZXhwb3J0cy5QYXRoRmlsdGVycy5zb3VyY2UsIDApO1xuICAgIExvYWRlci5wYXRoRmlsdGVycy5hZGQoZXhwb3J0cy5QYXRoRmlsdGVycy5ub3JtYWxpemUsIDEwKTtcbiAgICBMb2FkZXIucGF0aEZpbHRlcnMuYWRkKGV4cG9ydHMuUGF0aEZpbHRlcnMucHJlZml4LCAyMCk7XG59KShMb2FkZXIgPSBleHBvcnRzLkxvYWRlciB8fCAoZXhwb3J0cy5Mb2FkZXIgPSB7fSkpO1xuZXhwb3J0cy5NYXRoSmF4ID0gZ2xvYmFsX2pzXzEuTWF0aEpheDtcbmlmICh0eXBlb2YgZXhwb3J0cy5NYXRoSmF4LmxvYWRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAoMCwgZ2xvYmFsX2pzXzEuY29tYmluZURlZmF1bHRzKShleHBvcnRzLk1hdGhKYXguY29uZmlnLCAnbG9hZGVyJywge1xuICAgICAgICBwYXRoczoge1xuICAgICAgICAgICAgbWF0aGpheDogTG9hZGVyLmdldFJvb3QoKVxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2U6IHt9LFxuICAgICAgICBkZXBlbmRlbmNpZXM6IHt9LFxuICAgICAgICBwcm92aWRlczoge30sXG4gICAgICAgIGxvYWQ6IFtdLFxuICAgICAgICByZWFkeTogTG9hZGVyLmRlZmF1bHRSZWFkeS5iaW5kKExvYWRlciksXG4gICAgICAgIGZhaWxlZDogZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBjb25zb2xlLmxvZyhcIk1hdGhKYXgoXCIuY29uY2F0KGVycm9yLnBhY2thZ2UgfHwgJz8nLCBcIik6IFwiKS5jb25jYXQoZXJyb3IubWVzc2FnZSkpOyB9LFxuICAgICAgICByZXF1aXJlOiBudWxsLFxuICAgICAgICBwYXRoRmlsdGVyczogW10sXG4gICAgICAgIHZlcnNpb25XYXJuaW5nczogdHJ1ZVxuICAgIH0pO1xuICAgICgwLCBnbG9iYWxfanNfMS5jb21iaW5lV2l0aE1hdGhKYXgpKHtcbiAgICAgICAgbG9hZGVyOiBMb2FkZXJcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGV4cG9ydHMuTWF0aEpheC5jb25maWcubG9hZGVyLnBhdGhGaWx0ZXJzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyKSkge1xuICAgICAgICAgICAgICAgIExvYWRlci5wYXRoRmlsdGVycy5hZGQoZmlsdGVyWzBdLCBmaWx0ZXJbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgTG9hZGVyLnBhdGhGaWx0ZXJzLmFkZChmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ09ORklHID0gZXhwb3J0cy5NYXRoSmF4LmNvbmZpZy5sb2FkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYWNrYWdlID0gZXhwb3J0cy5QYWNrYWdlRXJyb3IgPSB2b2lkIDA7XG52YXIgbG9hZGVyX2pzXzEgPSByZXF1aXJlKFwiLi9sb2FkZXIuanNcIik7XG52YXIgUGFja2FnZUVycm9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUGFja2FnZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhY2thZ2VFcnJvcihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnBhY2thZ2UgPSBuYW1lO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYWNrYWdlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlBhY2thZ2VFcnJvciA9IFBhY2thZ2VFcnJvcjtcbnZhciBQYWNrYWdlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWNrYWdlKG5hbWUsIG5vTG9hZCkge1xuICAgICAgICBpZiAobm9Mb2FkID09PSB2b2lkIDApIHsgbm9Mb2FkID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc0ZhaWxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlcGVuZGVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgdGhpcy5kZXBlbmRlbmN5Q291bnQgPSAwO1xuICAgICAgICB0aGlzLnByb3ZpZGVkID0gW107XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMubm9Mb2FkID0gbm9Mb2FkO1xuICAgICAgICBQYWNrYWdlLnBhY2thZ2VzLnNldChuYW1lLCB0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5tYWtlUHJvbWlzZSh0aGlzLm1ha2VEZXBlbmRlbmNpZXMoKSk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQYWNrYWdlLnByb3RvdHlwZSwgXCJjYW5Mb2FkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXBlbmRlbmN5Q291bnQgPT09IDAgJiYgIXRoaXMubm9Mb2FkICYmICF0aGlzLmlzTG9hZGluZyAmJiAhdGhpcy5oYXNGYWlsZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBQYWNrYWdlLnJlc29sdmVQYXRoID0gZnVuY3Rpb24gKG5hbWUsIGFkZEV4dGVuc2lvbikge1xuICAgICAgICBpZiAoYWRkRXh0ZW5zaW9uID09PSB2b2lkIDApIHsgYWRkRXh0ZW5zaW9uID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgZGF0YSA9IHsgbmFtZTogbmFtZSwgb3JpZ2luYWw6IG5hbWUsIGFkZEV4dGVuc2lvbjogYWRkRXh0ZW5zaW9uIH07XG4gICAgICAgIGxvYWRlcl9qc18xLkxvYWRlci5wYXRoRmlsdGVycy5leGVjdXRlKGRhdGEpO1xuICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgIH07XG4gICAgUGFja2FnZS5sb2FkQWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5wYWNrYWdlcy52YWx1ZXMoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi5jYW5Mb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dGVuc2lvbi5sb2FkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhY2thZ2UucHJvdG90eXBlLm1ha2VEZXBlbmRlbmNpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgdmFyIG1hcCA9IFBhY2thZ2UucGFja2FnZXM7XG4gICAgICAgIHZhciBub0xvYWQgPSB0aGlzLm5vTG9hZDtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgaWYgKGxvYWRlcl9qc18xLkNPTkZJRy5kZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoLmFwcGx5KGRlcGVuZGVuY2llcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGxvYWRlcl9qc18xLkNPTkZJRy5kZXBlbmRlbmNpZXNbbmFtZV0pLCBmYWxzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgIT09ICdjb3JlJykge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goJ2NvcmUnKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgZGVwZW5kZW5jaWVzXzEgPSBfX3ZhbHVlcyhkZXBlbmRlbmNpZXMpLCBkZXBlbmRlbmNpZXNfMV8xID0gZGVwZW5kZW5jaWVzXzEubmV4dCgpOyAhZGVwZW5kZW5jaWVzXzFfMS5kb25lOyBkZXBlbmRlbmNpZXNfMV8xID0gZGVwZW5kZW5jaWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVudCA9IGRlcGVuZGVuY2llc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGV4dGVuc2lvbiA9IG1hcC5nZXQoZGVwZW5kZW50KSB8fCBuZXcgUGFja2FnZShkZXBlbmRlbnQsIG5vTG9hZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVwZW5kZW5jaWVzLmluZGV4T2YoZXh0ZW5zaW9uKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLmFkZERlcGVuZGVudCh0aGlzLCBub0xvYWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVuY2llcy5wdXNoKGV4dGVuc2lvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXh0ZW5zaW9uLmlzTG9hZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChleHRlbnNpb24ucHJvbWlzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChkZXBlbmRlbmNpZXNfMV8xICYmICFkZXBlbmRlbmNpZXNfMV8xLmRvbmUgJiYgKF9hID0gZGVwZW5kZW5jaWVzXzEucmV0dXJuKSkgX2EuY2FsbChkZXBlbmRlbmNpZXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2VzO1xuICAgIH07XG4gICAgUGFja2FnZS5wcm90b3R5cGUubWFrZVByb21pc2UgPSBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgX3RoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBfdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IChsb2FkZXJfanNfMS5DT05GSUdbdGhpcy5uYW1lXSB8fCB7fSk7XG4gICAgICAgIGlmIChjb25maWcucmVhZHkpIHtcbiAgICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKF9uYW1lKSB7IHJldHVybiBjb25maWcucmVhZHkoX3RoaXMubmFtZSk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKG5hbWVzKSB7IHJldHVybiBuYW1lcy5qb2luKCcsICcpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uZmlnLmZhaWxlZCkge1xuICAgICAgICAgICAgcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gY29uZmlnLmZhaWxlZChuZXcgUGFja2FnZUVycm9yKG1lc3NhZ2UsIF90aGlzLm5hbWUpKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2FkZWQgJiYgIXRoaXMuaXNMb2FkaW5nICYmICF0aGlzLm5vTG9hZCkge1xuICAgICAgICAgICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHVybCA9IFBhY2thZ2UucmVzb2x2ZVBhdGgodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIGlmIChsb2FkZXJfanNfMS5DT05GSUcucmVxdWlyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZEN1c3RvbSh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkU2NyaXB0KHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhY2thZ2UucHJvdG90eXBlLmxvYWRDdXN0b20gPSBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbG9hZGVyX2pzXzEuQ09ORklHLnJlcXVpcmUodXJsKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuY2hlY2tMb2FkKCk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBfdGhpcy5mYWlsZWQoJ0NhblxcJ3QgbG9hZCBcIicgKyB1cmwgKyAnXCJcXG4nICsgZXJyLm1lc3NhZ2UudHJpbSgpKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrTG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuZmFpbGVkKGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFja2FnZS5wcm90b3R5cGUubG9hZFNjcmlwdCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgICAgICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gICAgICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbiAoX2V2ZW50KSB7IHJldHVybiBfdGhpcy5jaGVja0xvYWQoKTsgfTtcbiAgICAgICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiAoX2V2ZW50KSB7IHJldHVybiBfdGhpcy5mYWlsZWQoJ0NhblxcJ3QgbG9hZCBcIicgKyB1cmwgKyAnXCInKTsgfTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH07XG4gICAgUGFja2FnZS5wcm90b3R5cGUubG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8zLCBfYSwgZV80LCBfYjtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHRoaXMuZGVwZW5kZW50cyksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW50ID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW50LnJlcXVpcmVtZW50U2F0aXNmaWVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2UgPSBfX3ZhbHVlcyh0aGlzLnByb3ZpZGVkKSwgX2YgPSBfZS5uZXh0KCk7ICFfZi5kb25lOyBfZiA9IF9lLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlZCA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgIHByb3ZpZGVkLmxvYWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2YgJiYgIV9mLmRvbmUgJiYgKF9iID0gX2UucmV0dXJuKSkgX2IuY2FsbChfZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlKHRoaXMubmFtZSk7XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5mYWlsZWQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmhhc0ZhaWxlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVqZWN0KG5ldyBQYWNrYWdlRXJyb3IobWVzc2FnZSwgdGhpcy5uYW1lKSk7XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5jaGVja0xvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjb25maWcgPSAobG9hZGVyX2pzXzEuQ09ORklHW3RoaXMubmFtZV0gfHwge30pO1xuICAgICAgICB2YXIgY2hlY2tSZWFkeSA9IGNvbmZpZy5jaGVja1JlYWR5IHx8IChmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgfSk7XG4gICAgICAgIGNoZWNrUmVhZHkoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmxvYWRlZCgpOyB9KVxuICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7IHJldHVybiBfdGhpcy5mYWlsZWQobWVzc2FnZSk7IH0pO1xuICAgIH07XG4gICAgUGFja2FnZS5wcm90b3R5cGUucmVxdWlyZW1lbnRTYXRpc2ZpZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY3lDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5kZXBlbmRlbmN5Q291bnQtLTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkxvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFja2FnZS5wcm90b3R5cGUucHJvdmlkZXMgPSBmdW5jdGlvbiAobmFtZXMpIHtcbiAgICAgICAgdmFyIGVfNSwgX2E7XG4gICAgICAgIGlmIChuYW1lcyA9PT0gdm9pZCAwKSB7IG5hbWVzID0gW107IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVzXzEgPSBfX3ZhbHVlcyhuYW1lcyksIG5hbWVzXzFfMSA9IG5hbWVzXzEubmV4dCgpOyAhbmFtZXNfMV8xLmRvbmU7IG5hbWVzXzFfMSA9IG5hbWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZWQgPSBQYWNrYWdlLnBhY2thZ2VzLmdldChuYW1lXzEpO1xuICAgICAgICAgICAgICAgIGlmICghcHJvdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsb2FkZXJfanNfMS5DT05GSUcuZGVwZW5kZW5jaWVzW25hbWVfMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRlcl9qc18xLkNPTkZJRy5kZXBlbmRlbmNpZXNbbmFtZV8xXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvYWRlcl9qc18xLkNPTkZJRy5kZXBlbmRlbmNpZXNbbmFtZV8xXS5wdXNoKG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkID0gbmV3IFBhY2thZ2UobmFtZV8xLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZWQuaXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlZC5wdXNoKHByb3ZpZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzXzFfMSAmJiAhbmFtZXNfMV8xLmRvbmUgJiYgKF9hID0gbmFtZXNfMS5yZXR1cm4pKSBfYS5jYWxsKG5hbWVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBQYWNrYWdlLnByb3RvdHlwZS5hZGREZXBlbmRlbnQgPSBmdW5jdGlvbiAoZXh0ZW5zaW9uLCBub0xvYWQpIHtcbiAgICAgICAgdGhpcy5kZXBlbmRlbnRzLnB1c2goZXh0ZW5zaW9uKTtcbiAgICAgICAgaWYgKCFub0xvYWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tOb0xvYWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFja2FnZS5wcm90b3R5cGUuY2hlY2tOb0xvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzYsIF9hO1xuICAgICAgICBpZiAodGhpcy5ub0xvYWQpIHtcbiAgICAgICAgICAgIHRoaXMubm9Mb2FkID0gZmFsc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5kZXBlbmRlbmNpZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXBlbmRlbmN5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kuY2hlY2tOb0xvYWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV82XzEpIHsgZV82ID0geyBlcnJvcjogZV82XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhY2thZ2UucGFja2FnZXMgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIFBhY2thZ2U7XG59KCkpO1xuZXhwb3J0cy5QYWNrYWdlID0gUGFja2FnZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhY2thZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlcXVpcmVDb25maWd1cmF0aW9uID0gZXhwb3J0cy5vcHRpb25zID0gZXhwb3J0cy5SZXF1aXJlTWV0aG9kcyA9IGV4cG9ydHMuUmVxdWlyZUxvYWQgPSB2b2lkIDA7XG52YXIgQ29uZmlndXJhdGlvbl9qc18xID0gcmVxdWlyZShcIi4uL0NvbmZpZ3VyYXRpb24uanNcIik7XG52YXIgU3ltYm9sTWFwX2pzXzEgPSByZXF1aXJlKFwiLi4vU3ltYm9sTWFwLmpzXCIpO1xudmFyIFRleEVycm9yX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL1RleEVycm9yLmpzXCIpKTtcbnZhciBnbG9iYWxfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb21wb25lbnRzL2dsb2JhbC5qc1wiKTtcbnZhciBwYWNrYWdlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vY29tcG9uZW50cy9wYWNrYWdlLmpzXCIpO1xudmFyIGxvYWRlcl9qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2NvbXBvbmVudHMvbG9hZGVyLmpzXCIpO1xudmFyIG1hdGhqYXhfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9tYXRoamF4LmpzXCIpO1xudmFyIE9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlsL09wdGlvbnMuanNcIik7XG52YXIgTUpDT05GSUcgPSBnbG9iYWxfanNfMS5NYXRoSmF4LmNvbmZpZztcbmZ1bmN0aW9uIFJlZ2lzdGVyRXh0ZW5zaW9uKGpheCwgbmFtZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgcmVxdWlyZSA9IGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy5yZXF1aXJlO1xuICAgIHZhciByZXF1aXJlZCA9IGpheC5wYXJzZU9wdGlvbnMucGFja2FnZURhdGEuZ2V0KCdyZXF1aXJlJykucmVxdWlyZWQ7XG4gICAgdmFyIGV4dGVuc2lvbiA9IG5hbWUuc3Vic3RyKHJlcXVpcmUucHJlZml4Lmxlbmd0aCk7XG4gICAgaWYgKHJlcXVpcmVkLmluZGV4T2YoZXh0ZW5zaW9uKSA8IDApIHtcbiAgICAgICAgcmVxdWlyZWQucHVzaChleHRlbnNpb24pO1xuICAgICAgICBSZWdpc3RlckRlcGVuZGVuY2llcyhqYXgsIGxvYWRlcl9qc18xLkNPTkZJRy5kZXBlbmRlbmNpZXNbbmFtZV0pO1xuICAgICAgICB2YXIgaGFuZGxlciA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uSGFuZGxlci5nZXQoZXh0ZW5zaW9uKTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zXzEgPSBNSkNPTkZJR1tuYW1lXSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyLm9wdGlvbnMgJiYgT2JqZWN0LmtleXMoaGFuZGxlci5vcHRpb25zKS5sZW5ndGggPT09IDEgJiYgaGFuZGxlci5vcHRpb25zW2V4dGVuc2lvbl0pIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zXzEgPSAoX2EgPSB7fSwgX2FbZXh0ZW5zaW9uXSA9IG9wdGlvbnNfMSwgX2EpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgamF4LmNvbmZpZ3VyYXRpb24uYWRkKGV4dGVuc2lvbiwgamF4LCBvcHRpb25zXzEpO1xuICAgICAgICAgICAgdmFyIGNvbmZpZ3VyZWQgPSBqYXgucGFyc2VPcHRpb25zLnBhY2thZ2VEYXRhLmdldCgncmVxdWlyZScpLmNvbmZpZ3VyZWQ7XG4gICAgICAgICAgICBpZiAoaGFuZGxlci5wcmVwcm9jZXNzb3JzLmxlbmd0aCAmJiAhY29uZmlndXJlZC5oYXMoZXh0ZW5zaW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWQuc2V0KGV4dGVuc2lvbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgbWF0aGpheF9qc18xLm1hdGhqYXgucmV0cnlBZnRlcihQcm9taXNlLnJlc29sdmUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBSZWdpc3RlckRlcGVuZGVuY2llcyhqYXgsIG5hbWVzKSB7XG4gICAgdmFyIGVfMSwgX2E7XG4gICAgaWYgKG5hbWVzID09PSB2b2lkIDApIHsgbmFtZXMgPSBbXTsgfVxuICAgIHZhciBwcmVmaXggPSBqYXgucGFyc2VPcHRpb25zLm9wdGlvbnMucmVxdWlyZS5wcmVmaXg7XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgbmFtZXNfMSA9IF9fdmFsdWVzKG5hbWVzKSwgbmFtZXNfMV8xID0gbmFtZXNfMS5uZXh0KCk7ICFuYW1lc18xXzEuZG9uZTsgbmFtZXNfMV8xID0gbmFtZXNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBuYW1lc18xXzEudmFsdWU7XG4gICAgICAgICAgICBpZiAobmFtZV8xLnN1YnN0cigwLCBwcmVmaXgubGVuZ3RoKSA9PT0gcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgUmVnaXN0ZXJFeHRlbnNpb24oamF4LCBuYW1lXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAobmFtZXNfMV8xICYmICFuYW1lc18xXzEuZG9uZSAmJiAoX2EgPSBuYW1lc18xLnJldHVybikpIF9hLmNhbGwobmFtZXNfMSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIFJlcXVpcmVMb2FkKHBhcnNlciwgbmFtZSkge1xuICAgIHZhciBvcHRpb25zID0gcGFyc2VyLm9wdGlvbnMucmVxdWlyZTtcbiAgICB2YXIgYWxsb3cgPSBvcHRpb25zLmFsbG93O1xuICAgIHZhciBleHRlbnNpb24gPSAobmFtZS5zdWJzdHIoMCwgMSkgPT09ICdbJyA/ICcnIDogb3B0aW9ucy5wcmVmaXgpICsgbmFtZTtcbiAgICB2YXIgYWxsb3dlZCA9IChhbGxvdy5oYXNPd25Qcm9wZXJ0eShleHRlbnNpb24pID8gYWxsb3dbZXh0ZW5zaW9uXSA6XG4gICAgICAgIGFsbG93Lmhhc093blByb3BlcnR5KG5hbWUpID8gYWxsb3dbbmFtZV0gOiBvcHRpb25zLmRlZmF1bHRBbGxvdyk7XG4gICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0JhZFJlcXVpcmUnLCAnRXh0ZW5zaW9uIFwiJTFcIiBpcyBub3QgYWxsb3dlZCB0byBiZSBsb2FkZWQnLCBleHRlbnNpb24pO1xuICAgIH1cbiAgICBpZiAocGFja2FnZV9qc18xLlBhY2thZ2UucGFja2FnZXMuaGFzKGV4dGVuc2lvbikpIHtcbiAgICAgICAgUmVnaXN0ZXJFeHRlbnNpb24ocGFyc2VyLmNvbmZpZ3VyYXRpb24ucGFja2FnZURhdGEuZ2V0KCdyZXF1aXJlJykuamF4LCBleHRlbnNpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbWF0aGpheF9qc18xLm1hdGhqYXgucmV0cnlBZnRlcihsb2FkZXJfanNfMS5Mb2FkZXIubG9hZChleHRlbnNpb24pKTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVpcmVMb2FkID0gUmVxdWlyZUxvYWQ7XG5mdW5jdGlvbiBjb25maWcoX2NvbmZpZywgamF4KSB7XG4gICAgamF4LnBhcnNlT3B0aW9ucy5wYWNrYWdlRGF0YS5zZXQoJ3JlcXVpcmUnLCB7XG4gICAgICAgIGpheDogamF4LFxuICAgICAgICByZXF1aXJlZDogX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGpheC5vcHRpb25zLnBhY2thZ2VzKSwgZmFsc2UpLFxuICAgICAgICBjb25maWd1cmVkOiBuZXcgTWFwKClcbiAgICB9KTtcbiAgICB2YXIgb3B0aW9ucyA9IGpheC5wYXJzZU9wdGlvbnMub3B0aW9ucy5yZXF1aXJlO1xuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLnByZWZpeDtcbiAgICBpZiAocHJlZml4Lm1hdGNoKC9bXl9hLXpBLVowLTldLykpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0lsbGVnYWwgY2hhcmFjdGVycyB1c2VkIGluIFxcXFxyZXF1aXJlIHByZWZpeCcpO1xuICAgIH1cbiAgICBpZiAoIWxvYWRlcl9qc18xLkNPTkZJRy5wYXRoc1twcmVmaXhdKSB7XG4gICAgICAgIGxvYWRlcl9qc18xLkNPTkZJRy5wYXRoc1twcmVmaXhdID0gJ1ttYXRoamF4XS9pbnB1dC90ZXgvZXh0ZW5zaW9ucyc7XG4gICAgfVxuICAgIG9wdGlvbnMucHJlZml4ID0gJ1snICsgcHJlZml4ICsgJ10vJztcbn1cbmV4cG9ydHMuUmVxdWlyZU1ldGhvZHMgPSB7XG4gICAgUmVxdWlyZTogZnVuY3Rpb24gKHBhcnNlciwgbmFtZSkge1xuICAgICAgICB2YXIgcmVxdWlyZWQgPSBwYXJzZXIuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgIGlmIChyZXF1aXJlZC5tYXRjaCgvW15fYS16QS1aMC05XS8pIHx8IHJlcXVpcmVkID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnQmFkUGFja2FnZU5hbWUnLCAnQXJndW1lbnQgZm9yICUxIGlzIG5vdCBhIHZhbGlkIHBhY2thZ2UgbmFtZScsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIFJlcXVpcmVMb2FkKHBhcnNlciwgcmVxdWlyZWQpO1xuICAgIH1cbn07XG5leHBvcnRzLm9wdGlvbnMgPSB7XG4gICAgcmVxdWlyZToge1xuICAgICAgICBhbGxvdzogKDAsIE9wdGlvbnNfanNfMS5leHBhbmRhYmxlKSh7XG4gICAgICAgICAgICBiYXNlOiBmYWxzZSxcbiAgICAgICAgICAgICdhbGwtcGFja2FnZXMnOiBmYWxzZSxcbiAgICAgICAgICAgIGF1dG9sb2FkOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ21hY3JvczogZmFsc2UsXG4gICAgICAgICAgICB0YWdmb3JtYXQ6IGZhbHNlLFxuICAgICAgICAgICAgc2V0b3B0aW9uczogZmFsc2VcbiAgICAgICAgfSksXG4gICAgICAgIGRlZmF1bHRBbGxvdzogdHJ1ZSxcbiAgICAgICAgcHJlZml4OiAndGV4J1xuICAgIH1cbn07XG5uZXcgU3ltYm9sTWFwX2pzXzEuQ29tbWFuZE1hcCgncmVxdWlyZScsIHsgcmVxdWlyZTogJ1JlcXVpcmUnIH0sIGV4cG9ydHMuUmVxdWlyZU1ldGhvZHMpO1xuZXhwb3J0cy5SZXF1aXJlQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb25fanNfMS5Db25maWd1cmF0aW9uLmNyZWF0ZSgncmVxdWlyZScsIHsgaGFuZGxlcjogeyBtYWNybzogWydyZXF1aXJlJ10gfSwgY29uZmlnOiBjb25maWcsIG9wdGlvbnM6IGV4cG9ydHMub3B0aW9ucyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcXVpcmVDb25maWd1cmF0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==