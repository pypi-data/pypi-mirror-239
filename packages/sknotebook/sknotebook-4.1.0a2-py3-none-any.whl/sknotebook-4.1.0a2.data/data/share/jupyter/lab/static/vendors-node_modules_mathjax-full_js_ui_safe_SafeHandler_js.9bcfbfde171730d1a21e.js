"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_ui_safe_SafeHandler_js"],{

/***/ "../node_modules/mathjax-full/js/ui/safe/SafeHandler.js":
/*!**************************************************************!*\
  !*** ../node_modules/mathjax-full/js/ui/safe/SafeHandler.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SafeHandler = exports.SafeMathDocumentMixin = void 0;
var safe_js_1 = __webpack_require__(/*! ./safe.js */ "../node_modules/mathjax-full/js/ui/safe/safe.js");
function SafeMathDocumentMixin(BaseDocument) {
    var _a;
    return _a = (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var e_1, _a;
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
                _this.safe = new _this.options.SafeClass(_this, _this.options.safeOptions);
                var ProcessBits = _this.constructor.ProcessBits;
                if (!ProcessBits.has('safe')) {
                    ProcessBits.allocate('safe');
                }
                try {
                    for (var _b = __values(_this.inputJax), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var jax = _c.value;
                        if (jax.name.match(/MathML/)) {
                            jax.mathml.filterAttribute = _this.safe.mmlAttribute.bind(_this.safe);
                            jax.mathml.filterClassList = _this.safe.mmlClassList.bind(_this.safe);
                        }
                        else if (jax.name.match(/TeX/)) {
                            jax.postFilters.add(_this.sanitize.bind(jax), -5.5);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return _this;
            }
            class_1.prototype.sanitize = function (data) {
                data.math.root = this.parseOptions.root;
                data.document.safe.sanitize(data.math, data.document);
            };
            return class_1;
        }(BaseDocument)),
        _a.OPTIONS = __assign(__assign({}, BaseDocument.OPTIONS), { safeOptions: __assign({}, safe_js_1.Safe.OPTIONS), SafeClass: safe_js_1.Safe }),
        _a;
}
exports.SafeMathDocumentMixin = SafeMathDocumentMixin;
function SafeHandler(handler) {
    handler.documentClass = SafeMathDocumentMixin(handler.documentClass);
    return handler;
}
exports.SafeHandler = SafeHandler;
//# sourceMappingURL=SafeHandler.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/ui/safe/SafeMethods.js":
/*!**************************************************************!*\
  !*** ../node_modules/mathjax-full/js/ui/safe/SafeMethods.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SafeMethods = void 0;
var lengths_js_1 = __webpack_require__(/*! ../../util/lengths.js */ "../node_modules/mathjax-full/js/util/lengths.js");
exports.SafeMethods = {
    filterURL: function (safe, url) {
        var protocol = (url.match(/^\s*([a-z]+):/i) || [null, ''])[1].toLowerCase();
        var allow = safe.allow.URLs;
        return (allow === 'all' || (allow === 'safe' &&
            (safe.options.safeProtocols[protocol] || !protocol))) ? url : null;
    },
    filterClassList: function (safe, list) {
        var _this = this;
        var classes = list.trim().replace(/\s\s+/g, ' ').split(/ /);
        return classes.map(function (name) { return _this.filterClass(safe, name) || ''; }).join(' ').trim().replace(/\s\s+/g, '');
    },
    filterClass: function (safe, CLASS) {
        var allow = safe.allow.classes;
        return (allow === 'all' || (allow === 'safe' && CLASS.match(safe.options.classPattern))) ? CLASS : null;
    },
    filterID: function (safe, id) {
        var allow = safe.allow.cssIDs;
        return (allow === 'all' || (allow === 'safe' && id.match(safe.options.idPattern))) ? id : null;
    },
    filterStyles: function (safe, styles) {
        var e_1, _a, e_2, _b;
        if (safe.allow.styles === 'all')
            return styles;
        if (safe.allow.styles !== 'safe')
            return null;
        var adaptor = safe.adaptor;
        var options = safe.options;
        try {
            var div1 = adaptor.node('div', { style: styles });
            var div2 = adaptor.node('div');
            try {
                for (var _c = __values(Object.keys(options.safeStyles)), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var style = _d.value;
                    if (options.styleParts[style]) {
                        try {
                            for (var _e = (e_2 = void 0, __values(['Top', 'Right', 'Bottom', 'Left'])), _f = _e.next(); !_f.done; _f = _e.next()) {
                                var sufix = _f.value;
                                var name_1 = style + sufix;
                                var value = this.filterStyle(safe, name_1, div1);
                                if (value) {
                                    adaptor.setStyle(div2, name_1, value);
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                    else {
                        var value = this.filterStyle(safe, style, div1);
                        if (value) {
                            adaptor.setStyle(div2, style, value);
                        }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            styles = adaptor.allStyles(div2);
        }
        catch (err) {
            styles = '';
        }
        return styles;
    },
    filterStyle: function (safe, style, div) {
        var value = safe.adaptor.getStyle(div, style);
        if (typeof value !== 'string' || value === '' || value.match(/^\s*calc/) ||
            (value.match(/javascript:/) && !safe.options.safeProtocols.javascript) ||
            (value.match(/data:/) && !safe.options.safeProtocols.data)) {
            return null;
        }
        var name = style.replace(/Top|Right|Left|Bottom/, '');
        if (!safe.options.safeStyles[style] && !safe.options.safeStyles[name]) {
            return null;
        }
        return this.filterStyleValue(safe, style, value, div);
    },
    filterStyleValue: function (safe, style, value, div) {
        var name = safe.options.styleLengths[style];
        if (!name) {
            return value;
        }
        if (typeof name !== 'string') {
            return this.filterStyleLength(safe, style, value);
        }
        var length = this.filterStyleLength(safe, name, safe.adaptor.getStyle(div, name));
        if (!length) {
            return null;
        }
        safe.adaptor.setStyle(div, name, length);
        return safe.adaptor.getStyle(div, style);
    },
    filterStyleLength: function (safe, style, value) {
        if (!value.match(/^(.+)(em|ex|ch|rem|px|mm|cm|in|pt|pc|%)$/))
            return null;
        var em = (0, lengths_js_1.length2em)(value, 1);
        var lengths = safe.options.styleLengths[style];
        var _a = __read((Array.isArray(lengths) ? lengths : [-safe.options.lengthMax, safe.options.lengthMax]), 2), m = _a[0], M = _a[1];
        return (m <= em && em <= M ? value : (em < m ? m : M).toFixed(3).replace(/\.?0+$/, '') + 'em');
    },
    filterFontSize: function (safe, size) {
        return this.filterStyleLength(safe, 'fontSize', size);
    },
    filterSizeMultiplier: function (safe, size) {
        var _a = __read(safe.options.scriptsizemultiplierRange || [-Infinity, Infinity], 2), m = _a[0], M = _a[1];
        return Math.min(M, Math.max(m, parseFloat(size))).toString();
    },
    filterScriptLevel: function (safe, level) {
        var _a = __read(safe.options.scriptlevelRange || [-Infinity, Infinity], 2), m = _a[0], M = _a[1];
        return Math.min(M, Math.max(m, parseInt(level))).toString();
    },
    filterData: function (safe, value, id) {
        return (id.match(safe.options.dataPattern) ? value : null);
    }
};
//# sourceMappingURL=SafeMethods.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/ui/safe/safe.js":
/*!*******************************************************!*\
  !*** ../node_modules/mathjax-full/js/ui/safe/safe.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Safe = void 0;
var Options_js_1 = __webpack_require__(/*! ../../util/Options.js */ "../node_modules/mathjax-full/js/util/Options.js");
var SafeMethods_js_1 = __webpack_require__(/*! ./SafeMethods.js */ "../node_modules/mathjax-full/js/ui/safe/SafeMethods.js");
var Safe = (function () {
    function Safe(document, options) {
        this.filterAttributes = new Map([
            ['href', 'filterURL'],
            ['src', 'filterURL'],
            ['altimg', 'filterURL'],
            ['class', 'filterClassList'],
            ['style', 'filterStyles'],
            ['id', 'filterID'],
            ['fontsize', 'filterFontSize'],
            ['mathsize', 'filterFontSize'],
            ['scriptminsize', 'filterFontSize'],
            ['scriptsizemultiplier', 'filterSizeMultiplier'],
            ['scriptlevel', 'filterScriptLevel'],
            ['data-', 'filterData']
        ]);
        this.filterMethods = __assign({}, SafeMethods_js_1.SafeMethods);
        this.adaptor = document.adaptor;
        this.options = options;
        this.allow = this.options.allow;
    }
    Safe.prototype.sanitize = function (math, document) {
        try {
            math.root.walkTree(this.sanitizeNode.bind(this));
        }
        catch (err) {
            document.options.compileError(document, math, err);
        }
    };
    Safe.prototype.sanitizeNode = function (node) {
        var e_1, _a;
        var attributes = node.attributes.getAllAttributes();
        try {
            for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var id = _c.value;
                var method = this.filterAttributes.get(id);
                if (method) {
                    var value = this.filterMethods[method](this, attributes[id]);
                    if (value) {
                        if (value !== (typeof value === 'number' ? parseFloat(attributes[id]) : attributes[id])) {
                            attributes[id] = value;
                        }
                    }
                    else {
                        delete attributes[id];
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    Safe.prototype.mmlAttribute = function (id, value) {
        if (id === 'class')
            return null;
        var method = this.filterAttributes.get(id);
        var filter = (method || (id.substr(0, 5) === 'data-' ? this.filterAttributes.get('data-') : null));
        if (!filter) {
            return value;
        }
        var result = this.filterMethods[filter](this, value, id);
        return (typeof result === 'number' || typeof result === 'boolean' ? String(result) : result);
    };
    Safe.prototype.mmlClassList = function (list) {
        var _this = this;
        return list.map(function (name) { return _this.filterMethods.filterClass(_this, name); })
            .filter(function (value) { return value !== null; });
    };
    Safe.OPTIONS = {
        allow: {
            URLs: 'safe',
            classes: 'safe',
            cssIDs: 'safe',
            styles: 'safe'
        },
        lengthMax: 3,
        scriptsizemultiplierRange: [.6, 1],
        scriptlevelRange: [-2, 2],
        classPattern: /^mjx-[-a-zA-Z0-9_.]+$/,
        idPattern: /^mjx-[-a-zA-Z0-9_.]+$/,
        dataPattern: /^data-mjx-/,
        safeProtocols: (0, Options_js_1.expandable)({
            http: true,
            https: true,
            file: true,
            javascript: false,
            data: false
        }),
        safeStyles: (0, Options_js_1.expandable)({
            color: true,
            backgroundColor: true,
            border: true,
            cursor: true,
            margin: true,
            padding: true,
            textShadow: true,
            fontFamily: true,
            fontSize: true,
            fontStyle: true,
            fontWeight: true,
            opacity: true,
            outline: true
        }),
        styleParts: (0, Options_js_1.expandable)({
            border: true,
            padding: true,
            margin: true,
            outline: true
        }),
        styleLengths: (0, Options_js_1.expandable)({
            borderTop: 'borderTopWidth',
            borderRight: 'borderRightWidth',
            borderBottom: 'borderBottomWidth',
            borderLeft: 'borderLeftWidth',
            paddingTop: true,
            paddingRight: true,
            paddingBottom: true,
            paddingLeft: true,
            marginTop: true,
            marginRight: true,
            marginBottom: true,
            marginLeft: true,
            outlineTop: true,
            outlineRight: true,
            outlineBottom: true,
            outlineLeft: true,
            fontSize: [.707, 1.44]
        })
    };
    return Safe;
}());
exports.Safe = Safe;
//# sourceMappingURL=safe.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/util/Options.js":
/*!*******************************************************!*\
  !*** ../node_modules/mathjax-full/js/util/Options.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lookup = exports.separateOptions = exports.selectOptionsFromKeys = exports.selectOptions = exports.userOptions = exports.defaultOptions = exports.insert = exports.copy = exports.keys = exports.makeArray = exports.expandable = exports.Expandable = exports.OPTIONS = exports.REMOVE = exports.APPEND = exports.isObject = void 0;
var OBJECT = {}.constructor;
function isObject(obj) {
    return typeof obj === 'object' && obj !== null &&
        (obj.constructor === OBJECT || obj.constructor === Expandable);
}
exports.isObject = isObject;
exports.APPEND = '[+]';
exports.REMOVE = '[-]';
exports.OPTIONS = {
    invalidOption: 'warn',
    optionError: function (message, _key) {
        if (exports.OPTIONS.invalidOption === 'fatal') {
            throw new Error(message);
        }
        console.warn('MathJax: ' + message);
    }
};
var Expandable = (function () {
    function Expandable() {
    }
    return Expandable;
}());
exports.Expandable = Expandable;
function expandable(def) {
    return Object.assign(Object.create(Expandable.prototype), def);
}
exports.expandable = expandable;
function makeArray(x) {
    return Array.isArray(x) ? x : [x];
}
exports.makeArray = makeArray;
function keys(def) {
    if (!def) {
        return [];
    }
    return Object.keys(def).concat(Object.getOwnPropertySymbols(def));
}
exports.keys = keys;
function copy(def) {
    var e_1, _a;
    var props = {};
    try {
        for (var _b = __values(keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            var prop = Object.getOwnPropertyDescriptor(def, key);
            var value = prop.value;
            if (Array.isArray(value)) {
                prop.value = insert([], value, false);
            }
            else if (isObject(value)) {
                prop.value = copy(value);
            }
            if (prop.enumerable) {
                props[key] = prop;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return Object.defineProperties(def.constructor === Expandable ? expandable({}) : {}, props);
}
exports.copy = copy;
function insert(dst, src, warn) {
    var e_2, _a;
    if (warn === void 0) { warn = true; }
    var _loop_1 = function (key) {
        if (warn && dst[key] === undefined && dst.constructor !== Expandable) {
            if (typeof key === 'symbol') {
                key = key.toString();
            }
            exports.OPTIONS.optionError("Invalid option \"".concat(key, "\" (no default value)."), key);
            return "continue";
        }
        var sval = src[key], dval = dst[key];
        if (isObject(sval) && dval !== null &&
            (typeof dval === 'object' || typeof dval === 'function')) {
            var ids = keys(sval);
            if (Array.isArray(dval) &&
                ((ids.length === 1 && (ids[0] === exports.APPEND || ids[0] === exports.REMOVE) && Array.isArray(sval[ids[0]])) ||
                    (ids.length === 2 && ids.sort().join(',') === exports.APPEND + ',' + exports.REMOVE &&
                        Array.isArray(sval[exports.APPEND]) && Array.isArray(sval[exports.REMOVE])))) {
                if (sval[exports.REMOVE]) {
                    dval = dst[key] = dval.filter(function (x) { return sval[exports.REMOVE].indexOf(x) < 0; });
                }
                if (sval[exports.APPEND]) {
                    dst[key] = __spreadArray(__spreadArray([], __read(dval), false), __read(sval[exports.APPEND]), false);
                }
            }
            else {
                insert(dval, sval, warn);
            }
        }
        else if (Array.isArray(sval)) {
            dst[key] = [];
            insert(dst[key], sval, false);
        }
        else if (isObject(sval)) {
            dst[key] = copy(sval);
        }
        else {
            dst[key] = sval;
        }
    };
    try {
        for (var _b = __values(keys(src)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            _loop_1(key);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return dst;
}
exports.insert = insert;
function defaultOptions(options) {
    var defs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        defs[_i - 1] = arguments[_i];
    }
    defs.forEach(function (def) { return insert(options, def, false); });
    return options;
}
exports.defaultOptions = defaultOptions;
function userOptions(options) {
    var defs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        defs[_i - 1] = arguments[_i];
    }
    defs.forEach(function (def) { return insert(options, def, true); });
    return options;
}
exports.userOptions = userOptions;
function selectOptions(options) {
    var e_3, _a;
    var keys = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        keys[_i - 1] = arguments[_i];
    }
    var subset = {};
    try {
        for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            if (options.hasOwnProperty(key)) {
                subset[key] = options[key];
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return subset;
}
exports.selectOptions = selectOptions;
function selectOptionsFromKeys(options, object) {
    return selectOptions.apply(void 0, __spreadArray([options], __read(Object.keys(object)), false));
}
exports.selectOptionsFromKeys = selectOptionsFromKeys;
function separateOptions(options) {
    var e_4, _a, e_5, _b;
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    var results = [];
    try {
        for (var objects_1 = __values(objects), objects_1_1 = objects_1.next(); !objects_1_1.done; objects_1_1 = objects_1.next()) {
            var object = objects_1_1.value;
            var exists = {}, missing = {};
            try {
                for (var _c = (e_5 = void 0, __values(Object.keys(options || {}))), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var key = _d.value;
                    (object[key] === undefined ? missing : exists)[key] = options[key];
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                }
                finally { if (e_5) throw e_5.error; }
            }
            results.push(exists);
            options = missing;
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (objects_1_1 && !objects_1_1.done && (_a = objects_1.return)) _a.call(objects_1);
        }
        finally { if (e_4) throw e_4.error; }
    }
    results.unshift(options);
    return results;
}
exports.separateOptions = separateOptions;
function lookup(name, lookup, def) {
    if (def === void 0) { def = null; }
    return (lookup.hasOwnProperty(name) ? lookup[name] : def);
}
exports.lookup = lookup;
//# sourceMappingURL=Options.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/util/lengths.js":
/*!*******************************************************!*\
  !*** ../node_modules/mathjax-full/js/util/lengths.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.px = exports.emRounded = exports.em = exports.percent = exports.length2em = exports.MATHSPACE = exports.RELUNITS = exports.UNITS = exports.BIGDIMEN = void 0;
exports.BIGDIMEN = 1000000;
exports.UNITS = {
    px: 1,
    'in': 96,
    cm: 96 / 2.54,
    mm: 96 / 25.4
};
exports.RELUNITS = {
    em: 1,
    ex: .431,
    pt: 1 / 10,
    pc: 12 / 10,
    mu: 1 / 18
};
exports.MATHSPACE = {
    veryverythinmathspace: 1 / 18,
    verythinmathspace: 2 / 18,
    thinmathspace: 3 / 18,
    mediummathspace: 4 / 18,
    thickmathspace: 5 / 18,
    verythickmathspace: 6 / 18,
    veryverythickmathspace: 7 / 18,
    negativeveryverythinmathspace: -1 / 18,
    negativeverythinmathspace: -2 / 18,
    negativethinmathspace: -3 / 18,
    negativemediummathspace: -4 / 18,
    negativethickmathspace: -5 / 18,
    negativeverythickmathspace: -6 / 18,
    negativeveryverythickmathspace: -7 / 18,
    thin: .04,
    medium: .06,
    thick: .1,
    normal: 1,
    big: 2,
    small: 1 / Math.sqrt(2),
    infinity: exports.BIGDIMEN
};
function length2em(length, size, scale, em) {
    if (size === void 0) { size = 0; }
    if (scale === void 0) { scale = 1; }
    if (em === void 0) { em = 16; }
    if (typeof length !== 'string') {
        length = String(length);
    }
    if (length === '' || length == null) {
        return size;
    }
    if (exports.MATHSPACE[length]) {
        return exports.MATHSPACE[length];
    }
    var match = length.match(/^\s*([-+]?(?:\.\d+|\d+(?:\.\d*)?))?(pt|em|ex|mu|px|pc|in|mm|cm|%)?/);
    if (!match) {
        return size;
    }
    var m = parseFloat(match[1] || '1'), unit = match[2];
    if (exports.UNITS.hasOwnProperty(unit)) {
        return m * exports.UNITS[unit] / em / scale;
    }
    if (exports.RELUNITS.hasOwnProperty(unit)) {
        return m * exports.RELUNITS[unit];
    }
    if (unit === '%') {
        return m / 100 * size;
    }
    return m * size;
}
exports.length2em = length2em;
function percent(m) {
    return (100 * m).toFixed(1).replace(/\.?0+$/, '') + '%';
}
exports.percent = percent;
function em(m) {
    if (Math.abs(m) < .001)
        return '0';
    return (m.toFixed(3).replace(/\.?0+$/, '')) + 'em';
}
exports.em = em;
function emRounded(m, em) {
    if (em === void 0) { em = 16; }
    m = (Math.round(m * em) + .05) / em;
    if (Math.abs(m) < .001)
        return '0em';
    return m.toFixed(3).replace(/\.?0+$/, '') + 'em';
}
exports.emRounded = emRounded;
function px(m, M, em) {
    if (M === void 0) { M = -exports.BIGDIMEN; }
    if (em === void 0) { em = 16; }
    m *= em;
    if (M && m < M)
        m = M;
    if (Math.abs(m) < .1)
        return '0';
    return m.toFixed(1).replace(/\.0$/, '') + 'px';
}
exports.px = px;
//# sourceMappingURL=lengths.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX3VpX3NhZmVfU2FmZUhhbmRsZXJfanMuOWJjZmJmZGUxNzE3MzBkMWEyMWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyw2QkFBNkI7QUFDbkQsZ0JBQWdCLG1CQUFPLENBQUMsa0VBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxVQUFVO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFD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QTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91aS9zYWZlL1NhZmVIYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3VpL3NhZmUvU2FmZU1ldGhvZHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdWkvc2FmZS9zYWZlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3V0aWwvT3B0aW9ucy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91dGlsL2xlbmd0aHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgZnVuY3Rpb24gKCkge1xuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgICAgICB0W3BdID0gc1twXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9O1xuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2FmZUhhbmRsZXIgPSBleHBvcnRzLlNhZmVNYXRoRG9jdW1lbnRNaXhpbiA9IHZvaWQgMDtcbnZhciBzYWZlX2pzXzEgPSByZXF1aXJlKFwiLi9zYWZlLmpzXCIpO1xuZnVuY3Rpb24gU2FmZU1hdGhEb2N1bWVudE1peGluKEJhc2VEb2N1bWVudCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX2EgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2FmZSA9IG5ldyBfdGhpcy5vcHRpb25zLlNhZmVDbGFzcyhfdGhpcywgX3RoaXMub3B0aW9ucy5zYWZlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIFByb2Nlc3NCaXRzID0gX3RoaXMuY29uc3RydWN0b3IuUHJvY2Vzc0JpdHM7XG4gICAgICAgICAgICAgICAgaWYgKCFQcm9jZXNzQml0cy5oYXMoJ3NhZmUnKSkge1xuICAgICAgICAgICAgICAgICAgICBQcm9jZXNzQml0cy5hbGxvY2F0ZSgnc2FmZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKF90aGlzLmlucHV0SmF4KSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGpheCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpheC5uYW1lLm1hdGNoKC9NYXRoTUwvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpheC5tYXRobWwuZmlsdGVyQXR0cmlidXRlID0gX3RoaXMuc2FmZS5tbWxBdHRyaWJ1dGUuYmluZChfdGhpcy5zYWZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYXgubWF0aG1sLmZpbHRlckNsYXNzTGlzdCA9IF90aGlzLnNhZmUubW1sQ2xhc3NMaXN0LmJpbmQoX3RoaXMuc2FmZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChqYXgubmFtZS5tYXRjaCgvVGVYLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqYXgucG9zdEZpbHRlcnMuYWRkKF90aGlzLnNhbml0aXplLmJpbmQoamF4KSwgLTUuNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNhbml0aXplID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhLm1hdGgucm9vdCA9IHRoaXMucGFyc2VPcHRpb25zLnJvb3Q7XG4gICAgICAgICAgICAgICAgZGF0YS5kb2N1bWVudC5zYWZlLnNhbml0aXplKGRhdGEubWF0aCwgZGF0YS5kb2N1bWVudCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGNsYXNzXzE7XG4gICAgICAgIH0oQmFzZURvY3VtZW50KSksXG4gICAgICAgIF9hLk9QVElPTlMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgQmFzZURvY3VtZW50Lk9QVElPTlMpLCB7IHNhZmVPcHRpb25zOiBfX2Fzc2lnbih7fSwgc2FmZV9qc18xLlNhZmUuT1BUSU9OUyksIFNhZmVDbGFzczogc2FmZV9qc18xLlNhZmUgfSksXG4gICAgICAgIF9hO1xufVxuZXhwb3J0cy5TYWZlTWF0aERvY3VtZW50TWl4aW4gPSBTYWZlTWF0aERvY3VtZW50TWl4aW47XG5mdW5jdGlvbiBTYWZlSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgaGFuZGxlci5kb2N1bWVudENsYXNzID0gU2FmZU1hdGhEb2N1bWVudE1peGluKGhhbmRsZXIuZG9jdW1lbnRDbGFzcyk7XG4gICAgcmV0dXJuIGhhbmRsZXI7XG59XG5leHBvcnRzLlNhZmVIYW5kbGVyID0gU2FmZUhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TYWZlSGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2FmZU1ldGhvZHMgPSB2b2lkIDA7XG52YXIgbGVuZ3Roc19qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvbGVuZ3Rocy5qc1wiKTtcbmV4cG9ydHMuU2FmZU1ldGhvZHMgPSB7XG4gICAgZmlsdGVyVVJMOiBmdW5jdGlvbiAoc2FmZSwgdXJsKSB7XG4gICAgICAgIHZhciBwcm90b2NvbCA9ICh1cmwubWF0Y2goL15cXHMqKFthLXpdKyk6L2kpIHx8IFtudWxsLCAnJ10pWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBhbGxvdyA9IHNhZmUuYWxsb3cuVVJMcztcbiAgICAgICAgcmV0dXJuIChhbGxvdyA9PT0gJ2FsbCcgfHwgKGFsbG93ID09PSAnc2FmZScgJiZcbiAgICAgICAgICAgIChzYWZlLm9wdGlvbnMuc2FmZVByb3RvY29sc1twcm90b2NvbF0gfHwgIXByb3RvY29sKSkpID8gdXJsIDogbnVsbDtcbiAgICB9LFxuICAgIGZpbHRlckNsYXNzTGlzdDogZnVuY3Rpb24gKHNhZmUsIGxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBsaXN0LnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMrL2csICcgJykuc3BsaXQoLyAvKTtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5maWx0ZXJDbGFzcyhzYWZlLCBuYW1lKSB8fCAnJzsgfSkuam9pbignICcpLnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMrL2csICcnKTtcbiAgICB9LFxuICAgIGZpbHRlckNsYXNzOiBmdW5jdGlvbiAoc2FmZSwgQ0xBU1MpIHtcbiAgICAgICAgdmFyIGFsbG93ID0gc2FmZS5hbGxvdy5jbGFzc2VzO1xuICAgICAgICByZXR1cm4gKGFsbG93ID09PSAnYWxsJyB8fCAoYWxsb3cgPT09ICdzYWZlJyAmJiBDTEFTUy5tYXRjaChzYWZlLm9wdGlvbnMuY2xhc3NQYXR0ZXJuKSkpID8gQ0xBU1MgOiBudWxsO1xuICAgIH0sXG4gICAgZmlsdGVySUQ6IGZ1bmN0aW9uIChzYWZlLCBpZCkge1xuICAgICAgICB2YXIgYWxsb3cgPSBzYWZlLmFsbG93LmNzc0lEcztcbiAgICAgICAgcmV0dXJuIChhbGxvdyA9PT0gJ2FsbCcgfHwgKGFsbG93ID09PSAnc2FmZScgJiYgaWQubWF0Y2goc2FmZS5vcHRpb25zLmlkUGF0dGVybikpKSA/IGlkIDogbnVsbDtcbiAgICB9LFxuICAgIGZpbHRlclN0eWxlczogZnVuY3Rpb24gKHNhZmUsIHN0eWxlcykge1xuICAgICAgICB2YXIgZV8xLCBfYSwgZV8yLCBfYjtcbiAgICAgICAgaWYgKHNhZmUuYWxsb3cuc3R5bGVzID09PSAnYWxsJylcbiAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIGlmIChzYWZlLmFsbG93LnN0eWxlcyAhPT0gJ3NhZmUnKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBhZGFwdG9yID0gc2FmZS5hZGFwdG9yO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHNhZmUub3B0aW9ucztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBkaXYxID0gYWRhcHRvci5ub2RlKCdkaXYnLCB7IHN0eWxlOiBzdHlsZXMgfSk7XG4gICAgICAgICAgICB2YXIgZGl2MiA9IGFkYXB0b3Iubm9kZSgnZGl2Jyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gX192YWx1ZXMoT2JqZWN0LmtleXMob3B0aW9ucy5zYWZlU3R5bGVzKSksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnN0eWxlUGFydHNbc3R5bGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9lID0gKGVfMiA9IHZvaWQgMCwgX192YWx1ZXMoWydUb3AnLCAnUmlnaHQnLCAnQm90dG9tJywgJ0xlZnQnXSkpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdWZpeCA9IF9mLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gc3R5bGUgKyBzdWZpeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5maWx0ZXJTdHlsZShzYWZlLCBuYW1lXzEsIGRpdjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUoZGl2MiwgbmFtZV8xLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9mICYmICFfZi5kb25lICYmIChfYiA9IF9lLnJldHVybikpIF9iLmNhbGwoX2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmZpbHRlclN0eWxlKHNhZmUsIHN0eWxlLCBkaXYxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkYXB0b3Iuc2V0U3R5bGUoZGl2Miwgc3R5bGUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlcyA9IGFkYXB0b3IuYWxsU3R5bGVzKGRpdjIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHN0eWxlcyA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgfSxcbiAgICBmaWx0ZXJTdHlsZTogZnVuY3Rpb24gKHNhZmUsIHN0eWxlLCBkaXYpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc2FmZS5hZGFwdG9yLmdldFN0eWxlKGRpdiwgc3R5bGUpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCB2YWx1ZSA9PT0gJycgfHwgdmFsdWUubWF0Y2goL15cXHMqY2FsYy8pIHx8XG4gICAgICAgICAgICAodmFsdWUubWF0Y2goL2phdmFzY3JpcHQ6LykgJiYgIXNhZmUub3B0aW9ucy5zYWZlUHJvdG9jb2xzLmphdmFzY3JpcHQpIHx8XG4gICAgICAgICAgICAodmFsdWUubWF0Y2goL2RhdGE6LykgJiYgIXNhZmUub3B0aW9ucy5zYWZlUHJvdG9jb2xzLmRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSA9IHN0eWxlLnJlcGxhY2UoL1RvcHxSaWdodHxMZWZ0fEJvdHRvbS8sICcnKTtcbiAgICAgICAgaWYgKCFzYWZlLm9wdGlvbnMuc2FmZVN0eWxlc1tzdHlsZV0gJiYgIXNhZmUub3B0aW9ucy5zYWZlU3R5bGVzW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJTdHlsZVZhbHVlKHNhZmUsIHN0eWxlLCB2YWx1ZSwgZGl2KTtcbiAgICB9LFxuICAgIGZpbHRlclN0eWxlVmFsdWU6IGZ1bmN0aW9uIChzYWZlLCBzdHlsZSwgdmFsdWUsIGRpdikge1xuICAgICAgICB2YXIgbmFtZSA9IHNhZmUub3B0aW9ucy5zdHlsZUxlbmd0aHNbc3R5bGVdO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJTdHlsZUxlbmd0aChzYWZlLCBzdHlsZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSB0aGlzLmZpbHRlclN0eWxlTGVuZ3RoKHNhZmUsIG5hbWUsIHNhZmUuYWRhcHRvci5nZXRTdHlsZShkaXYsIG5hbWUpKTtcbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHNhZmUuYWRhcHRvci5zZXRTdHlsZShkaXYsIG5hbWUsIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzYWZlLmFkYXB0b3IuZ2V0U3R5bGUoZGl2LCBzdHlsZSk7XG4gICAgfSxcbiAgICBmaWx0ZXJTdHlsZUxlbmd0aDogZnVuY3Rpb24gKHNhZmUsIHN0eWxlLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlLm1hdGNoKC9eKC4rKShlbXxleHxjaHxyZW18cHh8bW18Y218aW58cHR8cGN8JSkkLykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIGVtID0gKDAsIGxlbmd0aHNfanNfMS5sZW5ndGgyZW0pKHZhbHVlLCAxKTtcbiAgICAgICAgdmFyIGxlbmd0aHMgPSBzYWZlLm9wdGlvbnMuc3R5bGVMZW5ndGhzW3N0eWxlXTtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKChBcnJheS5pc0FycmF5KGxlbmd0aHMpID8gbGVuZ3RocyA6IFstc2FmZS5vcHRpb25zLmxlbmd0aE1heCwgc2FmZS5vcHRpb25zLmxlbmd0aE1heF0pLCAyKSwgbSA9IF9hWzBdLCBNID0gX2FbMV07XG4gICAgICAgIHJldHVybiAobSA8PSBlbSAmJiBlbSA8PSBNID8gdmFsdWUgOiAoZW0gPCBtID8gbSA6IE0pLnRvRml4ZWQoMykucmVwbGFjZSgvXFwuPzArJC8sICcnKSArICdlbScpO1xuICAgIH0sXG4gICAgZmlsdGVyRm9udFNpemU6IGZ1bmN0aW9uIChzYWZlLCBzaXplKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlclN0eWxlTGVuZ3RoKHNhZmUsICdmb250U2l6ZScsIHNpemUpO1xuICAgIH0sXG4gICAgZmlsdGVyU2l6ZU11bHRpcGxpZXI6IGZ1bmN0aW9uIChzYWZlLCBzaXplKSB7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChzYWZlLm9wdGlvbnMuc2NyaXB0c2l6ZW11bHRpcGxpZXJSYW5nZSB8fCBbLUluZmluaXR5LCBJbmZpbml0eV0sIDIpLCBtID0gX2FbMF0sIE0gPSBfYVsxXTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE0sIE1hdGgubWF4KG0sIHBhcnNlRmxvYXQoc2l6ZSkpKS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgZmlsdGVyU2NyaXB0TGV2ZWw6IGZ1bmN0aW9uIChzYWZlLCBsZXZlbCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoc2FmZS5vcHRpb25zLnNjcmlwdGxldmVsUmFuZ2UgfHwgWy1JbmZpbml0eSwgSW5maW5pdHldLCAyKSwgbSA9IF9hWzBdLCBNID0gX2FbMV07XG4gICAgICAgIHJldHVybiBNYXRoLm1pbihNLCBNYXRoLm1heChtLCBwYXJzZUludChsZXZlbCkpKS50b1N0cmluZygpO1xuICAgIH0sXG4gICAgZmlsdGVyRGF0YTogZnVuY3Rpb24gKHNhZmUsIHZhbHVlLCBpZCkge1xuICAgICAgICByZXR1cm4gKGlkLm1hdGNoKHNhZmUub3B0aW9ucy5kYXRhUGF0dGVybikgPyB2YWx1ZSA6IG51bGwpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TYWZlTWV0aG9kcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNhZmUgPSB2b2lkIDA7XG52YXIgT3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvT3B0aW9ucy5qc1wiKTtcbnZhciBTYWZlTWV0aG9kc19qc18xID0gcmVxdWlyZShcIi4vU2FmZU1ldGhvZHMuanNcIik7XG52YXIgU2FmZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2FmZShkb2N1bWVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmZpbHRlckF0dHJpYnV0ZXMgPSBuZXcgTWFwKFtcbiAgICAgICAgICAgIFsnaHJlZicsICdmaWx0ZXJVUkwnXSxcbiAgICAgICAgICAgIFsnc3JjJywgJ2ZpbHRlclVSTCddLFxuICAgICAgICAgICAgWydhbHRpbWcnLCAnZmlsdGVyVVJMJ10sXG4gICAgICAgICAgICBbJ2NsYXNzJywgJ2ZpbHRlckNsYXNzTGlzdCddLFxuICAgICAgICAgICAgWydzdHlsZScsICdmaWx0ZXJTdHlsZXMnXSxcbiAgICAgICAgICAgIFsnaWQnLCAnZmlsdGVySUQnXSxcbiAgICAgICAgICAgIFsnZm9udHNpemUnLCAnZmlsdGVyRm9udFNpemUnXSxcbiAgICAgICAgICAgIFsnbWF0aHNpemUnLCAnZmlsdGVyRm9udFNpemUnXSxcbiAgICAgICAgICAgIFsnc2NyaXB0bWluc2l6ZScsICdmaWx0ZXJGb250U2l6ZSddLFxuICAgICAgICAgICAgWydzY3JpcHRzaXplbXVsdGlwbGllcicsICdmaWx0ZXJTaXplTXVsdGlwbGllciddLFxuICAgICAgICAgICAgWydzY3JpcHRsZXZlbCcsICdmaWx0ZXJTY3JpcHRMZXZlbCddLFxuICAgICAgICAgICAgWydkYXRhLScsICdmaWx0ZXJEYXRhJ11cbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuZmlsdGVyTWV0aG9kcyA9IF9fYXNzaWduKHt9LCBTYWZlTWV0aG9kc19qc18xLlNhZmVNZXRob2RzKTtcbiAgICAgICAgdGhpcy5hZGFwdG9yID0gZG9jdW1lbnQuYWRhcHRvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5hbGxvdyA9IHRoaXMub3B0aW9ucy5hbGxvdztcbiAgICB9XG4gICAgU2FmZS5wcm90b3R5cGUuc2FuaXRpemUgPSBmdW5jdGlvbiAobWF0aCwgZG9jdW1lbnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hdGgucm9vdC53YWxrVHJlZSh0aGlzLnNhbml0aXplTm9kZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5vcHRpb25zLmNvbXBpbGVFcnJvcihkb2N1bWVudCwgbWF0aCwgZXJyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZS5wcm90b3R5cGUuc2FuaXRpemVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzLmdldEFsbEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMoYXR0cmlidXRlcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuZmlsdGVyQXR0cmlidXRlcy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5maWx0ZXJNZXRob2RzW21ldGhvZF0odGhpcywgYXR0cmlidXRlc1tpZF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgPyBwYXJzZUZsb2F0KGF0dHJpYnV0ZXNbaWRdKSA6IGF0dHJpYnV0ZXNbaWRdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbaWRdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlc1tpZF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgU2FmZS5wcm90b3R5cGUubW1sQXR0cmlidXRlID0gZnVuY3Rpb24gKGlkLCB2YWx1ZSkge1xuICAgICAgICBpZiAoaWQgPT09ICdjbGFzcycpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXMuZmlsdGVyQXR0cmlidXRlcy5nZXQoaWQpO1xuICAgICAgICB2YXIgZmlsdGVyID0gKG1ldGhvZCB8fCAoaWQuc3Vic3RyKDAsIDUpID09PSAnZGF0YS0nID8gdGhpcy5maWx0ZXJBdHRyaWJ1dGVzLmdldCgnZGF0YS0nKSA6IG51bGwpKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maWx0ZXJNZXRob2RzW2ZpbHRlcl0odGhpcywgdmFsdWUsIGlkKTtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgcmVzdWx0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcmVzdWx0ID09PSAnYm9vbGVhbicgPyBTdHJpbmcocmVzdWx0KSA6IHJlc3VsdCk7XG4gICAgfTtcbiAgICBTYWZlLnByb3RvdHlwZS5tbWxDbGFzc0xpc3QgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbGlzdC5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmZpbHRlck1ldGhvZHMuZmlsdGVyQ2xhc3MoX3RoaXMsIG5hbWUpOyB9KVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlICE9PSBudWxsOyB9KTtcbiAgICB9O1xuICAgIFNhZmUuT1BUSU9OUyA9IHtcbiAgICAgICAgYWxsb3c6IHtcbiAgICAgICAgICAgIFVSTHM6ICdzYWZlJyxcbiAgICAgICAgICAgIGNsYXNzZXM6ICdzYWZlJyxcbiAgICAgICAgICAgIGNzc0lEczogJ3NhZmUnLFxuICAgICAgICAgICAgc3R5bGVzOiAnc2FmZSdcbiAgICAgICAgfSxcbiAgICAgICAgbGVuZ3RoTWF4OiAzLFxuICAgICAgICBzY3JpcHRzaXplbXVsdGlwbGllclJhbmdlOiBbLjYsIDFdLFxuICAgICAgICBzY3JpcHRsZXZlbFJhbmdlOiBbLTIsIDJdLFxuICAgICAgICBjbGFzc1BhdHRlcm46IC9ebWp4LVstYS16QS1aMC05Xy5dKyQvLFxuICAgICAgICBpZFBhdHRlcm46IC9ebWp4LVstYS16QS1aMC05Xy5dKyQvLFxuICAgICAgICBkYXRhUGF0dGVybjogL15kYXRhLW1qeC0vLFxuICAgICAgICBzYWZlUHJvdG9jb2xzOiAoMCwgT3B0aW9uc19qc18xLmV4cGFuZGFibGUpKHtcbiAgICAgICAgICAgIGh0dHA6IHRydWUsXG4gICAgICAgICAgICBodHRwczogdHJ1ZSxcbiAgICAgICAgICAgIGZpbGU6IHRydWUsXG4gICAgICAgICAgICBqYXZhc2NyaXB0OiBmYWxzZSxcbiAgICAgICAgICAgIGRhdGE6IGZhbHNlXG4gICAgICAgIH0pLFxuICAgICAgICBzYWZlU3R5bGVzOiAoMCwgT3B0aW9uc19qc18xLmV4cGFuZGFibGUpKHtcbiAgICAgICAgICAgIGNvbG9yOiB0cnVlLFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0cnVlLFxuICAgICAgICAgICAgYm9yZGVyOiB0cnVlLFxuICAgICAgICAgICAgY3Vyc29yOiB0cnVlLFxuICAgICAgICAgICAgbWFyZ2luOiB0cnVlLFxuICAgICAgICAgICAgcGFkZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIHRleHRTaGFkb3c6IHRydWUsXG4gICAgICAgICAgICBmb250RmFtaWx5OiB0cnVlLFxuICAgICAgICAgICAgZm9udFNpemU6IHRydWUsXG4gICAgICAgICAgICBmb250U3R5bGU6IHRydWUsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgb3BhY2l0eTogdHJ1ZSxcbiAgICAgICAgICAgIG91dGxpbmU6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIHN0eWxlUGFydHM6ICgwLCBPcHRpb25zX2pzXzEuZXhwYW5kYWJsZSkoe1xuICAgICAgICAgICAgYm9yZGVyOiB0cnVlLFxuICAgICAgICAgICAgcGFkZGluZzogdHJ1ZSxcbiAgICAgICAgICAgIG1hcmdpbjogdHJ1ZSxcbiAgICAgICAgICAgIG91dGxpbmU6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIHN0eWxlTGVuZ3RoczogKDAsIE9wdGlvbnNfanNfMS5leHBhbmRhYmxlKSh7XG4gICAgICAgICAgICBib3JkZXJUb3A6ICdib3JkZXJUb3BXaWR0aCcsXG4gICAgICAgICAgICBib3JkZXJSaWdodDogJ2JvcmRlclJpZ2h0V2lkdGgnLFxuICAgICAgICAgICAgYm9yZGVyQm90dG9tOiAnYm9yZGVyQm90dG9tV2lkdGgnLFxuICAgICAgICAgICAgYm9yZGVyTGVmdDogJ2JvcmRlckxlZnRXaWR0aCcsXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiB0cnVlLFxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgcGFkZGluZ0JvdHRvbTogdHJ1ZSxcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiB0cnVlLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiB0cnVlLFxuICAgICAgICAgICAgbWFyZ2luUmlnaHQ6IHRydWUsXG4gICAgICAgICAgICBtYXJnaW5Cb3R0b206IHRydWUsXG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiB0cnVlLFxuICAgICAgICAgICAgb3V0bGluZVRvcDogdHJ1ZSxcbiAgICAgICAgICAgIG91dGxpbmVSaWdodDogdHJ1ZSxcbiAgICAgICAgICAgIG91dGxpbmVCb3R0b206IHRydWUsXG4gICAgICAgICAgICBvdXRsaW5lTGVmdDogdHJ1ZSxcbiAgICAgICAgICAgIGZvbnRTaXplOiBbLjcwNywgMS40NF1cbiAgICAgICAgfSlcbiAgICB9O1xuICAgIHJldHVybiBTYWZlO1xufSgpKTtcbmV4cG9ydHMuU2FmZSA9IFNhZmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zYWZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sb29rdXAgPSBleHBvcnRzLnNlcGFyYXRlT3B0aW9ucyA9IGV4cG9ydHMuc2VsZWN0T3B0aW9uc0Zyb21LZXlzID0gZXhwb3J0cy5zZWxlY3RPcHRpb25zID0gZXhwb3J0cy51c2VyT3B0aW9ucyA9IGV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBleHBvcnRzLmluc2VydCA9IGV4cG9ydHMuY29weSA9IGV4cG9ydHMua2V5cyA9IGV4cG9ydHMubWFrZUFycmF5ID0gZXhwb3J0cy5leHBhbmRhYmxlID0gZXhwb3J0cy5FeHBhbmRhYmxlID0gZXhwb3J0cy5PUFRJT05TID0gZXhwb3J0cy5SRU1PVkUgPSBleHBvcnRzLkFQUEVORCA9IGV4cG9ydHMuaXNPYmplY3QgPSB2b2lkIDA7XG52YXIgT0JKRUNUID0ge30uY29uc3RydWN0b3I7XG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsICYmXG4gICAgICAgIChvYmouY29uc3RydWN0b3IgPT09IE9CSkVDVCB8fCBvYmouY29uc3RydWN0b3IgPT09IEV4cGFuZGFibGUpO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5BUFBFTkQgPSAnWytdJztcbmV4cG9ydHMuUkVNT1ZFID0gJ1stXSc7XG5leHBvcnRzLk9QVElPTlMgPSB7XG4gICAgaW52YWxpZE9wdGlvbjogJ3dhcm4nLFxuICAgIG9wdGlvbkVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSwgX2tleSkge1xuICAgICAgICBpZiAoZXhwb3J0cy5PUFRJT05TLmludmFsaWRPcHRpb24gPT09ICdmYXRhbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oJ01hdGhKYXg6ICcgKyBtZXNzYWdlKTtcbiAgICB9XG59O1xudmFyIEV4cGFuZGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV4cGFuZGFibGUoKSB7XG4gICAgfVxuICAgIHJldHVybiBFeHBhbmRhYmxlO1xufSgpKTtcbmV4cG9ydHMuRXhwYW5kYWJsZSA9IEV4cGFuZGFibGU7XG5mdW5jdGlvbiBleHBhbmRhYmxlKGRlZikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoRXhwYW5kYWJsZS5wcm90b3R5cGUpLCBkZWYpO1xufVxuZXhwb3J0cy5leHBhbmRhYmxlID0gZXhwYW5kYWJsZTtcbmZ1bmN0aW9uIG1ha2VBcnJheSh4KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoeCkgPyB4IDogW3hdO1xufVxuZXhwb3J0cy5tYWtlQXJyYXkgPSBtYWtlQXJyYXk7XG5mdW5jdGlvbiBrZXlzKGRlZikge1xuICAgIGlmICghZGVmKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGRlZikuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZGVmKSk7XG59XG5leHBvcnRzLmtleXMgPSBrZXlzO1xuZnVuY3Rpb24gY29weShkZWYpIHtcbiAgICB2YXIgZV8xLCBfYTtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGtleXMoZGVmKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBwcm9wID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWYsIGtleSk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcHJvcC52YWx1ZSA9IGluc2VydChbXSwgdmFsdWUsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHByb3AudmFsdWUgPSBjb3B5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wLmVudW1lcmFibGUpIHtcbiAgICAgICAgICAgICAgICBwcm9wc1trZXldID0gcHJvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRlZi5jb25zdHJ1Y3RvciA9PT0gRXhwYW5kYWJsZSA/IGV4cGFuZGFibGUoe30pIDoge30sIHByb3BzKTtcbn1cbmV4cG9ydHMuY29weSA9IGNvcHk7XG5mdW5jdGlvbiBpbnNlcnQoZHN0LCBzcmMsIHdhcm4pIHtcbiAgICB2YXIgZV8yLCBfYTtcbiAgICBpZiAod2FybiA9PT0gdm9pZCAwKSB7IHdhcm4gPSB0cnVlOyB9XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICh3YXJuICYmIGRzdFtrZXldID09PSB1bmRlZmluZWQgJiYgZHN0LmNvbnN0cnVjdG9yICE9PSBFeHBhbmRhYmxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9ydHMuT1BUSU9OUy5vcHRpb25FcnJvcihcIkludmFsaWQgb3B0aW9uIFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCIgKG5vIGRlZmF1bHQgdmFsdWUpLlwiKSwga2V5KTtcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN2YWwgPSBzcmNba2V5XSwgZHZhbCA9IGRzdFtrZXldO1xuICAgICAgICBpZiAoaXNPYmplY3Qoc3ZhbCkgJiYgZHZhbCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgKHR5cGVvZiBkdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgZHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIHZhciBpZHMgPSBrZXlzKHN2YWwpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZHZhbCkgJiZcbiAgICAgICAgICAgICAgICAoKGlkcy5sZW5ndGggPT09IDEgJiYgKGlkc1swXSA9PT0gZXhwb3J0cy5BUFBFTkQgfHwgaWRzWzBdID09PSBleHBvcnRzLlJFTU9WRSkgJiYgQXJyYXkuaXNBcnJheShzdmFsW2lkc1swXV0pKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaWRzLmxlbmd0aCA9PT0gMiAmJiBpZHMuc29ydCgpLmpvaW4oJywnKSA9PT0gZXhwb3J0cy5BUFBFTkQgKyAnLCcgKyBleHBvcnRzLlJFTU9WRSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShzdmFsW2V4cG9ydHMuQVBQRU5EXSkgJiYgQXJyYXkuaXNBcnJheShzdmFsW2V4cG9ydHMuUkVNT1ZFXSkpKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdmFsW2V4cG9ydHMuUkVNT1ZFXSkge1xuICAgICAgICAgICAgICAgICAgICBkdmFsID0gZHN0W2tleV0gPSBkdmFsLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gc3ZhbFtleHBvcnRzLlJFTU9WRV0uaW5kZXhPZih4KSA8IDA7IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ZhbFtleHBvcnRzLkFQUEVORF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZHN0W2tleV0gPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChkdmFsKSwgZmFsc2UpLCBfX3JlYWQoc3ZhbFtleHBvcnRzLkFQUEVORF0pLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0KGR2YWwsIHN2YWwsIHdhcm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3ZhbCkpIHtcbiAgICAgICAgICAgIGRzdFtrZXldID0gW107XG4gICAgICAgICAgICBpbnNlcnQoZHN0W2tleV0sIHN2YWwsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc09iamVjdChzdmFsKSkge1xuICAgICAgICAgICAgZHN0W2tleV0gPSBjb3B5KHN2YWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHN0W2tleV0gPSBzdmFsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGtleXMoc3JjKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgIF9sb29wXzEoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbmV4cG9ydHMuaW5zZXJ0ID0gaW5zZXJ0O1xuZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBkZWZzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZGVmc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChkZWYpIHsgcmV0dXJuIGluc2VydChvcHRpb25zLCBkZWYsIGZhbHNlKTsgfSk7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG59XG5leHBvcnRzLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG5mdW5jdGlvbiB1c2VyT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIGRlZnMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBkZWZzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBkZWZzLmZvckVhY2goZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gaW5zZXJ0KG9wdGlvbnMsIGRlZiwgdHJ1ZSk7IH0pO1xuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy51c2VyT3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuZnVuY3Rpb24gc2VsZWN0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIGVfMywgX2E7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBrZXlzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgc3Vic2V0ID0ge307XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIga2V5c18xID0gX192YWx1ZXMoa2V5cyksIGtleXNfMV8xID0ga2V5c18xLm5leHQoKTsgIWtleXNfMV8xLmRvbmU7IGtleXNfMV8xID0ga2V5c18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHN1YnNldFtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoa2V5c18xXzEgJiYgIWtleXNfMV8xLmRvbmUgJiYgKF9hID0ga2V5c18xLnJldHVybikpIF9hLmNhbGwoa2V5c18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBzdWJzZXQ7XG59XG5leHBvcnRzLnNlbGVjdE9wdGlvbnMgPSBzZWxlY3RPcHRpb25zO1xuZnVuY3Rpb24gc2VsZWN0T3B0aW9uc0Zyb21LZXlzKG9wdGlvbnMsIG9iamVjdCkge1xuICAgIHJldHVybiBzZWxlY3RPcHRpb25zLmFwcGx5KHZvaWQgMCwgX19zcHJlYWRBcnJheShbb3B0aW9uc10sIF9fcmVhZChPYmplY3Qua2V5cyhvYmplY3QpKSwgZmFsc2UpKTtcbn1cbmV4cG9ydHMuc2VsZWN0T3B0aW9uc0Zyb21LZXlzID0gc2VsZWN0T3B0aW9uc0Zyb21LZXlzO1xuZnVuY3Rpb24gc2VwYXJhdGVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICB2YXIgZV80LCBfYSwgZV81LCBfYjtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9iamVjdHNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgb2JqZWN0c18xID0gX192YWx1ZXMob2JqZWN0cyksIG9iamVjdHNfMV8xID0gb2JqZWN0c18xLm5leHQoKTsgIW9iamVjdHNfMV8xLmRvbmU7IG9iamVjdHNfMV8xID0gb2JqZWN0c18xLm5leHQoKSkge1xuICAgICAgICAgICAgdmFyIG9iamVjdCA9IG9iamVjdHNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgdmFyIGV4aXN0cyA9IHt9LCBtaXNzaW5nID0ge307XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9jID0gKGVfNSA9IHZvaWQgMCwgX192YWx1ZXMoT2JqZWN0LmtleXMob3B0aW9ucyB8fCB7fSkpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIChvYmplY3Rba2V5XSA9PT0gdW5kZWZpbmVkID8gbWlzc2luZyA6IGV4aXN0cylba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYiA9IF9jLnJldHVybikpIF9iLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goZXhpc3RzKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBtaXNzaW5nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0c18xXzEgJiYgIW9iamVjdHNfMV8xLmRvbmUgJiYgKF9hID0gb2JqZWN0c18xLnJldHVybikpIF9hLmNhbGwob2JqZWN0c18xKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgfVxuICAgIHJlc3VsdHMudW5zaGlmdChvcHRpb25zKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn1cbmV4cG9ydHMuc2VwYXJhdGVPcHRpb25zID0gc2VwYXJhdGVPcHRpb25zO1xuZnVuY3Rpb24gbG9va3VwKG5hbWUsIGxvb2t1cCwgZGVmKSB7XG4gICAgaWYgKGRlZiA9PT0gdm9pZCAwKSB7IGRlZiA9IG51bGw7IH1cbiAgICByZXR1cm4gKGxvb2t1cC5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IGxvb2t1cFtuYW1lXSA6IGRlZik7XG59XG5leHBvcnRzLmxvb2t1cCA9IGxvb2t1cDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9wdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnB4ID0gZXhwb3J0cy5lbVJvdW5kZWQgPSBleHBvcnRzLmVtID0gZXhwb3J0cy5wZXJjZW50ID0gZXhwb3J0cy5sZW5ndGgyZW0gPSBleHBvcnRzLk1BVEhTUEFDRSA9IGV4cG9ydHMuUkVMVU5JVFMgPSBleHBvcnRzLlVOSVRTID0gZXhwb3J0cy5CSUdESU1FTiA9IHZvaWQgMDtcbmV4cG9ydHMuQklHRElNRU4gPSAxMDAwMDAwO1xuZXhwb3J0cy5VTklUUyA9IHtcbiAgICBweDogMSxcbiAgICAnaW4nOiA5NixcbiAgICBjbTogOTYgLyAyLjU0LFxuICAgIG1tOiA5NiAvIDI1LjRcbn07XG5leHBvcnRzLlJFTFVOSVRTID0ge1xuICAgIGVtOiAxLFxuICAgIGV4OiAuNDMxLFxuICAgIHB0OiAxIC8gMTAsXG4gICAgcGM6IDEyIC8gMTAsXG4gICAgbXU6IDEgLyAxOFxufTtcbmV4cG9ydHMuTUFUSFNQQUNFID0ge1xuICAgIHZlcnl2ZXJ5dGhpbm1hdGhzcGFjZTogMSAvIDE4LFxuICAgIHZlcnl0aGlubWF0aHNwYWNlOiAyIC8gMTgsXG4gICAgdGhpbm1hdGhzcGFjZTogMyAvIDE4LFxuICAgIG1lZGl1bW1hdGhzcGFjZTogNCAvIDE4LFxuICAgIHRoaWNrbWF0aHNwYWNlOiA1IC8gMTgsXG4gICAgdmVyeXRoaWNrbWF0aHNwYWNlOiA2IC8gMTgsXG4gICAgdmVyeXZlcnl0aGlja21hdGhzcGFjZTogNyAvIDE4LFxuICAgIG5lZ2F0aXZldmVyeXZlcnl0aGlubWF0aHNwYWNlOiAtMSAvIDE4LFxuICAgIG5lZ2F0aXZldmVyeXRoaW5tYXRoc3BhY2U6IC0yIC8gMTgsXG4gICAgbmVnYXRpdmV0aGlubWF0aHNwYWNlOiAtMyAvIDE4LFxuICAgIG5lZ2F0aXZlbWVkaXVtbWF0aHNwYWNlOiAtNCAvIDE4LFxuICAgIG5lZ2F0aXZldGhpY2ttYXRoc3BhY2U6IC01IC8gMTgsXG4gICAgbmVnYXRpdmV2ZXJ5dGhpY2ttYXRoc3BhY2U6IC02IC8gMTgsXG4gICAgbmVnYXRpdmV2ZXJ5dmVyeXRoaWNrbWF0aHNwYWNlOiAtNyAvIDE4LFxuICAgIHRoaW46IC4wNCxcbiAgICBtZWRpdW06IC4wNixcbiAgICB0aGljazogLjEsXG4gICAgbm9ybWFsOiAxLFxuICAgIGJpZzogMixcbiAgICBzbWFsbDogMSAvIE1hdGguc3FydCgyKSxcbiAgICBpbmZpbml0eTogZXhwb3J0cy5CSUdESU1FTlxufTtcbmZ1bmN0aW9uIGxlbmd0aDJlbShsZW5ndGgsIHNpemUsIHNjYWxlLCBlbSkge1xuICAgIGlmIChzaXplID09PSB2b2lkIDApIHsgc2l6ZSA9IDA7IH1cbiAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDE7IH1cbiAgICBpZiAoZW0gPT09IHZvaWQgMCkgeyBlbSA9IDE2OyB9XG4gICAgaWYgKHR5cGVvZiBsZW5ndGggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxlbmd0aCA9IFN0cmluZyhsZW5ndGgpO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoID09PSAnJyB8fCBsZW5ndGggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuTUFUSFNQQUNFW2xlbmd0aF0pIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTUFUSFNQQUNFW2xlbmd0aF07XG4gICAgfVxuICAgIHZhciBtYXRjaCA9IGxlbmd0aC5tYXRjaCgvXlxccyooWy0rXT8oPzpcXC5cXGQrfFxcZCsoPzpcXC5cXGQqKT8pKT8ocHR8ZW18ZXh8bXV8cHh8cGN8aW58bW18Y218JSk/Lyk7XG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgdmFyIG0gPSBwYXJzZUZsb2F0KG1hdGNoWzFdIHx8ICcxJyksIHVuaXQgPSBtYXRjaFsyXTtcbiAgICBpZiAoZXhwb3J0cy5VTklUUy5oYXNPd25Qcm9wZXJ0eSh1bml0KSkge1xuICAgICAgICByZXR1cm4gbSAqIGV4cG9ydHMuVU5JVFNbdW5pdF0gLyBlbSAvIHNjYWxlO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5SRUxVTklUUy5oYXNPd25Qcm9wZXJ0eSh1bml0KSkge1xuICAgICAgICByZXR1cm4gbSAqIGV4cG9ydHMuUkVMVU5JVFNbdW5pdF07XG4gICAgfVxuICAgIGlmICh1bml0ID09PSAnJScpIHtcbiAgICAgICAgcmV0dXJuIG0gLyAxMDAgKiBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gbSAqIHNpemU7XG59XG5leHBvcnRzLmxlbmd0aDJlbSA9IGxlbmd0aDJlbTtcbmZ1bmN0aW9uIHBlcmNlbnQobSkge1xuICAgIHJldHVybiAoMTAwICogbSkudG9GaXhlZCgxKS5yZXBsYWNlKC9cXC4/MCskLywgJycpICsgJyUnO1xufVxuZXhwb3J0cy5wZXJjZW50ID0gcGVyY2VudDtcbmZ1bmN0aW9uIGVtKG0pIHtcbiAgICBpZiAoTWF0aC5hYnMobSkgPCAuMDAxKVxuICAgICAgICByZXR1cm4gJzAnO1xuICAgIHJldHVybiAobS50b0ZpeGVkKDMpLnJlcGxhY2UoL1xcLj8wKyQvLCAnJykpICsgJ2VtJztcbn1cbmV4cG9ydHMuZW0gPSBlbTtcbmZ1bmN0aW9uIGVtUm91bmRlZChtLCBlbSkge1xuICAgIGlmIChlbSA9PT0gdm9pZCAwKSB7IGVtID0gMTY7IH1cbiAgICBtID0gKE1hdGgucm91bmQobSAqIGVtKSArIC4wNSkgLyBlbTtcbiAgICBpZiAoTWF0aC5hYnMobSkgPCAuMDAxKVxuICAgICAgICByZXR1cm4gJzBlbSc7XG4gICAgcmV0dXJuIG0udG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpICsgJ2VtJztcbn1cbmV4cG9ydHMuZW1Sb3VuZGVkID0gZW1Sb3VuZGVkO1xuZnVuY3Rpb24gcHgobSwgTSwgZW0pIHtcbiAgICBpZiAoTSA9PT0gdm9pZCAwKSB7IE0gPSAtZXhwb3J0cy5CSUdESU1FTjsgfVxuICAgIGlmIChlbSA9PT0gdm9pZCAwKSB7IGVtID0gMTY7IH1cbiAgICBtICo9IGVtO1xuICAgIGlmIChNICYmIG0gPCBNKVxuICAgICAgICBtID0gTTtcbiAgICBpZiAoTWF0aC5hYnMobSkgPCAuMSlcbiAgICAgICAgcmV0dXJuICcwJztcbiAgICByZXR1cm4gbS50b0ZpeGVkKDEpLnJlcGxhY2UoL1xcLjAkLywgJycpICsgJ3B4Jztcbn1cbmV4cG9ydHMucHggPSBweDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxlbmd0aHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9