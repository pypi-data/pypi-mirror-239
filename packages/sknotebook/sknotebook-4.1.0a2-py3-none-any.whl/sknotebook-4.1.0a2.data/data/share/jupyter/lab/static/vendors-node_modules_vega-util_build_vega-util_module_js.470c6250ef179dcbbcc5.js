"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_vega-util_build_vega-util_module_js"],{

/***/ "../node_modules/vega-util/build/vega-util.module.js":
/*!***********************************************************!*\
  !*** ../node_modules/vega-util/build/vega-util.module.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Debug": () => (/* binding */ Debug),
/* harmony export */   "Error": () => (/* binding */ Error$1),
/* harmony export */   "Info": () => (/* binding */ Info),
/* harmony export */   "None": () => (/* binding */ None),
/* harmony export */   "Warn": () => (/* binding */ Warn),
/* harmony export */   "accessor": () => (/* binding */ accessor),
/* harmony export */   "accessorFields": () => (/* binding */ accessorFields),
/* harmony export */   "accessorName": () => (/* binding */ accessorName),
/* harmony export */   "array": () => (/* binding */ array),
/* harmony export */   "ascending": () => (/* binding */ ascending),
/* harmony export */   "clampRange": () => (/* binding */ clampRange),
/* harmony export */   "compare": () => (/* binding */ compare),
/* harmony export */   "constant": () => (/* binding */ constant),
/* harmony export */   "debounce": () => (/* binding */ debounce),
/* harmony export */   "error": () => (/* binding */ error),
/* harmony export */   "extend": () => (/* binding */ extend),
/* harmony export */   "extent": () => (/* binding */ extent),
/* harmony export */   "extentIndex": () => (/* binding */ extentIndex),
/* harmony export */   "falsy": () => (/* binding */ falsy),
/* harmony export */   "fastmap": () => (/* binding */ fastmap),
/* harmony export */   "field": () => (/* binding */ field),
/* harmony export */   "flush": () => (/* binding */ flush),
/* harmony export */   "hasOwnProperty": () => (/* binding */ has),
/* harmony export */   "id": () => (/* binding */ id),
/* harmony export */   "identity": () => (/* binding */ identity),
/* harmony export */   "inherits": () => (/* binding */ inherits),
/* harmony export */   "inrange": () => (/* binding */ inrange),
/* harmony export */   "isArray": () => (/* binding */ isArray),
/* harmony export */   "isBoolean": () => (/* binding */ isBoolean),
/* harmony export */   "isDate": () => (/* binding */ isDate),
/* harmony export */   "isFunction": () => (/* binding */ isFunction),
/* harmony export */   "isIterable": () => (/* binding */ isIterable),
/* harmony export */   "isNumber": () => (/* binding */ isNumber),
/* harmony export */   "isObject": () => (/* binding */ isObject),
/* harmony export */   "isRegExp": () => (/* binding */ isRegExp),
/* harmony export */   "isString": () => (/* binding */ isString),
/* harmony export */   "key": () => (/* binding */ key),
/* harmony export */   "lerp": () => (/* binding */ lerp),
/* harmony export */   "logger": () => (/* binding */ logger),
/* harmony export */   "lruCache": () => (/* binding */ lruCache),
/* harmony export */   "merge": () => (/* binding */ merge),
/* harmony export */   "mergeConfig": () => (/* binding */ mergeConfig),
/* harmony export */   "one": () => (/* binding */ one),
/* harmony export */   "pad": () => (/* binding */ pad),
/* harmony export */   "panLinear": () => (/* binding */ panLinear),
/* harmony export */   "panLog": () => (/* binding */ panLog),
/* harmony export */   "panPow": () => (/* binding */ panPow),
/* harmony export */   "panSymlog": () => (/* binding */ panSymlog),
/* harmony export */   "peek": () => (/* binding */ peek),
/* harmony export */   "quarter": () => (/* binding */ quarter),
/* harmony export */   "repeat": () => (/* binding */ repeat),
/* harmony export */   "span": () => (/* binding */ span),
/* harmony export */   "splitAccessPath": () => (/* binding */ splitAccessPath),
/* harmony export */   "stringValue": () => (/* binding */ $),
/* harmony export */   "toBoolean": () => (/* binding */ toBoolean),
/* harmony export */   "toDate": () => (/* binding */ toDate),
/* harmony export */   "toNumber": () => (/* binding */ toNumber),
/* harmony export */   "toSet": () => (/* binding */ toSet),
/* harmony export */   "toString": () => (/* binding */ toString),
/* harmony export */   "truncate": () => (/* binding */ truncate),
/* harmony export */   "truthy": () => (/* binding */ truthy),
/* harmony export */   "utcquarter": () => (/* binding */ utcquarter),
/* harmony export */   "visitArray": () => (/* binding */ visitArray),
/* harmony export */   "writeConfig": () => (/* binding */ writeConfig),
/* harmony export */   "zero": () => (/* binding */ zero),
/* harmony export */   "zoomLinear": () => (/* binding */ zoomLinear),
/* harmony export */   "zoomLog": () => (/* binding */ zoomLog),
/* harmony export */   "zoomPow": () => (/* binding */ zoomPow),
/* harmony export */   "zoomSymlog": () => (/* binding */ zoomSymlog)
/* harmony export */ });
function accessor (fn, fields, name) {
  fn.fields = fields || [];
  fn.fname = name;
  return fn;
}
function accessorName(fn) {
  return fn == null ? null : fn.fname;
}
function accessorFields(fn) {
  return fn == null ? null : fn.fields;
}

function getter (path) {
  return path.length === 1 ? get1(path[0]) : getN(path);
}
const get1 = field => function (obj) {
  return obj[field];
};
const getN = path => {
  const len = path.length;
  return function (obj) {
    for (let i = 0; i < len; ++i) {
      obj = obj[path[i]];
    }
    return obj;
  };
};

function error (message) {
  throw Error(message);
}

function splitAccessPath (p) {
  const path = [],
    n = p.length;
  let q = null,
    b = 0,
    s = '',
    i,
    j,
    c;
  p = p + '';
  function push() {
    path.push(s + p.substring(i, j));
    s = '';
    i = j + 1;
  }
  for (i = j = 0; j < n; ++j) {
    c = p[j];
    if (c === '\\') {
      s += p.substring(i, j);
      s += p.substring(++j, ++j);
      i = j;
    } else if (c === q) {
      push();
      q = null;
      b = -1;
    } else if (q) {
      continue;
    } else if (i === b && c === '"') {
      i = j + 1;
      q = c;
    } else if (i === b && c === "'") {
      i = j + 1;
      q = c;
    } else if (c === '.' && !b) {
      if (j > i) {
        push();
      } else {
        i = j + 1;
      }
    } else if (c === '[') {
      if (j > i) push();
      b = i = j + 1;
    } else if (c === ']') {
      if (!b) error('Access path missing open bracket: ' + p);
      if (b > 0) push();
      b = 0;
      i = j + 1;
    }
  }
  if (b) error('Access path missing closing bracket: ' + p);
  if (q) error('Access path missing closing quote: ' + p);
  if (j > i) {
    j++;
    push();
  }
  return path;
}

function field (field, name, opt) {
  const path = splitAccessPath(field);
  field = path.length === 1 ? path[0] : field;
  return accessor((opt && opt.get || getter)(path), [field], name || field);
}

const id = field('id');
const identity = accessor(_ => _, [], 'identity');
const zero = accessor(() => 0, [], 'zero');
const one = accessor(() => 1, [], 'one');
const truthy = accessor(() => true, [], 'true');
const falsy = accessor(() => false, [], 'false');

function log$1(method, level, input) {
  const args = [level].concat([].slice.call(input));
  console[method].apply(console, args); // eslint-disable-line no-console
}

const None = 0;
const Error$1 = 1;
const Warn = 2;
const Info = 3;
const Debug = 4;
function logger (_, method) {
  let handler = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : log$1;
  let level = _ || None;
  return {
    level(_) {
      if (arguments.length) {
        level = +_;
        return this;
      } else {
        return level;
      }
    },
    error() {
      if (level >= Error$1) handler(method || 'error', 'ERROR', arguments);
      return this;
    },
    warn() {
      if (level >= Warn) handler(method || 'warn', 'WARN', arguments);
      return this;
    },
    info() {
      if (level >= Info) handler(method || 'log', 'INFO', arguments);
      return this;
    },
    debug() {
      if (level >= Debug) handler(method || 'log', 'DEBUG', arguments);
      return this;
    }
  };
}

var isArray = Array.isArray;

function isObject (_) {
  return _ === Object(_);
}

const isLegalKey = key => key !== '__proto__';
function mergeConfig() {
  for (var _len = arguments.length, configs = new Array(_len), _key = 0; _key < _len; _key++) {
    configs[_key] = arguments[_key];
  }
  return configs.reduce((out, source) => {
    for (const key in source) {
      if (key === 'signals') {
        // for signals, we merge the signals arrays
        // source signals take precedence over
        // existing signals with the same name
        out.signals = mergeNamed(out.signals, source.signals);
      } else {
        // otherwise, merge objects subject to recursion constraints
        // for legend block, recurse for the layout entry only
        // for style block, recurse for all properties
        // otherwise, no recursion: objects overwrite, no merging
        const r = key === 'legend' ? {
          layout: 1
        } : key === 'style' ? true : null;
        writeConfig(out, key, source[key], r);
      }
    }
    return out;
  }, {});
}
function writeConfig(output, key, value, recurse) {
  if (!isLegalKey(key)) return;
  let k, o;
  if (isObject(value) && !isArray(value)) {
    o = isObject(output[key]) ? output[key] : output[key] = {};
    for (k in value) {
      if (recurse && (recurse === true || recurse[k])) {
        writeConfig(o, k, value[k]);
      } else if (isLegalKey(k)) {
        o[k] = value[k];
      }
    }
  } else {
    output[key] = value;
  }
}
function mergeNamed(a, b) {
  if (a == null) return b;
  const map = {},
    out = [];
  function add(_) {
    if (!map[_.name]) {
      map[_.name] = 1;
      out.push(_);
    }
  }
  b.forEach(add);
  a.forEach(add);
  return out;
}

function peek (array) {
  return array[array.length - 1];
}

function toNumber (_) {
  return _ == null || _ === '' ? null : +_;
}

const exp = sign => x => sign * Math.exp(x);
const log = sign => x => Math.log(sign * x);
const symlog = c => x => Math.sign(x) * Math.log1p(Math.abs(x / c));
const symexp = c => x => Math.sign(x) * Math.expm1(Math.abs(x)) * c;
const pow = exponent => x => x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
function pan(domain, delta, lift, ground) {
  const d0 = lift(domain[0]),
    d1 = lift(peek(domain)),
    dd = (d1 - d0) * delta;
  return [ground(d0 - dd), ground(d1 - dd)];
}
function panLinear(domain, delta) {
  return pan(domain, delta, toNumber, identity);
}
function panLog(domain, delta) {
  var sign = Math.sign(domain[0]);
  return pan(domain, delta, log(sign), exp(sign));
}
function panPow(domain, delta, exponent) {
  return pan(domain, delta, pow(exponent), pow(1 / exponent));
}
function panSymlog(domain, delta, constant) {
  return pan(domain, delta, symlog(constant), symexp(constant));
}
function zoom(domain, anchor, scale, lift, ground) {
  const d0 = lift(domain[0]),
    d1 = lift(peek(domain)),
    da = anchor != null ? lift(anchor) : (d0 + d1) / 2;
  return [ground(da + (d0 - da) * scale), ground(da + (d1 - da) * scale)];
}
function zoomLinear(domain, anchor, scale) {
  return zoom(domain, anchor, scale, toNumber, identity);
}
function zoomLog(domain, anchor, scale) {
  const sign = Math.sign(domain[0]);
  return zoom(domain, anchor, scale, log(sign), exp(sign));
}
function zoomPow(domain, anchor, scale, exponent) {
  return zoom(domain, anchor, scale, pow(exponent), pow(1 / exponent));
}
function zoomSymlog(domain, anchor, scale, constant) {
  return zoom(domain, anchor, scale, symlog(constant), symexp(constant));
}

function quarter(date) {
  return 1 + ~~(new Date(date).getMonth() / 3);
}
function utcquarter(date) {
  return 1 + ~~(new Date(date).getUTCMonth() / 3);
}

function array (_) {
  return _ != null ? isArray(_) ? _ : [_] : [];
}

/**
 * Span-preserving range clamp. If the span of the input range is less
 * than (max - min) and an endpoint exceeds either the min or max value,
 * the range is translated such that the span is preserved and one
 * endpoint touches the boundary of the min/max range.
 * If the span exceeds (max - min), the range [min, max] is returned.
 */
function clampRange (range, min, max) {
  let lo = range[0],
    hi = range[1],
    span;
  if (hi < lo) {
    span = hi;
    hi = lo;
    lo = span;
  }
  span = hi - lo;
  return span >= max - min ? [min, max] : [lo = Math.min(Math.max(lo, min), max - span), lo + span];
}

function isFunction (_) {
  return typeof _ === 'function';
}

const DESCENDING = 'descending';
function compare (fields, orders, opt) {
  opt = opt || {};
  orders = array(orders) || [];
  const ord = [],
    get = [],
    fmap = {},
    gen = opt.comparator || comparator;
  array(fields).forEach((f, i) => {
    if (f == null) return;
    ord.push(orders[i] === DESCENDING ? -1 : 1);
    get.push(f = isFunction(f) ? f : field(f, null, opt));
    (accessorFields(f) || []).forEach(_ => fmap[_] = 1);
  });
  return get.length === 0 ? null : accessor(gen(get, ord), Object.keys(fmap));
}
const ascending = (u, v) => (u < v || u == null) && v != null ? -1 : (u > v || v == null) && u != null ? 1 : (v = v instanceof Date ? +v : v, u = u instanceof Date ? +u : u) !== u && v === v ? -1 : v !== v && u === u ? 1 : 0;
const comparator = (fields, orders) => fields.length === 1 ? compare1(fields[0], orders[0]) : compareN(fields, orders, fields.length);
const compare1 = (field, order) => function (a, b) {
  return ascending(field(a), field(b)) * order;
};
const compareN = (fields, orders, n) => {
  orders.push(0); // pad zero for convenient lookup
  return function (a, b) {
    let f,
      c = 0,
      i = -1;
    while (c === 0 && ++i < n) {
      f = fields[i];
      c = ascending(f(a), f(b));
    }
    return c * orders[i];
  };
};

function constant (_) {
  return isFunction(_) ? _ : () => _;
}

function debounce (delay, handler) {
  let tid;
  return e => {
    if (tid) clearTimeout(tid);
    tid = setTimeout(() => (handler(e), tid = null), delay);
  };
}

function extend (_) {
  for (let x, k, i = 1, len = arguments.length; i < len; ++i) {
    x = arguments[i];
    for (k in x) {
      _[k] = x[k];
    }
  }
  return _;
}

/**
 * Return an array with minimum and maximum values, in the
 * form [min, max]. Ignores null, undefined, and NaN values.
 */
function extent (array, f) {
  let i = 0,
    n,
    v,
    min,
    max;
  if (array && (n = array.length)) {
    if (f == null) {
      // find first valid value
      for (v = array[i]; i < n && (v == null || v !== v); v = array[++i]);
      min = max = v;

      // visit all other values
      for (; i < n; ++i) {
        v = array[i];
        // skip null/undefined; NaN will fail all comparisons
        if (v != null) {
          if (v < min) min = v;
          if (v > max) max = v;
        }
      }
    } else {
      // find first valid value
      for (v = f(array[i]); i < n && (v == null || v !== v); v = f(array[++i]));
      min = max = v;

      // visit all other values
      for (; i < n; ++i) {
        v = f(array[i]);
        // skip null/undefined; NaN will fail all comparisons
        if (v != null) {
          if (v < min) min = v;
          if (v > max) max = v;
        }
      }
    }
  }
  return [min, max];
}

function extentIndex (array, f) {
  const n = array.length;
  let i = -1,
    a,
    b,
    c,
    u,
    v;
  if (f == null) {
    while (++i < n) {
      b = array[i];
      if (b != null && b >= b) {
        a = c = b;
        break;
      }
    }
    if (i === n) return [-1, -1];
    u = v = i;
    while (++i < n) {
      b = array[i];
      if (b != null) {
        if (a > b) {
          a = b;
          u = i;
        }
        if (c < b) {
          c = b;
          v = i;
        }
      }
    }
  } else {
    while (++i < n) {
      b = f(array[i], i, array);
      if (b != null && b >= b) {
        a = c = b;
        break;
      }
    }
    if (i === n) return [-1, -1];
    u = v = i;
    while (++i < n) {
      b = f(array[i], i, array);
      if (b != null) {
        if (a > b) {
          a = b;
          u = i;
        }
        if (c < b) {
          c = b;
          v = i;
        }
      }
    }
  }
  return [u, v];
}

const hop = Object.prototype.hasOwnProperty;
function has (object, property) {
  return hop.call(object, property);
}

const NULL = {};
function fastmap (input) {
  let obj = {},
    test;
  function has$1(key) {
    return has(obj, key) && obj[key] !== NULL;
  }
  const map = {
    size: 0,
    empty: 0,
    object: obj,
    has: has$1,
    get(key) {
      return has$1(key) ? obj[key] : undefined;
    },
    set(key, value) {
      if (!has$1(key)) {
        ++map.size;
        if (obj[key] === NULL) --map.empty;
      }
      obj[key] = value;
      return this;
    },
    delete(key) {
      if (has$1(key)) {
        --map.size;
        ++map.empty;
        obj[key] = NULL;
      }
      return this;
    },
    clear() {
      map.size = map.empty = 0;
      map.object = obj = {};
    },
    test(_) {
      if (arguments.length) {
        test = _;
        return map;
      } else {
        return test;
      }
    },
    clean() {
      const next = {};
      let size = 0;
      for (const key in obj) {
        const value = obj[key];
        if (value !== NULL && (!test || !test(value))) {
          next[key] = value;
          ++size;
        }
      }
      map.size = size;
      map.empty = 0;
      map.object = obj = next;
    }
  };
  if (input) Object.keys(input).forEach(key => {
    map.set(key, input[key]);
  });
  return map;
}

function flush (range, value, threshold, left, right, center) {
  if (!threshold && threshold !== 0) return center;
  const t = +threshold;
  let a = range[0],
    b = peek(range),
    l;

  // swap endpoints if range is reversed
  if (b < a) {
    l = a;
    a = b;
    b = l;
  }

  // compare value to endpoints
  l = Math.abs(value - a);
  const r = Math.abs(b - value);

  // adjust if value is within threshold distance of endpoint
  return l < r && l <= t ? left : r <= t ? right : center;
}

function inherits (child, parent, members) {
  const proto = child.prototype = Object.create(parent.prototype);
  Object.defineProperty(proto, 'constructor', {
    value: child,
    writable: true,
    enumerable: true,
    configurable: true
  });
  return extend(proto, members);
}

/**
 * Predicate that returns true if the value lies within the span
 * of the given range. The left and right flags control the use
 * of inclusive (true) or exclusive (false) comparisons.
 */
function inrange (value, range, left, right) {
  let r0 = range[0],
    r1 = range[range.length - 1],
    t;
  if (r0 > r1) {
    t = r0;
    r0 = r1;
    r1 = t;
  }
  left = left === undefined || left;
  right = right === undefined || right;
  return (left ? r0 <= value : r0 < value) && (right ? value <= r1 : value < r1);
}

function isBoolean (_) {
  return typeof _ === 'boolean';
}

function isDate (_) {
  return Object.prototype.toString.call(_) === '[object Date]';
}

function isIterable (_) {
  return _ && isFunction(_[Symbol.iterator]);
}

function isNumber (_) {
  return typeof _ === 'number';
}

function isRegExp (_) {
  return Object.prototype.toString.call(_) === '[object RegExp]';
}

function isString (_) {
  return typeof _ === 'string';
}

function key (fields, flat, opt) {
  if (fields) {
    fields = flat ? array(fields).map(f => f.replace(/\\(.)/g, '$1')) : array(fields);
  }
  const len = fields && fields.length,
    gen = opt && opt.get || getter,
    map = f => gen(flat ? [f] : splitAccessPath(f));
  let fn;
  if (!len) {
    fn = function () {
      return '';
    };
  } else if (len === 1) {
    const get = map(fields[0]);
    fn = function (_) {
      return '' + get(_);
    };
  } else {
    const get = fields.map(map);
    fn = function (_) {
      let s = '' + get[0](_),
        i = 0;
      while (++i < len) s += '|' + get[i](_);
      return s;
    };
  }
  return accessor(fn, fields, 'key');
}

function lerp (array, frac) {
  const lo = array[0],
    hi = peek(array),
    f = +frac;
  return !f ? lo : f === 1 ? hi : lo + f * (hi - lo);
}

const DEFAULT_MAX_SIZE = 10000;

// adapted from https://github.com/dominictarr/hashlru/ (MIT License)
function lruCache (maxsize) {
  maxsize = +maxsize || DEFAULT_MAX_SIZE;
  let curr, prev, size;
  const clear = () => {
    curr = {};
    prev = {};
    size = 0;
  };
  const update = (key, value) => {
    if (++size > maxsize) {
      prev = curr;
      curr = {};
      size = 1;
    }
    return curr[key] = value;
  };
  clear();
  return {
    clear,
    has: key => has(curr, key) || has(prev, key),
    get: key => has(curr, key) ? curr[key] : has(prev, key) ? update(key, prev[key]) : undefined,
    set: (key, value) => has(curr, key) ? curr[key] = value : update(key, value)
  };
}

function merge (compare, array0, array1, output) {
  const n0 = array0.length,
    n1 = array1.length;
  if (!n1) return array0;
  if (!n0) return array1;
  const merged = output || new array0.constructor(n0 + n1);
  let i0 = 0,
    i1 = 0,
    i = 0;
  for (; i0 < n0 && i1 < n1; ++i) {
    merged[i] = compare(array0[i0], array1[i1]) > 0 ? array1[i1++] : array0[i0++];
  }
  for (; i0 < n0; ++i0, ++i) {
    merged[i] = array0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    merged[i] = array1[i1];
  }
  return merged;
}

function repeat (str, reps) {
  let s = '';
  while (--reps >= 0) s += str;
  return s;
}

function pad (str, length, padchar, align) {
  const c = padchar || ' ',
    s = str + '',
    n = length - s.length;
  return n <= 0 ? s : align === 'left' ? repeat(c, n) + s : align === 'center' ? repeat(c, ~~(n / 2)) + s + repeat(c, Math.ceil(n / 2)) : s + repeat(c, n);
}

/**
 * Return the numerical span of an array: the difference between
 * the last and first values.
 */
function span (array) {
  return array && peek(array) - array[0] || 0;
}

function $(x) {
  return isArray(x) ? '[' + x.map($) + ']' : isObject(x) || isString(x) ?
  // Output valid JSON and JS source strings.
  // See http://timelessrepo.com/json-isnt-a-javascript-subset
  JSON.stringify(x).replace('\u2028', '\\u2028').replace('\u2029', '\\u2029') : x;
}

function toBoolean (_) {
  return _ == null || _ === '' ? null : !_ || _ === 'false' || _ === '0' ? false : !!_;
}

const defaultParser = _ => isNumber(_) ? _ : isDate(_) ? _ : Date.parse(_);
function toDate (_, parser) {
  parser = parser || defaultParser;
  return _ == null || _ === '' ? null : parser(_);
}

function toString (_) {
  return _ == null || _ === '' ? null : _ + '';
}

function toSet (_) {
  const s = {},
    n = _.length;
  for (let i = 0; i < n; ++i) s[_[i]] = true;
  return s;
}

function truncate (str, length, align, ellipsis) {
  const e = ellipsis != null ? ellipsis : '\u2026',
    s = str + '',
    n = s.length,
    l = Math.max(0, length - e.length);
  return n <= length ? s : align === 'left' ? e + s.slice(n - l) : align === 'center' ? s.slice(0, Math.ceil(l / 2)) + e + s.slice(n - ~~(l / 2)) : s.slice(0, l) + e;
}

function visitArray (array, filter, visitor) {
  if (array) {
    if (filter) {
      const n = array.length;
      for (let i = 0; i < n; ++i) {
        const t = filter(array[i]);
        if (t) visitor(t, i, array);
      }
    } else {
      array.forEach(visitor);
    }
  }
}




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdmVnYS11dGlsX2J1aWxkX3ZlZ2EtdXRpbF9tb2R1bGVfanMuNDcwYzYyNTBlZjE3OWRjYmJjYzUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUVBQXlFLGFBQWE7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELFNBQVM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUNBQWlDO0FBQzFEOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CO0FBQzdCO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFb3FCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy92ZWdhLXV0aWwvYnVpbGQvdmVnYS11dGlsLm1vZHVsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBhY2Nlc3NvciAoZm4sIGZpZWxkcywgbmFtZSkge1xuICBmbi5maWVsZHMgPSBmaWVsZHMgfHwgW107XG4gIGZuLmZuYW1lID0gbmFtZTtcbiAgcmV0dXJuIGZuO1xufVxuZnVuY3Rpb24gYWNjZXNzb3JOYW1lKGZuKSB7XG4gIHJldHVybiBmbiA9PSBudWxsID8gbnVsbCA6IGZuLmZuYW1lO1xufVxuZnVuY3Rpb24gYWNjZXNzb3JGaWVsZHMoZm4pIHtcbiAgcmV0dXJuIGZuID09IG51bGwgPyBudWxsIDogZm4uZmllbGRzO1xufVxuXG5mdW5jdGlvbiBnZXR0ZXIgKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGgubGVuZ3RoID09PSAxID8gZ2V0MShwYXRoWzBdKSA6IGdldE4ocGF0aCk7XG59XG5jb25zdCBnZXQxID0gZmllbGQgPT4gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqW2ZpZWxkXTtcbn07XG5jb25zdCBnZXROID0gcGF0aCA9PiB7XG4gIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIG9iaiA9IG9ialtwYXRoW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yIChtZXNzYWdlKSB7XG4gIHRocm93IEVycm9yKG1lc3NhZ2UpO1xufVxuXG5mdW5jdGlvbiBzcGxpdEFjY2Vzc1BhdGggKHApIHtcbiAgY29uc3QgcGF0aCA9IFtdLFxuICAgIG4gPSBwLmxlbmd0aDtcbiAgbGV0IHEgPSBudWxsLFxuICAgIGIgPSAwLFxuICAgIHMgPSAnJyxcbiAgICBpLFxuICAgIGosXG4gICAgYztcbiAgcCA9IHAgKyAnJztcbiAgZnVuY3Rpb24gcHVzaCgpIHtcbiAgICBwYXRoLnB1c2gocyArIHAuc3Vic3RyaW5nKGksIGopKTtcbiAgICBzID0gJyc7XG4gICAgaSA9IGogKyAxO1xuICB9XG4gIGZvciAoaSA9IGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgYyA9IHBbal07XG4gICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgcyArPSBwLnN1YnN0cmluZyhpLCBqKTtcbiAgICAgIHMgKz0gcC5zdWJzdHJpbmcoKytqLCArK2opO1xuICAgICAgaSA9IGo7XG4gICAgfSBlbHNlIGlmIChjID09PSBxKSB7XG4gICAgICBwdXNoKCk7XG4gICAgICBxID0gbnVsbDtcbiAgICAgIGIgPSAtMTtcbiAgICB9IGVsc2UgaWYgKHEpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoaSA9PT0gYiAmJiBjID09PSAnXCInKSB7XG4gICAgICBpID0gaiArIDE7XG4gICAgICBxID0gYztcbiAgICB9IGVsc2UgaWYgKGkgPT09IGIgJiYgYyA9PT0gXCInXCIpIHtcbiAgICAgIGkgPSBqICsgMTtcbiAgICAgIHEgPSBjO1xuICAgIH0gZWxzZSBpZiAoYyA9PT0gJy4nICYmICFiKSB7XG4gICAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgcHVzaCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IGogKyAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYyA9PT0gJ1snKSB7XG4gICAgICBpZiAoaiA+IGkpIHB1c2goKTtcbiAgICAgIGIgPSBpID0gaiArIDE7XG4gICAgfSBlbHNlIGlmIChjID09PSAnXScpIHtcbiAgICAgIGlmICghYikgZXJyb3IoJ0FjY2VzcyBwYXRoIG1pc3Npbmcgb3BlbiBicmFja2V0OiAnICsgcCk7XG4gICAgICBpZiAoYiA+IDApIHB1c2goKTtcbiAgICAgIGIgPSAwO1xuICAgICAgaSA9IGogKyAxO1xuICAgIH1cbiAgfVxuICBpZiAoYikgZXJyb3IoJ0FjY2VzcyBwYXRoIG1pc3NpbmcgY2xvc2luZyBicmFja2V0OiAnICsgcCk7XG4gIGlmIChxKSBlcnJvcignQWNjZXNzIHBhdGggbWlzc2luZyBjbG9zaW5nIHF1b3RlOiAnICsgcCk7XG4gIGlmIChqID4gaSkge1xuICAgIGorKztcbiAgICBwdXNoKCk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmZ1bmN0aW9uIGZpZWxkIChmaWVsZCwgbmFtZSwgb3B0KSB7XG4gIGNvbnN0IHBhdGggPSBzcGxpdEFjY2Vzc1BhdGgoZmllbGQpO1xuICBmaWVsZCA9IHBhdGgubGVuZ3RoID09PSAxID8gcGF0aFswXSA6IGZpZWxkO1xuICByZXR1cm4gYWNjZXNzb3IoKG9wdCAmJiBvcHQuZ2V0IHx8IGdldHRlcikocGF0aCksIFtmaWVsZF0sIG5hbWUgfHwgZmllbGQpO1xufVxuXG5jb25zdCBpZCA9IGZpZWxkKCdpZCcpO1xuY29uc3QgaWRlbnRpdHkgPSBhY2Nlc3NvcihfID0+IF8sIFtdLCAnaWRlbnRpdHknKTtcbmNvbnN0IHplcm8gPSBhY2Nlc3NvcigoKSA9PiAwLCBbXSwgJ3plcm8nKTtcbmNvbnN0IG9uZSA9IGFjY2Vzc29yKCgpID0+IDEsIFtdLCAnb25lJyk7XG5jb25zdCB0cnV0aHkgPSBhY2Nlc3NvcigoKSA9PiB0cnVlLCBbXSwgJ3RydWUnKTtcbmNvbnN0IGZhbHN5ID0gYWNjZXNzb3IoKCkgPT4gZmFsc2UsIFtdLCAnZmFsc2UnKTtcblxuZnVuY3Rpb24gbG9nJDEobWV0aG9kLCBsZXZlbCwgaW5wdXQpIHtcbiAgY29uc3QgYXJncyA9IFtsZXZlbF0uY29uY2F0KFtdLnNsaWNlLmNhbGwoaW5wdXQpKTtcbiAgY29uc29sZVttZXRob2RdLmFwcGx5KGNvbnNvbGUsIGFyZ3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbn1cblxuY29uc3QgTm9uZSA9IDA7XG5jb25zdCBFcnJvciQxID0gMTtcbmNvbnN0IFdhcm4gPSAyO1xuY29uc3QgSW5mbyA9IDM7XG5jb25zdCBEZWJ1ZyA9IDQ7XG5mdW5jdGlvbiBsb2dnZXIgKF8sIG1ldGhvZCkge1xuICBsZXQgaGFuZGxlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbG9nJDE7XG4gIGxldCBsZXZlbCA9IF8gfHwgTm9uZTtcbiAgcmV0dXJuIHtcbiAgICBsZXZlbChfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBsZXZlbCA9ICtfO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBsZXZlbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVycm9yKCkge1xuICAgICAgaWYgKGxldmVsID49IEVycm9yJDEpIGhhbmRsZXIobWV0aG9kIHx8ICdlcnJvcicsICdFUlJPUicsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHdhcm4oKSB7XG4gICAgICBpZiAobGV2ZWwgPj0gV2FybikgaGFuZGxlcihtZXRob2QgfHwgJ3dhcm4nLCAnV0FSTicsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGluZm8oKSB7XG4gICAgICBpZiAobGV2ZWwgPj0gSW5mbykgaGFuZGxlcihtZXRob2QgfHwgJ2xvZycsICdJTkZPJywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZGVidWcoKSB7XG4gICAgICBpZiAobGV2ZWwgPj0gRGVidWcpIGhhbmRsZXIobWV0aG9kIHx8ICdsb2cnLCAnREVCVUcnLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xufVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0IChfKSB7XG4gIHJldHVybiBfID09PSBPYmplY3QoXyk7XG59XG5cbmNvbnN0IGlzTGVnYWxLZXkgPSBrZXkgPT4ga2V5ICE9PSAnX19wcm90b19fJztcbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY29uZmlncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBjb25maWdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG4gIHJldHVybiBjb25maWdzLnJlZHVjZSgob3V0LCBzb3VyY2UpID0+IHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChrZXkgPT09ICdzaWduYWxzJykge1xuICAgICAgICAvLyBmb3Igc2lnbmFscywgd2UgbWVyZ2UgdGhlIHNpZ25hbHMgYXJyYXlzXG4gICAgICAgIC8vIHNvdXJjZSBzaWduYWxzIHRha2UgcHJlY2VkZW5jZSBvdmVyXG4gICAgICAgIC8vIGV4aXN0aW5nIHNpZ25hbHMgd2l0aCB0aGUgc2FtZSBuYW1lXG4gICAgICAgIG91dC5zaWduYWxzID0gbWVyZ2VOYW1lZChvdXQuc2lnbmFscywgc291cmNlLnNpZ25hbHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBtZXJnZSBvYmplY3RzIHN1YmplY3QgdG8gcmVjdXJzaW9uIGNvbnN0cmFpbnRzXG4gICAgICAgIC8vIGZvciBsZWdlbmQgYmxvY2ssIHJlY3Vyc2UgZm9yIHRoZSBsYXlvdXQgZW50cnkgb25seVxuICAgICAgICAvLyBmb3Igc3R5bGUgYmxvY2ssIHJlY3Vyc2UgZm9yIGFsbCBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIG90aGVyd2lzZSwgbm8gcmVjdXJzaW9uOiBvYmplY3RzIG92ZXJ3cml0ZSwgbm8gbWVyZ2luZ1xuICAgICAgICBjb25zdCByID0ga2V5ID09PSAnbGVnZW5kJyA/IHtcbiAgICAgICAgICBsYXlvdXQ6IDFcbiAgICAgICAgfSA6IGtleSA9PT0gJ3N0eWxlJyA/IHRydWUgOiBudWxsO1xuICAgICAgICB3cml0ZUNvbmZpZyhvdXQsIGtleSwgc291cmNlW2tleV0sIHIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiB3cml0ZUNvbmZpZyhvdXRwdXQsIGtleSwgdmFsdWUsIHJlY3Vyc2UpIHtcbiAgaWYgKCFpc0xlZ2FsS2V5KGtleSkpIHJldHVybjtcbiAgbGV0IGssIG87XG4gIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpKSB7XG4gICAgbyA9IGlzT2JqZWN0KG91dHB1dFtrZXldKSA/IG91dHB1dFtrZXldIDogb3V0cHV0W2tleV0gPSB7fTtcbiAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgIGlmIChyZWN1cnNlICYmIChyZWN1cnNlID09PSB0cnVlIHx8IHJlY3Vyc2Vba10pKSB7XG4gICAgICAgIHdyaXRlQ29uZmlnKG8sIGssIHZhbHVlW2tdKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMZWdhbEtleShrKSkge1xuICAgICAgICBvW2tdID0gdmFsdWVba107XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dHB1dFtrZXldID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lcmdlTmFtZWQoYSwgYikge1xuICBpZiAoYSA9PSBudWxsKSByZXR1cm4gYjtcbiAgY29uc3QgbWFwID0ge30sXG4gICAgb3V0ID0gW107XG4gIGZ1bmN0aW9uIGFkZChfKSB7XG4gICAgaWYgKCFtYXBbXy5uYW1lXSkge1xuICAgICAgbWFwW18ubmFtZV0gPSAxO1xuICAgICAgb3V0LnB1c2goXyk7XG4gICAgfVxuICB9XG4gIGIuZm9yRWFjaChhZGQpO1xuICBhLmZvckVhY2goYWRkKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcGVlayAoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xufVxuXG5mdW5jdGlvbiB0b051bWJlciAoXykge1xuICByZXR1cm4gXyA9PSBudWxsIHx8IF8gPT09ICcnID8gbnVsbCA6ICtfO1xufVxuXG5jb25zdCBleHAgPSBzaWduID0+IHggPT4gc2lnbiAqIE1hdGguZXhwKHgpO1xuY29uc3QgbG9nID0gc2lnbiA9PiB4ID0+IE1hdGgubG9nKHNpZ24gKiB4KTtcbmNvbnN0IHN5bWxvZyA9IGMgPT4geCA9PiBNYXRoLnNpZ24oeCkgKiBNYXRoLmxvZzFwKE1hdGguYWJzKHggLyBjKSk7XG5jb25zdCBzeW1leHAgPSBjID0+IHggPT4gTWF0aC5zaWduKHgpICogTWF0aC5leHBtMShNYXRoLmFicyh4KSkgKiBjO1xuY29uc3QgcG93ID0gZXhwb25lbnQgPT4geCA9PiB4IDwgMCA/IC1NYXRoLnBvdygteCwgZXhwb25lbnQpIDogTWF0aC5wb3coeCwgZXhwb25lbnQpO1xuZnVuY3Rpb24gcGFuKGRvbWFpbiwgZGVsdGEsIGxpZnQsIGdyb3VuZCkge1xuICBjb25zdCBkMCA9IGxpZnQoZG9tYWluWzBdKSxcbiAgICBkMSA9IGxpZnQocGVlayhkb21haW4pKSxcbiAgICBkZCA9IChkMSAtIGQwKSAqIGRlbHRhO1xuICByZXR1cm4gW2dyb3VuZChkMCAtIGRkKSwgZ3JvdW5kKGQxIC0gZGQpXTtcbn1cbmZ1bmN0aW9uIHBhbkxpbmVhcihkb21haW4sIGRlbHRhKSB7XG4gIHJldHVybiBwYW4oZG9tYWluLCBkZWx0YSwgdG9OdW1iZXIsIGlkZW50aXR5KTtcbn1cbmZ1bmN0aW9uIHBhbkxvZyhkb21haW4sIGRlbHRhKSB7XG4gIHZhciBzaWduID0gTWF0aC5zaWduKGRvbWFpblswXSk7XG4gIHJldHVybiBwYW4oZG9tYWluLCBkZWx0YSwgbG9nKHNpZ24pLCBleHAoc2lnbikpO1xufVxuZnVuY3Rpb24gcGFuUG93KGRvbWFpbiwgZGVsdGEsIGV4cG9uZW50KSB7XG4gIHJldHVybiBwYW4oZG9tYWluLCBkZWx0YSwgcG93KGV4cG9uZW50KSwgcG93KDEgLyBleHBvbmVudCkpO1xufVxuZnVuY3Rpb24gcGFuU3ltbG9nKGRvbWFpbiwgZGVsdGEsIGNvbnN0YW50KSB7XG4gIHJldHVybiBwYW4oZG9tYWluLCBkZWx0YSwgc3ltbG9nKGNvbnN0YW50KSwgc3ltZXhwKGNvbnN0YW50KSk7XG59XG5mdW5jdGlvbiB6b29tKGRvbWFpbiwgYW5jaG9yLCBzY2FsZSwgbGlmdCwgZ3JvdW5kKSB7XG4gIGNvbnN0IGQwID0gbGlmdChkb21haW5bMF0pLFxuICAgIGQxID0gbGlmdChwZWVrKGRvbWFpbikpLFxuICAgIGRhID0gYW5jaG9yICE9IG51bGwgPyBsaWZ0KGFuY2hvcikgOiAoZDAgKyBkMSkgLyAyO1xuICByZXR1cm4gW2dyb3VuZChkYSArIChkMCAtIGRhKSAqIHNjYWxlKSwgZ3JvdW5kKGRhICsgKGQxIC0gZGEpICogc2NhbGUpXTtcbn1cbmZ1bmN0aW9uIHpvb21MaW5lYXIoZG9tYWluLCBhbmNob3IsIHNjYWxlKSB7XG4gIHJldHVybiB6b29tKGRvbWFpbiwgYW5jaG9yLCBzY2FsZSwgdG9OdW1iZXIsIGlkZW50aXR5KTtcbn1cbmZ1bmN0aW9uIHpvb21Mb2coZG9tYWluLCBhbmNob3IsIHNjYWxlKSB7XG4gIGNvbnN0IHNpZ24gPSBNYXRoLnNpZ24oZG9tYWluWzBdKTtcbiAgcmV0dXJuIHpvb20oZG9tYWluLCBhbmNob3IsIHNjYWxlLCBsb2coc2lnbiksIGV4cChzaWduKSk7XG59XG5mdW5jdGlvbiB6b29tUG93KGRvbWFpbiwgYW5jaG9yLCBzY2FsZSwgZXhwb25lbnQpIHtcbiAgcmV0dXJuIHpvb20oZG9tYWluLCBhbmNob3IsIHNjYWxlLCBwb3coZXhwb25lbnQpLCBwb3coMSAvIGV4cG9uZW50KSk7XG59XG5mdW5jdGlvbiB6b29tU3ltbG9nKGRvbWFpbiwgYW5jaG9yLCBzY2FsZSwgY29uc3RhbnQpIHtcbiAgcmV0dXJuIHpvb20oZG9tYWluLCBhbmNob3IsIHNjYWxlLCBzeW1sb2coY29uc3RhbnQpLCBzeW1leHAoY29uc3RhbnQpKTtcbn1cblxuZnVuY3Rpb24gcXVhcnRlcihkYXRlKSB7XG4gIHJldHVybiAxICsgfn4obmV3IERhdGUoZGF0ZSkuZ2V0TW9udGgoKSAvIDMpO1xufVxuZnVuY3Rpb24gdXRjcXVhcnRlcihkYXRlKSB7XG4gIHJldHVybiAxICsgfn4obmV3IERhdGUoZGF0ZSkuZ2V0VVRDTW9udGgoKSAvIDMpO1xufVxuXG5mdW5jdGlvbiBhcnJheSAoXykge1xuICByZXR1cm4gXyAhPSBudWxsID8gaXNBcnJheShfKSA/IF8gOiBbX10gOiBbXTtcbn1cblxuLyoqXG4gKiBTcGFuLXByZXNlcnZpbmcgcmFuZ2UgY2xhbXAuIElmIHRoZSBzcGFuIG9mIHRoZSBpbnB1dCByYW5nZSBpcyBsZXNzXG4gKiB0aGFuIChtYXggLSBtaW4pIGFuZCBhbiBlbmRwb2ludCBleGNlZWRzIGVpdGhlciB0aGUgbWluIG9yIG1heCB2YWx1ZSxcbiAqIHRoZSByYW5nZSBpcyB0cmFuc2xhdGVkIHN1Y2ggdGhhdCB0aGUgc3BhbiBpcyBwcmVzZXJ2ZWQgYW5kIG9uZVxuICogZW5kcG9pbnQgdG91Y2hlcyB0aGUgYm91bmRhcnkgb2YgdGhlIG1pbi9tYXggcmFuZ2UuXG4gKiBJZiB0aGUgc3BhbiBleGNlZWRzIChtYXggLSBtaW4pLCB0aGUgcmFuZ2UgW21pbiwgbWF4XSBpcyByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gY2xhbXBSYW5nZSAocmFuZ2UsIG1pbiwgbWF4KSB7XG4gIGxldCBsbyA9IHJhbmdlWzBdLFxuICAgIGhpID0gcmFuZ2VbMV0sXG4gICAgc3BhbjtcbiAgaWYgKGhpIDwgbG8pIHtcbiAgICBzcGFuID0gaGk7XG4gICAgaGkgPSBsbztcbiAgICBsbyA9IHNwYW47XG4gIH1cbiAgc3BhbiA9IGhpIC0gbG87XG4gIHJldHVybiBzcGFuID49IG1heCAtIG1pbiA/IFttaW4sIG1heF0gOiBbbG8gPSBNYXRoLm1pbihNYXRoLm1heChsbywgbWluKSwgbWF4IC0gc3BhbiksIGxvICsgc3Bhbl07XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKF8pIHtcbiAgcmV0dXJuIHR5cGVvZiBfID09PSAnZnVuY3Rpb24nO1xufVxuXG5jb25zdCBERVNDRU5ESU5HID0gJ2Rlc2NlbmRpbmcnO1xuZnVuY3Rpb24gY29tcGFyZSAoZmllbGRzLCBvcmRlcnMsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIG9yZGVycyA9IGFycmF5KG9yZGVycykgfHwgW107XG4gIGNvbnN0IG9yZCA9IFtdLFxuICAgIGdldCA9IFtdLFxuICAgIGZtYXAgPSB7fSxcbiAgICBnZW4gPSBvcHQuY29tcGFyYXRvciB8fCBjb21wYXJhdG9yO1xuICBhcnJheShmaWVsZHMpLmZvckVhY2goKGYsIGkpID0+IHtcbiAgICBpZiAoZiA9PSBudWxsKSByZXR1cm47XG4gICAgb3JkLnB1c2gob3JkZXJzW2ldID09PSBERVNDRU5ESU5HID8gLTEgOiAxKTtcbiAgICBnZXQucHVzaChmID0gaXNGdW5jdGlvbihmKSA/IGYgOiBmaWVsZChmLCBudWxsLCBvcHQpKTtcbiAgICAoYWNjZXNzb3JGaWVsZHMoZikgfHwgW10pLmZvckVhY2goXyA9PiBmbWFwW19dID0gMSk7XG4gIH0pO1xuICByZXR1cm4gZ2V0Lmxlbmd0aCA9PT0gMCA/IG51bGwgOiBhY2Nlc3NvcihnZW4oZ2V0LCBvcmQpLCBPYmplY3Qua2V5cyhmbWFwKSk7XG59XG5jb25zdCBhc2NlbmRpbmcgPSAodSwgdikgPT4gKHUgPCB2IHx8IHUgPT0gbnVsbCkgJiYgdiAhPSBudWxsID8gLTEgOiAodSA+IHYgfHwgdiA9PSBudWxsKSAmJiB1ICE9IG51bGwgPyAxIDogKHYgPSB2IGluc3RhbmNlb2YgRGF0ZSA/ICt2IDogdiwgdSA9IHUgaW5zdGFuY2VvZiBEYXRlID8gK3UgOiB1KSAhPT0gdSAmJiB2ID09PSB2ID8gLTEgOiB2ICE9PSB2ICYmIHUgPT09IHUgPyAxIDogMDtcbmNvbnN0IGNvbXBhcmF0b3IgPSAoZmllbGRzLCBvcmRlcnMpID0+IGZpZWxkcy5sZW5ndGggPT09IDEgPyBjb21wYXJlMShmaWVsZHNbMF0sIG9yZGVyc1swXSkgOiBjb21wYXJlTihmaWVsZHMsIG9yZGVycywgZmllbGRzLmxlbmd0aCk7XG5jb25zdCBjb21wYXJlMSA9IChmaWVsZCwgb3JkZXIpID0+IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhc2NlbmRpbmcoZmllbGQoYSksIGZpZWxkKGIpKSAqIG9yZGVyO1xufTtcbmNvbnN0IGNvbXBhcmVOID0gKGZpZWxkcywgb3JkZXJzLCBuKSA9PiB7XG4gIG9yZGVycy5wdXNoKDApOyAvLyBwYWQgemVybyBmb3IgY29udmVuaWVudCBsb29rdXBcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgbGV0IGYsXG4gICAgICBjID0gMCxcbiAgICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoYyA9PT0gMCAmJiArK2kgPCBuKSB7XG4gICAgICBmID0gZmllbGRzW2ldO1xuICAgICAgYyA9IGFzY2VuZGluZyhmKGEpLCBmKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGMgKiBvcmRlcnNbaV07XG4gIH07XG59O1xuXG5mdW5jdGlvbiBjb25zdGFudCAoXykge1xuICByZXR1cm4gaXNGdW5jdGlvbihfKSA/IF8gOiAoKSA9PiBfO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZSAoZGVsYXksIGhhbmRsZXIpIHtcbiAgbGV0IHRpZDtcbiAgcmV0dXJuIGUgPT4ge1xuICAgIGlmICh0aWQpIGNsZWFyVGltZW91dCh0aWQpO1xuICAgIHRpZCA9IHNldFRpbWVvdXQoKCkgPT4gKGhhbmRsZXIoZSksIHRpZCA9IG51bGwpLCBkZWxheSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4dGVuZCAoXykge1xuICBmb3IgKGxldCB4LCBrLCBpID0gMSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgeCA9IGFyZ3VtZW50c1tpXTtcbiAgICBmb3IgKGsgaW4geCkge1xuICAgICAgX1trXSA9IHhba107XG4gICAgfVxuICB9XG4gIHJldHVybiBfO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSB3aXRoIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVzLCBpbiB0aGVcbiAqIGZvcm0gW21pbiwgbWF4XS4gSWdub3JlcyBudWxsLCB1bmRlZmluZWQsIGFuZCBOYU4gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBleHRlbnQgKGFycmF5LCBmKSB7XG4gIGxldCBpID0gMCxcbiAgICBuLFxuICAgIHYsXG4gICAgbWluLFxuICAgIG1heDtcbiAgaWYgKGFycmF5ICYmIChuID0gYXJyYXkubGVuZ3RoKSkge1xuICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgIC8vIGZpbmQgZmlyc3QgdmFsaWQgdmFsdWVcbiAgICAgIGZvciAodiA9IGFycmF5W2ldOyBpIDwgbiAmJiAodiA9PSBudWxsIHx8IHYgIT09IHYpOyB2ID0gYXJyYXlbKytpXSk7XG4gICAgICBtaW4gPSBtYXggPSB2O1xuXG4gICAgICAvLyB2aXNpdCBhbGwgb3RoZXIgdmFsdWVzXG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICB2ID0gYXJyYXlbaV07XG4gICAgICAgIC8vIHNraXAgbnVsbC91bmRlZmluZWQ7IE5hTiB3aWxsIGZhaWwgYWxsIGNvbXBhcmlzb25zXG4gICAgICAgIGlmICh2ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodiA8IG1pbikgbWluID0gdjtcbiAgICAgICAgICBpZiAodiA+IG1heCkgbWF4ID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmaW5kIGZpcnN0IHZhbGlkIHZhbHVlXG4gICAgICBmb3IgKHYgPSBmKGFycmF5W2ldKTsgaSA8IG4gJiYgKHYgPT0gbnVsbCB8fCB2ICE9PSB2KTsgdiA9IGYoYXJyYXlbKytpXSkpO1xuICAgICAgbWluID0gbWF4ID0gdjtcblxuICAgICAgLy8gdmlzaXQgYWxsIG90aGVyIHZhbHVlc1xuICAgICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdiA9IGYoYXJyYXlbaV0pO1xuICAgICAgICAvLyBza2lwIG51bGwvdW5kZWZpbmVkOyBOYU4gd2lsbCBmYWlsIGFsbCBjb21wYXJpc29uc1xuICAgICAgICBpZiAodiAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHYgPCBtaW4pIG1pbiA9IHY7XG4gICAgICAgICAgaWYgKHYgPiBtYXgpIG1heCA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbmZ1bmN0aW9uIGV4dGVudEluZGV4IChhcnJheSwgZikge1xuICBjb25zdCBuID0gYXJyYXkubGVuZ3RoO1xuICBsZXQgaSA9IC0xLFxuICAgIGEsXG4gICAgYixcbiAgICBjLFxuICAgIHUsXG4gICAgdjtcbiAgaWYgKGYgPT0gbnVsbCkge1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBiID0gYXJyYXlbaV07XG4gICAgICBpZiAoYiAhPSBudWxsICYmIGIgPj0gYikge1xuICAgICAgICBhID0gYyA9IGI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaSA9PT0gbikgcmV0dXJuIFstMSwgLTFdO1xuICAgIHUgPSB2ID0gaTtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYiA9IGFycmF5W2ldO1xuICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICBhID0gYjtcbiAgICAgICAgICB1ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IGIpIHtcbiAgICAgICAgICBjID0gYjtcbiAgICAgICAgICB2ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAgYiA9IGYoYXJyYXlbaV0sIGksIGFycmF5KTtcbiAgICAgIGlmIChiICE9IG51bGwgJiYgYiA+PSBiKSB7XG4gICAgICAgIGEgPSBjID0gYjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpID09PSBuKSByZXR1cm4gWy0xLCAtMV07XG4gICAgdSA9IHYgPSBpO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBiID0gZihhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYSA+IGIpIHtcbiAgICAgICAgICBhID0gYjtcbiAgICAgICAgICB1ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA8IGIpIHtcbiAgICAgICAgICBjID0gYjtcbiAgICAgICAgICB2ID0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gW3UsIHZdO1xufVxuXG5jb25zdCBob3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzIChvYmplY3QsIHByb3BlcnR5KSB7XG4gIHJldHVybiBob3AuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbn1cblxuY29uc3QgTlVMTCA9IHt9O1xuZnVuY3Rpb24gZmFzdG1hcCAoaW5wdXQpIHtcbiAgbGV0IG9iaiA9IHt9LFxuICAgIHRlc3Q7XG4gIGZ1bmN0aW9uIGhhcyQxKGtleSkge1xuICAgIHJldHVybiBoYXMob2JqLCBrZXkpICYmIG9ialtrZXldICE9PSBOVUxMO1xuICB9XG4gIGNvbnN0IG1hcCA9IHtcbiAgICBzaXplOiAwLFxuICAgIGVtcHR5OiAwLFxuICAgIG9iamVjdDogb2JqLFxuICAgIGhhczogaGFzJDEsXG4gICAgZ2V0KGtleSkge1xuICAgICAgcmV0dXJuIGhhcyQxKGtleSkgPyBvYmpba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIWhhcyQxKGtleSkpIHtcbiAgICAgICAgKyttYXAuc2l6ZTtcbiAgICAgICAgaWYgKG9ialtrZXldID09PSBOVUxMKSAtLW1hcC5lbXB0eTtcbiAgICAgIH1cbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgIGlmIChoYXMkMShrZXkpKSB7XG4gICAgICAgIC0tbWFwLnNpemU7XG4gICAgICAgICsrbWFwLmVtcHR5O1xuICAgICAgICBvYmpba2V5XSA9IE5VTEw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgbWFwLnNpemUgPSBtYXAuZW1wdHkgPSAwO1xuICAgICAgbWFwLm9iamVjdCA9IG9iaiA9IHt9O1xuICAgIH0sXG4gICAgdGVzdChfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0ZXN0ID0gXztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0ZXN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYW4oKSB7XG4gICAgICBjb25zdCBuZXh0ID0ge307XG4gICAgICBsZXQgc2l6ZSA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBOVUxMICYmICghdGVzdCB8fCAhdGVzdCh2YWx1ZSkpKSB7XG4gICAgICAgICAgbmV4dFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgKytzaXplO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBtYXAuc2l6ZSA9IHNpemU7XG4gICAgICBtYXAuZW1wdHkgPSAwO1xuICAgICAgbWFwLm9iamVjdCA9IG9iaiA9IG5leHQ7XG4gICAgfVxuICB9O1xuICBpZiAoaW5wdXQpIE9iamVjdC5rZXlzKGlucHV0KS5mb3JFYWNoKGtleSA9PiB7XG4gICAgbWFwLnNldChrZXksIGlucHV0W2tleV0pO1xuICB9KTtcbiAgcmV0dXJuIG1hcDtcbn1cblxuZnVuY3Rpb24gZmx1c2ggKHJhbmdlLCB2YWx1ZSwgdGhyZXNob2xkLCBsZWZ0LCByaWdodCwgY2VudGVyKSB7XG4gIGlmICghdGhyZXNob2xkICYmIHRocmVzaG9sZCAhPT0gMCkgcmV0dXJuIGNlbnRlcjtcbiAgY29uc3QgdCA9ICt0aHJlc2hvbGQ7XG4gIGxldCBhID0gcmFuZ2VbMF0sXG4gICAgYiA9IHBlZWsocmFuZ2UpLFxuICAgIGw7XG5cbiAgLy8gc3dhcCBlbmRwb2ludHMgaWYgcmFuZ2UgaXMgcmV2ZXJzZWRcbiAgaWYgKGIgPCBhKSB7XG4gICAgbCA9IGE7XG4gICAgYSA9IGI7XG4gICAgYiA9IGw7XG4gIH1cblxuICAvLyBjb21wYXJlIHZhbHVlIHRvIGVuZHBvaW50c1xuICBsID0gTWF0aC5hYnModmFsdWUgLSBhKTtcbiAgY29uc3QgciA9IE1hdGguYWJzKGIgLSB2YWx1ZSk7XG5cbiAgLy8gYWRqdXN0IGlmIHZhbHVlIGlzIHdpdGhpbiB0aHJlc2hvbGQgZGlzdGFuY2Ugb2YgZW5kcG9pbnRcbiAgcmV0dXJuIGwgPCByICYmIGwgPD0gdCA/IGxlZnQgOiByIDw9IHQgPyByaWdodCA6IGNlbnRlcjtcbn1cblxuZnVuY3Rpb24gaW5oZXJpdHMgKGNoaWxkLCBwYXJlbnQsIG1lbWJlcnMpIHtcbiAgY29uc3QgcHJvdG8gPSBjaGlsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHBhcmVudC5wcm90b3R5cGUpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdjb25zdHJ1Y3RvcicsIHtcbiAgICB2YWx1ZTogY2hpbGQsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBleHRlbmQocHJvdG8sIG1lbWJlcnMpO1xufVxuXG4vKipcbiAqIFByZWRpY2F0ZSB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgbGllcyB3aXRoaW4gdGhlIHNwYW5cbiAqIG9mIHRoZSBnaXZlbiByYW5nZS4gVGhlIGxlZnQgYW5kIHJpZ2h0IGZsYWdzIGNvbnRyb2wgdGhlIHVzZVxuICogb2YgaW5jbHVzaXZlICh0cnVlKSBvciBleGNsdXNpdmUgKGZhbHNlKSBjb21wYXJpc29ucy5cbiAqL1xuZnVuY3Rpb24gaW5yYW5nZSAodmFsdWUsIHJhbmdlLCBsZWZ0LCByaWdodCkge1xuICBsZXQgcjAgPSByYW5nZVswXSxcbiAgICByMSA9IHJhbmdlW3JhbmdlLmxlbmd0aCAtIDFdLFxuICAgIHQ7XG4gIGlmIChyMCA+IHIxKSB7XG4gICAgdCA9IHIwO1xuICAgIHIwID0gcjE7XG4gICAgcjEgPSB0O1xuICB9XG4gIGxlZnQgPSBsZWZ0ID09PSB1bmRlZmluZWQgfHwgbGVmdDtcbiAgcmlnaHQgPSByaWdodCA9PT0gdW5kZWZpbmVkIHx8IHJpZ2h0O1xuICByZXR1cm4gKGxlZnQgPyByMCA8PSB2YWx1ZSA6IHIwIDwgdmFsdWUpICYmIChyaWdodCA/IHZhbHVlIDw9IHIxIDogdmFsdWUgPCByMSk7XG59XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbiAoXykge1xuICByZXR1cm4gdHlwZW9mIF8gPT09ICdib29sZWFuJztcbn1cblxuZnVuY3Rpb24gaXNEYXRlIChfKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoXykgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuZnVuY3Rpb24gaXNJdGVyYWJsZSAoXykge1xuICByZXR1cm4gXyAmJiBpc0Z1bmN0aW9uKF9bU3ltYm9sLml0ZXJhdG9yXSk7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyIChfKSB7XG4gIHJldHVybiB0eXBlb2YgXyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzUmVnRXhwIChfKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoXykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyAoXykge1xuICByZXR1cm4gdHlwZW9mIF8gPT09ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBrZXkgKGZpZWxkcywgZmxhdCwgb3B0KSB7XG4gIGlmIChmaWVsZHMpIHtcbiAgICBmaWVsZHMgPSBmbGF0ID8gYXJyYXkoZmllbGRzKS5tYXAoZiA9PiBmLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJykpIDogYXJyYXkoZmllbGRzKTtcbiAgfVxuICBjb25zdCBsZW4gPSBmaWVsZHMgJiYgZmllbGRzLmxlbmd0aCxcbiAgICBnZW4gPSBvcHQgJiYgb3B0LmdldCB8fCBnZXR0ZXIsXG4gICAgbWFwID0gZiA9PiBnZW4oZmxhdCA/IFtmXSA6IHNwbGl0QWNjZXNzUGF0aChmKSk7XG4gIGxldCBmbjtcbiAgaWYgKCFsZW4pIHtcbiAgICBmbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuICB9IGVsc2UgaWYgKGxlbiA9PT0gMSkge1xuICAgIGNvbnN0IGdldCA9IG1hcChmaWVsZHNbMF0pO1xuICAgIGZuID0gZnVuY3Rpb24gKF8pIHtcbiAgICAgIHJldHVybiAnJyArIGdldChfKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGdldCA9IGZpZWxkcy5tYXAobWFwKTtcbiAgICBmbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgICBsZXQgcyA9ICcnICsgZ2V0WzBdKF8pLFxuICAgICAgICBpID0gMDtcbiAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHMgKz0gJ3wnICsgZ2V0W2ldKF8pO1xuICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gYWNjZXNzb3IoZm4sIGZpZWxkcywgJ2tleScpO1xufVxuXG5mdW5jdGlvbiBsZXJwIChhcnJheSwgZnJhYykge1xuICBjb25zdCBsbyA9IGFycmF5WzBdLFxuICAgIGhpID0gcGVlayhhcnJheSksXG4gICAgZiA9ICtmcmFjO1xuICByZXR1cm4gIWYgPyBsbyA6IGYgPT09IDEgPyBoaSA6IGxvICsgZiAqIChoaSAtIGxvKTtcbn1cblxuY29uc3QgREVGQVVMVF9NQVhfU0laRSA9IDEwMDAwO1xuXG4vLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2RvbWluaWN0YXJyL2hhc2hscnUvIChNSVQgTGljZW5zZSlcbmZ1bmN0aW9uIGxydUNhY2hlIChtYXhzaXplKSB7XG4gIG1heHNpemUgPSArbWF4c2l6ZSB8fCBERUZBVUxUX01BWF9TSVpFO1xuICBsZXQgY3VyciwgcHJldiwgc2l6ZTtcbiAgY29uc3QgY2xlYXIgPSAoKSA9PiB7XG4gICAgY3VyciA9IHt9O1xuICAgIHByZXYgPSB7fTtcbiAgICBzaXplID0gMDtcbiAgfTtcbiAgY29uc3QgdXBkYXRlID0gKGtleSwgdmFsdWUpID0+IHtcbiAgICBpZiAoKytzaXplID4gbWF4c2l6ZSkge1xuICAgICAgcHJldiA9IGN1cnI7XG4gICAgICBjdXJyID0ge307XG4gICAgICBzaXplID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJba2V5XSA9IHZhbHVlO1xuICB9O1xuICBjbGVhcigpO1xuICByZXR1cm4ge1xuICAgIGNsZWFyLFxuICAgIGhhczoga2V5ID0+IGhhcyhjdXJyLCBrZXkpIHx8IGhhcyhwcmV2LCBrZXkpLFxuICAgIGdldDoga2V5ID0+IGhhcyhjdXJyLCBrZXkpID8gY3VycltrZXldIDogaGFzKHByZXYsIGtleSkgPyB1cGRhdGUoa2V5LCBwcmV2W2tleV0pIDogdW5kZWZpbmVkLFxuICAgIHNldDogKGtleSwgdmFsdWUpID0+IGhhcyhjdXJyLCBrZXkpID8gY3VycltrZXldID0gdmFsdWUgOiB1cGRhdGUoa2V5LCB2YWx1ZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UgKGNvbXBhcmUsIGFycmF5MCwgYXJyYXkxLCBvdXRwdXQpIHtcbiAgY29uc3QgbjAgPSBhcnJheTAubGVuZ3RoLFxuICAgIG4xID0gYXJyYXkxLmxlbmd0aDtcbiAgaWYgKCFuMSkgcmV0dXJuIGFycmF5MDtcbiAgaWYgKCFuMCkgcmV0dXJuIGFycmF5MTtcbiAgY29uc3QgbWVyZ2VkID0gb3V0cHV0IHx8IG5ldyBhcnJheTAuY29uc3RydWN0b3IobjAgKyBuMSk7XG4gIGxldCBpMCA9IDAsXG4gICAgaTEgPSAwLFxuICAgIGkgPSAwO1xuICBmb3IgKDsgaTAgPCBuMCAmJiBpMSA8IG4xOyArK2kpIHtcbiAgICBtZXJnZWRbaV0gPSBjb21wYXJlKGFycmF5MFtpMF0sIGFycmF5MVtpMV0pID4gMCA/IGFycmF5MVtpMSsrXSA6IGFycmF5MFtpMCsrXTtcbiAgfVxuICBmb3IgKDsgaTAgPCBuMDsgKytpMCwgKytpKSB7XG4gICAgbWVyZ2VkW2ldID0gYXJyYXkwW2kwXTtcbiAgfVxuICBmb3IgKDsgaTEgPCBuMTsgKytpMSwgKytpKSB7XG4gICAgbWVyZ2VkW2ldID0gYXJyYXkxW2kxXTtcbiAgfVxuICByZXR1cm4gbWVyZ2VkO1xufVxuXG5mdW5jdGlvbiByZXBlYXQgKHN0ciwgcmVwcykge1xuICBsZXQgcyA9ICcnO1xuICB3aGlsZSAoLS1yZXBzID49IDApIHMgKz0gc3RyO1xuICByZXR1cm4gcztcbn1cblxuZnVuY3Rpb24gcGFkIChzdHIsIGxlbmd0aCwgcGFkY2hhciwgYWxpZ24pIHtcbiAgY29uc3QgYyA9IHBhZGNoYXIgfHwgJyAnLFxuICAgIHMgPSBzdHIgKyAnJyxcbiAgICBuID0gbGVuZ3RoIC0gcy5sZW5ndGg7XG4gIHJldHVybiBuIDw9IDAgPyBzIDogYWxpZ24gPT09ICdsZWZ0JyA/IHJlcGVhdChjLCBuKSArIHMgOiBhbGlnbiA9PT0gJ2NlbnRlcicgPyByZXBlYXQoYywgfn4obiAvIDIpKSArIHMgKyByZXBlYXQoYywgTWF0aC5jZWlsKG4gLyAyKSkgOiBzICsgcmVwZWF0KGMsIG4pO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtZXJpY2FsIHNwYW4gb2YgYW4gYXJyYXk6IHRoZSBkaWZmZXJlbmNlIGJldHdlZW5cbiAqIHRoZSBsYXN0IGFuZCBmaXJzdCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNwYW4gKGFycmF5KSB7XG4gIHJldHVybiBhcnJheSAmJiBwZWVrKGFycmF5KSAtIGFycmF5WzBdIHx8IDA7XG59XG5cbmZ1bmN0aW9uICQoeCkge1xuICByZXR1cm4gaXNBcnJheSh4KSA/ICdbJyArIHgubWFwKCQpICsgJ10nIDogaXNPYmplY3QoeCkgfHwgaXNTdHJpbmcoeCkgP1xuICAvLyBPdXRwdXQgdmFsaWQgSlNPTiBhbmQgSlMgc291cmNlIHN0cmluZ3MuXG4gIC8vIFNlZSBodHRwOi8vdGltZWxlc3NyZXBvLmNvbS9qc29uLWlzbnQtYS1qYXZhc2NyaXB0LXN1YnNldFxuICBKU09OLnN0cmluZ2lmeSh4KS5yZXBsYWNlKCdcXHUyMDI4JywgJ1xcXFx1MjAyOCcpLnJlcGxhY2UoJ1xcdTIwMjknLCAnXFxcXHUyMDI5JykgOiB4O1xufVxuXG5mdW5jdGlvbiB0b0Jvb2xlYW4gKF8pIHtcbiAgcmV0dXJuIF8gPT0gbnVsbCB8fCBfID09PSAnJyA/IG51bGwgOiAhXyB8fCBfID09PSAnZmFsc2UnIHx8IF8gPT09ICcwJyA/IGZhbHNlIDogISFfO1xufVxuXG5jb25zdCBkZWZhdWx0UGFyc2VyID0gXyA9PiBpc051bWJlcihfKSA/IF8gOiBpc0RhdGUoXykgPyBfIDogRGF0ZS5wYXJzZShfKTtcbmZ1bmN0aW9uIHRvRGF0ZSAoXywgcGFyc2VyKSB7XG4gIHBhcnNlciA9IHBhcnNlciB8fCBkZWZhdWx0UGFyc2VyO1xuICByZXR1cm4gXyA9PSBudWxsIHx8IF8gPT09ICcnID8gbnVsbCA6IHBhcnNlcihfKTtcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmcgKF8pIHtcbiAgcmV0dXJuIF8gPT0gbnVsbCB8fCBfID09PSAnJyA/IG51bGwgOiBfICsgJyc7XG59XG5cbmZ1bmN0aW9uIHRvU2V0IChfKSB7XG4gIGNvbnN0IHMgPSB7fSxcbiAgICBuID0gXy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBzW19baV1dID0gdHJ1ZTtcbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlIChzdHIsIGxlbmd0aCwgYWxpZ24sIGVsbGlwc2lzKSB7XG4gIGNvbnN0IGUgPSBlbGxpcHNpcyAhPSBudWxsID8gZWxsaXBzaXMgOiAnXFx1MjAyNicsXG4gICAgcyA9IHN0ciArICcnLFxuICAgIG4gPSBzLmxlbmd0aCxcbiAgICBsID0gTWF0aC5tYXgoMCwgbGVuZ3RoIC0gZS5sZW5ndGgpO1xuICByZXR1cm4gbiA8PSBsZW5ndGggPyBzIDogYWxpZ24gPT09ICdsZWZ0JyA/IGUgKyBzLnNsaWNlKG4gLSBsKSA6IGFsaWduID09PSAnY2VudGVyJyA/IHMuc2xpY2UoMCwgTWF0aC5jZWlsKGwgLyAyKSkgKyBlICsgcy5zbGljZShuIC0gfn4obCAvIDIpKSA6IHMuc2xpY2UoMCwgbCkgKyBlO1xufVxuXG5mdW5jdGlvbiB2aXNpdEFycmF5IChhcnJheSwgZmlsdGVyLCB2aXNpdG9yKSB7XG4gIGlmIChhcnJheSkge1xuICAgIGlmIChmaWx0ZXIpIHtcbiAgICAgIGNvbnN0IG4gPSBhcnJheS5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCB0ID0gZmlsdGVyKGFycmF5W2ldKTtcbiAgICAgICAgaWYgKHQpIHZpc2l0b3IodCwgaSwgYXJyYXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcnJheS5mb3JFYWNoKHZpc2l0b3IpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgeyBEZWJ1ZywgRXJyb3IkMSBhcyBFcnJvciwgSW5mbywgTm9uZSwgV2FybiwgYWNjZXNzb3IsIGFjY2Vzc29yRmllbGRzLCBhY2Nlc3Nvck5hbWUsIGFycmF5LCBhc2NlbmRpbmcsIGNsYW1wUmFuZ2UsIGNvbXBhcmUsIGNvbnN0YW50LCBkZWJvdW5jZSwgZXJyb3IsIGV4dGVuZCwgZXh0ZW50LCBleHRlbnRJbmRleCwgZmFsc3ksIGZhc3RtYXAsIGZpZWxkLCBmbHVzaCwgaGFzIGFzIGhhc093blByb3BlcnR5LCBpZCwgaWRlbnRpdHksIGluaGVyaXRzLCBpbnJhbmdlLCBpc0FycmF5LCBpc0Jvb2xlYW4sIGlzRGF0ZSwgaXNGdW5jdGlvbiwgaXNJdGVyYWJsZSwgaXNOdW1iZXIsIGlzT2JqZWN0LCBpc1JlZ0V4cCwgaXNTdHJpbmcsIGtleSwgbGVycCwgbG9nZ2VyLCBscnVDYWNoZSwgbWVyZ2UsIG1lcmdlQ29uZmlnLCBvbmUsIHBhZCwgcGFuTGluZWFyLCBwYW5Mb2csIHBhblBvdywgcGFuU3ltbG9nLCBwZWVrLCBxdWFydGVyLCByZXBlYXQsIHNwYW4sIHNwbGl0QWNjZXNzUGF0aCwgJCBhcyBzdHJpbmdWYWx1ZSwgdG9Cb29sZWFuLCB0b0RhdGUsIHRvTnVtYmVyLCB0b1NldCwgdG9TdHJpbmcsIHRydW5jYXRlLCB0cnV0aHksIHV0Y3F1YXJ0ZXIsIHZpc2l0QXJyYXksIHdyaXRlQ29uZmlnLCB6ZXJvLCB6b29tTGluZWFyLCB6b29tTG9nLCB6b29tUG93LCB6b29tU3ltbG9nIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=