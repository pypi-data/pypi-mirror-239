"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_coffeescript_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/coffeescript.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/coffeescript.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "coffeeScript": () => (/* binding */ coffeeScript)
/* harmony export */ });
var ERRORCLASS = "error";

function wordRegexp(words) {
  return new RegExp("^((" + words.join(")|(") + "))\\b");
}

var operators = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&&|\?)=)/;
var delimiters = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/;
var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;
var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;

var wordOperators = wordRegexp(["and", "or", "not",
                                "is", "isnt", "in",
                                "instanceof", "typeof"]);
var indentKeywords = ["for", "while", "loop", "if", "unless", "else",
                      "switch", "try", "catch", "finally", "class"];
var commonKeywords = ["break", "by", "continue", "debugger", "delete",
                      "do", "in", "of", "new", "return", "then",
                      "this", "@", "throw", "when", "until", "extends"];

var keywords = wordRegexp(indentKeywords.concat(commonKeywords));

indentKeywords = wordRegexp(indentKeywords);


var stringPrefixes = /^('{3}|\"{3}|['\"])/;
var regexPrefixes = /^(\/{3}|\/)/;
var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];
var constants = wordRegexp(commonConstants);

// Tokenizers
function tokenBase(stream, state) {
  // Handle scope changes
  if (stream.sol()) {
    if (state.scope.align === null) state.scope.align = false;
    var scopeOffset = state.scope.offset;
    if (stream.eatSpace()) {
      var lineOffset = stream.indentation();
      if (lineOffset > scopeOffset && state.scope.type == "coffee") {
        return "indent";
      } else if (lineOffset < scopeOffset) {
        return "dedent";
      }
      return null;
    } else {
      if (scopeOffset > 0) {
        dedent(stream, state);
      }
    }
  }
  if (stream.eatSpace()) {
    return null;
  }

  var ch = stream.peek();

  // Handle docco title comment (single line)
  if (stream.match("####")) {
    stream.skipToEnd();
    return "comment";
  }

  // Handle multi line comments
  if (stream.match("###")) {
    state.tokenize = longComment;
    return state.tokenize(stream, state);
  }

  // Single line comment
  if (ch === "#") {
    stream.skipToEnd();
    return "comment";
  }

  // Handle number literals
  if (stream.match(/^-?[0-9\.]/, false)) {
    var floatLiteral = false;
    // Floats
    if (stream.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i)) {
      floatLiteral = true;
    }
    if (stream.match(/^-?\d+\.\d*/)) {
      floatLiteral = true;
    }
    if (stream.match(/^-?\.\d+/)) {
      floatLiteral = true;
    }

    if (floatLiteral) {
      // prevent from getting extra . on 1..
      if (stream.peek() == "."){
        stream.backUp(1);
      }
      return "number";
    }
    // Integers
    var intLiteral = false;
    // Hex
    if (stream.match(/^-?0x[0-9a-f]+/i)) {
      intLiteral = true;
    }
    // Decimal
    if (stream.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/)) {
      intLiteral = true;
    }
    // Zero by itself with no other piece of number.
    if (stream.match(/^-?0(?![\dx])/i)) {
      intLiteral = true;
    }
    if (intLiteral) {
      return "number";
    }
  }

  // Handle strings
  if (stream.match(stringPrefixes)) {
    state.tokenize = tokenFactory(stream.current(), false, "string");
    return state.tokenize(stream, state);
  }
  // Handle regex literals
  if (stream.match(regexPrefixes)) {
    if (stream.current() != "/" || stream.match(/^.*\//, false)) { // prevent highlight of division
      state.tokenize = tokenFactory(stream.current(), true, "string.special");
      return state.tokenize(stream, state);
    } else {
      stream.backUp(1);
    }
  }



  // Handle operators and delimiters
  if (stream.match(operators) || stream.match(wordOperators)) {
    return "operator";
  }
  if (stream.match(delimiters)) {
    return "punctuation";
  }

  if (stream.match(constants)) {
    return "atom";
  }

  if (stream.match(atProp) || state.prop && stream.match(identifiers)) {
    return "property";
  }

  if (stream.match(keywords)) {
    return "keyword";
  }

  if (stream.match(identifiers)) {
    return "variable";
  }

  // Handle non-detected items
  stream.next();
  return ERRORCLASS;
}

function tokenFactory(delimiter, singleline, outclass) {
  return function(stream, state) {
    while (!stream.eol()) {
      stream.eatWhile(/[^'"\/\\]/);
      if (stream.eat("\\")) {
        stream.next();
        if (singleline && stream.eol()) {
          return outclass;
        }
      } else if (stream.match(delimiter)) {
        state.tokenize = tokenBase;
        return outclass;
      } else {
        stream.eat(/['"\/]/);
      }
    }
    if (singleline) {
      state.tokenize = tokenBase;
    }
    return outclass;
  };
}

function longComment(stream, state) {
  while (!stream.eol()) {
    stream.eatWhile(/[^#]/);
    if (stream.match("###")) {
      state.tokenize = tokenBase;
      break;
    }
    stream.eatWhile("#");
  }
  return "comment";
}

function indent(stream, state, type = "coffee") {
  var offset = 0, align = false, alignOffset = null;
  for (var scope = state.scope; scope; scope = scope.prev) {
    if (scope.type === "coffee" || scope.type == "}") {
      offset = scope.offset + stream.indentUnit;
      break;
    }
  }
  if (type !== "coffee") {
    align = null;
    alignOffset = stream.column() + stream.current().length;
  } else if (state.scope.align) {
    state.scope.align = false;
  }
  state.scope = {
    offset: offset,
    type: type,
    prev: state.scope,
    align: align,
    alignOffset: alignOffset
  };
}

function dedent(stream, state) {
  if (!state.scope.prev) return;
  if (state.scope.type === "coffee") {
    var _indent = stream.indentation();
    var matched = false;
    for (var scope = state.scope; scope; scope = scope.prev) {
      if (_indent === scope.offset) {
        matched = true;
        break;
      }
    }
    if (!matched) {
      return true;
    }
    while (state.scope.prev && state.scope.offset !== _indent) {
      state.scope = state.scope.prev;
    }
    return false;
  } else {
    state.scope = state.scope.prev;
    return false;
  }
}

function tokenLexer(stream, state) {
  var style = state.tokenize(stream, state);
  var current = stream.current();

  // Handle scope changes.
  if (current === "return") {
    state.dedent = true;
  }
  if (((current === "->" || current === "=>") && stream.eol())
      || style === "indent") {
    indent(stream, state);
  }
  var delimiter_index = "[({".indexOf(current);
  if (delimiter_index !== -1) {
    indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));
  }
  if (indentKeywords.exec(current)){
    indent(stream, state);
  }
  if (current == "then"){
    dedent(stream, state);
  }


  if (style === "dedent") {
    if (dedent(stream, state)) {
      return ERRORCLASS;
    }
  }
  delimiter_index = "])}".indexOf(current);
  if (delimiter_index !== -1) {
    while (state.scope.type == "coffee" && state.scope.prev)
      state.scope = state.scope.prev;
    if (state.scope.type == current)
      state.scope = state.scope.prev;
  }
  if (state.dedent && stream.eol()) {
    if (state.scope.type == "coffee" && state.scope.prev)
      state.scope = state.scope.prev;
    state.dedent = false;
  }

  return style == "indent" || style == "dedent" ? null : style;
}

const coffeeScript = {
  name: "coffeescript",
  startState: function() {
    return {
      tokenize: tokenBase,
      scope: {offset: 0, type:"coffee", prev: null, align: false},
      prop: false,
      dedent: 0
    };
  },

  token: function(stream, state) {
    var fillAlign = state.scope.align === null && state.scope;
    if (fillAlign && stream.sol()) fillAlign.align = false;

    var style = tokenLexer(stream, state);
    if (style && style != "comment") {
      if (fillAlign) fillAlign.align = true;
      state.prop = style == "punctuation" && stream.current() == "."
    }

    return style;
  },

  indent: function(state, text) {
    if (state.tokenize != tokenBase) return 0;
    var scope = state.scope;
    var closer = text && "])}".indexOf(text.charAt(0)) > -1;
    if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;
    var closes = closer && scope.type === text.charAt(0);
    if (scope.align)
      return scope.alignOffset - (closes ? 1 : 0);
    else
      return (closes ? scope.prev : scope).offset;
  },

  languageData: {
    commentTokens: {line: "#"}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfY29mZmVlc2NyaXB0X2pzLjBmZDBiMDhlN2FlNGYxMjMxMmM3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLDBCQUEwQixFQUFFLElBQUksRUFBRTtBQUNsQywwQkFBMEIsRUFBRTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QyxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbURBQW1EO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2NvZmZlZXNjcmlwdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRVJST1JDTEFTUyA9IFwiZXJyb3JcIjtcblxuZnVuY3Rpb24gd29yZFJlZ2V4cCh3b3Jkcykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChcIl4oKFwiICsgd29yZHMuam9pbihcIil8KFwiKSArIFwiKSlcXFxcYlwiKTtcbn1cblxudmFyIG9wZXJhdG9ycyA9IC9eKD86LT58PT58XFwrWys9XT98LVtcXC09XT98XFwqW1xcKj1dP3xcXC9bXFwvPV0/fFs9IV09fDxbPjxdPz0/fD4+Pz0/fCU9P3wmPT98XFx8PT98XFxePT98XFx+fCF8XFw/fChvcnxhbmR8XFx8XFx8fCYmfFxcPyk9KS87XG52YXIgZGVsaW1pdGVycyA9IC9eKD86WygpXFxbXFxde30sOmA9O118XFwuXFwuP1xcLj8pLztcbnZhciBpZGVudGlmaWVycyA9IC9eW19BLVphLXokXVtfQS1aYS16JDAtOV0qLztcbnZhciBhdFByb3AgPSAvXkBbX0EtWmEteiRdW19BLVphLXokMC05XSovO1xuXG52YXIgd29yZE9wZXJhdG9ycyA9IHdvcmRSZWdleHAoW1wiYW5kXCIsIFwib3JcIiwgXCJub3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpc1wiLCBcImlzbnRcIiwgXCJpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImluc3RhbmNlb2ZcIiwgXCJ0eXBlb2ZcIl0pO1xudmFyIGluZGVudEtleXdvcmRzID0gW1wiZm9yXCIsIFwid2hpbGVcIiwgXCJsb29wXCIsIFwiaWZcIiwgXCJ1bmxlc3NcIiwgXCJlbHNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJzd2l0Y2hcIiwgXCJ0cnlcIiwgXCJjYXRjaFwiLCBcImZpbmFsbHlcIiwgXCJjbGFzc1wiXTtcbnZhciBjb21tb25LZXl3b3JkcyA9IFtcImJyZWFrXCIsIFwiYnlcIiwgXCJjb250aW51ZVwiLCBcImRlYnVnZ2VyXCIsIFwiZGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJkb1wiLCBcImluXCIsIFwib2ZcIiwgXCJuZXdcIiwgXCJyZXR1cm5cIiwgXCJ0aGVuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0aGlzXCIsIFwiQFwiLCBcInRocm93XCIsIFwid2hlblwiLCBcInVudGlsXCIsIFwiZXh0ZW5kc1wiXTtcblxudmFyIGtleXdvcmRzID0gd29yZFJlZ2V4cChpbmRlbnRLZXl3b3Jkcy5jb25jYXQoY29tbW9uS2V5d29yZHMpKTtcblxuaW5kZW50S2V5d29yZHMgPSB3b3JkUmVnZXhwKGluZGVudEtleXdvcmRzKTtcblxuXG52YXIgc3RyaW5nUHJlZml4ZXMgPSAvXignezN9fFxcXCJ7M318WydcXFwiXSkvO1xudmFyIHJlZ2V4UHJlZml4ZXMgPSAvXihcXC97M318XFwvKS87XG52YXIgY29tbW9uQ29uc3RhbnRzID0gW1wiSW5maW5pdHlcIiwgXCJOYU5cIiwgXCJ1bmRlZmluZWRcIiwgXCJudWxsXCIsIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwib25cIiwgXCJvZmZcIiwgXCJ5ZXNcIiwgXCJub1wiXTtcbnZhciBjb25zdGFudHMgPSB3b3JkUmVnZXhwKGNvbW1vbkNvbnN0YW50cyk7XG5cbi8vIFRva2VuaXplcnNcbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIC8vIEhhbmRsZSBzY29wZSBjaGFuZ2VzXG4gIGlmIChzdHJlYW0uc29sKCkpIHtcbiAgICBpZiAoc3RhdGUuc2NvcGUuYWxpZ24gPT09IG51bGwpIHN0YXRlLnNjb3BlLmFsaWduID0gZmFsc2U7XG4gICAgdmFyIHNjb3BlT2Zmc2V0ID0gc3RhdGUuc2NvcGUub2Zmc2V0O1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgdmFyIGxpbmVPZmZzZXQgPSBzdHJlYW0uaW5kZW50YXRpb24oKTtcbiAgICAgIGlmIChsaW5lT2Zmc2V0ID4gc2NvcGVPZmZzZXQgJiYgc3RhdGUuc2NvcGUudHlwZSA9PSBcImNvZmZlZVwiKSB7XG4gICAgICAgIHJldHVybiBcImluZGVudFwiO1xuICAgICAgfSBlbHNlIGlmIChsaW5lT2Zmc2V0IDwgc2NvcGVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIFwiZGVkZW50XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHNjb3BlT2Zmc2V0ID4gMCkge1xuICAgICAgICBkZWRlbnQoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGNoID0gc3RyZWFtLnBlZWsoKTtcblxuICAvLyBIYW5kbGUgZG9jY28gdGl0bGUgY29tbWVudCAoc2luZ2xlIGxpbmUpXG4gIGlmIChzdHJlYW0ubWF0Y2goXCIjIyMjXCIpKSB7XG4gICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBtdWx0aSBsaW5lIGNvbW1lbnRzXG4gIGlmIChzdHJlYW0ubWF0Y2goXCIjIyNcIikpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IGxvbmdDb21tZW50O1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIC8vIFNpbmdsZSBsaW5lIGNvbW1lbnRcbiAgaWYgKGNoID09PSBcIiNcIikge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cblxuICAvLyBIYW5kbGUgbnVtYmVyIGxpdGVyYWxzXG4gIGlmIChzdHJlYW0ubWF0Y2goL14tP1swLTlcXC5dLywgZmFsc2UpKSB7XG4gICAgdmFyIGZsb2F0TGl0ZXJhbCA9IGZhbHNlO1xuICAgIC8vIEZsb2F0c1xuICAgIGlmIChzdHJlYW0ubWF0Y2goL14tP1xcZCpcXC5cXGQrKGVbXFwrXFwtXT9cXGQrKT8vaSkpIHtcbiAgICAgIGZsb2F0TGl0ZXJhbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14tP1xcZCtcXC5cXGQqLykpIHtcbiAgICAgIGZsb2F0TGl0ZXJhbCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzdHJlYW0ubWF0Y2goL14tP1xcLlxcZCsvKSkge1xuICAgICAgZmxvYXRMaXRlcmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZmxvYXRMaXRlcmFsKSB7XG4gICAgICAvLyBwcmV2ZW50IGZyb20gZ2V0dGluZyBleHRyYSAuIG9uIDEuLlxuICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT0gXCIuXCIpe1xuICAgICAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICAgIC8vIEludGVnZXJzXG4gICAgdmFyIGludExpdGVyYWwgPSBmYWxzZTtcbiAgICAvLyBIZXhcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT8weFswLTlhLWZdKy9pKSkge1xuICAgICAgaW50TGl0ZXJhbCA9IHRydWU7XG4gICAgfVxuICAgIC8vIERlY2ltYWxcbiAgICBpZiAoc3RyZWFtLm1hdGNoKC9eLT9bMS05XVxcZCooZVtcXCtcXC1dP1xcZCspPy8pKSB7XG4gICAgICBpbnRMaXRlcmFsID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gWmVybyBieSBpdHNlbGYgd2l0aCBubyBvdGhlciBwaWVjZSBvZiBudW1iZXIuXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/MCg/IVtcXGR4XSkvaSkpIHtcbiAgICAgIGludExpdGVyYWwgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaW50TGl0ZXJhbCkge1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHN0cmluZ3NcbiAgaWYgKHN0cmVhbS5tYXRjaChzdHJpbmdQcmVmaXhlcykpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuRmFjdG9yeShzdHJlYW0uY3VycmVudCgpLCBmYWxzZSwgXCJzdHJpbmdcIik7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIC8vIEhhbmRsZSByZWdleCBsaXRlcmFsc1xuICBpZiAoc3RyZWFtLm1hdGNoKHJlZ2V4UHJlZml4ZXMpKSB7XG4gICAgaWYgKHN0cmVhbS5jdXJyZW50KCkgIT0gXCIvXCIgfHwgc3RyZWFtLm1hdGNoKC9eLipcXC8vLCBmYWxzZSkpIHsgLy8gcHJldmVudCBoaWdobGlnaHQgb2YgZGl2aXNpb25cbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5GYWN0b3J5KHN0cmVhbS5jdXJyZW50KCksIHRydWUsIFwic3RyaW5nLnNwZWNpYWxcIik7XG4gICAgICByZXR1cm4gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgfVxuICB9XG5cblxuXG4gIC8vIEhhbmRsZSBvcGVyYXRvcnMgYW5kIGRlbGltaXRlcnNcbiAgaWYgKHN0cmVhbS5tYXRjaChvcGVyYXRvcnMpIHx8IHN0cmVhbS5tYXRjaCh3b3JkT3BlcmF0b3JzKSkge1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH1cbiAgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXJzKSkge1xuICAgIHJldHVybiBcInB1bmN0dWF0aW9uXCI7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGNvbnN0YW50cykpIHtcbiAgICByZXR1cm4gXCJhdG9tXCI7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGF0UHJvcCkgfHwgc3RhdGUucHJvcCAmJiBzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnMpKSB7XG4gICAgcmV0dXJuIFwicHJvcGVydHlcIjtcbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goa2V5d29yZHMpKSB7XG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICB9XG5cbiAgaWYgKHN0cmVhbS5tYXRjaChpZGVudGlmaWVycykpIHtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG5cbiAgLy8gSGFuZGxlIG5vbi1kZXRlY3RlZCBpdGVtc1xuICBzdHJlYW0ubmV4dCgpO1xuICByZXR1cm4gRVJST1JDTEFTUztcbn1cblxuZnVuY3Rpb24gdG9rZW5GYWN0b3J5KGRlbGltaXRlciwgc2luZ2xlbGluZSwgb3V0Y2xhc3MpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXidcIlxcL1xcXFxdLyk7XG4gICAgICBpZiAoc3RyZWFtLmVhdChcIlxcXFxcIikpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgaWYgKHNpbmdsZWxpbmUgJiYgc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGNsYXNzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChkZWxpbWl0ZXIpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICByZXR1cm4gb3V0Y2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0uZWF0KC9bJ1wiXFwvXS8pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2luZ2xlbGluZSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgfVxuICAgIHJldHVybiBvdXRjbGFzcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gbG9uZ0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW14jXS8pO1xuICAgIGlmIChzdHJlYW0ubWF0Y2goXCIjIyNcIikpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHN0cmVhbS5lYXRXaGlsZShcIiNcIik7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiBpbmRlbnQoc3RyZWFtLCBzdGF0ZSwgdHlwZSA9IFwiY29mZmVlXCIpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGFsaWduID0gZmFsc2UsIGFsaWduT2Zmc2V0ID0gbnVsbDtcbiAgZm9yICh2YXIgc2NvcGUgPSBzdGF0ZS5zY29wZTsgc2NvcGU7IHNjb3BlID0gc2NvcGUucHJldikge1xuICAgIGlmIChzY29wZS50eXBlID09PSBcImNvZmZlZVwiIHx8IHNjb3BlLnR5cGUgPT0gXCJ9XCIpIHtcbiAgICAgIG9mZnNldCA9IHNjb3BlLm9mZnNldCArIHN0cmVhbS5pbmRlbnRVbml0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlICE9PSBcImNvZmZlZVwiKSB7XG4gICAgYWxpZ24gPSBudWxsO1xuICAgIGFsaWduT2Zmc2V0ID0gc3RyZWFtLmNvbHVtbigpICsgc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGg7XG4gIH0gZWxzZSBpZiAoc3RhdGUuc2NvcGUuYWxpZ24pIHtcbiAgICBzdGF0ZS5zY29wZS5hbGlnbiA9IGZhbHNlO1xuICB9XG4gIHN0YXRlLnNjb3BlID0ge1xuICAgIG9mZnNldDogb2Zmc2V0LFxuICAgIHR5cGU6IHR5cGUsXG4gICAgcHJldjogc3RhdGUuc2NvcGUsXG4gICAgYWxpZ246IGFsaWduLFxuICAgIGFsaWduT2Zmc2V0OiBhbGlnbk9mZnNldFxuICB9O1xufVxuXG5mdW5jdGlvbiBkZWRlbnQoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnNjb3BlLnByZXYpIHJldHVybjtcbiAgaWYgKHN0YXRlLnNjb3BlLnR5cGUgPT09IFwiY29mZmVlXCIpIHtcbiAgICB2YXIgX2luZGVudCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgIHZhciBtYXRjaGVkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgc2NvcGUgPSBzdGF0ZS5zY29wZTsgc2NvcGU7IHNjb3BlID0gc2NvcGUucHJldikge1xuICAgICAgaWYgKF9pbmRlbnQgPT09IHNjb3BlLm9mZnNldCkge1xuICAgICAgICBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbWF0Y2hlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdoaWxlIChzdGF0ZS5zY29wZS5wcmV2ICYmIHN0YXRlLnNjb3BlLm9mZnNldCAhPT0gX2luZGVudCkge1xuICAgICAgc3RhdGUuc2NvcGUgPSBzdGF0ZS5zY29wZS5wcmV2O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUuc2NvcGUgPSBzdGF0ZS5zY29wZS5wcmV2O1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0b2tlbkxleGVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gIHZhciBjdXJyZW50ID0gc3RyZWFtLmN1cnJlbnQoKTtcblxuICAvLyBIYW5kbGUgc2NvcGUgY2hhbmdlcy5cbiAgaWYgKGN1cnJlbnQgPT09IFwicmV0dXJuXCIpIHtcbiAgICBzdGF0ZS5kZWRlbnQgPSB0cnVlO1xuICB9XG4gIGlmICgoKGN1cnJlbnQgPT09IFwiLT5cIiB8fCBjdXJyZW50ID09PSBcIj0+XCIpICYmIHN0cmVhbS5lb2woKSlcbiAgICAgIHx8IHN0eWxlID09PSBcImluZGVudFwiKSB7XG4gICAgaW5kZW50KHN0cmVhbSwgc3RhdGUpO1xuICB9XG4gIHZhciBkZWxpbWl0ZXJfaW5kZXggPSBcIlsoe1wiLmluZGV4T2YoY3VycmVudCk7XG4gIGlmIChkZWxpbWl0ZXJfaW5kZXggIT09IC0xKSB7XG4gICAgaW5kZW50KHN0cmVhbSwgc3RhdGUsIFwiXSl9XCIuc2xpY2UoZGVsaW1pdGVyX2luZGV4LCBkZWxpbWl0ZXJfaW5kZXgrMSkpO1xuICB9XG4gIGlmIChpbmRlbnRLZXl3b3Jkcy5leGVjKGN1cnJlbnQpKXtcbiAgICBpbmRlbnQoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbiAgaWYgKGN1cnJlbnQgPT0gXCJ0aGVuXCIpe1xuICAgIGRlZGVudChzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG5cbiAgaWYgKHN0eWxlID09PSBcImRlZGVudFwiKSB7XG4gICAgaWYgKGRlZGVudChzdHJlYW0sIHN0YXRlKSkge1xuICAgICAgcmV0dXJuIEVSUk9SQ0xBU1M7XG4gICAgfVxuICB9XG4gIGRlbGltaXRlcl9pbmRleCA9IFwiXSl9XCIuaW5kZXhPZihjdXJyZW50KTtcbiAgaWYgKGRlbGltaXRlcl9pbmRleCAhPT0gLTEpIHtcbiAgICB3aGlsZSAoc3RhdGUuc2NvcGUudHlwZSA9PSBcImNvZmZlZVwiICYmIHN0YXRlLnNjb3BlLnByZXYpXG4gICAgICBzdGF0ZS5zY29wZSA9IHN0YXRlLnNjb3BlLnByZXY7XG4gICAgaWYgKHN0YXRlLnNjb3BlLnR5cGUgPT0gY3VycmVudClcbiAgICAgIHN0YXRlLnNjb3BlID0gc3RhdGUuc2NvcGUucHJldjtcbiAgfVxuICBpZiAoc3RhdGUuZGVkZW50ICYmIHN0cmVhbS5lb2woKSkge1xuICAgIGlmIChzdGF0ZS5zY29wZS50eXBlID09IFwiY29mZmVlXCIgJiYgc3RhdGUuc2NvcGUucHJldilcbiAgICAgIHN0YXRlLnNjb3BlID0gc3RhdGUuc2NvcGUucHJldjtcbiAgICBzdGF0ZS5kZWRlbnQgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzdHlsZSA9PSBcImluZGVudFwiIHx8IHN0eWxlID09IFwiZGVkZW50XCIgPyBudWxsIDogc3R5bGU7XG59XG5cbmV4cG9ydCBjb25zdCBjb2ZmZWVTY3JpcHQgPSB7XG4gIG5hbWU6IFwiY29mZmVlc2NyaXB0XCIsXG4gIHN0YXJ0U3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgc2NvcGU6IHtvZmZzZXQ6IDAsIHR5cGU6XCJjb2ZmZWVcIiwgcHJldjogbnVsbCwgYWxpZ246IGZhbHNlfSxcbiAgICAgIHByb3A6IGZhbHNlLFxuICAgICAgZGVkZW50OiAwXG4gICAgfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBmaWxsQWxpZ24gPSBzdGF0ZS5zY29wZS5hbGlnbiA9PT0gbnVsbCAmJiBzdGF0ZS5zY29wZTtcbiAgICBpZiAoZmlsbEFsaWduICYmIHN0cmVhbS5zb2woKSkgZmlsbEFsaWduLmFsaWduID0gZmFsc2U7XG5cbiAgICB2YXIgc3R5bGUgPSB0b2tlbkxleGVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdHlsZSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIikge1xuICAgICAgaWYgKGZpbGxBbGlnbikgZmlsbEFsaWduLmFsaWduID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnByb3AgPSBzdHlsZSA9PSBcInB1bmN0dWF0aW9uXCIgJiYgc3RyZWFtLmN1cnJlbnQoKSA9PSBcIi5cIlxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0KSB7XG4gICAgaWYgKHN0YXRlLnRva2VuaXplICE9IHRva2VuQmFzZSkgcmV0dXJuIDA7XG4gICAgdmFyIHNjb3BlID0gc3RhdGUuc2NvcGU7XG4gICAgdmFyIGNsb3NlciA9IHRleHQgJiYgXCJdKX1cIi5pbmRleE9mKHRleHQuY2hhckF0KDApKSA+IC0xO1xuICAgIGlmIChjbG9zZXIpIHdoaWxlIChzY29wZS50eXBlID09IFwiY29mZmVlXCIgJiYgc2NvcGUucHJldikgc2NvcGUgPSBzY29wZS5wcmV2O1xuICAgIHZhciBjbG9zZXMgPSBjbG9zZXIgJiYgc2NvcGUudHlwZSA9PT0gdGV4dC5jaGFyQXQoMCk7XG4gICAgaWYgKHNjb3BlLmFsaWduKVxuICAgICAgcmV0dXJuIHNjb3BlLmFsaWduT2Zmc2V0IC0gKGNsb3NlcyA/IDEgOiAwKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gKGNsb3NlcyA/IHNjb3BlLnByZXYgOiBzY29wZSkub2Zmc2V0O1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIiNcIn1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==