"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_commonlisp_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/commonlisp.js":
/*!*******************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/commonlisp.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "commonLisp": () => (/* binding */ commonLisp)
/* harmony export */ });
var specialForm = /^(block|let*|return-from|catch|load-time-value|setq|eval-when|locally|symbol-macrolet|flet|macrolet|tagbody|function|multiple-value-call|the|go|multiple-value-prog1|throw|if|progn|unwind-protect|labels|progv|let|quote)$/;
var assumeBody = /^with|^def|^do|^prog|case$|^cond$|bind$|when$|unless$/;
var numLiteral = /^(?:[+\-]?(?:\d+|\d*\.\d+)(?:[efd][+\-]?\d+)?|[+\-]?\d+(?:\/[+\-]?\d+)?|#b[+\-]?[01]+|#o[+\-]?[0-7]+|#x[+\-]?[\da-f]+)/;
var symbol = /[^\s'`,@()\[\]";]/;
var type;

function readSym(stream) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "\\") stream.next();
    else if (!symbol.test(ch)) { stream.backUp(1); break; }
  }
  return stream.current();
}

function base(stream, state) {
  if (stream.eatSpace()) {type = "ws"; return null;}
  if (stream.match(numLiteral)) return "number";
  var ch = stream.next();
  if (ch == "\\") ch = stream.next();

  if (ch == '"') return (state.tokenize = inString)(stream, state);
  else if (ch == "(") { type = "open"; return "bracket"; }
  else if (ch == ")" || ch == "]") { type = "close"; return "bracket"; }
  else if (ch == ";") { stream.skipToEnd(); type = "ws"; return "comment"; }
  else if (/['`,@]/.test(ch)) return null;
  else if (ch == "|") {
    if (stream.skipTo("|")) { stream.next(); return "variableName"; }
    else { stream.skipToEnd(); return "error"; }
  } else if (ch == "#") {
    var ch = stream.next();
    if (ch == "(") { type = "open"; return "bracket"; }
    else if (/[+\-=\.']/.test(ch)) return null;
    else if (/\d/.test(ch) && stream.match(/^\d*#/)) return null;
    else if (ch == "|") return (state.tokenize = inComment)(stream, state);
    else if (ch == ":") { readSym(stream); return "meta"; }
    else if (ch == "\\") { stream.next(); readSym(stream); return "string.special" }
    else return "error";
  } else {
    var name = readSym(stream);
    if (name == ".") return null;
    type = "symbol";
    if (name == "nil" || name == "t" || name.charAt(0) == ":") return "atom";
    if (state.lastType == "open" && (specialForm.test(name) || assumeBody.test(name))) return "keyword";
    if (name.charAt(0) == "&") return "variableName.special";
    return "variableName";
  }
}

function inString(stream, state) {
  var escaped = false, next;
  while (next = stream.next()) {
    if (next == '"' && !escaped) { state.tokenize = base; break; }
    escaped = !escaped && next == "\\";
  }
  return "string";
}

function inComment(stream, state) {
  var next, last;
  while (next = stream.next()) {
    if (next == "#" && last == "|") { state.tokenize = base; break; }
    last = next;
  }
  type = "ws";
  return "comment";
}

const commonLisp = {
  name: "commonlisp",
  startState: function () {
    return {ctx: {prev: null, start: 0, indentTo: 0}, lastType: null, tokenize: base};
  },

  token: function (stream, state) {
    if (stream.sol() && typeof state.ctx.indentTo != "number")
      state.ctx.indentTo = state.ctx.start + 1;

    type = null;
    var style = state.tokenize(stream, state);
    if (type != "ws") {
      if (state.ctx.indentTo == null) {
        if (type == "symbol" && assumeBody.test(stream.current()))
          state.ctx.indentTo = state.ctx.start + stream.indentUnit;
        else
          state.ctx.indentTo = "next";
      } else if (state.ctx.indentTo == "next") {
        state.ctx.indentTo = stream.column();
      }
      state.lastType = type;
    }
    if (type == "open") state.ctx = {prev: state.ctx, start: stream.column(), indentTo: null};
    else if (type == "close") state.ctx = state.ctx.prev || state.ctx;
    return style;
  },

  indent: function (state) {
    var i = state.ctx.indentTo;
    return typeof i == "number" ? i : state.ctx.start + 1;
  },

  languageData: {
    commentTokens: {line: ";;", block: {open: "#|", close: "|#"}},
    closeBrackets: {brackets: ["(", "[", "{", '"']}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfY29tbW9ubGlzcF9qcy5lNzAzNzhhNGYyYjUxMmVmNWQ4OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsZUFBZTtBQUN2QyxxQ0FBcUMsZ0JBQWdCO0FBQ3JELG1CQUFtQixLQUFLLG9CQUFvQixhQUFhO0FBQ3pEO0FBQ0E7QUFDQSw4QkFBOEIsZUFBZTtBQUM3QyxXQUFXLG9CQUFvQjtBQUMvQixJQUFJO0FBQ0o7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDLDJCQUEyQixlQUFlLGlCQUFpQjtBQUMzRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHVCQUF1QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsWUFBWSxNQUFNLGtDQUFrQztBQUNwRCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxvQkFBb0IsU0FBUyxXQUFXLHlCQUF5QjtBQUNqRSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2NvbW1vbmxpc3AuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHNwZWNpYWxGb3JtID0gL14oYmxvY2t8bGV0KnxyZXR1cm4tZnJvbXxjYXRjaHxsb2FkLXRpbWUtdmFsdWV8c2V0cXxldmFsLXdoZW58bG9jYWxseXxzeW1ib2wtbWFjcm9sZXR8ZmxldHxtYWNyb2xldHx0YWdib2R5fGZ1bmN0aW9ufG11bHRpcGxlLXZhbHVlLWNhbGx8dGhlfGdvfG11bHRpcGxlLXZhbHVlLXByb2cxfHRocm93fGlmfHByb2dufHVud2luZC1wcm90ZWN0fGxhYmVsc3xwcm9ndnxsZXR8cXVvdGUpJC87XG52YXIgYXNzdW1lQm9keSA9IC9ed2l0aHxeZGVmfF5kb3xecHJvZ3xjYXNlJHxeY29uZCR8YmluZCR8d2hlbiR8dW5sZXNzJC87XG52YXIgbnVtTGl0ZXJhbCA9IC9eKD86WytcXC1dPyg/OlxcZCt8XFxkKlxcLlxcZCspKD86W2VmZF1bK1xcLV0/XFxkKyk/fFsrXFwtXT9cXGQrKD86XFwvWytcXC1dP1xcZCspP3wjYlsrXFwtXT9bMDFdK3wjb1srXFwtXT9bMC03XSt8I3hbK1xcLV0/W1xcZGEtZl0rKS87XG52YXIgc3ltYm9sID0gL1teXFxzJ2AsQCgpXFxbXFxdXCI7XS87XG52YXIgdHlwZTtcblxuZnVuY3Rpb24gcmVhZFN5bShzdHJlYW0pIHtcbiAgdmFyIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiXFxcXFwiKSBzdHJlYW0ubmV4dCgpO1xuICAgIGVsc2UgaWYgKCFzeW1ib2wudGVzdChjaCkpIHsgc3RyZWFtLmJhY2tVcCgxKTsgYnJlYWs7IH1cbiAgfVxuICByZXR1cm4gc3RyZWFtLmN1cnJlbnQoKTtcbn1cblxuZnVuY3Rpb24gYmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge3R5cGUgPSBcIndzXCI7IHJldHVybiBudWxsO31cbiAgaWYgKHN0cmVhbS5tYXRjaChudW1MaXRlcmFsKSkgcmV0dXJuIFwibnVtYmVyXCI7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gIGlmIChjaCA9PSBcIlxcXFxcIikgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gIGlmIChjaCA9PSAnXCInKSByZXR1cm4gKHN0YXRlLnRva2VuaXplID0gaW5TdHJpbmcpKHN0cmVhbSwgc3RhdGUpO1xuICBlbHNlIGlmIChjaCA9PSBcIihcIikgeyB0eXBlID0gXCJvcGVuXCI7IHJldHVybiBcImJyYWNrZXRcIjsgfVxuICBlbHNlIGlmIChjaCA9PSBcIilcIiB8fCBjaCA9PSBcIl1cIikgeyB0eXBlID0gXCJjbG9zZVwiOyByZXR1cm4gXCJicmFja2V0XCI7IH1cbiAgZWxzZSBpZiAoY2ggPT0gXCI7XCIpIHsgc3RyZWFtLnNraXBUb0VuZCgpOyB0eXBlID0gXCJ3c1wiOyByZXR1cm4gXCJjb21tZW50XCI7IH1cbiAgZWxzZSBpZiAoL1snYCxAXS8udGVzdChjaCkpIHJldHVybiBudWxsO1xuICBlbHNlIGlmIChjaCA9PSBcInxcIikge1xuICAgIGlmIChzdHJlYW0uc2tpcFRvKFwifFwiKSkgeyBzdHJlYW0ubmV4dCgpOyByZXR1cm4gXCJ2YXJpYWJsZU5hbWVcIjsgfVxuICAgIGVsc2UgeyBzdHJlYW0uc2tpcFRvRW5kKCk7IHJldHVybiBcImVycm9yXCI7IH1cbiAgfSBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgaWYgKGNoID09IFwiKFwiKSB7IHR5cGUgPSBcIm9wZW5cIjsgcmV0dXJuIFwiYnJhY2tldFwiOyB9XG4gICAgZWxzZSBpZiAoL1srXFwtPVxcLiddLy50ZXN0KGNoKSkgcmV0dXJuIG51bGw7XG4gICAgZWxzZSBpZiAoL1xcZC8udGVzdChjaCkgJiYgc3RyZWFtLm1hdGNoKC9eXFxkKiMvKSkgcmV0dXJuIG51bGw7XG4gICAgZWxzZSBpZiAoY2ggPT0gXCJ8XCIpIHJldHVybiAoc3RhdGUudG9rZW5pemUgPSBpbkNvbW1lbnQpKHN0cmVhbSwgc3RhdGUpO1xuICAgIGVsc2UgaWYgKGNoID09IFwiOlwiKSB7IHJlYWRTeW0oc3RyZWFtKTsgcmV0dXJuIFwibWV0YVwiOyB9XG4gICAgZWxzZSBpZiAoY2ggPT0gXCJcXFxcXCIpIHsgc3RyZWFtLm5leHQoKTsgcmVhZFN5bShzdHJlYW0pOyByZXR1cm4gXCJzdHJpbmcuc3BlY2lhbFwiIH1cbiAgICBlbHNlIHJldHVybiBcImVycm9yXCI7XG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSByZWFkU3ltKHN0cmVhbSk7XG4gICAgaWYgKG5hbWUgPT0gXCIuXCIpIHJldHVybiBudWxsO1xuICAgIHR5cGUgPSBcInN5bWJvbFwiO1xuICAgIGlmIChuYW1lID09IFwibmlsXCIgfHwgbmFtZSA9PSBcInRcIiB8fCBuYW1lLmNoYXJBdCgwKSA9PSBcIjpcIikgcmV0dXJuIFwiYXRvbVwiO1xuICAgIGlmIChzdGF0ZS5sYXN0VHlwZSA9PSBcIm9wZW5cIiAmJiAoc3BlY2lhbEZvcm0udGVzdChuYW1lKSB8fCBhc3N1bWVCb2R5LnRlc3QobmFtZSkpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgaWYgKG5hbWUuY2hhckF0KDApID09IFwiJlwiKSByZXR1cm4gXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiO1xuICAgIHJldHVybiBcInZhcmlhYmxlTmFtZVwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluU3RyaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dDtcbiAgd2hpbGUgKG5leHQgPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKG5leHQgPT0gJ1wiJyAmJiAhZXNjYXBlZCkgeyBzdGF0ZS50b2tlbml6ZSA9IGJhc2U7IGJyZWFrOyB9XG4gICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT0gXCJcXFxcXCI7XG4gIH1cbiAgcmV0dXJuIFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGluQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZXh0LCBsYXN0O1xuICB3aGlsZSAobmV4dCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAobmV4dCA9PSBcIiNcIiAmJiBsYXN0ID09IFwifFwiKSB7IHN0YXRlLnRva2VuaXplID0gYmFzZTsgYnJlYWs7IH1cbiAgICBsYXN0ID0gbmV4dDtcbiAgfVxuICB0eXBlID0gXCJ3c1wiO1xuICByZXR1cm4gXCJjb21tZW50XCI7XG59XG5cbmV4cG9ydCBjb25zdCBjb21tb25MaXNwID0ge1xuICBuYW1lOiBcImNvbW1vbmxpc3BcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7Y3R4OiB7cHJldjogbnVsbCwgc3RhcnQ6IDAsIGluZGVudFRvOiAwfSwgbGFzdFR5cGU6IG51bGwsIHRva2VuaXplOiBiYXNlfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpICYmIHR5cGVvZiBzdGF0ZS5jdHguaW5kZW50VG8gIT0gXCJudW1iZXJcIilcbiAgICAgIHN0YXRlLmN0eC5pbmRlbnRUbyA9IHN0YXRlLmN0eC5zdGFydCArIDE7XG5cbiAgICB0eXBlID0gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAodHlwZSAhPSBcIndzXCIpIHtcbiAgICAgIGlmIChzdGF0ZS5jdHguaW5kZW50VG8gPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZSA9PSBcInN5bWJvbFwiICYmIGFzc3VtZUJvZHkudGVzdChzdHJlYW0uY3VycmVudCgpKSlcbiAgICAgICAgICBzdGF0ZS5jdHguaW5kZW50VG8gPSBzdGF0ZS5jdHguc3RhcnQgKyBzdHJlYW0uaW5kZW50VW5pdDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlLmN0eC5pbmRlbnRUbyA9IFwibmV4dFwiO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5jdHguaW5kZW50VG8gPT0gXCJuZXh0XCIpIHtcbiAgICAgICAgc3RhdGUuY3R4LmluZGVudFRvID0gc3RyZWFtLmNvbHVtbigpO1xuICAgICAgfVxuICAgICAgc3RhdGUubGFzdFR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PSBcIm9wZW5cIikgc3RhdGUuY3R4ID0ge3ByZXY6IHN0YXRlLmN0eCwgc3RhcnQ6IHN0cmVhbS5jb2x1bW4oKSwgaW5kZW50VG86IG51bGx9O1xuICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJjbG9zZVwiKSBzdGF0ZS5jdHggPSBzdGF0ZS5jdHgucHJldiB8fCBzdGF0ZS5jdHg7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGluZGVudDogZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgdmFyIGkgPSBzdGF0ZS5jdHguaW5kZW50VG87XG4gICAgcmV0dXJuIHR5cGVvZiBpID09IFwibnVtYmVyXCIgPyBpIDogc3RhdGUuY3R4LnN0YXJ0ICsgMTtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7bGluZTogXCI7O1wiLCBibG9jazoge29wZW46IFwiI3xcIiwgY2xvc2U6IFwifCNcIn19LFxuICAgIGNsb3NlQnJhY2tldHM6IHticmFja2V0czogW1wiKFwiLCBcIltcIiwgXCJ7XCIsICdcIiddfVxuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=