"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_dtd_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/dtd.js":
/*!************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/dtd.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dtd": () => (/* binding */ dtd)
/* harmony export */ });
var type;
function ret(style, tp) {type = tp; return style;}

function tokenBase(stream, state) {
  var ch = stream.next();

  if (ch == "<" && stream.eat("!") ) {
    if (stream.eatWhile(/[\-]/)) {
      state.tokenize = tokenSGMLComment;
      return tokenSGMLComment(stream, state);
    } else if (stream.eatWhile(/[\w]/)) return ret("keyword", "doindent");
  } else if (ch == "<" && stream.eat("?")) { //xml declaration
    state.tokenize = inBlock("meta", "?>");
    return ret("meta", ch);
  } else if (ch == "#" && stream.eatWhile(/[\w]/)) return ret("atom", "tag");
  else if (ch == "|") return ret("keyword", "separator");
  else if (ch.match(/[\(\)\[\]\-\.,\+\?>]/)) return ret(null, ch);//if(ch === ">") return ret(null, "endtag"); else
  else if (ch.match(/[\[\]]/)) return ret("rule", ch);
  else if (ch == "\"" || ch == "'") {
    state.tokenize = tokenString(ch);
    return state.tokenize(stream, state);
  } else if (stream.eatWhile(/[a-zA-Z\?\+\d]/)) {
    var sc = stream.current();
    if( sc.substr(sc.length-1,sc.length).match(/\?|\+/) !== null )stream.backUp(1);
    return ret("tag", "tag");
  } else if (ch == "%" || ch == "*" ) return ret("number", "number");
  else {
    stream.eatWhile(/[\w\\\-_%.{,]/);
    return ret(null, null);
  }
}

function tokenSGMLComment(stream, state) {
  var dashes = 0, ch;
  while ((ch = stream.next()) != null) {
    if (dashes >= 2 && ch == ">") {
      state.tokenize = tokenBase;
      break;
    }
    dashes = (ch == "-") ? dashes + 1 : 0;
  }
  return ret("comment", "comment");
}

function tokenString(quote) {
  return function(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == quote && !escaped) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && ch == "\\";
    }
    return ret("string", "tag");
  };
}

function inBlock(style, terminator) {
  return function(stream, state) {
    while (!stream.eol()) {
      if (stream.match(terminator)) {
        state.tokenize = tokenBase;
        break;
      }
      stream.next();
    }
    return style;
  };
}

const dtd = {
  name: "dtd",
  startState: function() {
    return {tokenize: tokenBase,
            baseIndent: 0,
            stack: []};
  },

  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    var style = state.tokenize(stream, state);

    var context = state.stack[state.stack.length-1];
    if (stream.current() == "[" || type === "doindent" || type == "[") state.stack.push("rule");
    else if (type === "endtag") state.stack[state.stack.length-1] = "endtag";
    else if (stream.current() == "]" || type == "]" || (type == ">" && context == "rule")) state.stack.pop();
    else if (type == "[") state.stack.push("[");
    return style;
  },

  indent: function(state, textAfter, cx) {
    var n = state.stack.length;

    if( textAfter.charAt(0) === ']' )n--;
    else if(textAfter.substr(textAfter.length-1, textAfter.length) === ">"){
      if(textAfter.substr(0,1) === "<") {}
      else if( type == "doindent" && textAfter.length > 1 ) {}
      else if( type == "doindent")n--;
      else if( type == ">" && textAfter.length > 1) {}
      else if( type == "tag" && textAfter !== ">") {}
      else if( type == "tag" && state.stack[state.stack.length-1] == "rule")n--;
      else if( type == "tag")n++;
      else if( textAfter === ">" && state.stack[state.stack.length-1] == "rule" && type === ">")n--;
      else if( textAfter === ">" && state.stack[state.stack.length-1] == "rule") {}
      else if( textAfter.substr(0,1) !== "<" && textAfter.substr(0,1) === ">" )n=n-1;
      else if( textAfter === ">") {}
      else n=n-1;
      //over rule them all
      if(type == null || type == "]")n--;
    }

    return state.baseIndent + n * cx.unit;
  },

  languageData: {
    indentOnInput: /^\s*[\]>]$/
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZHRkX2pzLjA1OGU4ODVjMzJkMTEwOTMzMmU4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBLHlCQUF5QixXQUFXOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUkseUNBQXlDO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrRUFBa0UsNkNBQTZDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2R0ZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdHlwZTtcbmZ1bmN0aW9uIHJldChzdHlsZSwgdHApIHt0eXBlID0gdHA7IHJldHVybiBzdHlsZTt9XG5cbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgaWYgKGNoID09IFwiPFwiICYmIHN0cmVhbS5lYXQoXCIhXCIpICkge1xuICAgIGlmIChzdHJlYW0uZWF0V2hpbGUoL1tcXC1dLykpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5TR01MQ29tbWVudDtcbiAgICAgIHJldHVybiB0b2tlblNHTUxDb21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdFdoaWxlKC9bXFx3XS8pKSByZXR1cm4gcmV0KFwia2V5d29yZFwiLCBcImRvaW5kZW50XCIpO1xuICB9IGVsc2UgaWYgKGNoID09IFwiPFwiICYmIHN0cmVhbS5lYXQoXCI/XCIpKSB7IC8veG1sIGRlY2xhcmF0aW9uXG4gICAgc3RhdGUudG9rZW5pemUgPSBpbkJsb2NrKFwibWV0YVwiLCBcIj8+XCIpO1xuICAgIHJldHVybiByZXQoXCJtZXRhXCIsIGNoKTtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIiNcIiAmJiBzdHJlYW0uZWF0V2hpbGUoL1tcXHddLykpIHJldHVybiByZXQoXCJhdG9tXCIsIFwidGFnXCIpO1xuICBlbHNlIGlmIChjaCA9PSBcInxcIikgcmV0dXJuIHJldChcImtleXdvcmRcIiwgXCJzZXBhcmF0b3JcIik7XG4gIGVsc2UgaWYgKGNoLm1hdGNoKC9bXFwoXFwpXFxbXFxdXFwtXFwuLFxcK1xcPz5dLykpIHJldHVybiByZXQobnVsbCwgY2gpOy8vaWYoY2ggPT09IFwiPlwiKSByZXR1cm4gcmV0KG51bGwsIFwiZW5kdGFnXCIpOyBlbHNlXG4gIGVsc2UgaWYgKGNoLm1hdGNoKC9bXFxbXFxdXS8pKSByZXR1cm4gcmV0KFwicnVsZVwiLCBjaCk7XG4gIGVsc2UgaWYgKGNoID09IFwiXFxcIlwiIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0cmVhbS5lYXRXaGlsZSgvW2EtekEtWlxcP1xcK1xcZF0vKSkge1xuICAgIHZhciBzYyA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgaWYoIHNjLnN1YnN0cihzYy5sZW5ndGgtMSxzYy5sZW5ndGgpLm1hdGNoKC9cXD98XFwrLykgIT09IG51bGwgKXN0cmVhbS5iYWNrVXAoMSk7XG4gICAgcmV0dXJuIHJldChcInRhZ1wiLCBcInRhZ1wiKTtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIiVcIiB8fCBjaCA9PSBcIipcIiApIHJldHVybiByZXQoXCJudW1iZXJcIiwgXCJudW1iZXJcIik7XG4gIGVsc2Uge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcXFxcXC1fJS57LF0vKTtcbiAgICByZXR1cm4gcmV0KG51bGwsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRva2VuU0dNTENvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgZGFzaGVzID0gMCwgY2g7XG4gIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgaWYgKGRhc2hlcyA+PSAyICYmIGNoID09IFwiPlwiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkYXNoZXMgPSAoY2ggPT0gXCItXCIpID8gZGFzaGVzICsgMSA6IDA7XG4gIH1cbiAgcmV0dXJuIHJldChcImNvbW1lbnRcIiwgXCJjb21tZW50XCIpO1xufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAoY2ggPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICByZXR1cm4gcmV0KFwic3RyaW5nXCIsIFwidGFnXCIpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbkJsb2NrKHN0eWxlLCB0ZXJtaW5hdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIGlmIChzdHJlYW0ubWF0Y2godGVybWluYXRvcikpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3QgZHRkID0ge1xuICBuYW1lOiBcImR0ZFwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge3Rva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICAgICAgICBiYXNlSW5kZW50OiAwLFxuICAgICAgICAgICAgc3RhY2s6IFtdfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICB2YXIgY29udGV4dCA9IHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXTtcbiAgICBpZiAoc3RyZWFtLmN1cnJlbnQoKSA9PSBcIltcIiB8fCB0eXBlID09PSBcImRvaW5kZW50XCIgfHwgdHlwZSA9PSBcIltcIikgc3RhdGUuc3RhY2sucHVzaChcInJ1bGVcIik7XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gXCJlbmR0YWdcIikgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoLTFdID0gXCJlbmR0YWdcIjtcbiAgICBlbHNlIGlmIChzdHJlYW0uY3VycmVudCgpID09IFwiXVwiIHx8IHR5cGUgPT0gXCJdXCIgfHwgKHR5cGUgPT0gXCI+XCIgJiYgY29udGV4dCA9PSBcInJ1bGVcIikpIHN0YXRlLnN0YWNrLnBvcCgpO1xuICAgIGVsc2UgaWYgKHR5cGUgPT0gXCJbXCIpIHN0YXRlLnN0YWNrLnB1c2goXCJbXCIpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBpbmRlbnQ6IGZ1bmN0aW9uKHN0YXRlLCB0ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgdmFyIG4gPSBzdGF0ZS5zdGFjay5sZW5ndGg7XG5cbiAgICBpZiggdGV4dEFmdGVyLmNoYXJBdCgwKSA9PT0gJ10nICluLS07XG4gICAgZWxzZSBpZih0ZXh0QWZ0ZXIuc3Vic3RyKHRleHRBZnRlci5sZW5ndGgtMSwgdGV4dEFmdGVyLmxlbmd0aCkgPT09IFwiPlwiKXtcbiAgICAgIGlmKHRleHRBZnRlci5zdWJzdHIoMCwxKSA9PT0gXCI8XCIpIHt9XG4gICAgICBlbHNlIGlmKCB0eXBlID09IFwiZG9pbmRlbnRcIiAmJiB0ZXh0QWZ0ZXIubGVuZ3RoID4gMSApIHt9XG4gICAgICBlbHNlIGlmKCB0eXBlID09IFwiZG9pbmRlbnRcIiluLS07XG4gICAgICBlbHNlIGlmKCB0eXBlID09IFwiPlwiICYmIHRleHRBZnRlci5sZW5ndGggPiAxKSB7fVxuICAgICAgZWxzZSBpZiggdHlwZSA9PSBcInRhZ1wiICYmIHRleHRBZnRlciAhPT0gXCI+XCIpIHt9XG4gICAgICBlbHNlIGlmKCB0eXBlID09IFwidGFnXCIgJiYgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoLTFdID09IFwicnVsZVwiKW4tLTtcbiAgICAgIGVsc2UgaWYoIHR5cGUgPT0gXCJ0YWdcIiluKys7XG4gICAgICBlbHNlIGlmKCB0ZXh0QWZ0ZXIgPT09IFwiPlwiICYmIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXSA9PSBcInJ1bGVcIiAmJiB0eXBlID09PSBcIj5cIiluLS07XG4gICAgICBlbHNlIGlmKCB0ZXh0QWZ0ZXIgPT09IFwiPlwiICYmIHN0YXRlLnN0YWNrW3N0YXRlLnN0YWNrLmxlbmd0aC0xXSA9PSBcInJ1bGVcIikge31cbiAgICAgIGVsc2UgaWYoIHRleHRBZnRlci5zdWJzdHIoMCwxKSAhPT0gXCI8XCIgJiYgdGV4dEFmdGVyLnN1YnN0cigwLDEpID09PSBcIj5cIiApbj1uLTE7XG4gICAgICBlbHNlIGlmKCB0ZXh0QWZ0ZXIgPT09IFwiPlwiKSB7fVxuICAgICAgZWxzZSBuPW4tMTtcbiAgICAgIC8vb3ZlciBydWxlIHRoZW0gYWxsXG4gICAgICBpZih0eXBlID09IG51bGwgfHwgdHlwZSA9PSBcIl1cIiluLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0YXRlLmJhc2VJbmRlbnQgKyBuICogY3gudW5pdDtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBpbmRlbnRPbklucHV0OiAvXlxccypbXFxdPl0kL1xuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=