"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_dylan_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/dylan.js":
/*!**************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/dylan.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dylan": () => (/* binding */ dylan)
/* harmony export */ });
function forEach(arr, f) {
  for (var i = 0; i < arr.length; i++) f(arr[i], i)
}
function some(arr, f) {
  for (var i = 0; i < arr.length; i++) if (f(arr[i], i)) return true
  return false
}

// Words
var words = {
  // Words that introduce unnamed definitions like "define interface"
  unnamedDefinition: ["interface"],

  // Words that introduce simple named definitions like "define library"
  namedDefinition: ["module", "library", "macro",
                    "C-struct", "C-union",
                    "C-function", "C-callable-wrapper"
                   ],

  // Words that introduce type definitions like "define class".
  // These are also parameterized like "define method" and are
  // appended to otherParameterizedDefinitionWords
  typeParameterizedDefinition: ["class", "C-subtype", "C-mapped-subtype"],

  // Words that introduce trickier definitions like "define method".
  // These require special definitions to be added to startExpressions
  otherParameterizedDefinition: ["method", "function",
                                 "C-variable", "C-address"
                                ],

  // Words that introduce module constant definitions.
  // These must also be simple definitions and are
  // appended to otherSimpleDefinitionWords
  constantSimpleDefinition: ["constant"],

  // Words that introduce module variable definitions.
  // These must also be simple definitions and are
  // appended to otherSimpleDefinitionWords
  variableSimpleDefinition: ["variable"],

  // Other words that introduce simple definitions
  // (without implicit bodies).
  otherSimpleDefinition: ["generic", "domain",
                          "C-pointer-type",
                          "table"
                         ],

  // Words that begin statements with implicit bodies.
  statement: ["if", "block", "begin", "method", "case",
              "for", "select", "when", "unless", "until",
              "while", "iterate", "profiling", "dynamic-bind"
             ],

  // Patterns that act as separators in compound statements.
  // This may include any general pattern that must be indented
  // specially.
  separator: ["finally", "exception", "cleanup", "else",
              "elseif", "afterwards"
             ],

  // Keywords that do not require special indentation handling,
  // but which should be highlighted
  other: ["above", "below", "by", "from", "handler", "in",
          "instance", "let", "local", "otherwise", "slot",
          "subclass", "then", "to", "keyed-by", "virtual"
         ],

  // Condition signaling function calls
  signalingCalls: ["signal", "error", "cerror",
                   "break", "check-type", "abort"
                  ]
};

words["otherDefinition"] =
  words["unnamedDefinition"]
  .concat(words["namedDefinition"])
  .concat(words["otherParameterizedDefinition"]);

words["definition"] =
  words["typeParameterizedDefinition"]
  .concat(words["otherDefinition"]);

words["parameterizedDefinition"] =
  words["typeParameterizedDefinition"]
  .concat(words["otherParameterizedDefinition"]);

words["simpleDefinition"] =
  words["constantSimpleDefinition"]
  .concat(words["variableSimpleDefinition"])
  .concat(words["otherSimpleDefinition"]);

words["keyword"] =
  words["statement"]
  .concat(words["separator"])
  .concat(words["other"]);

// Patterns
var symbolPattern = "[-_a-zA-Z?!*@<>$%]+";
var symbol = new RegExp("^" + symbolPattern);
var patterns = {
  // Symbols with special syntax
  symbolKeyword: symbolPattern + ":",
  symbolClass: "<" + symbolPattern + ">",
  symbolGlobal: "\\*" + symbolPattern + "\\*",
  symbolConstant: "\\$" + symbolPattern
};
var patternStyles = {
  symbolKeyword: "atom",
  symbolClass: "tag",
  symbolGlobal: "variableName.standard",
  symbolConstant: "variableName.constant"
};

// Compile all patterns to regular expressions
for (var patternName in patterns)
  if (patterns.hasOwnProperty(patternName))
    patterns[patternName] = new RegExp("^" + patterns[patternName]);

// Names beginning "with-" and "without-" are commonly
// used as statement macro
patterns["keyword"] = [/^with(?:out)?-[-_a-zA-Z?!*@<>$%]+/];

var styles = {};
styles["keyword"] = "keyword";
styles["definition"] = "def";
styles["simpleDefinition"] = "def";
styles["signalingCalls"] = "builtin";

// protected words lookup table
var wordLookup = {};
var styleLookup = {};

forEach([
  "keyword",
  "definition",
  "simpleDefinition",
  "signalingCalls"
], function(type) {
  forEach(words[type], function(word) {
    wordLookup[word] = type;
    styleLookup[word] = styles[type];
  });
});


function chain(stream, state, f) {
  state.tokenize = f;
  return f(stream, state);
}

function tokenBase(stream, state) {
  // String
  var ch = stream.peek();
  if (ch == "'" || ch == '"') {
    stream.next();
    return chain(stream, state, tokenString(ch, "string"));
  }
  // Comment
  else if (ch == "/") {
    stream.next();
    if (stream.eat("*")) {
      return chain(stream, state, tokenComment);
    } else if (stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
    stream.backUp(1);
  }
  // Decimal
  else if (/[+\-\d\.]/.test(ch)) {
    if (stream.match(/^[+-]?[0-9]*\.[0-9]*([esdx][+-]?[0-9]+)?/i) ||
        stream.match(/^[+-]?[0-9]+([esdx][+-]?[0-9]+)/i) ||
        stream.match(/^[+-]?\d+/)) {
      return "number";
    }
  }
  // Hash
  else if (ch == "#") {
    stream.next();
    // Symbol with string syntax
    ch = stream.peek();
    if (ch == '"') {
      stream.next();
      return chain(stream, state, tokenString('"', "string"));
    }
    // Binary number
    else if (ch == "b") {
      stream.next();
      stream.eatWhile(/[01]/);
      return "number";
    }
    // Hex number
    else if (ch == "x") {
      stream.next();
      stream.eatWhile(/[\da-f]/i);
      return "number";
    }
    // Octal number
    else if (ch == "o") {
      stream.next();
      stream.eatWhile(/[0-7]/);
      return "number";
    }
    // Token concatenation in macros
    else if (ch == '#') {
      stream.next();
      return "punctuation";
    }
    // Sequence literals
    else if ((ch == '[') || (ch == '(')) {
      stream.next();
      return "bracket";
      // Hash symbol
    } else if (stream.match(/f|t|all-keys|include|key|next|rest/i)) {
      return "atom";
    } else {
      stream.eatWhile(/[-a-zA-Z]/);
      return "error";
    }
  } else if (ch == "~") {
    stream.next();
    ch = stream.peek();
    if (ch == "=") {
      stream.next();
      ch = stream.peek();
      if (ch == "=") {
        stream.next();
        return "operator";
      }
      return "operator";
    }
    return "operator";
  } else if (ch == ":") {
    stream.next();
    ch = stream.peek();
    if (ch == "=") {
      stream.next();
      return "operator";
    } else if (ch == ":") {
      stream.next();
      return "punctuation";
    }
  } else if ("[](){}".indexOf(ch) != -1) {
    stream.next();
    return "bracket";
  } else if (".,".indexOf(ch) != -1) {
    stream.next();
    return "punctuation";
  } else if (stream.match("end")) {
    return "keyword";
  }
  for (var name in patterns) {
    if (patterns.hasOwnProperty(name)) {
      var pattern = patterns[name];
      if ((pattern instanceof Array && some(pattern, function(p) {
        return stream.match(p);
      })) || stream.match(pattern))
        return patternStyles[name];
    }
  }
  if (/[+\-*\/^=<>&|]/.test(ch)) {
    stream.next();
    return "operator";
  }
  if (stream.match("define")) {
    return "def";
  } else {
    stream.eatWhile(/[\w\-]/);
    // Keyword
    if (wordLookup.hasOwnProperty(stream.current())) {
      return styleLookup[stream.current()];
    } else if (stream.current().match(symbol)) {
      return "variable";
    } else {
      stream.next();
      return "variableName.standard";
    }
  }
}

function tokenComment(stream, state) {
  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
  while ((ch = stream.next())) {
    if (ch == "/" && maybeEnd) {
      if (nestedCount > 0) {
        nestedCount--;
      } else {
        state.tokenize = tokenBase;
        break;
      }
    } else if (ch == "*" && maybeNested) {
      nestedCount++;
    }
    maybeEnd = (ch == "*");
    maybeNested = (ch == "/");
  }
  return "comment";
}

function tokenString(quote, style) {
  return function(stream, state) {
    var escaped = false, next, end = false;
    while ((next = stream.next()) != null) {
      if (next == quote && !escaped) {
        end = true;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    if (end || !escaped) {
      state.tokenize = tokenBase;
    }
    return style;
  };
}

// Interface
const dylan = {
  name: "dylan",
  startState: function() {
    return {
      tokenize: tokenBase,
      currentIndent: 0
    };
  },
  token: function(stream, state) {
    if (stream.eatSpace())
      return null;
    var style = state.tokenize(stream, state);
    return style;
  },
  languageData: {
    commentTokens: {block: {open: "/*", close: "*/"}}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZHlsYW5fanMuNzhlYWVkZjJjNzc3ZjdiNDJkZmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9keWxhbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBmb3JFYWNoKGFyciwgZikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgZihhcnJbaV0sIGkpXG59XG5mdW5jdGlvbiBzb21lKGFyciwgZikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykgaWYgKGYoYXJyW2ldLCBpKSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8vIFdvcmRzXG52YXIgd29yZHMgPSB7XG4gIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIHVubmFtZWQgZGVmaW5pdGlvbnMgbGlrZSBcImRlZmluZSBpbnRlcmZhY2VcIlxuICB1bm5hbWVkRGVmaW5pdGlvbjogW1wiaW50ZXJmYWNlXCJdLFxuXG4gIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIHNpbXBsZSBuYW1lZCBkZWZpbml0aW9ucyBsaWtlIFwiZGVmaW5lIGxpYnJhcnlcIlxuICBuYW1lZERlZmluaXRpb246IFtcIm1vZHVsZVwiLCBcImxpYnJhcnlcIiwgXCJtYWNyb1wiLFxuICAgICAgICAgICAgICAgICAgICBcIkMtc3RydWN0XCIsIFwiQy11bmlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcIkMtZnVuY3Rpb25cIiwgXCJDLWNhbGxhYmxlLXdyYXBwZXJcIlxuICAgICAgICAgICAgICAgICAgIF0sXG5cbiAgLy8gV29yZHMgdGhhdCBpbnRyb2R1Y2UgdHlwZSBkZWZpbml0aW9ucyBsaWtlIFwiZGVmaW5lIGNsYXNzXCIuXG4gIC8vIFRoZXNlIGFyZSBhbHNvIHBhcmFtZXRlcml6ZWQgbGlrZSBcImRlZmluZSBtZXRob2RcIiBhbmQgYXJlXG4gIC8vIGFwcGVuZGVkIHRvIG90aGVyUGFyYW1ldGVyaXplZERlZmluaXRpb25Xb3Jkc1xuICB0eXBlUGFyYW1ldGVyaXplZERlZmluaXRpb246IFtcImNsYXNzXCIsIFwiQy1zdWJ0eXBlXCIsIFwiQy1tYXBwZWQtc3VidHlwZVwiXSxcblxuICAvLyBXb3JkcyB0aGF0IGludHJvZHVjZSB0cmlja2llciBkZWZpbml0aW9ucyBsaWtlIFwiZGVmaW5lIG1ldGhvZFwiLlxuICAvLyBUaGVzZSByZXF1aXJlIHNwZWNpYWwgZGVmaW5pdGlvbnMgdG8gYmUgYWRkZWQgdG8gc3RhcnRFeHByZXNzaW9uc1xuICBvdGhlclBhcmFtZXRlcml6ZWREZWZpbml0aW9uOiBbXCJtZXRob2RcIiwgXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDLXZhcmlhYmxlXCIsIFwiQy1hZGRyZXNzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcblxuICAvLyBXb3JkcyB0aGF0IGludHJvZHVjZSBtb2R1bGUgY29uc3RhbnQgZGVmaW5pdGlvbnMuXG4gIC8vIFRoZXNlIG11c3QgYWxzbyBiZSBzaW1wbGUgZGVmaW5pdGlvbnMgYW5kIGFyZVxuICAvLyBhcHBlbmRlZCB0byBvdGhlclNpbXBsZURlZmluaXRpb25Xb3Jkc1xuICBjb25zdGFudFNpbXBsZURlZmluaXRpb246IFtcImNvbnN0YW50XCJdLFxuXG4gIC8vIFdvcmRzIHRoYXQgaW50cm9kdWNlIG1vZHVsZSB2YXJpYWJsZSBkZWZpbml0aW9ucy5cbiAgLy8gVGhlc2UgbXVzdCBhbHNvIGJlIHNpbXBsZSBkZWZpbml0aW9ucyBhbmQgYXJlXG4gIC8vIGFwcGVuZGVkIHRvIG90aGVyU2ltcGxlRGVmaW5pdGlvbldvcmRzXG4gIHZhcmlhYmxlU2ltcGxlRGVmaW5pdGlvbjogW1widmFyaWFibGVcIl0sXG5cbiAgLy8gT3RoZXIgd29yZHMgdGhhdCBpbnRyb2R1Y2Ugc2ltcGxlIGRlZmluaXRpb25zXG4gIC8vICh3aXRob3V0IGltcGxpY2l0IGJvZGllcykuXG4gIG90aGVyU2ltcGxlRGVmaW5pdGlvbjogW1wiZ2VuZXJpY1wiLCBcImRvbWFpblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcIkMtcG9pbnRlci10eXBlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwidGFibGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG5cbiAgLy8gV29yZHMgdGhhdCBiZWdpbiBzdGF0ZW1lbnRzIHdpdGggaW1wbGljaXQgYm9kaWVzLlxuICBzdGF0ZW1lbnQ6IFtcImlmXCIsIFwiYmxvY2tcIiwgXCJiZWdpblwiLCBcIm1ldGhvZFwiLCBcImNhc2VcIixcbiAgICAgICAgICAgICAgXCJmb3JcIiwgXCJzZWxlY3RcIiwgXCJ3aGVuXCIsIFwidW5sZXNzXCIsIFwidW50aWxcIixcbiAgICAgICAgICAgICAgXCJ3aGlsZVwiLCBcIml0ZXJhdGVcIiwgXCJwcm9maWxpbmdcIiwgXCJkeW5hbWljLWJpbmRcIlxuICAgICAgICAgICAgIF0sXG5cbiAgLy8gUGF0dGVybnMgdGhhdCBhY3QgYXMgc2VwYXJhdG9ycyBpbiBjb21wb3VuZCBzdGF0ZW1lbnRzLlxuICAvLyBUaGlzIG1heSBpbmNsdWRlIGFueSBnZW5lcmFsIHBhdHRlcm4gdGhhdCBtdXN0IGJlIGluZGVudGVkXG4gIC8vIHNwZWNpYWxseS5cbiAgc2VwYXJhdG9yOiBbXCJmaW5hbGx5XCIsIFwiZXhjZXB0aW9uXCIsIFwiY2xlYW51cFwiLCBcImVsc2VcIixcbiAgICAgICAgICAgICAgXCJlbHNlaWZcIiwgXCJhZnRlcndhcmRzXCJcbiAgICAgICAgICAgICBdLFxuXG4gIC8vIEtleXdvcmRzIHRoYXQgZG8gbm90IHJlcXVpcmUgc3BlY2lhbCBpbmRlbnRhdGlvbiBoYW5kbGluZyxcbiAgLy8gYnV0IHdoaWNoIHNob3VsZCBiZSBoaWdobGlnaHRlZFxuICBvdGhlcjogW1wiYWJvdmVcIiwgXCJiZWxvd1wiLCBcImJ5XCIsIFwiZnJvbVwiLCBcImhhbmRsZXJcIiwgXCJpblwiLFxuICAgICAgICAgIFwiaW5zdGFuY2VcIiwgXCJsZXRcIiwgXCJsb2NhbFwiLCBcIm90aGVyd2lzZVwiLCBcInNsb3RcIixcbiAgICAgICAgICBcInN1YmNsYXNzXCIsIFwidGhlblwiLCBcInRvXCIsIFwia2V5ZWQtYnlcIiwgXCJ2aXJ0dWFsXCJcbiAgICAgICAgIF0sXG5cbiAgLy8gQ29uZGl0aW9uIHNpZ25hbGluZyBmdW5jdGlvbiBjYWxsc1xuICBzaWduYWxpbmdDYWxsczogW1wic2lnbmFsXCIsIFwiZXJyb3JcIiwgXCJjZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICBcImJyZWFrXCIsIFwiY2hlY2stdHlwZVwiLCBcImFib3J0XCJcbiAgICAgICAgICAgICAgICAgIF1cbn07XG5cbndvcmRzW1wib3RoZXJEZWZpbml0aW9uXCJdID1cbiAgd29yZHNbXCJ1bm5hbWVkRGVmaW5pdGlvblwiXVxuICAuY29uY2F0KHdvcmRzW1wibmFtZWREZWZpbml0aW9uXCJdKVxuICAuY29uY2F0KHdvcmRzW1wib3RoZXJQYXJhbWV0ZXJpemVkRGVmaW5pdGlvblwiXSk7XG5cbndvcmRzW1wiZGVmaW5pdGlvblwiXSA9XG4gIHdvcmRzW1widHlwZVBhcmFtZXRlcml6ZWREZWZpbml0aW9uXCJdXG4gIC5jb25jYXQod29yZHNbXCJvdGhlckRlZmluaXRpb25cIl0pO1xuXG53b3Jkc1tcInBhcmFtZXRlcml6ZWREZWZpbml0aW9uXCJdID1cbiAgd29yZHNbXCJ0eXBlUGFyYW1ldGVyaXplZERlZmluaXRpb25cIl1cbiAgLmNvbmNhdCh3b3Jkc1tcIm90aGVyUGFyYW1ldGVyaXplZERlZmluaXRpb25cIl0pO1xuXG53b3Jkc1tcInNpbXBsZURlZmluaXRpb25cIl0gPVxuICB3b3Jkc1tcImNvbnN0YW50U2ltcGxlRGVmaW5pdGlvblwiXVxuICAuY29uY2F0KHdvcmRzW1widmFyaWFibGVTaW1wbGVEZWZpbml0aW9uXCJdKVxuICAuY29uY2F0KHdvcmRzW1wib3RoZXJTaW1wbGVEZWZpbml0aW9uXCJdKTtcblxud29yZHNbXCJrZXl3b3JkXCJdID1cbiAgd29yZHNbXCJzdGF0ZW1lbnRcIl1cbiAgLmNvbmNhdCh3b3Jkc1tcInNlcGFyYXRvclwiXSlcbiAgLmNvbmNhdCh3b3Jkc1tcIm90aGVyXCJdKTtcblxuLy8gUGF0dGVybnNcbnZhciBzeW1ib2xQYXR0ZXJuID0gXCJbLV9hLXpBLVo/ISpAPD4kJV0rXCI7XG52YXIgc3ltYm9sID0gbmV3IFJlZ0V4cChcIl5cIiArIHN5bWJvbFBhdHRlcm4pO1xudmFyIHBhdHRlcm5zID0ge1xuICAvLyBTeW1ib2xzIHdpdGggc3BlY2lhbCBzeW50YXhcbiAgc3ltYm9sS2V5d29yZDogc3ltYm9sUGF0dGVybiArIFwiOlwiLFxuICBzeW1ib2xDbGFzczogXCI8XCIgKyBzeW1ib2xQYXR0ZXJuICsgXCI+XCIsXG4gIHN5bWJvbEdsb2JhbDogXCJcXFxcKlwiICsgc3ltYm9sUGF0dGVybiArIFwiXFxcXCpcIixcbiAgc3ltYm9sQ29uc3RhbnQ6IFwiXFxcXCRcIiArIHN5bWJvbFBhdHRlcm5cbn07XG52YXIgcGF0dGVyblN0eWxlcyA9IHtcbiAgc3ltYm9sS2V5d29yZDogXCJhdG9tXCIsXG4gIHN5bWJvbENsYXNzOiBcInRhZ1wiLFxuICBzeW1ib2xHbG9iYWw6IFwidmFyaWFibGVOYW1lLnN0YW5kYXJkXCIsXG4gIHN5bWJvbENvbnN0YW50OiBcInZhcmlhYmxlTmFtZS5jb25zdGFudFwiXG59O1xuXG4vLyBDb21waWxlIGFsbCBwYXR0ZXJucyB0byByZWd1bGFyIGV4cHJlc3Npb25zXG5mb3IgKHZhciBwYXR0ZXJuTmFtZSBpbiBwYXR0ZXJucylcbiAgaWYgKHBhdHRlcm5zLmhhc093blByb3BlcnR5KHBhdHRlcm5OYW1lKSlcbiAgICBwYXR0ZXJuc1twYXR0ZXJuTmFtZV0gPSBuZXcgUmVnRXhwKFwiXlwiICsgcGF0dGVybnNbcGF0dGVybk5hbWVdKTtcblxuLy8gTmFtZXMgYmVnaW5uaW5nIFwid2l0aC1cIiBhbmQgXCJ3aXRob3V0LVwiIGFyZSBjb21tb25seVxuLy8gdXNlZCBhcyBzdGF0ZW1lbnQgbWFjcm9cbnBhdHRlcm5zW1wia2V5d29yZFwiXSA9IFsvXndpdGgoPzpvdXQpPy1bLV9hLXpBLVo/ISpAPD4kJV0rL107XG5cbnZhciBzdHlsZXMgPSB7fTtcbnN0eWxlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbnN0eWxlc1tcImRlZmluaXRpb25cIl0gPSBcImRlZlwiO1xuc3R5bGVzW1wic2ltcGxlRGVmaW5pdGlvblwiXSA9IFwiZGVmXCI7XG5zdHlsZXNbXCJzaWduYWxpbmdDYWxsc1wiXSA9IFwiYnVpbHRpblwiO1xuXG4vLyBwcm90ZWN0ZWQgd29yZHMgbG9va3VwIHRhYmxlXG52YXIgd29yZExvb2t1cCA9IHt9O1xudmFyIHN0eWxlTG9va3VwID0ge307XG5cbmZvckVhY2goW1xuICBcImtleXdvcmRcIixcbiAgXCJkZWZpbml0aW9uXCIsXG4gIFwic2ltcGxlRGVmaW5pdGlvblwiLFxuICBcInNpZ25hbGluZ0NhbGxzXCJcbl0sIGZ1bmN0aW9uKHR5cGUpIHtcbiAgZm9yRWFjaCh3b3Jkc1t0eXBlXSwgZnVuY3Rpb24od29yZCkge1xuICAgIHdvcmRMb29rdXBbd29yZF0gPSB0eXBlO1xuICAgIHN0eWxlTG9va3VwW3dvcmRdID0gc3R5bGVzW3R5cGVdO1xuICB9KTtcbn0pO1xuXG5cbmZ1bmN0aW9uIGNoYWluKHN0cmVhbSwgc3RhdGUsIGYpIHtcbiAgc3RhdGUudG9rZW5pemUgPSBmO1xuICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gU3RyaW5nXG4gIHZhciBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gIGlmIChjaCA9PSBcIidcIiB8fCBjaCA9PSAnXCInKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5TdHJpbmcoY2gsIFwic3RyaW5nXCIpKTtcbiAgfVxuICAvLyBDb21tZW50XG4gIGVsc2UgaWYgKGNoID09IFwiL1wiKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICBpZiAoc3RyZWFtLmVhdChcIipcIikpIHtcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlbkNvbW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIi9cIikpIHtcbiAgICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgfVxuICAvLyBEZWNpbWFsXG4gIGVsc2UgaWYgKC9bK1xcLVxcZFxcLl0vLnRlc3QoY2gpKSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXlsrLV0/WzAtOV0qXFwuWzAtOV0qKFtlc2R4XVsrLV0/WzAtOV0rKT8vaSkgfHxcbiAgICAgICAgc3RyZWFtLm1hdGNoKC9eWystXT9bMC05XSsoW2VzZHhdWystXT9bMC05XSspL2kpIHx8XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXlsrLV0/XFxkKy8pKSB7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gIH1cbiAgLy8gSGFzaFxuICBlbHNlIGlmIChjaCA9PSBcIiNcIikge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgLy8gU3ltYm9sIHdpdGggc3RyaW5nIHN5bnRheFxuICAgIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICBpZiAoY2ggPT0gJ1wiJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblN0cmluZygnXCInLCBcInN0cmluZ1wiKSk7XG4gICAgfVxuICAgIC8vIEJpbmFyeSBudW1iZXJcbiAgICBlbHNlIGlmIChjaCA9PSBcImJcIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvWzAxXS8pO1xuICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgfVxuICAgIC8vIEhleCBudW1iZXJcbiAgICBlbHNlIGlmIChjaCA9PSBcInhcIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcZGEtZl0vaSk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgLy8gT2N0YWwgbnVtYmVyXG4gICAgZWxzZSBpZiAoY2ggPT0gXCJvXCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1swLTddLyk7XG4gICAgICByZXR1cm4gXCJudW1iZXJcIjtcbiAgICB9XG4gICAgLy8gVG9rZW4gY29uY2F0ZW5hdGlvbiBpbiBtYWNyb3NcbiAgICBlbHNlIGlmIChjaCA9PSAnIycpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJwdW5jdHVhdGlvblwiO1xuICAgIH1cbiAgICAvLyBTZXF1ZW5jZSBsaXRlcmFsc1xuICAgIGVsc2UgaWYgKChjaCA9PSAnWycpIHx8IChjaCA9PSAnKCcpKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICAgICAgLy8gSGFzaCBzeW1ib2xcbiAgICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaCgvZnx0fGFsbC1rZXlzfGluY2x1ZGV8a2V5fG5leHR8cmVzdC9pKSkge1xuICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0uZWF0V2hpbGUoL1stYS16QS1aXS8pO1xuICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCJ+XCIpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICBpZiAoY2ggPT0gXCI9XCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBjaCA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICBpZiAoY2ggPT0gXCI9XCIpIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gICAgfVxuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH0gZWxzZSBpZiAoY2ggPT0gXCI6XCIpIHtcbiAgICBzdHJlYW0ubmV4dCgpO1xuICAgIGNoID0gc3RyZWFtLnBlZWsoKTtcbiAgICBpZiAoY2ggPT0gXCI9XCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIH0gZWxzZSBpZiAoY2ggPT0gXCI6XCIpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJwdW5jdHVhdGlvblwiO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcIltdKCl7fVwiLmluZGV4T2YoY2gpICE9IC0xKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gIH0gZWxzZSBpZiAoXCIuLFwiLmluZGV4T2YoY2gpICE9IC0xKSB7XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgICByZXR1cm4gXCJwdW5jdHVhdGlvblwiO1xuICB9IGVsc2UgaWYgKHN0cmVhbS5tYXRjaChcImVuZFwiKSkge1xuICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgfVxuICBmb3IgKHZhciBuYW1lIGluIHBhdHRlcm5zKSB7XG4gICAgaWYgKHBhdHRlcm5zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB2YXIgcGF0dGVybiA9IHBhdHRlcm5zW25hbWVdO1xuICAgICAgaWYgKChwYXR0ZXJuIGluc3RhbmNlb2YgQXJyYXkgJiYgc29tZShwYXR0ZXJuLCBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ubWF0Y2gocCk7XG4gICAgICB9KSkgfHwgc3RyZWFtLm1hdGNoKHBhdHRlcm4pKVxuICAgICAgICByZXR1cm4gcGF0dGVyblN0eWxlc1tuYW1lXTtcbiAgICB9XG4gIH1cbiAgaWYgKC9bK1xcLSpcXC9ePTw+JnxdLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfVxuICBpZiAoc3RyZWFtLm1hdGNoKFwiZGVmaW5lXCIpKSB7XG4gICAgcmV0dXJuIFwiZGVmXCI7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwtXS8pO1xuICAgIC8vIEtleXdvcmRcbiAgICBpZiAod29yZExvb2t1cC5oYXNPd25Qcm9wZXJ0eShzdHJlYW0uY3VycmVudCgpKSkge1xuICAgICAgcmV0dXJuIHN0eWxlTG9va3VwW3N0cmVhbS5jdXJyZW50KCldO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmN1cnJlbnQoKS5tYXRjaChzeW1ib2wpKSB7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwidmFyaWFibGVOYW1lLnN0YW5kYXJkXCI7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBtYXliZUVuZCA9IGZhbHNlLCBtYXliZU5lc3RlZCA9IGZhbHNlLCBuZXN0ZWRDb3VudCA9IDAsIGNoO1xuICB3aGlsZSAoKGNoID0gc3RyZWFtLm5leHQoKSkpIHtcbiAgICBpZiAoY2ggPT0gXCIvXCIgJiYgbWF5YmVFbmQpIHtcbiAgICAgIGlmIChuZXN0ZWRDb3VudCA+IDApIHtcbiAgICAgICAgbmVzdGVkQ291bnQtLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoID09IFwiKlwiICYmIG1heWJlTmVzdGVkKSB7XG4gICAgICBuZXN0ZWRDb3VudCsrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gICAgbWF5YmVOZXN0ZWQgPSAoY2ggPT0gXCIvXCIpO1xuICB9XG4gIHJldHVybiBcImNvbW1lbnRcIjtcbn1cblxuZnVuY3Rpb24gdG9rZW5TdHJpbmcocXVvdGUsIHN0eWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgbmV4dCwgZW5kID0gZmFsc2U7XG4gICAgd2hpbGUgKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgICAgaWYgKG5leHQgPT0gcXVvdGUgJiYgIWVzY2FwZWQpIHtcbiAgICAgICAgZW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgbmV4dCA9PSBcIlxcXFxcIjtcbiAgICB9XG4gICAgaWYgKGVuZCB8fCAhZXNjYXBlZCkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcbn1cblxuLy8gSW50ZXJmYWNlXG5leHBvcnQgY29uc3QgZHlsYW4gPSB7XG4gIG5hbWU6IFwiZHlsYW5cIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICBjdXJyZW50SW5kZW50OiAwXG4gICAgfTtcbiAgfSxcbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgc3R5bGUgPSBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtibG9jazoge29wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIn19XG4gIH1cbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==