"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_eiffel_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/eiffel.js":
/*!***************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/eiffel.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eiffel": () => (/* binding */ eiffel)
/* harmony export */ });
function wordObj(words) {
  var o = {};
  for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;
  return o;
}
var keywords = wordObj([
  'note',
  'across',
  'when',
  'variant',
  'until',
  'unique',
  'undefine',
  'then',
  'strip',
  'select',
  'retry',
  'rescue',
  'require',
  'rename',
  'reference',
  'redefine',
  'prefix',
  'once',
  'old',
  'obsolete',
  'loop',
  'local',
  'like',
  'is',
  'inspect',
  'infix',
  'include',
  'if',
  'frozen',
  'from',
  'external',
  'export',
  'ensure',
  'end',
  'elseif',
  'else',
  'do',
  'creation',
  'create',
  'check',
  'alias',
  'agent',
  'separate',
  'invariant',
  'inherit',
  'indexing',
  'feature',
  'expanded',
  'deferred',
  'class',
  'Void',
  'True',
  'Result',
  'Precursor',
  'False',
  'Current',
  'create',
  'attached',
  'detachable',
  'as',
  'and',
  'implies',
  'not',
  'or'
]);
var operators = wordObj([":=", "and then","and", "or","<<",">>"]);

function chain(newtok, stream, state) {
  state.tokenize.push(newtok);
  return newtok(stream, state);
}

function tokenBase(stream, state) {
  if (stream.eatSpace()) return null;
  var ch = stream.next();
  if (ch == '"'||ch == "'") {
    return chain(readQuoted(ch, "string"), stream, state);
  } else if (ch == "-"&&stream.eat("-")) {
    stream.skipToEnd();
    return "comment";
  } else if (ch == ":"&&stream.eat("=")) {
    return "operator";
  } else if (/[0-9]/.test(ch)) {
    stream.eatWhile(/[xXbBCc0-9\.]/);
    stream.eat(/[\?\!]/);
    return "variable";
  } else if (/[a-zA-Z_0-9]/.test(ch)) {
    stream.eatWhile(/[a-zA-Z_0-9]/);
    stream.eat(/[\?\!]/);
    return "variable";
  } else if (/[=+\-\/*^%<>~]/.test(ch)) {
    stream.eatWhile(/[=+\-\/*^%<>~]/);
    return "operator";
  } else {
    return null;
  }
}

function readQuoted(quote, style,  unescaped) {
  return function(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == quote && (unescaped || !escaped)) {
        state.tokenize.pop();
        break;
      }
      escaped = !escaped && ch == "%";
    }
    return style;
  };
}

const eiffel = {
  name: "eiffel",
  startState: function() {
    return {tokenize: [tokenBase]};
  },

  token: function(stream, state) {
    var style = state.tokenize[state.tokenize.length-1](stream, state);
    if (style == "variable") {
      var word = stream.current();
      style = keywords.propertyIsEnumerable(stream.current()) ? "keyword"
        : operators.propertyIsEnumerable(stream.current()) ? "operator"
        : /^[A-Z][A-Z_0-9]*$/g.test(word) ? "tag"
        : /^0[bB][0-1]+$/g.test(word) ? "number"
        : /^0[cC][0-7]+$/g.test(word) ? "number"
        : /^0[xX][a-fA-F0-9]+$/g.test(word) ? "number"
        : /^([0-9]+\.[0-9]*)|([0-9]*\.[0-9]+)$/g.test(word) ? "number"
        : /^[0-9]+$/g.test(word) ? "number"
        : "variable";
    }
    return style;
  },
  languageData: {
    commentTokens: {line: "--"}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfZWlmZmVsX2pzLmM3MWVhMWE3NTNjYTljZTVlNTI3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBLFlBQVk7QUFDWixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9laWZmZWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd29yZE9iaih3b3Jkcykge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgZSA9IHdvcmRzLmxlbmd0aDsgaSA8IGU7ICsraSkgb1t3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gbztcbn1cbnZhciBrZXl3b3JkcyA9IHdvcmRPYmooW1xuICAnbm90ZScsXG4gICdhY3Jvc3MnLFxuICAnd2hlbicsXG4gICd2YXJpYW50JyxcbiAgJ3VudGlsJyxcbiAgJ3VuaXF1ZScsXG4gICd1bmRlZmluZScsXG4gICd0aGVuJyxcbiAgJ3N0cmlwJyxcbiAgJ3NlbGVjdCcsXG4gICdyZXRyeScsXG4gICdyZXNjdWUnLFxuICAncmVxdWlyZScsXG4gICdyZW5hbWUnLFxuICAncmVmZXJlbmNlJyxcbiAgJ3JlZGVmaW5lJyxcbiAgJ3ByZWZpeCcsXG4gICdvbmNlJyxcbiAgJ29sZCcsXG4gICdvYnNvbGV0ZScsXG4gICdsb29wJyxcbiAgJ2xvY2FsJyxcbiAgJ2xpa2UnLFxuICAnaXMnLFxuICAnaW5zcGVjdCcsXG4gICdpbmZpeCcsXG4gICdpbmNsdWRlJyxcbiAgJ2lmJyxcbiAgJ2Zyb3plbicsXG4gICdmcm9tJyxcbiAgJ2V4dGVybmFsJyxcbiAgJ2V4cG9ydCcsXG4gICdlbnN1cmUnLFxuICAnZW5kJyxcbiAgJ2Vsc2VpZicsXG4gICdlbHNlJyxcbiAgJ2RvJyxcbiAgJ2NyZWF0aW9uJyxcbiAgJ2NyZWF0ZScsXG4gICdjaGVjaycsXG4gICdhbGlhcycsXG4gICdhZ2VudCcsXG4gICdzZXBhcmF0ZScsXG4gICdpbnZhcmlhbnQnLFxuICAnaW5oZXJpdCcsXG4gICdpbmRleGluZycsXG4gICdmZWF0dXJlJyxcbiAgJ2V4cGFuZGVkJyxcbiAgJ2RlZmVycmVkJyxcbiAgJ2NsYXNzJyxcbiAgJ1ZvaWQnLFxuICAnVHJ1ZScsXG4gICdSZXN1bHQnLFxuICAnUHJlY3Vyc29yJyxcbiAgJ0ZhbHNlJyxcbiAgJ0N1cnJlbnQnLFxuICAnY3JlYXRlJyxcbiAgJ2F0dGFjaGVkJyxcbiAgJ2RldGFjaGFibGUnLFxuICAnYXMnLFxuICAnYW5kJyxcbiAgJ2ltcGxpZXMnLFxuICAnbm90JyxcbiAgJ29yJ1xuXSk7XG52YXIgb3BlcmF0b3JzID0gd29yZE9iaihbXCI6PVwiLCBcImFuZCB0aGVuXCIsXCJhbmRcIiwgXCJvclwiLFwiPDxcIixcIj4+XCJdKTtcblxuZnVuY3Rpb24gY2hhaW4obmV3dG9rLCBzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLnRva2VuaXplLnB1c2gobmV3dG9rKTtcbiAgcmV0dXJuIG5ld3RvayhzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gdG9rZW5CYXNlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0cmVhbS5lYXRTcGFjZSgpKSByZXR1cm4gbnVsbDtcbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgaWYgKGNoID09ICdcIid8fGNoID09IFwiJ1wiKSB7XG4gICAgcmV0dXJuIGNoYWluKHJlYWRRdW90ZWQoY2gsIFwic3RyaW5nXCIpLCBzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIGlmIChjaCA9PSBcIi1cIiYmc3RyZWFtLmVhdChcIi1cIikpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9IGVsc2UgaWYgKGNoID09IFwiOlwiJiZzdHJlYW0uZWF0KFwiPVwiKSkge1xuICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIH0gZWxzZSBpZiAoL1swLTldLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW3hYYkJDYzAtOVxcLl0vKTtcbiAgICBzdHJlYW0uZWF0KC9bXFw/XFwhXS8pO1xuICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gIH0gZWxzZSBpZiAoL1thLXpBLVpfMC05XS8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1thLXpBLVpfMC05XS8pO1xuICAgIHN0cmVhbS5lYXQoL1tcXD9cXCFdLyk7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfSBlbHNlIGlmICgvWz0rXFwtXFwvKl4lPD5+XS8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1s9K1xcLVxcLypeJTw+fl0vKTtcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRRdW90ZWQocXVvdGUsIHN0eWxlLCAgdW5lc2NhcGVkKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChjaCA9PSBxdW90ZSAmJiAodW5lc2NhcGVkIHx8ICFlc2NhcGVkKSkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZS5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCIlXCI7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcbn1cblxuZXhwb3J0IGNvbnN0IGVpZmZlbCA9IHtcbiAgbmFtZTogXCJlaWZmZWxcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHt0b2tlbml6ZTogW3Rva2VuQmFzZV19O1xuICB9LFxuXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemVbc3RhdGUudG9rZW5pemUubGVuZ3RoLTFdKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdHlsZSA9PSBcInZhcmlhYmxlXCIpIHtcbiAgICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHN0eWxlID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoc3RyZWFtLmN1cnJlbnQoKSkgPyBcImtleXdvcmRcIlxuICAgICAgICA6IG9wZXJhdG9ycy5wcm9wZXJ0eUlzRW51bWVyYWJsZShzdHJlYW0uY3VycmVudCgpKSA/IFwib3BlcmF0b3JcIlxuICAgICAgICA6IC9eW0EtWl1bQS1aXzAtOV0qJC9nLnRlc3Qod29yZCkgPyBcInRhZ1wiXG4gICAgICAgIDogL14wW2JCXVswLTFdKyQvZy50ZXN0KHdvcmQpID8gXCJudW1iZXJcIlxuICAgICAgICA6IC9eMFtjQ11bMC03XSskL2cudGVzdCh3b3JkKSA/IFwibnVtYmVyXCJcbiAgICAgICAgOiAvXjBbeFhdW2EtZkEtRjAtOV0rJC9nLnRlc3Qod29yZCkgPyBcIm51bWJlclwiXG4gICAgICAgIDogL14oWzAtOV0rXFwuWzAtOV0qKXwoWzAtOV0qXFwuWzAtOV0rKSQvZy50ZXN0KHdvcmQpID8gXCJudW1iZXJcIlxuICAgICAgICA6IC9eWzAtOV0rJC9nLnRlc3Qod29yZCkgPyBcIm51bWJlclwiXG4gICAgICAgIDogXCJ2YXJpYWJsZVwiO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH0sXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi0tXCJ9XG4gIH1cbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==