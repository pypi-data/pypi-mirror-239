"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_haskell_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/haskell.js":
/*!****************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/haskell.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "haskell": () => (/* binding */ haskell)
/* harmony export */ });
function switchState(source, setState, f) {
  setState(f);
  return f(source, setState);
}

// These should all be Unicode extended, as per the Haskell 2010 report
var smallRE = /[a-z_]/;
var largeRE = /[A-Z]/;
var digitRE = /\d/;
var hexitRE = /[0-9A-Fa-f]/;
var octitRE = /[0-7]/;
var idRE = /[a-z_A-Z0-9'\xa1-\uffff]/;
var symbolRE = /[-!#$%&*+.\/<=>?@\\^|~:]/;
var specialRE = /[(),;[\]`{}]/;
var whiteCharRE = /[ \t\v\f]/; // newlines are handled in tokenizer

function normal(source, setState) {
  if (source.eatWhile(whiteCharRE)) {
    return null;
  }

  var ch = source.next();
  if (specialRE.test(ch)) {
    if (ch == '{' && source.eat('-')) {
      var t = "comment";
      if (source.eat('#')) {
        t = "meta";
      }
      return switchState(source, setState, ncomment(t, 1));
    }
    return null;
  }

  if (ch == '\'') {
    if (source.eat('\\')) {
      source.next();  // should handle other escapes here
    }
    else {
      source.next();
    }
    if (source.eat('\'')) {
      return "string";
    }
    return "error";
  }

  if (ch == '"') {
    return switchState(source, setState, stringLiteral);
  }

  if (largeRE.test(ch)) {
    source.eatWhile(idRE);
    if (source.eat('.')) {
      return "qualifier";
    }
    return "type";
  }

  if (smallRE.test(ch)) {
    source.eatWhile(idRE);
    return "variable";
  }

  if (digitRE.test(ch)) {
    if (ch == '0') {
      if (source.eat(/[xX]/)) {
        source.eatWhile(hexitRE); // should require at least 1
        return "integer";
      }
      if (source.eat(/[oO]/)) {
        source.eatWhile(octitRE); // should require at least 1
        return "number";
      }
    }
    source.eatWhile(digitRE);
    var t = "number";
    if (source.match(/^\.\d+/)) {
      t = "number";
    }
    if (source.eat(/[eE]/)) {
      t = "number";
      source.eat(/[-+]/);
      source.eatWhile(digitRE); // should require at least 1
    }
    return t;
  }

  if (ch == "." && source.eat("."))
    return "keyword";

  if (symbolRE.test(ch)) {
    if (ch == '-' && source.eat(/-/)) {
      source.eatWhile(/-/);
      if (!source.eat(symbolRE)) {
        source.skipToEnd();
        return "comment";
      }
    }
    source.eatWhile(symbolRE);
    return "variable"
  }

  return "error";
}

function ncomment(type, nest) {
  if (nest == 0) {
    return normal;
  }
  return function(source, setState) {
    var currNest = nest;
    while (!source.eol()) {
      var ch = source.next();
      if (ch == '{' && source.eat('-')) {
        ++currNest;
      }
      else if (ch == '-' && source.eat('}')) {
        --currNest;
        if (currNest == 0) {
          setState(normal);
          return type;
        }
      }
    }
    setState(ncomment(type, currNest));
    return type;
  };
}

function stringLiteral(source, setState) {
  while (!source.eol()) {
    var ch = source.next();
    if (ch == '"') {
      setState(normal);
      return "string";
    }
    if (ch == '\\') {
      if (source.eol() || source.eat(whiteCharRE)) {
        setState(stringGap);
        return "string";
      }
      if (source.eat('&')) {
      }
      else {
        source.next(); // should handle other escapes here
      }
    }
  }
  setState(normal);
  return "error";
}

function stringGap(source, setState) {
  if (source.eat('\\')) {
    return switchState(source, setState, stringLiteral);
  }
  source.next();
  setState(normal);
  return "error";
}


var wellKnownWords = (function() {
  var wkw = {};
  function setType(t) {
    return function () {
      for (var i = 0; i < arguments.length; i++)
        wkw[arguments[i]] = t;
    };
  }

  setType("keyword")(
    "case", "class", "data", "default", "deriving", "do", "else", "foreign",
    "if", "import", "in", "infix", "infixl", "infixr", "instance", "let",
    "module", "newtype", "of", "then", "type", "where", "_");

  setType("keyword")(
    "\.\.", ":", "::", "=", "\\", "<-", "->", "@", "~", "=>");

  setType("builtin")(
    "!!", "$!", "$", "&&", "+", "++", "-", ".", "/", "/=", "<", "<*", "<=",
    "<$>", "<*>", "=<<", "==", ">", ">=", ">>", ">>=", "^", "^^", "||", "*",
    "*>", "**");

  setType("builtin")(
    "Applicative", "Bool", "Bounded", "Char", "Double", "EQ", "Either", "Enum",
    "Eq", "False", "FilePath", "Float", "Floating", "Fractional", "Functor",
    "GT", "IO", "IOError", "Int", "Integer", "Integral", "Just", "LT", "Left",
    "Maybe", "Monad", "Nothing", "Num", "Ord", "Ordering", "Rational", "Read",
    "ReadS", "Real", "RealFloat", "RealFrac", "Right", "Show", "ShowS",
    "String", "True");

  setType("builtin")(
    "abs", "acos", "acosh", "all", "and", "any", "appendFile", "asTypeOf",
    "asin", "asinh", "atan", "atan2", "atanh", "break", "catch", "ceiling",
    "compare", "concat", "concatMap", "const", "cos", "cosh", "curry",
    "cycle", "decodeFloat", "div", "divMod", "drop", "dropWhile", "either",
    "elem", "encodeFloat", "enumFrom", "enumFromThen", "enumFromThenTo",
    "enumFromTo", "error", "even", "exp", "exponent", "fail", "filter",
    "flip", "floatDigits", "floatRadix", "floatRange", "floor", "fmap",
    "foldl", "foldl1", "foldr", "foldr1", "fromEnum", "fromInteger",
    "fromIntegral", "fromRational", "fst", "gcd", "getChar", "getContents",
    "getLine", "head", "id", "init", "interact", "ioError", "isDenormalized",
    "isIEEE", "isInfinite", "isNaN", "isNegativeZero", "iterate", "last",
    "lcm", "length", "lex", "lines", "log", "logBase", "lookup", "map",
    "mapM", "mapM_", "max", "maxBound", "maximum", "maybe", "min", "minBound",
    "minimum", "mod", "negate", "not", "notElem", "null", "odd", "or",
    "otherwise", "pi", "pred", "print", "product", "properFraction", "pure",
    "putChar", "putStr", "putStrLn", "quot", "quotRem", "read", "readFile",
    "readIO", "readList", "readLn", "readParen", "reads", "readsPrec",
    "realToFrac", "recip", "rem", "repeat", "replicate", "return", "reverse",
    "round", "scaleFloat", "scanl", "scanl1", "scanr", "scanr1", "seq",
    "sequence", "sequence_", "show", "showChar", "showList", "showParen",
    "showString", "shows", "showsPrec", "significand", "signum", "sin",
    "sinh", "snd", "span", "splitAt", "sqrt", "subtract", "succ", "sum",
    "tail", "take", "takeWhile", "tan", "tanh", "toEnum", "toInteger",
    "toRational", "truncate", "uncurry", "undefined", "unlines", "until",
    "unwords", "unzip", "unzip3", "userError", "words", "writeFile", "zip",
    "zip3", "zipWith", "zipWith3");

  return wkw;
})();

const haskell = {
  name: "haskell",
  startState: function ()  { return { f: normal }; },
  copyState:  function (s) { return { f: s.f }; },

  token: function(stream, state) {
    var t = state.f(stream, function(s) { state.f = s; });
    var w = stream.current();
    return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;
  },

  languageData: {
    commentTokens: {line: "--", block: {open: "{-", close: "-}"}}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfaGFza2VsbF9qcy45NDUxMjgwNjNmZDVkYzY5ZmY1OS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBLDZCQUE2QixTQUFTLGNBQWM7QUFDcEQsNkJBQTZCLFNBQVMsV0FBVzs7QUFFakQ7QUFDQSwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9CQUFvQixvQkFBb0IsUUFBUSxjQUFjO0FBQzlEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2hhc2tlbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgZikge1xuICBzZXRTdGF0ZShmKTtcbiAgcmV0dXJuIGYoc291cmNlLCBzZXRTdGF0ZSk7XG59XG5cbi8vIFRoZXNlIHNob3VsZCBhbGwgYmUgVW5pY29kZSBleHRlbmRlZCwgYXMgcGVyIHRoZSBIYXNrZWxsIDIwMTAgcmVwb3J0XG52YXIgc21hbGxSRSA9IC9bYS16X10vO1xudmFyIGxhcmdlUkUgPSAvW0EtWl0vO1xudmFyIGRpZ2l0UkUgPSAvXFxkLztcbnZhciBoZXhpdFJFID0gL1swLTlBLUZhLWZdLztcbnZhciBvY3RpdFJFID0gL1swLTddLztcbnZhciBpZFJFID0gL1thLXpfQS1aMC05J1xceGExLVxcdWZmZmZdLztcbnZhciBzeW1ib2xSRSA9IC9bLSEjJCUmKisuXFwvPD0+P0BcXFxcXnx+Ol0vO1xudmFyIHNwZWNpYWxSRSA9IC9bKCksO1tcXF1ge31dLztcbnZhciB3aGl0ZUNoYXJSRSA9IC9bIFxcdFxcdlxcZl0vOyAvLyBuZXdsaW5lcyBhcmUgaGFuZGxlZCBpbiB0b2tlbml6ZXJcblxuZnVuY3Rpb24gbm9ybWFsKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgaWYgKHNvdXJjZS5lYXRXaGlsZSh3aGl0ZUNoYXJSRSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjaCA9IHNvdXJjZS5uZXh0KCk7XG4gIGlmIChzcGVjaWFsUkUudGVzdChjaCkpIHtcbiAgICBpZiAoY2ggPT0gJ3snICYmIHNvdXJjZS5lYXQoJy0nKSkge1xuICAgICAgdmFyIHQgPSBcImNvbW1lbnRcIjtcbiAgICAgIGlmIChzb3VyY2UuZWF0KCcjJykpIHtcbiAgICAgICAgdCA9IFwibWV0YVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIG5jb21tZW50KHQsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY2ggPT0gJ1xcJycpIHtcbiAgICBpZiAoc291cmNlLmVhdCgnXFxcXCcpKSB7XG4gICAgICBzb3VyY2UubmV4dCgpOyAgLy8gc2hvdWxkIGhhbmRsZSBvdGhlciBlc2NhcGVzIGhlcmVcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzb3VyY2UubmV4dCgpO1xuICAgIH1cbiAgICBpZiAoc291cmNlLmVhdCgnXFwnJykpIHtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJlcnJvclwiO1xuICB9XG5cbiAgaWYgKGNoID09ICdcIicpIHtcbiAgICByZXR1cm4gc3dpdGNoU3RhdGUoc291cmNlLCBzZXRTdGF0ZSwgc3RyaW5nTGl0ZXJhbCk7XG4gIH1cblxuICBpZiAobGFyZ2VSRS50ZXN0KGNoKSkge1xuICAgIHNvdXJjZS5lYXRXaGlsZShpZFJFKTtcbiAgICBpZiAoc291cmNlLmVhdCgnLicpKSB7XG4gICAgICByZXR1cm4gXCJxdWFsaWZpZXJcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwidHlwZVwiO1xuICB9XG5cbiAgaWYgKHNtYWxsUkUudGVzdChjaCkpIHtcbiAgICBzb3VyY2UuZWF0V2hpbGUoaWRSRSk7XG4gICAgcmV0dXJuIFwidmFyaWFibGVcIjtcbiAgfVxuXG4gIGlmIChkaWdpdFJFLnRlc3QoY2gpKSB7XG4gICAgaWYgKGNoID09ICcwJykge1xuICAgICAgaWYgKHNvdXJjZS5lYXQoL1t4WF0vKSkge1xuICAgICAgICBzb3VyY2UuZWF0V2hpbGUoaGV4aXRSRSk7IC8vIHNob3VsZCByZXF1aXJlIGF0IGxlYXN0IDFcbiAgICAgICAgcmV0dXJuIFwiaW50ZWdlclwiO1xuICAgICAgfVxuICAgICAgaWYgKHNvdXJjZS5lYXQoL1tvT10vKSkge1xuICAgICAgICBzb3VyY2UuZWF0V2hpbGUob2N0aXRSRSk7IC8vIHNob3VsZCByZXF1aXJlIGF0IGxlYXN0IDFcbiAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHNvdXJjZS5lYXRXaGlsZShkaWdpdFJFKTtcbiAgICB2YXIgdCA9IFwibnVtYmVyXCI7XG4gICAgaWYgKHNvdXJjZS5tYXRjaCgvXlxcLlxcZCsvKSkge1xuICAgICAgdCA9IFwibnVtYmVyXCI7XG4gICAgfVxuICAgIGlmIChzb3VyY2UuZWF0KC9bZUVdLykpIHtcbiAgICAgIHQgPSBcIm51bWJlclwiO1xuICAgICAgc291cmNlLmVhdCgvWy0rXS8pO1xuICAgICAgc291cmNlLmVhdFdoaWxlKGRpZ2l0UkUpOyAvLyBzaG91bGQgcmVxdWlyZSBhdCBsZWFzdCAxXG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG5cbiAgaWYgKGNoID09IFwiLlwiICYmIHNvdXJjZS5lYXQoXCIuXCIpKVxuICAgIHJldHVybiBcImtleXdvcmRcIjtcblxuICBpZiAoc3ltYm9sUkUudGVzdChjaCkpIHtcbiAgICBpZiAoY2ggPT0gJy0nICYmIHNvdXJjZS5lYXQoLy0vKSkge1xuICAgICAgc291cmNlLmVhdFdoaWxlKC8tLyk7XG4gICAgICBpZiAoIXNvdXJjZS5lYXQoc3ltYm9sUkUpKSB7XG4gICAgICAgIHNvdXJjZS5za2lwVG9FbmQoKTtcbiAgICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2UuZWF0V2hpbGUoc3ltYm9sUkUpO1xuICAgIHJldHVybiBcInZhcmlhYmxlXCJcbiAgfVxuXG4gIHJldHVybiBcImVycm9yXCI7XG59XG5cbmZ1bmN0aW9uIG5jb21tZW50KHR5cGUsIG5lc3QpIHtcbiAgaWYgKG5lc3QgPT0gMCkge1xuICAgIHJldHVybiBub3JtYWw7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSwgc2V0U3RhdGUpIHtcbiAgICB2YXIgY3Vyck5lc3QgPSBuZXN0O1xuICAgIHdoaWxlICghc291cmNlLmVvbCgpKSB7XG4gICAgICB2YXIgY2ggPSBzb3VyY2UubmV4dCgpO1xuICAgICAgaWYgKGNoID09ICd7JyAmJiBzb3VyY2UuZWF0KCctJykpIHtcbiAgICAgICAgKytjdXJyTmVzdDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGNoID09ICctJyAmJiBzb3VyY2UuZWF0KCd9JykpIHtcbiAgICAgICAgLS1jdXJyTmVzdDtcbiAgICAgICAgaWYgKGN1cnJOZXN0ID09IDApIHtcbiAgICAgICAgICBzZXRTdGF0ZShub3JtYWwpO1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHNldFN0YXRlKG5jb21tZW50KHR5cGUsIGN1cnJOZXN0KSk7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmluZ0xpdGVyYWwoc291cmNlLCBzZXRTdGF0ZSkge1xuICB3aGlsZSAoIXNvdXJjZS5lb2woKSkge1xuICAgIHZhciBjaCA9IHNvdXJjZS5uZXh0KCk7XG4gICAgaWYgKGNoID09ICdcIicpIHtcbiAgICAgIHNldFN0YXRlKG5vcm1hbCk7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKGNoID09ICdcXFxcJykge1xuICAgICAgaWYgKHNvdXJjZS5lb2woKSB8fCBzb3VyY2UuZWF0KHdoaXRlQ2hhclJFKSkge1xuICAgICAgICBzZXRTdGF0ZShzdHJpbmdHYXApO1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgIH1cbiAgICAgIGlmIChzb3VyY2UuZWF0KCcmJykpIHtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzb3VyY2UubmV4dCgpOyAvLyBzaG91bGQgaGFuZGxlIG90aGVyIGVzY2FwZXMgaGVyZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRTdGF0ZShub3JtYWwpO1xuICByZXR1cm4gXCJlcnJvclwiO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdHYXAoc291cmNlLCBzZXRTdGF0ZSkge1xuICBpZiAoc291cmNlLmVhdCgnXFxcXCcpKSB7XG4gICAgcmV0dXJuIHN3aXRjaFN0YXRlKHNvdXJjZSwgc2V0U3RhdGUsIHN0cmluZ0xpdGVyYWwpO1xuICB9XG4gIHNvdXJjZS5uZXh0KCk7XG4gIHNldFN0YXRlKG5vcm1hbCk7XG4gIHJldHVybiBcImVycm9yXCI7XG59XG5cblxudmFyIHdlbGxLbm93bldvcmRzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgd2t3ID0ge307XG4gIGZ1bmN0aW9uIHNldFR5cGUodCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgd2t3W2FyZ3VtZW50c1tpXV0gPSB0O1xuICAgIH07XG4gIH1cblxuICBzZXRUeXBlKFwia2V5d29yZFwiKShcbiAgICBcImNhc2VcIiwgXCJjbGFzc1wiLCBcImRhdGFcIiwgXCJkZWZhdWx0XCIsIFwiZGVyaXZpbmdcIiwgXCJkb1wiLCBcImVsc2VcIiwgXCJmb3JlaWduXCIsXG4gICAgXCJpZlwiLCBcImltcG9ydFwiLCBcImluXCIsIFwiaW5maXhcIiwgXCJpbmZpeGxcIiwgXCJpbmZpeHJcIiwgXCJpbnN0YW5jZVwiLCBcImxldFwiLFxuICAgIFwibW9kdWxlXCIsIFwibmV3dHlwZVwiLCBcIm9mXCIsIFwidGhlblwiLCBcInR5cGVcIiwgXCJ3aGVyZVwiLCBcIl9cIik7XG5cbiAgc2V0VHlwZShcImtleXdvcmRcIikoXG4gICAgXCJcXC5cXC5cIiwgXCI6XCIsIFwiOjpcIiwgXCI9XCIsIFwiXFxcXFwiLCBcIjwtXCIsIFwiLT5cIiwgXCJAXCIsIFwiflwiLCBcIj0+XCIpO1xuXG4gIHNldFR5cGUoXCJidWlsdGluXCIpKFxuICAgIFwiISFcIiwgXCIkIVwiLCBcIiRcIiwgXCImJlwiLCBcIitcIiwgXCIrK1wiLCBcIi1cIiwgXCIuXCIsIFwiL1wiLCBcIi89XCIsIFwiPFwiLCBcIjwqXCIsIFwiPD1cIixcbiAgICBcIjwkPlwiLCBcIjwqPlwiLCBcIj08PFwiLCBcIj09XCIsIFwiPlwiLCBcIj49XCIsIFwiPj5cIiwgXCI+Pj1cIiwgXCJeXCIsIFwiXl5cIiwgXCJ8fFwiLCBcIipcIixcbiAgICBcIio+XCIsIFwiKipcIik7XG5cbiAgc2V0VHlwZShcImJ1aWx0aW5cIikoXG4gICAgXCJBcHBsaWNhdGl2ZVwiLCBcIkJvb2xcIiwgXCJCb3VuZGVkXCIsIFwiQ2hhclwiLCBcIkRvdWJsZVwiLCBcIkVRXCIsIFwiRWl0aGVyXCIsIFwiRW51bVwiLFxuICAgIFwiRXFcIiwgXCJGYWxzZVwiLCBcIkZpbGVQYXRoXCIsIFwiRmxvYXRcIiwgXCJGbG9hdGluZ1wiLCBcIkZyYWN0aW9uYWxcIiwgXCJGdW5jdG9yXCIsXG4gICAgXCJHVFwiLCBcIklPXCIsIFwiSU9FcnJvclwiLCBcIkludFwiLCBcIkludGVnZXJcIiwgXCJJbnRlZ3JhbFwiLCBcIkp1c3RcIiwgXCJMVFwiLCBcIkxlZnRcIixcbiAgICBcIk1heWJlXCIsIFwiTW9uYWRcIiwgXCJOb3RoaW5nXCIsIFwiTnVtXCIsIFwiT3JkXCIsIFwiT3JkZXJpbmdcIiwgXCJSYXRpb25hbFwiLCBcIlJlYWRcIixcbiAgICBcIlJlYWRTXCIsIFwiUmVhbFwiLCBcIlJlYWxGbG9hdFwiLCBcIlJlYWxGcmFjXCIsIFwiUmlnaHRcIiwgXCJTaG93XCIsIFwiU2hvd1NcIixcbiAgICBcIlN0cmluZ1wiLCBcIlRydWVcIik7XG5cbiAgc2V0VHlwZShcImJ1aWx0aW5cIikoXG4gICAgXCJhYnNcIiwgXCJhY29zXCIsIFwiYWNvc2hcIiwgXCJhbGxcIiwgXCJhbmRcIiwgXCJhbnlcIiwgXCJhcHBlbmRGaWxlXCIsIFwiYXNUeXBlT2ZcIixcbiAgICBcImFzaW5cIiwgXCJhc2luaFwiLCBcImF0YW5cIiwgXCJhdGFuMlwiLCBcImF0YW5oXCIsIFwiYnJlYWtcIiwgXCJjYXRjaFwiLCBcImNlaWxpbmdcIixcbiAgICBcImNvbXBhcmVcIiwgXCJjb25jYXRcIiwgXCJjb25jYXRNYXBcIiwgXCJjb25zdFwiLCBcImNvc1wiLCBcImNvc2hcIiwgXCJjdXJyeVwiLFxuICAgIFwiY3ljbGVcIiwgXCJkZWNvZGVGbG9hdFwiLCBcImRpdlwiLCBcImRpdk1vZFwiLCBcImRyb3BcIiwgXCJkcm9wV2hpbGVcIiwgXCJlaXRoZXJcIixcbiAgICBcImVsZW1cIiwgXCJlbmNvZGVGbG9hdFwiLCBcImVudW1Gcm9tXCIsIFwiZW51bUZyb21UaGVuXCIsIFwiZW51bUZyb21UaGVuVG9cIixcbiAgICBcImVudW1Gcm9tVG9cIiwgXCJlcnJvclwiLCBcImV2ZW5cIiwgXCJleHBcIiwgXCJleHBvbmVudFwiLCBcImZhaWxcIiwgXCJmaWx0ZXJcIixcbiAgICBcImZsaXBcIiwgXCJmbG9hdERpZ2l0c1wiLCBcImZsb2F0UmFkaXhcIiwgXCJmbG9hdFJhbmdlXCIsIFwiZmxvb3JcIiwgXCJmbWFwXCIsXG4gICAgXCJmb2xkbFwiLCBcImZvbGRsMVwiLCBcImZvbGRyXCIsIFwiZm9sZHIxXCIsIFwiZnJvbUVudW1cIiwgXCJmcm9tSW50ZWdlclwiLFxuICAgIFwiZnJvbUludGVncmFsXCIsIFwiZnJvbVJhdGlvbmFsXCIsIFwiZnN0XCIsIFwiZ2NkXCIsIFwiZ2V0Q2hhclwiLCBcImdldENvbnRlbnRzXCIsXG4gICAgXCJnZXRMaW5lXCIsIFwiaGVhZFwiLCBcImlkXCIsIFwiaW5pdFwiLCBcImludGVyYWN0XCIsIFwiaW9FcnJvclwiLCBcImlzRGVub3JtYWxpemVkXCIsXG4gICAgXCJpc0lFRUVcIiwgXCJpc0luZmluaXRlXCIsIFwiaXNOYU5cIiwgXCJpc05lZ2F0aXZlWmVyb1wiLCBcIml0ZXJhdGVcIiwgXCJsYXN0XCIsXG4gICAgXCJsY21cIiwgXCJsZW5ndGhcIiwgXCJsZXhcIiwgXCJsaW5lc1wiLCBcImxvZ1wiLCBcImxvZ0Jhc2VcIiwgXCJsb29rdXBcIiwgXCJtYXBcIixcbiAgICBcIm1hcE1cIiwgXCJtYXBNX1wiLCBcIm1heFwiLCBcIm1heEJvdW5kXCIsIFwibWF4aW11bVwiLCBcIm1heWJlXCIsIFwibWluXCIsIFwibWluQm91bmRcIixcbiAgICBcIm1pbmltdW1cIiwgXCJtb2RcIiwgXCJuZWdhdGVcIiwgXCJub3RcIiwgXCJub3RFbGVtXCIsIFwibnVsbFwiLCBcIm9kZFwiLCBcIm9yXCIsXG4gICAgXCJvdGhlcndpc2VcIiwgXCJwaVwiLCBcInByZWRcIiwgXCJwcmludFwiLCBcInByb2R1Y3RcIiwgXCJwcm9wZXJGcmFjdGlvblwiLCBcInB1cmVcIixcbiAgICBcInB1dENoYXJcIiwgXCJwdXRTdHJcIiwgXCJwdXRTdHJMblwiLCBcInF1b3RcIiwgXCJxdW90UmVtXCIsIFwicmVhZFwiLCBcInJlYWRGaWxlXCIsXG4gICAgXCJyZWFkSU9cIiwgXCJyZWFkTGlzdFwiLCBcInJlYWRMblwiLCBcInJlYWRQYXJlblwiLCBcInJlYWRzXCIsIFwicmVhZHNQcmVjXCIsXG4gICAgXCJyZWFsVG9GcmFjXCIsIFwicmVjaXBcIiwgXCJyZW1cIiwgXCJyZXBlYXRcIiwgXCJyZXBsaWNhdGVcIiwgXCJyZXR1cm5cIiwgXCJyZXZlcnNlXCIsXG4gICAgXCJyb3VuZFwiLCBcInNjYWxlRmxvYXRcIiwgXCJzY2FubFwiLCBcInNjYW5sMVwiLCBcInNjYW5yXCIsIFwic2NhbnIxXCIsIFwic2VxXCIsXG4gICAgXCJzZXF1ZW5jZVwiLCBcInNlcXVlbmNlX1wiLCBcInNob3dcIiwgXCJzaG93Q2hhclwiLCBcInNob3dMaXN0XCIsIFwic2hvd1BhcmVuXCIsXG4gICAgXCJzaG93U3RyaW5nXCIsIFwic2hvd3NcIiwgXCJzaG93c1ByZWNcIiwgXCJzaWduaWZpY2FuZFwiLCBcInNpZ251bVwiLCBcInNpblwiLFxuICAgIFwic2luaFwiLCBcInNuZFwiLCBcInNwYW5cIiwgXCJzcGxpdEF0XCIsIFwic3FydFwiLCBcInN1YnRyYWN0XCIsIFwic3VjY1wiLCBcInN1bVwiLFxuICAgIFwidGFpbFwiLCBcInRha2VcIiwgXCJ0YWtlV2hpbGVcIiwgXCJ0YW5cIiwgXCJ0YW5oXCIsIFwidG9FbnVtXCIsIFwidG9JbnRlZ2VyXCIsXG4gICAgXCJ0b1JhdGlvbmFsXCIsIFwidHJ1bmNhdGVcIiwgXCJ1bmN1cnJ5XCIsIFwidW5kZWZpbmVkXCIsIFwidW5saW5lc1wiLCBcInVudGlsXCIsXG4gICAgXCJ1bndvcmRzXCIsIFwidW56aXBcIiwgXCJ1bnppcDNcIiwgXCJ1c2VyRXJyb3JcIiwgXCJ3b3Jkc1wiLCBcIndyaXRlRmlsZVwiLCBcInppcFwiLFxuICAgIFwiemlwM1wiLCBcInppcFdpdGhcIiwgXCJ6aXBXaXRoM1wiKTtcblxuICByZXR1cm4gd2t3O1xufSkoKTtcblxuZXhwb3J0IGNvbnN0IGhhc2tlbGwgPSB7XG4gIG5hbWU6IFwiaGFza2VsbFwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSAgeyByZXR1cm4geyBmOiBub3JtYWwgfTsgfSxcbiAgY29weVN0YXRlOiAgZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHsgZjogcy5mIH07IH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB2YXIgdCA9IHN0YXRlLmYoc3RyZWFtLCBmdW5jdGlvbihzKSB7IHN0YXRlLmYgPSBzOyB9KTtcbiAgICB2YXIgdyA9IHN0cmVhbS5jdXJyZW50KCk7XG4gICAgcmV0dXJuIHdlbGxLbm93bldvcmRzLmhhc093blByb3BlcnR5KHcpID8gd2VsbEtub3duV29yZHNbd10gOiB0O1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi0tXCIsIGJsb2NrOiB7b3BlbjogXCJ7LVwiLCBjbG9zZTogXCItfVwifX1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==