"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_smalltalk_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/smalltalk.js":
/*!******************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/smalltalk.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "smalltalk": () => (/* binding */ smalltalk)
/* harmony export */ });
var specialChars = /[+\-\/\\*~<>=@%|&?!.,:;^]/;
var keywords = /true|false|nil|self|super|thisContext/;

var Context = function(tokenizer, parent) {
  this.next = tokenizer;
  this.parent = parent;
};

var Token = function(name, context, eos) {
  this.name = name;
  this.context = context;
  this.eos = eos;
};

var State = function() {
  this.context = new Context(next, null);
  this.expectVariable = true;
  this.indentation = 0;
  this.userIndentationDelta = 0;
};

State.prototype.userIndent = function(indentation, indentUnit) {
  this.userIndentationDelta = indentation > 0 ? (indentation / indentUnit - this.indentation) : 0;
};

var next = function(stream, context, state) {
  var token = new Token(null, context, false);
  var aChar = stream.next();

  if (aChar === '"') {
    token = nextComment(stream, new Context(nextComment, context));

  } else if (aChar === '\'') {
    token = nextString(stream, new Context(nextString, context));

  } else if (aChar === '#') {
    if (stream.peek() === '\'') {
      stream.next();
      token = nextSymbol(stream, new Context(nextSymbol, context));
    } else {
      if (stream.eatWhile(/[^\s.{}\[\]()]/))
        token.name = 'string.special';
      else
        token.name = 'meta';
    }

  } else if (aChar === '$') {
    if (stream.next() === '<') {
      stream.eatWhile(/[^\s>]/);
      stream.next();
    }
    token.name = 'string.special';

  } else if (aChar === '|' && state.expectVariable) {
    token.context = new Context(nextTemporaries, context);

  } else if (/[\[\]{}()]/.test(aChar)) {
    token.name = 'bracket';
    token.eos = /[\[{(]/.test(aChar);

    if (aChar === '[') {
      state.indentation++;
    } else if (aChar === ']') {
      state.indentation = Math.max(0, state.indentation - 1);
    }

  } else if (specialChars.test(aChar)) {
    stream.eatWhile(specialChars);
    token.name = 'operator';
    token.eos = aChar !== ';'; // ; cascaded message expression

  } else if (/\d/.test(aChar)) {
    stream.eatWhile(/[\w\d]/);
    token.name = 'number';

  } else if (/[\w_]/.test(aChar)) {
    stream.eatWhile(/[\w\d_]/);
    token.name = state.expectVariable ? (keywords.test(stream.current()) ? 'keyword' : 'variable') : null;

  } else {
    token.eos = state.expectVariable;
  }

  return token;
};

var nextComment = function(stream, context) {
  stream.eatWhile(/[^"]/);
  return new Token('comment', stream.eat('"') ? context.parent : context, true);
};

var nextString = function(stream, context) {
  stream.eatWhile(/[^']/);
  return new Token('string', stream.eat('\'') ? context.parent : context, false);
};

var nextSymbol = function(stream, context) {
  stream.eatWhile(/[^']/);
  return new Token('string.special', stream.eat('\'') ? context.parent : context, false);
};

var nextTemporaries = function(stream, context) {
  var token = new Token(null, context, false);
  var aChar = stream.next();

  if (aChar === '|') {
    token.context = context.parent;
    token.eos = true;

  } else {
    stream.eatWhile(/[^|]/);
    token.name = 'variable';
  }

  return token;
};

const smalltalk = {
  name: "smalltalk",

  startState: function() {
    return new State;
  },

  token: function(stream, state) {
    state.userIndent(stream.indentation(), stream.indentUnit);

    if (stream.eatSpace()) {
      return null;
    }

    var token = state.context.next(stream, state.context, state);
    state.context = token.context;
    state.expectVariable = token.eos;

    return token.name;
  },

  blankLine: function(state, indentUnit) {
    state.userIndent(0, indentUnit);
  },

  indent: function(state, textAfter, cx) {
    var i = state.context.next === next && textAfter && textAfter.charAt(0) === ']' ? -1 : state.userIndentationDelta;
    return (state.indentation + i) * cx.unit;
  },

  languageData: {
    indentOnInput: /^\s*\]$/
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfc21hbGx0YWxrX2pzLjBmNDMwZmNlNTJhODc4ZTllOWY3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQ0FBMkM7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7O0FBRUEsSUFBSSxpQkFBaUI7QUFDckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDRCQUE0QixHQUFHLEtBQUs7O0FBRXBDLElBQUk7QUFDSjtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3NtYWxsdGFsay5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc3BlY2lhbENoYXJzID0gL1srXFwtXFwvXFxcXCp+PD49QCV8Jj8hLiw6O15dLztcbnZhciBrZXl3b3JkcyA9IC90cnVlfGZhbHNlfG5pbHxzZWxmfHN1cGVyfHRoaXNDb250ZXh0LztcblxudmFyIENvbnRleHQgPSBmdW5jdGlvbih0b2tlbml6ZXIsIHBhcmVudCkge1xuICB0aGlzLm5leHQgPSB0b2tlbml6ZXI7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xufTtcblxudmFyIFRva2VuID0gZnVuY3Rpb24obmFtZSwgY29udGV4dCwgZW9zKSB7XG4gIHRoaXMubmFtZSA9IG5hbWU7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZW9zID0gZW9zO1xufTtcblxudmFyIFN0YXRlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29udGV4dCA9IG5ldyBDb250ZXh0KG5leHQsIG51bGwpO1xuICB0aGlzLmV4cGVjdFZhcmlhYmxlID0gdHJ1ZTtcbiAgdGhpcy5pbmRlbnRhdGlvbiA9IDA7XG4gIHRoaXMudXNlckluZGVudGF0aW9uRGVsdGEgPSAwO1xufTtcblxuU3RhdGUucHJvdG90eXBlLnVzZXJJbmRlbnQgPSBmdW5jdGlvbihpbmRlbnRhdGlvbiwgaW5kZW50VW5pdCkge1xuICB0aGlzLnVzZXJJbmRlbnRhdGlvbkRlbHRhID0gaW5kZW50YXRpb24gPiAwID8gKGluZGVudGF0aW9uIC8gaW5kZW50VW5pdCAtIHRoaXMuaW5kZW50YXRpb24pIDogMDtcbn07XG5cbnZhciBuZXh0ID0gZnVuY3Rpb24oc3RyZWFtLCBjb250ZXh0LCBzdGF0ZSkge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4obnVsbCwgY29udGV4dCwgZmFsc2UpO1xuICB2YXIgYUNoYXIgPSBzdHJlYW0ubmV4dCgpO1xuXG4gIGlmIChhQ2hhciA9PT0gJ1wiJykge1xuICAgIHRva2VuID0gbmV4dENvbW1lbnQoc3RyZWFtLCBuZXcgQ29udGV4dChuZXh0Q29tbWVudCwgY29udGV4dCkpO1xuXG4gIH0gZWxzZSBpZiAoYUNoYXIgPT09ICdcXCcnKSB7XG4gICAgdG9rZW4gPSBuZXh0U3RyaW5nKHN0cmVhbSwgbmV3IENvbnRleHQobmV4dFN0cmluZywgY29udGV4dCkpO1xuXG4gIH0gZWxzZSBpZiAoYUNoYXIgPT09ICcjJykge1xuICAgIGlmIChzdHJlYW0ucGVlaygpID09PSAnXFwnJykge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHRva2VuID0gbmV4dFN5bWJvbChzdHJlYW0sIG5ldyBDb250ZXh0KG5leHRTeW1ib2wsIGNvbnRleHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0cmVhbS5lYXRXaGlsZSgvW15cXHMue31cXFtcXF0oKV0vKSlcbiAgICAgICAgdG9rZW4ubmFtZSA9ICdzdHJpbmcuc3BlY2lhbCc7XG4gICAgICBlbHNlXG4gICAgICAgIHRva2VuLm5hbWUgPSAnbWV0YSc7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoYUNoYXIgPT09ICckJykge1xuICAgIGlmIChzdHJlYW0ubmV4dCgpID09PSAnPCcpIHtcbiAgICAgIHN0cmVhbS5lYXRXaGlsZSgvW15cXHM+XS8pO1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICB9XG4gICAgdG9rZW4ubmFtZSA9ICdzdHJpbmcuc3BlY2lhbCc7XG5cbiAgfSBlbHNlIGlmIChhQ2hhciA9PT0gJ3wnICYmIHN0YXRlLmV4cGVjdFZhcmlhYmxlKSB7XG4gICAgdG9rZW4uY29udGV4dCA9IG5ldyBDb250ZXh0KG5leHRUZW1wb3JhcmllcywgY29udGV4dCk7XG5cbiAgfSBlbHNlIGlmICgvW1xcW1xcXXt9KCldLy50ZXN0KGFDaGFyKSkge1xuICAgIHRva2VuLm5hbWUgPSAnYnJhY2tldCc7XG4gICAgdG9rZW4uZW9zID0gL1tcXFt7KF0vLnRlc3QoYUNoYXIpO1xuXG4gICAgaWYgKGFDaGFyID09PSAnWycpIHtcbiAgICAgIHN0YXRlLmluZGVudGF0aW9uKys7XG4gICAgfSBlbHNlIGlmIChhQ2hhciA9PT0gJ10nKSB7XG4gICAgICBzdGF0ZS5pbmRlbnRhdGlvbiA9IE1hdGgubWF4KDAsIHN0YXRlLmluZGVudGF0aW9uIC0gMSk7XG4gICAgfVxuXG4gIH0gZWxzZSBpZiAoc3BlY2lhbENoYXJzLnRlc3QoYUNoYXIpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKHNwZWNpYWxDaGFycyk7XG4gICAgdG9rZW4ubmFtZSA9ICdvcGVyYXRvcic7XG4gICAgdG9rZW4uZW9zID0gYUNoYXIgIT09ICc7JzsgLy8gOyBjYXNjYWRlZCBtZXNzYWdlIGV4cHJlc3Npb25cblxuICB9IGVsc2UgaWYgKC9cXGQvLnRlc3QoYUNoYXIpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxkXS8pO1xuICAgIHRva2VuLm5hbWUgPSAnbnVtYmVyJztcblxuICB9IGVsc2UgaWYgKC9bXFx3X10vLnRlc3QoYUNoYXIpKSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFxkX10vKTtcbiAgICB0b2tlbi5uYW1lID0gc3RhdGUuZXhwZWN0VmFyaWFibGUgPyAoa2V5d29yZHMudGVzdChzdHJlYW0uY3VycmVudCgpKSA/ICdrZXl3b3JkJyA6ICd2YXJpYWJsZScpIDogbnVsbDtcblxuICB9IGVsc2Uge1xuICAgIHRva2VuLmVvcyA9IHN0YXRlLmV4cGVjdFZhcmlhYmxlO1xuICB9XG5cbiAgcmV0dXJuIHRva2VuO1xufTtcblxudmFyIG5leHRDb21tZW50ID0gZnVuY3Rpb24oc3RyZWFtLCBjb250ZXh0KSB7XG4gIHN0cmVhbS5lYXRXaGlsZSgvW15cIl0vKTtcbiAgcmV0dXJuIG5ldyBUb2tlbignY29tbWVudCcsIHN0cmVhbS5lYXQoJ1wiJykgPyBjb250ZXh0LnBhcmVudCA6IGNvbnRleHQsIHRydWUpO1xufTtcblxudmFyIG5leHRTdHJpbmcgPSBmdW5jdGlvbihzdHJlYW0sIGNvbnRleHQpIHtcbiAgc3RyZWFtLmVhdFdoaWxlKC9bXiddLyk7XG4gIHJldHVybiBuZXcgVG9rZW4oJ3N0cmluZycsIHN0cmVhbS5lYXQoJ1xcJycpID8gY29udGV4dC5wYXJlbnQgOiBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG52YXIgbmV4dFN5bWJvbCA9IGZ1bmN0aW9uKHN0cmVhbSwgY29udGV4dCkge1xuICBzdHJlYW0uZWF0V2hpbGUoL1teJ10vKTtcbiAgcmV0dXJuIG5ldyBUb2tlbignc3RyaW5nLnNwZWNpYWwnLCBzdHJlYW0uZWF0KCdcXCcnKSA/IGNvbnRleHQucGFyZW50IDogY29udGV4dCwgZmFsc2UpO1xufTtcblxudmFyIG5leHRUZW1wb3JhcmllcyA9IGZ1bmN0aW9uKHN0cmVhbSwgY29udGV4dCkge1xuICB2YXIgdG9rZW4gPSBuZXcgVG9rZW4obnVsbCwgY29udGV4dCwgZmFsc2UpO1xuICB2YXIgYUNoYXIgPSBzdHJlYW0ubmV4dCgpO1xuXG4gIGlmIChhQ2hhciA9PT0gJ3wnKSB7XG4gICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQucGFyZW50O1xuICAgIHRva2VuLmVvcyA9IHRydWU7XG5cbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1tefF0vKTtcbiAgICB0b2tlbi5uYW1lID0gJ3ZhcmlhYmxlJztcbiAgfVxuXG4gIHJldHVybiB0b2tlbjtcbn07XG5cbmV4cG9ydCBjb25zdCBzbWFsbHRhbGsgPSB7XG4gIG5hbWU6IFwic21hbGx0YWxrXCIsXG5cbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBTdGF0ZTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0YXRlLnVzZXJJbmRlbnQoc3RyZWFtLmluZGVudGF0aW9uKCksIHN0cmVhbS5pbmRlbnRVbml0KTtcblxuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRva2VuID0gc3RhdGUuY29udGV4dC5uZXh0KHN0cmVhbSwgc3RhdGUuY29udGV4dCwgc3RhdGUpO1xuICAgIHN0YXRlLmNvbnRleHQgPSB0b2tlbi5jb250ZXh0O1xuICAgIHN0YXRlLmV4cGVjdFZhcmlhYmxlID0gdG9rZW4uZW9zO1xuXG4gICAgcmV0dXJuIHRva2VuLm5hbWU7XG4gIH0sXG5cbiAgYmxhbmtMaW5lOiBmdW5jdGlvbihzdGF0ZSwgaW5kZW50VW5pdCkge1xuICAgIHN0YXRlLnVzZXJJbmRlbnQoMCwgaW5kZW50VW5pdCk7XG4gIH0sXG5cbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgIHZhciBpID0gc3RhdGUuY29udGV4dC5uZXh0ID09PSBuZXh0ICYmIHRleHRBZnRlciAmJiB0ZXh0QWZ0ZXIuY2hhckF0KDApID09PSAnXScgPyAtMSA6IHN0YXRlLnVzZXJJbmRlbnRhdGlvbkRlbHRhO1xuICAgIHJldHVybiAoc3RhdGUuaW5kZW50YXRpb24gKyBpKSAqIGN4LnVuaXQ7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqXFxdJC9cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9