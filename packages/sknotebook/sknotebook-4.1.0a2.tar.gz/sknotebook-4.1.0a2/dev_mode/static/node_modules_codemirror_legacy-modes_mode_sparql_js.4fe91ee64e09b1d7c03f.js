"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_sparql_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/sparql.js":
/*!***************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/sparql.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "sparql": () => (/* binding */ sparql)
/* harmony export */ });
var curPunc;

function wordRegexp(words) {
  return new RegExp("^(?:" + words.join("|") + ")$", "i");
}
var ops = wordRegexp(["str", "lang", "langmatches", "datatype", "bound", "sameterm", "isiri", "isuri",
                      "iri", "uri", "bnode", "count", "sum", "min", "max", "avg", "sample",
                      "group_concat", "rand", "abs", "ceil", "floor", "round", "concat", "substr", "strlen",
                      "replace", "ucase", "lcase", "encode_for_uri", "contains", "strstarts", "strends",
                      "strbefore", "strafter", "year", "month", "day", "hours", "minutes", "seconds",
                      "timezone", "tz", "now", "uuid", "struuid", "md5", "sha1", "sha256", "sha384",
                      "sha512", "coalesce", "if", "strlang", "strdt", "isnumeric", "regex", "exists",
                      "isblank", "isliteral", "a", "bind"]);
var keywords = wordRegexp(["base", "prefix", "select", "distinct", "reduced", "construct", "describe",
                           "ask", "from", "named", "where", "order", "limit", "offset", "filter", "optional",
                           "graph", "by", "asc", "desc", "as", "having", "undef", "values", "group",
                           "minus", "in", "not", "service", "silent", "using", "insert", "delete", "union",
                           "true", "false", "with",
                           "data", "copy", "to", "move", "add", "create", "drop", "clear", "load", "into"]);
var operatorChars = /[*+\-<>=&|\^\/!\?]/;

function tokenBase(stream, state) {
  var ch = stream.next();
  curPunc = null;
  if (ch == "$" || ch == "?") {
    if(ch == "?" && stream.match(/\s/, false)){
      return "operator";
    }
    stream.match(/^[A-Za-z0-9_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][A-Za-z0-9_\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]*/);
    return "variableName.local";
  }
  else if (ch == "<" && !stream.match(/^[\s\u00a0=]/, false)) {
    stream.match(/^[^\s\u00a0>]*>?/);
    return "atom";
  }
  else if (ch == "\"" || ch == "'") {
    state.tokenize = tokenLiteral(ch);
    return state.tokenize(stream, state);
  }
  else if (/[{}\(\),\.;\[\]]/.test(ch)) {
    curPunc = ch;
    return "bracket";
  }
  else if (ch == "#") {
    stream.skipToEnd();
    return "comment";
  }
  else if (operatorChars.test(ch)) {
    return "operator";
  }
  else if (ch == ":") {
    eatPnLocal(stream);
    return "atom";
  }
  else if (ch == "@") {
    stream.eatWhile(/[a-z\d\-]/i);
    return "meta";
  }
  else {
    stream.eatWhile(/[_\w\d]/);
    if (stream.eat(":")) {
      eatPnLocal(stream);
      return "atom";
    }
    var word = stream.current();
    if (ops.test(word))
      return "builtin";
    else if (keywords.test(word))
      return "keyword";
    else
      return "variable";
  }
}

function eatPnLocal(stream) {
  stream.match(/(\.(?=[\w_\-\\%])|[:\w_-]|\\[-\\_~.!$&'()*+,;=/?#@%]|%[a-f\d][a-f\d])+/i);
}

function tokenLiteral(quote) {
  return function(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == quote && !escaped) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && ch == "\\";
    }
    return "string";
  };
}

function pushContext(state, type, col) {
  state.context = {prev: state.context, indent: state.indent, col: col, type: type};
}
function popContext(state) {
  state.indent = state.context.indent;
  state.context = state.context.prev;
}

const sparql = {
  name: "sparql",

  startState: function() {
    return {tokenize: tokenBase,
            context: null,
            indent: 0,
            col: 0};
  },

  token: function(stream, state) {
    if (stream.sol()) {
      if (state.context && state.context.align == null) state.context.align = false;
      state.indent = stream.indentation();
    }
    if (stream.eatSpace()) return null;
    var style = state.tokenize(stream, state);

    if (style != "comment" && state.context && state.context.align == null && state.context.type != "pattern") {
      state.context.align = true;
    }

    if (curPunc == "(") pushContext(state, ")", stream.column());
    else if (curPunc == "[") pushContext(state, "]", stream.column());
    else if (curPunc == "{") pushContext(state, "}", stream.column());
    else if (/[\]\}\)]/.test(curPunc)) {
      while (state.context && state.context.type == "pattern") popContext(state);
      if (state.context && curPunc == state.context.type) {
        popContext(state);
        if (curPunc == "}" && state.context && state.context.type == "pattern")
          popContext(state);
      }
    }
    else if (curPunc == "." && state.context && state.context.type == "pattern") popContext(state);
    else if (/atom|string|variable/.test(style) && state.context) {
      if (/[\}\]]/.test(state.context.type))
        pushContext(state, "pattern", stream.column());
      else if (state.context.type == "pattern" && !state.context.align) {
        state.context.align = true;
        state.context.col = stream.column();
      }
    }

    return style;
  },

  indent: function(state, textAfter, cx) {
    var firstChar = textAfter && textAfter.charAt(0);
    var context = state.context;
    if (/[\]\}]/.test(firstChar))
      while (context && context.type == "pattern") context = context.prev;

    var closing = context && firstChar == context.type;
    if (!context)
      return 0;
    else if (context.type == "pattern")
      return context.col;
    else if (context.align)
      return context.col + (closing ? 0 : 1);
    else
      return context.indent + (closing ? 0 : cx.unit);
  },

  languageData: {
    commentTokens: {line: "#"}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfc3BhcnFsX2pzLjRmZTkxZWU2NGUwOWIxZDdjMDNmLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvc3BhcnFsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjdXJQdW5jO1xuXG5mdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMuam9pbihcInxcIikgKyBcIikkXCIsIFwiaVwiKTtcbn1cbnZhciBvcHMgPSB3b3JkUmVnZXhwKFtcInN0clwiLCBcImxhbmdcIiwgXCJsYW5nbWF0Y2hlc1wiLCBcImRhdGF0eXBlXCIsIFwiYm91bmRcIiwgXCJzYW1ldGVybVwiLCBcImlzaXJpXCIsIFwiaXN1cmlcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImlyaVwiLCBcInVyaVwiLCBcImJub2RlXCIsIFwiY291bnRcIiwgXCJzdW1cIiwgXCJtaW5cIiwgXCJtYXhcIiwgXCJhdmdcIiwgXCJzYW1wbGVcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImdyb3VwX2NvbmNhdFwiLCBcInJhbmRcIiwgXCJhYnNcIiwgXCJjZWlsXCIsIFwiZmxvb3JcIiwgXCJyb3VuZFwiLCBcImNvbmNhdFwiLCBcInN1YnN0clwiLCBcInN0cmxlblwiLFxuICAgICAgICAgICAgICAgICAgICAgIFwicmVwbGFjZVwiLCBcInVjYXNlXCIsIFwibGNhc2VcIiwgXCJlbmNvZGVfZm9yX3VyaVwiLCBcImNvbnRhaW5zXCIsIFwic3Ryc3RhcnRzXCIsIFwic3RyZW5kc1wiLFxuICAgICAgICAgICAgICAgICAgICAgIFwic3RyYmVmb3JlXCIsIFwic3RyYWZ0ZXJcIiwgXCJ5ZWFyXCIsIFwibW9udGhcIiwgXCJkYXlcIiwgXCJob3Vyc1wiLCBcIm1pbnV0ZXNcIiwgXCJzZWNvbmRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0aW1lem9uZVwiLCBcInR6XCIsIFwibm93XCIsIFwidXVpZFwiLCBcInN0cnV1aWRcIiwgXCJtZDVcIiwgXCJzaGExXCIsIFwic2hhMjU2XCIsIFwic2hhMzg0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgXCJzaGE1MTJcIiwgXCJjb2FsZXNjZVwiLCBcImlmXCIsIFwic3RybGFuZ1wiLCBcInN0cmR0XCIsIFwiaXNudW1lcmljXCIsIFwicmVnZXhcIiwgXCJleGlzdHNcIixcbiAgICAgICAgICAgICAgICAgICAgICBcImlzYmxhbmtcIiwgXCJpc2xpdGVyYWxcIiwgXCJhXCIsIFwiYmluZFwiXSk7XG52YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKFtcImJhc2VcIiwgXCJwcmVmaXhcIiwgXCJzZWxlY3RcIiwgXCJkaXN0aW5jdFwiLCBcInJlZHVjZWRcIiwgXCJjb25zdHJ1Y3RcIiwgXCJkZXNjcmliZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJhc2tcIiwgXCJmcm9tXCIsIFwibmFtZWRcIiwgXCJ3aGVyZVwiLCBcIm9yZGVyXCIsIFwibGltaXRcIiwgXCJvZmZzZXRcIiwgXCJmaWx0ZXJcIiwgXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJncmFwaFwiLCBcImJ5XCIsIFwiYXNjXCIsIFwiZGVzY1wiLCBcImFzXCIsIFwiaGF2aW5nXCIsIFwidW5kZWZcIiwgXCJ2YWx1ZXNcIiwgXCJncm91cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJtaW51c1wiLCBcImluXCIsIFwibm90XCIsIFwic2VydmljZVwiLCBcInNpbGVudFwiLCBcInVzaW5nXCIsIFwiaW5zZXJ0XCIsIFwiZGVsZXRlXCIsIFwidW5pb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidHJ1ZVwiLCBcImZhbHNlXCIsIFwid2l0aFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJkYXRhXCIsIFwiY29weVwiLCBcInRvXCIsIFwibW92ZVwiLCBcImFkZFwiLCBcImNyZWF0ZVwiLCBcImRyb3BcIiwgXCJjbGVhclwiLCBcImxvYWRcIiwgXCJpbnRvXCJdKTtcbnZhciBvcGVyYXRvckNoYXJzID0gL1sqK1xcLTw+PSZ8XFxeXFwvIVxcP10vO1xuXG5mdW5jdGlvbiB0b2tlbkJhc2Uoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICBjdXJQdW5jID0gbnVsbDtcbiAgaWYgKGNoID09IFwiJFwiIHx8IGNoID09IFwiP1wiKSB7XG4gICAgaWYoY2ggPT0gXCI/XCIgJiYgc3RyZWFtLm1hdGNoKC9cXHMvLCBmYWxzZSkpe1xuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG4gICAgc3RyZWFtLm1hdGNoKC9eW0EtWmEtejAtOV9cXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdW0EtWmEtejAtOV9cXHUwMEI3XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjAzRi1cXHUyMDQwXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXSovKTtcbiAgICByZXR1cm4gXCJ2YXJpYWJsZU5hbWUubG9jYWxcIjtcbiAgfVxuICBlbHNlIGlmIChjaCA9PSBcIjxcIiAmJiAhc3RyZWFtLm1hdGNoKC9eW1xcc1xcdTAwYTA9XS8sIGZhbHNlKSkge1xuICAgIHN0cmVhbS5tYXRjaCgvXlteXFxzXFx1MDBhMD5dKj4/Lyk7XG4gICAgcmV0dXJuIFwiYXRvbVwiO1xuICB9XG4gIGVsc2UgaWYgKGNoID09IFwiXFxcIlwiIHx8IGNoID09IFwiJ1wiKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkxpdGVyYWwoY2gpO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuICBlbHNlIGlmICgvW3t9XFwoXFwpLFxcLjtcXFtcXF1dLy50ZXN0KGNoKSkge1xuICAgIGN1clB1bmMgPSBjaDtcbiAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gIH1cbiAgZWxzZSBpZiAoY2ggPT0gXCIjXCIpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG4gIGVsc2UgaWYgKG9wZXJhdG9yQ2hhcnMudGVzdChjaCkpIHtcbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9XG4gIGVsc2UgaWYgKGNoID09IFwiOlwiKSB7XG4gICAgZWF0UG5Mb2NhbChzdHJlYW0pO1xuICAgIHJldHVybiBcImF0b21cIjtcbiAgfVxuICBlbHNlIGlmIChjaCA9PSBcIkBcIikge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW2EtelxcZFxcLV0vaSk7XG4gICAgcmV0dXJuIFwibWV0YVwiO1xuICB9XG4gIGVsc2Uge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW19cXHdcXGRdLyk7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCI6XCIpKSB7XG4gICAgICBlYXRQbkxvY2FsKHN0cmVhbSk7XG4gICAgICByZXR1cm4gXCJhdG9tXCI7XG4gICAgfVxuICAgIHZhciB3b3JkID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICBpZiAob3BzLnRlc3Qod29yZCkpXG4gICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgZWxzZSBpZiAoa2V5d29yZHMudGVzdCh3b3JkKSlcbiAgICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVhdFBuTG9jYWwoc3RyZWFtKSB7XG4gIHN0cmVhbS5tYXRjaCgvKFxcLig/PVtcXHdfXFwtXFxcXCVdKXxbOlxcd18tXXxcXFxcWy1cXFxcX34uISQmJygpKissOz0vPyNAJV18JVthLWZcXGRdW2EtZlxcZF0pKy9pKTtcbn1cblxuZnVuY3Rpb24gdG9rZW5MaXRlcmFsKHF1b3RlKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZSwgY2g7XG4gICAgd2hpbGUgKChjaCA9IHN0cmVhbS5uZXh0KCkpICE9IG51bGwpIHtcbiAgICAgIGlmIChjaCA9PSBxdW90ZSAmJiAhZXNjYXBlZCkge1xuICAgICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlc2NhcGVkID0gIWVzY2FwZWQgJiYgY2ggPT0gXCJcXFxcXCI7XG4gICAgfVxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBwdXNoQ29udGV4dChzdGF0ZSwgdHlwZSwgY29sKSB7XG4gIHN0YXRlLmNvbnRleHQgPSB7cHJldjogc3RhdGUuY29udGV4dCwgaW5kZW50OiBzdGF0ZS5pbmRlbnQsIGNvbDogY29sLCB0eXBlOiB0eXBlfTtcbn1cbmZ1bmN0aW9uIHBvcENvbnRleHQoc3RhdGUpIHtcbiAgc3RhdGUuaW5kZW50ID0gc3RhdGUuY29udGV4dC5pbmRlbnQ7XG4gIHN0YXRlLmNvbnRleHQgPSBzdGF0ZS5jb250ZXh0LnByZXY7XG59XG5cbmV4cG9ydCBjb25zdCBzcGFycWwgPSB7XG4gIG5hbWU6IFwic3BhcnFsXCIsXG5cbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHt0b2tlbml6ZTogdG9rZW5CYXNlLFxuICAgICAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgICAgIGluZGVudDogMCxcbiAgICAgICAgICAgIGNvbDogMH07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICBpZiAoc3RhdGUuY29udGV4dCAmJiBzdGF0ZS5jb250ZXh0LmFsaWduID09IG51bGwpIHN0YXRlLmNvbnRleHQuYWxpZ24gPSBmYWxzZTtcbiAgICAgIHN0YXRlLmluZGVudCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0eWxlICE9IFwiY29tbWVudFwiICYmIHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC5hbGlnbiA9PSBudWxsICYmIHN0YXRlLmNvbnRleHQudHlwZSAhPSBcInBhdHRlcm5cIikge1xuICAgICAgc3RhdGUuY29udGV4dC5hbGlnbiA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGN1clB1bmMgPT0gXCIoXCIpIHB1c2hDb250ZXh0KHN0YXRlLCBcIilcIiwgc3RyZWFtLmNvbHVtbigpKTtcbiAgICBlbHNlIGlmIChjdXJQdW5jID09IFwiW1wiKSBwdXNoQ29udGV4dChzdGF0ZSwgXCJdXCIsIHN0cmVhbS5jb2x1bW4oKSk7XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIntcIikgcHVzaENvbnRleHQoc3RhdGUsIFwifVwiLCBzdHJlYW0uY29sdW1uKCkpO1xuICAgIGVsc2UgaWYgKC9bXFxdXFx9XFwpXS8udGVzdChjdXJQdW5jKSkge1xuICAgICAgd2hpbGUgKHN0YXRlLmNvbnRleHQgJiYgc3RhdGUuY29udGV4dC50eXBlID09IFwicGF0dGVyblwiKSBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIGlmIChzdGF0ZS5jb250ZXh0ICYmIGN1clB1bmMgPT0gc3RhdGUuY29udGV4dC50eXBlKSB7XG4gICAgICAgIHBvcENvbnRleHQoc3RhdGUpO1xuICAgICAgICBpZiAoY3VyUHVuYyA9PSBcIn1cIiAmJiBzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInBhdHRlcm5cIilcbiAgICAgICAgICBwb3BDb250ZXh0KHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY3VyUHVuYyA9PSBcIi5cIiAmJiBzdGF0ZS5jb250ZXh0ICYmIHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInBhdHRlcm5cIikgcG9wQ29udGV4dChzdGF0ZSk7XG4gICAgZWxzZSBpZiAoL2F0b218c3RyaW5nfHZhcmlhYmxlLy50ZXN0KHN0eWxlKSAmJiBzdGF0ZS5jb250ZXh0KSB7XG4gICAgICBpZiAoL1tcXH1cXF1dLy50ZXN0KHN0YXRlLmNvbnRleHQudHlwZSkpXG4gICAgICAgIHB1c2hDb250ZXh0KHN0YXRlLCBcInBhdHRlcm5cIiwgc3RyZWFtLmNvbHVtbigpKTtcbiAgICAgIGVsc2UgaWYgKHN0YXRlLmNvbnRleHQudHlwZSA9PSBcInBhdHRlcm5cIiAmJiAhc3RhdGUuY29udGV4dC5hbGlnbikge1xuICAgICAgICBzdGF0ZS5jb250ZXh0LmFsaWduID0gdHJ1ZTtcbiAgICAgICAgc3RhdGUuY29udGV4dC5jb2wgPSBzdHJlYW0uY29sdW1uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9LFxuXG4gIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIHRleHRBZnRlciwgY3gpIHtcbiAgICB2YXIgZmlyc3RDaGFyID0gdGV4dEFmdGVyICYmIHRleHRBZnRlci5jaGFyQXQoMCk7XG4gICAgdmFyIGNvbnRleHQgPSBzdGF0ZS5jb250ZXh0O1xuICAgIGlmICgvW1xcXVxcfV0vLnRlc3QoZmlyc3RDaGFyKSlcbiAgICAgIHdoaWxlIChjb250ZXh0ICYmIGNvbnRleHQudHlwZSA9PSBcInBhdHRlcm5cIikgY29udGV4dCA9IGNvbnRleHQucHJldjtcblxuICAgIHZhciBjbG9zaW5nID0gY29udGV4dCAmJiBmaXJzdENoYXIgPT0gY29udGV4dC50eXBlO1xuICAgIGlmICghY29udGV4dClcbiAgICAgIHJldHVybiAwO1xuICAgIGVsc2UgaWYgKGNvbnRleHQudHlwZSA9PSBcInBhdHRlcm5cIilcbiAgICAgIHJldHVybiBjb250ZXh0LmNvbDtcbiAgICBlbHNlIGlmIChjb250ZXh0LmFsaWduKVxuICAgICAgcmV0dXJuIGNvbnRleHQuY29sICsgKGNsb3NpbmcgPyAwIDogMSk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIGNvbnRleHQuaW5kZW50ICsgKGNsb3NpbmcgPyAwIDogY3gudW5pdCk7XG4gIH0sXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiI1wifVxuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=