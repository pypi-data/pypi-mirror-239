"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_spreadsheet_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/spreadsheet.js":
/*!********************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/spreadsheet.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "spreadsheet": () => (/* binding */ spreadsheet)
/* harmony export */ });
const spreadsheet = {
  name: "spreadsheet",

  startState: function () {
    return {
      stringType: null,
      stack: []
    };
  },
  token: function (stream, state) {
    if (!stream) return;

    //check for state changes
    if (state.stack.length === 0) {
      //strings
      if ((stream.peek() == '"') || (stream.peek() == "'")) {
        state.stringType = stream.peek();
        stream.next(); // Skip quote
        state.stack.unshift("string");
      }
    }

    //return state
    //stack has
    switch (state.stack[0]) {
    case "string":
      while (state.stack[0] === "string" && !stream.eol()) {
        if (stream.peek() === state.stringType) {
          stream.next(); // Skip quote
          state.stack.shift(); // Clear flag
        } else if (stream.peek() === "\\") {
          stream.next();
          stream.next();
        } else {
          stream.match(/^.[^\\\"\']*/);
        }
      }
      return "string";

    case "characterClass":
      while (state.stack[0] === "characterClass" && !stream.eol()) {
        if (!(stream.match(/^[^\]\\]+/) || stream.match(/^\\./)))
          state.stack.shift();
      }
      return "operator";
    }

    var peek = stream.peek();

    //no stack
    switch (peek) {
    case "[":
      stream.next();
      state.stack.unshift("characterClass");
      return "bracket";
    case ":":
      stream.next();
      return "operator";
    case "\\":
      if (stream.match(/\\[a-z]+/)) return "string.special";
      else {
        stream.next();
        return "atom";
      }
    case ".":
    case ",":
    case ";":
    case "*":
    case "-":
    case "+":
    case "^":
    case "<":
    case "/":
    case "=":
      stream.next();
      return "atom";
    case "$":
      stream.next();
      return "builtin";
    }

    if (stream.match(/\d+/)) {
      if (stream.match(/^\w+/)) return "error";
      return "number";
    } else if (stream.match(/^[a-zA-Z_]\w*/)) {
      if (stream.match(/(?=[\(.])/, false)) return "keyword";
      return "variable";
    } else if (["[", "]", "(", ")", "{", "}"].indexOf(peek) != -1) {
      stream.next();
      return "bracket";
    } else if (!stream.eatSpace()) {
      stream.next();
    }
    return null;
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfc3ByZWFkc2hlZXRfanMuZmUxZjQ0OTNkOTg0YWQ3Mjc5MDkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiwrQkFBK0I7QUFDL0IsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU0sZ0NBQWdDLEtBQUs7QUFDM0M7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS9zcHJlYWRzaGVldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3Qgc3ByZWFkc2hlZXQgPSB7XG4gIG5hbWU6IFwic3ByZWFkc2hlZXRcIixcblxuICBzdGFydFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cmluZ1R5cGU6IG51bGwsXG4gICAgICBzdGFjazogW11cbiAgICB9O1xuICB9LFxuICB0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoIXN0cmVhbSkgcmV0dXJuO1xuXG4gICAgLy9jaGVjayBmb3Igc3RhdGUgY2hhbmdlc1xuICAgIGlmIChzdGF0ZS5zdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vc3RyaW5nc1xuICAgICAgaWYgKChzdHJlYW0ucGVlaygpID09ICdcIicpIHx8IChzdHJlYW0ucGVlaygpID09IFwiJ1wiKSkge1xuICAgICAgICBzdGF0ZS5zdHJpbmdUeXBlID0gc3RyZWFtLnBlZWsoKTtcbiAgICAgICAgc3RyZWFtLm5leHQoKTsgLy8gU2tpcCBxdW90ZVxuICAgICAgICBzdGF0ZS5zdGFjay51bnNoaWZ0KFwic3RyaW5nXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vcmV0dXJuIHN0YXRlXG4gICAgLy9zdGFjayBoYXNcbiAgICBzd2l0Y2ggKHN0YXRlLnN0YWNrWzBdKSB7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgd2hpbGUgKHN0YXRlLnN0YWNrWzBdID09PSBcInN0cmluZ1wiICYmICFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5wZWVrKCkgPT09IHN0YXRlLnN0cmluZ1R5cGUpIHtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpOyAvLyBTa2lwIHF1b3RlXG4gICAgICAgICAgc3RhdGUuc3RhY2suc2hpZnQoKTsgLy8gQ2xlYXIgZmxhZ1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmVhbS5wZWVrKCkgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbS5tYXRjaCgvXi5bXlxcXFxcXFwiXFwnXSovKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG5cbiAgICBjYXNlIFwiY2hhcmFjdGVyQ2xhc3NcIjpcbiAgICAgIHdoaWxlIChzdGF0ZS5zdGFja1swXSA9PT0gXCJjaGFyYWN0ZXJDbGFzc1wiICYmICFzdHJlYW0uZW9sKCkpIHtcbiAgICAgICAgaWYgKCEoc3RyZWFtLm1hdGNoKC9eW15cXF1cXFxcXSsvKSB8fCBzdHJlYW0ubWF0Y2goL15cXFxcLi8pKSlcbiAgICAgICAgICBzdGF0ZS5zdGFjay5zaGlmdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgICB9XG5cbiAgICB2YXIgcGVlayA9IHN0cmVhbS5wZWVrKCk7XG5cbiAgICAvL25vIHN0YWNrXG4gICAgc3dpdGNoIChwZWVrKSB7XG4gICAgY2FzZSBcIltcIjpcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBzdGF0ZS5zdGFjay51bnNoaWZ0KFwiY2hhcmFjdGVyQ2xhc3NcIik7XG4gICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgY2FzZSBcIjpcIjpcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC9cXFxcW2Etel0rLykpIHJldHVybiBcInN0cmluZy5zcGVjaWFsXCI7XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgICAgfVxuICAgIGNhc2UgXCIuXCI6XG4gICAgY2FzZSBcIixcIjpcbiAgICBjYXNlIFwiO1wiOlxuICAgIGNhc2UgXCIqXCI6XG4gICAgY2FzZSBcIi1cIjpcbiAgICBjYXNlIFwiK1wiOlxuICAgIGNhc2UgXCJeXCI6XG4gICAgY2FzZSBcIjxcIjpcbiAgICBjYXNlIFwiL1wiOlxuICAgIGNhc2UgXCI9XCI6XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICAgIGNhc2UgXCIkXCI6XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICAgIH1cblxuICAgIGlmIChzdHJlYW0ubWF0Y2goL1xcZCsvKSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXlxcdysvKSkgcmV0dXJuIFwiZXJyb3JcIjtcbiAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9eW2EtekEtWl9dXFx3Ki8pKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKC8oPz1bXFwoLl0pLywgZmFsc2UpKSByZXR1cm4gXCJrZXl3b3JkXCI7XG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICAgIH0gZWxzZSBpZiAoW1wiW1wiLCBcIl1cIiwgXCIoXCIsIFwiKVwiLCBcIntcIiwgXCJ9XCJdLmluZGV4T2YocGVlaykgIT0gLTEpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gICAgfSBlbHNlIGlmICghc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9