"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_webidl_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/webidl.js":
/*!***************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/webidl.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "webIDL": () => (/* binding */ webIDL)
/* harmony export */ });
function wordRegexp(words) {
  return new RegExp("^((" + words.join(")|(") + "))\\b");
};

var builtinArray = [
  "Clamp",
  "Constructor",
  "EnforceRange",
  "Exposed",
  "ImplicitThis",
  "Global", "PrimaryGlobal",
  "LegacyArrayClass",
  "LegacyUnenumerableNamedProperties",
  "LenientThis",
  "NamedConstructor",
  "NewObject",
  "NoInterfaceObject",
  "OverrideBuiltins",
  "PutForwards",
  "Replaceable",
  "SameObject",
  "TreatNonObjectAsNull",
  "TreatNullAs",
    "EmptyString",
  "Unforgeable",
  "Unscopeable"
];
var builtins = wordRegexp(builtinArray);

var typeArray = [
  "unsigned", "short", "long",                  // UnsignedIntegerType
  "unrestricted", "float", "double",            // UnrestrictedFloatType
  "boolean", "byte", "octet",                   // Rest of PrimitiveType
  "Promise",                                    // PromiseType
  "ArrayBuffer", "DataView", "Int8Array", "Int16Array", "Int32Array",
  "Uint8Array", "Uint16Array", "Uint32Array", "Uint8ClampedArray",
  "Float32Array", "Float64Array",               // BufferRelatedType
  "ByteString", "DOMString", "USVString", "sequence", "object", "RegExp",
  "Error", "DOMException", "FrozenArray",       // Rest of NonAnyType
  "any",                                        // Rest of SingleType
  "void"                                        // Rest of ReturnType
];
var types = wordRegexp(typeArray);

var keywordArray = [
  "attribute", "callback", "const", "deleter", "dictionary", "enum", "getter",
  "implements", "inherit", "interface", "iterable", "legacycaller", "maplike",
  "partial", "required", "serializer", "setlike", "setter", "static",
  "stringifier", "typedef",                     // ArgumentNameKeyword except
                                                // "unrestricted"
  "optional", "readonly", "or"
];
var keywords = wordRegexp(keywordArray);

var atomArray = [
  "true", "false",                              // BooleanLiteral
  "Infinity", "NaN",                            // FloatLiteral
  "null"                                        // Rest of ConstValue
];
var atoms = wordRegexp(atomArray);

var startDefArray = ["callback", "dictionary", "enum", "interface"];
var startDefs = wordRegexp(startDefArray);

var endDefArray = ["typedef"];
var endDefs = wordRegexp(endDefArray);

var singleOperators = /^[:<=>?]/;
var integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;
var floats = /^-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;
var identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;
var identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\s*;)/;
var strings = /^"[^"]*"/;
var multilineComments = /^\/\*.*?\*\//;
var multilineCommentsStart = /^\/\*.*/;
var multilineCommentsEnd = /^.*?\*\//;

function readToken(stream, state) {
  // whitespace
  if (stream.eatSpace()) return null;

  // comment
  if (state.inComment) {
    if (stream.match(multilineCommentsEnd)) {
      state.inComment = false;
      return "comment";
    }
    stream.skipToEnd();
    return "comment";
  }
  if (stream.match("//")) {
    stream.skipToEnd();
    return "comment";
  }
  if (stream.match(multilineComments)) return "comment";
  if (stream.match(multilineCommentsStart)) {
    state.inComment = true;
    return "comment";
  }

  // integer and float
  if (stream.match(/^-?[0-9\.]/, false)) {
    if (stream.match(integers) || stream.match(floats)) return "number";
  }

  // string
  if (stream.match(strings)) return "string";

  // identifier
  if (state.startDef && stream.match(identifiers)) return "def";

  if (state.endDef && stream.match(identifiersEnd)) {
    state.endDef = false;
    return "def";
  }

  if (stream.match(keywords)) return "keyword";

  if (stream.match(types)) {
    var lastToken = state.lastToken;
    var nextToken = (stream.match(/^\s*(.+?)\b/, false) || [])[1];

    if (lastToken === ":" || lastToken === "implements" ||
        nextToken === "implements" || nextToken === "=") {
      // Used as identifier
      return "builtin";
    } else {
      // Used as type
      return "type";
    }
  }

  if (stream.match(builtins)) return "builtin";
  if (stream.match(atoms)) return "atom";
  if (stream.match(identifiers)) return "variable";

  // other
  if (stream.match(singleOperators)) return "operator";

  // unrecognized
  stream.next();
  return null;
};

const webIDL = {
  name: "webidl",
  startState: function() {
    return {
      // Is in multiline comment
      inComment: false,
      // Last non-whitespace, matched token
      lastToken: "",
      // Next token is a definition
      startDef: false,
      // Last token of the statement is a definition
      endDef: false
    };
  },
  token: function(stream, state) {
    var style = readToken(stream, state);

    if (style) {
      var cur = stream.current();
      state.lastToken = cur;
      if (style === "keyword") {
        state.startDef = startDefs.test(cur);
        state.endDef = state.endDef || endDefs.test(cur);
      } else {
        state.startDef = false;
      }
    }

    return style;
  },

  languageData: {
    autocomplete: builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray)
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfd2ViaWRsX2pzLjM0OWY5YTZlODY5MjhmMzA0YTQ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL3dlYmlkbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3b3JkUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXigoXCIgKyB3b3Jkcy5qb2luKFwiKXwoXCIpICsgXCIpKVxcXFxiXCIpO1xufTtcblxudmFyIGJ1aWx0aW5BcnJheSA9IFtcbiAgXCJDbGFtcFwiLFxuICBcIkNvbnN0cnVjdG9yXCIsXG4gIFwiRW5mb3JjZVJhbmdlXCIsXG4gIFwiRXhwb3NlZFwiLFxuICBcIkltcGxpY2l0VGhpc1wiLFxuICBcIkdsb2JhbFwiLCBcIlByaW1hcnlHbG9iYWxcIixcbiAgXCJMZWdhY3lBcnJheUNsYXNzXCIsXG4gIFwiTGVnYWN5VW5lbnVtZXJhYmxlTmFtZWRQcm9wZXJ0aWVzXCIsXG4gIFwiTGVuaWVudFRoaXNcIixcbiAgXCJOYW1lZENvbnN0cnVjdG9yXCIsXG4gIFwiTmV3T2JqZWN0XCIsXG4gIFwiTm9JbnRlcmZhY2VPYmplY3RcIixcbiAgXCJPdmVycmlkZUJ1aWx0aW5zXCIsXG4gIFwiUHV0Rm9yd2FyZHNcIixcbiAgXCJSZXBsYWNlYWJsZVwiLFxuICBcIlNhbWVPYmplY3RcIixcbiAgXCJUcmVhdE5vbk9iamVjdEFzTnVsbFwiLFxuICBcIlRyZWF0TnVsbEFzXCIsXG4gICAgXCJFbXB0eVN0cmluZ1wiLFxuICBcIlVuZm9yZ2VhYmxlXCIsXG4gIFwiVW5zY29wZWFibGVcIlxuXTtcbnZhciBidWlsdGlucyA9IHdvcmRSZWdleHAoYnVpbHRpbkFycmF5KTtcblxudmFyIHR5cGVBcnJheSA9IFtcbiAgXCJ1bnNpZ25lZFwiLCBcInNob3J0XCIsIFwibG9uZ1wiLCAgICAgICAgICAgICAgICAgIC8vIFVuc2lnbmVkSW50ZWdlclR5cGVcbiAgXCJ1bnJlc3RyaWN0ZWRcIiwgXCJmbG9hdFwiLCBcImRvdWJsZVwiLCAgICAgICAgICAgIC8vIFVucmVzdHJpY3RlZEZsb2F0VHlwZVxuICBcImJvb2xlYW5cIiwgXCJieXRlXCIsIFwib2N0ZXRcIiwgICAgICAgICAgICAgICAgICAgLy8gUmVzdCBvZiBQcmltaXRpdmVUeXBlXG4gIFwiUHJvbWlzZVwiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFByb21pc2VUeXBlXG4gIFwiQXJyYXlCdWZmZXJcIiwgXCJEYXRhVmlld1wiLCBcIkludDhBcnJheVwiLCBcIkludDE2QXJyYXlcIiwgXCJJbnQzMkFycmF5XCIsXG4gIFwiVWludDhBcnJheVwiLCBcIlVpbnQxNkFycmF5XCIsIFwiVWludDMyQXJyYXlcIiwgXCJVaW50OENsYW1wZWRBcnJheVwiLFxuICBcIkZsb2F0MzJBcnJheVwiLCBcIkZsb2F0NjRBcnJheVwiLCAgICAgICAgICAgICAgIC8vIEJ1ZmZlclJlbGF0ZWRUeXBlXG4gIFwiQnl0ZVN0cmluZ1wiLCBcIkRPTVN0cmluZ1wiLCBcIlVTVlN0cmluZ1wiLCBcInNlcXVlbmNlXCIsIFwib2JqZWN0XCIsIFwiUmVnRXhwXCIsXG4gIFwiRXJyb3JcIiwgXCJET01FeGNlcHRpb25cIiwgXCJGcm96ZW5BcnJheVwiLCAgICAgICAvLyBSZXN0IG9mIE5vbkFueVR5cGVcbiAgXCJhbnlcIiwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdCBvZiBTaW5nbGVUeXBlXG4gIFwidm9pZFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3Qgb2YgUmV0dXJuVHlwZVxuXTtcbnZhciB0eXBlcyA9IHdvcmRSZWdleHAodHlwZUFycmF5KTtcblxudmFyIGtleXdvcmRBcnJheSA9IFtcbiAgXCJhdHRyaWJ1dGVcIiwgXCJjYWxsYmFja1wiLCBcImNvbnN0XCIsIFwiZGVsZXRlclwiLCBcImRpY3Rpb25hcnlcIiwgXCJlbnVtXCIsIFwiZ2V0dGVyXCIsXG4gIFwiaW1wbGVtZW50c1wiLCBcImluaGVyaXRcIiwgXCJpbnRlcmZhY2VcIiwgXCJpdGVyYWJsZVwiLCBcImxlZ2FjeWNhbGxlclwiLCBcIm1hcGxpa2VcIixcbiAgXCJwYXJ0aWFsXCIsIFwicmVxdWlyZWRcIiwgXCJzZXJpYWxpemVyXCIsIFwic2V0bGlrZVwiLCBcInNldHRlclwiLCBcInN0YXRpY1wiLFxuICBcInN0cmluZ2lmaWVyXCIsIFwidHlwZWRlZlwiLCAgICAgICAgICAgICAgICAgICAgIC8vIEFyZ3VtZW50TmFtZUtleXdvcmQgZXhjZXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcInVucmVzdHJpY3RlZFwiXG4gIFwib3B0aW9uYWxcIiwgXCJyZWFkb25seVwiLCBcIm9yXCJcbl07XG52YXIga2V5d29yZHMgPSB3b3JkUmVnZXhwKGtleXdvcmRBcnJheSk7XG5cbnZhciBhdG9tQXJyYXkgPSBbXG4gIFwidHJ1ZVwiLCBcImZhbHNlXCIsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQm9vbGVhbkxpdGVyYWxcbiAgXCJJbmZpbml0eVwiLCBcIk5hTlwiLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGbG9hdExpdGVyYWxcbiAgXCJudWxsXCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVzdCBvZiBDb25zdFZhbHVlXG5dO1xudmFyIGF0b21zID0gd29yZFJlZ2V4cChhdG9tQXJyYXkpO1xuXG52YXIgc3RhcnREZWZBcnJheSA9IFtcImNhbGxiYWNrXCIsIFwiZGljdGlvbmFyeVwiLCBcImVudW1cIiwgXCJpbnRlcmZhY2VcIl07XG52YXIgc3RhcnREZWZzID0gd29yZFJlZ2V4cChzdGFydERlZkFycmF5KTtcblxudmFyIGVuZERlZkFycmF5ID0gW1widHlwZWRlZlwiXTtcbnZhciBlbmREZWZzID0gd29yZFJlZ2V4cChlbmREZWZBcnJheSk7XG5cbnZhciBzaW5nbGVPcGVyYXRvcnMgPSAvXls6PD0+P10vO1xudmFyIGludGVnZXJzID0gL14tPyhbMS05XVswLTldKnwwW1h4XVswLTlBLUZhLWZdK3wwWzAtN10qKS87XG52YXIgZmxvYXRzID0gL14tPygoWzAtOV0rXFwuWzAtOV0qfFswLTldKlxcLlswLTldKykoW0VlXVsrLV0/WzAtOV0rKT98WzAtOV0rW0VlXVsrLV0/WzAtOV0rKS87XG52YXIgaWRlbnRpZmllcnMgPSAvXl8/W0EtWmEtel1bMC05QS1aX2Etei1dKi87XG52YXIgaWRlbnRpZmllcnNFbmQgPSAvXl8/W0EtWmEtel1bMC05QS1aX2Etei1dKig/PVxccyo7KS87XG52YXIgc3RyaW5ncyA9IC9eXCJbXlwiXSpcIi87XG52YXIgbXVsdGlsaW5lQ29tbWVudHMgPSAvXlxcL1xcKi4qP1xcKlxcLy87XG52YXIgbXVsdGlsaW5lQ29tbWVudHNTdGFydCA9IC9eXFwvXFwqLiovO1xudmFyIG11bHRpbGluZUNvbW1lbnRzRW5kID0gL14uKj9cXCpcXC8vO1xuXG5mdW5jdGlvbiByZWFkVG9rZW4oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyB3aGl0ZXNwYWNlXG4gIGlmIChzdHJlYW0uZWF0U3BhY2UoKSkgcmV0dXJuIG51bGw7XG5cbiAgLy8gY29tbWVudFxuICBpZiAoc3RhdGUuaW5Db21tZW50KSB7XG4gICAgaWYgKHN0cmVhbS5tYXRjaChtdWx0aWxpbmVDb21tZW50c0VuZCkpIHtcbiAgICAgIHN0YXRlLmluQ29tbWVudCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG4gIGlmIChzdHJlYW0ubWF0Y2goXCIvL1wiKSkge1xuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gIH1cbiAgaWYgKHN0cmVhbS5tYXRjaChtdWx0aWxpbmVDb21tZW50cykpIHJldHVybiBcImNvbW1lbnRcIjtcbiAgaWYgKHN0cmVhbS5tYXRjaChtdWx0aWxpbmVDb21tZW50c1N0YXJ0KSkge1xuICAgIHN0YXRlLmluQ29tbWVudCA9IHRydWU7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgLy8gaW50ZWdlciBhbmQgZmxvYXRcbiAgaWYgKHN0cmVhbS5tYXRjaCgvXi0/WzAtOVxcLl0vLCBmYWxzZSkpIHtcbiAgICBpZiAoc3RyZWFtLm1hdGNoKGludGVnZXJzKSB8fCBzdHJlYW0ubWF0Y2goZmxvYXRzKSkgcmV0dXJuIFwibnVtYmVyXCI7XG4gIH1cblxuICAvLyBzdHJpbmdcbiAgaWYgKHN0cmVhbS5tYXRjaChzdHJpbmdzKSkgcmV0dXJuIFwic3RyaW5nXCI7XG5cbiAgLy8gaWRlbnRpZmllclxuICBpZiAoc3RhdGUuc3RhcnREZWYgJiYgc3RyZWFtLm1hdGNoKGlkZW50aWZpZXJzKSkgcmV0dXJuIFwiZGVmXCI7XG5cbiAgaWYgKHN0YXRlLmVuZERlZiAmJiBzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnNFbmQpKSB7XG4gICAgc3RhdGUuZW5kRGVmID0gZmFsc2U7XG4gICAgcmV0dXJuIFwiZGVmXCI7XG4gIH1cblxuICBpZiAoc3RyZWFtLm1hdGNoKGtleXdvcmRzKSkgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gIGlmIChzdHJlYW0ubWF0Y2godHlwZXMpKSB7XG4gICAgdmFyIGxhc3RUb2tlbiA9IHN0YXRlLmxhc3RUb2tlbjtcbiAgICB2YXIgbmV4dFRva2VuID0gKHN0cmVhbS5tYXRjaCgvXlxccyooLis/KVxcYi8sIGZhbHNlKSB8fCBbXSlbMV07XG5cbiAgICBpZiAobGFzdFRva2VuID09PSBcIjpcIiB8fCBsYXN0VG9rZW4gPT09IFwiaW1wbGVtZW50c1wiIHx8XG4gICAgICAgIG5leHRUb2tlbiA9PT0gXCJpbXBsZW1lbnRzXCIgfHwgbmV4dFRva2VuID09PSBcIj1cIikge1xuICAgICAgLy8gVXNlZCBhcyBpZGVudGlmaWVyXG4gICAgICByZXR1cm4gXCJidWlsdGluXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVzZWQgYXMgdHlwZVxuICAgICAgcmV0dXJuIFwidHlwZVwiO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdHJlYW0ubWF0Y2goYnVpbHRpbnMpKSByZXR1cm4gXCJidWlsdGluXCI7XG4gIGlmIChzdHJlYW0ubWF0Y2goYXRvbXMpKSByZXR1cm4gXCJhdG9tXCI7XG4gIGlmIChzdHJlYW0ubWF0Y2goaWRlbnRpZmllcnMpKSByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuXG4gIC8vIG90aGVyXG4gIGlmIChzdHJlYW0ubWF0Y2goc2luZ2xlT3BlcmF0b3JzKSkgcmV0dXJuIFwib3BlcmF0b3JcIjtcblxuICAvLyB1bnJlY29nbml6ZWRcbiAgc3RyZWFtLm5leHQoKTtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5leHBvcnQgY29uc3Qgd2ViSURMID0ge1xuICBuYW1lOiBcIndlYmlkbFwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gSXMgaW4gbXVsdGlsaW5lIGNvbW1lbnRcbiAgICAgIGluQ29tbWVudDogZmFsc2UsXG4gICAgICAvLyBMYXN0IG5vbi13aGl0ZXNwYWNlLCBtYXRjaGVkIHRva2VuXG4gICAgICBsYXN0VG9rZW46IFwiXCIsXG4gICAgICAvLyBOZXh0IHRva2VuIGlzIGEgZGVmaW5pdGlvblxuICAgICAgc3RhcnREZWY6IGZhbHNlLFxuICAgICAgLy8gTGFzdCB0b2tlbiBvZiB0aGUgc3RhdGVtZW50IGlzIGEgZGVmaW5pdGlvblxuICAgICAgZW5kRGVmOiBmYWxzZVxuICAgIH07XG4gIH0sXG4gIHRva2VuOiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIHN0eWxlID0gcmVhZFRva2VuKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICB2YXIgY3VyID0gc3RyZWFtLmN1cnJlbnQoKTtcbiAgICAgIHN0YXRlLmxhc3RUb2tlbiA9IGN1cjtcbiAgICAgIGlmIChzdHlsZSA9PT0gXCJrZXl3b3JkXCIpIHtcbiAgICAgICAgc3RhdGUuc3RhcnREZWYgPSBzdGFydERlZnMudGVzdChjdXIpO1xuICAgICAgICBzdGF0ZS5lbmREZWYgPSBzdGF0ZS5lbmREZWYgfHwgZW5kRGVmcy50ZXN0KGN1cik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5zdGFydERlZiA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBhdXRvY29tcGxldGU6IGJ1aWx0aW5BcnJheS5jb25jYXQodHlwZUFycmF5KS5jb25jYXQoa2V5d29yZEFycmF5KS5jb25jYXQoYXRvbUFycmF5KVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9