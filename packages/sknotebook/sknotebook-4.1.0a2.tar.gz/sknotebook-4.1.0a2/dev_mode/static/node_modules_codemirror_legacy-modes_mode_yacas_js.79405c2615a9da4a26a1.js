"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_yacas_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/yacas.js":
/*!**************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/yacas.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "yacas": () => (/* binding */ yacas)
/* harmony export */ });
function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}

var bodiedOps = words("Assert BackQuote D Defun Deriv For ForEach FromFile " +
                      "FromString Function Integrate InverseTaylor Limit " +
                      "LocalSymbols Macro MacroRule MacroRulePattern " +
                      "NIntegrate Rule RulePattern Subst TD TExplicitSum " +
                      "TSum Taylor Taylor1 Taylor2 Taylor3 ToFile " +
                      "ToStdout ToString TraceRule Until While");

// patterns
var pFloatForm  = "(?:(?:\\.\\d+|\\d+\\.\\d*|\\d+)(?:[eE][+-]?\\d+)?)";
var pIdentifier = "(?:[a-zA-Z\\$'][a-zA-Z0-9\\$']*)";

// regular expressions
var reFloatForm    = new RegExp(pFloatForm);
var reIdentifier   = new RegExp(pIdentifier);
var rePattern      = new RegExp(pIdentifier + "?_" + pIdentifier);
var reFunctionLike = new RegExp(pIdentifier + "\\s*\\(");

function tokenBase(stream, state) {
  var ch;

  // get next character
  ch = stream.next();

  // string
  if (ch === '"') {
    state.tokenize = tokenString;
    return state.tokenize(stream, state);
  }

  // comment
  if (ch === '/') {
    if (stream.eat('*')) {
      state.tokenize = tokenComment;
      return state.tokenize(stream, state);
    }
    if (stream.eat("/")) {
      stream.skipToEnd();
      return "comment";
    }
  }

  // go back one character
  stream.backUp(1);

  // update scope info
  var m = stream.match(/^(\w+)\s*\(/, false);
  if (m !== null && bodiedOps.hasOwnProperty(m[1]))
    state.scopes.push('bodied');

  var scope = currentScope(state);

  if (scope === 'bodied' && ch === '[')
    state.scopes.pop();

  if (ch === '[' || ch === '{' || ch === '(')
    state.scopes.push(ch);

  scope = currentScope(state);

  if (scope === '[' && ch === ']' ||
      scope === '{' && ch === '}' ||
      scope === '(' && ch === ')')
    state.scopes.pop();

  if (ch === ';') {
    while (scope === 'bodied') {
      state.scopes.pop();
      scope = currentScope(state);
    }
  }

  // look for ordered rules
  if (stream.match(/\d+ *#/, true, false)) {
    return 'qualifier';
  }

  // look for numbers
  if (stream.match(reFloatForm, true, false)) {
    return 'number';
  }

  // look for placeholders
  if (stream.match(rePattern, true, false)) {
    return 'variableName.special';
  }

  // match all braces separately
  if (stream.match(/(?:\[|\]|{|}|\(|\))/, true, false)) {
    return 'bracket';
  }

  // literals looking like function calls
  if (stream.match(reFunctionLike, true, false)) {
    stream.backUp(1);
    return 'variableName.function';
  }

  // all other identifiers
  if (stream.match(reIdentifier, true, false)) {
    return 'variable';
  }

  // operators; note that operators like @@ or /; are matched separately for each symbol.
  if (stream.match(/(?:\\|\+|\-|\*|\/|,|;|\.|:|@|~|=|>|<|&|\||_|`|'|\^|\?|!|%|#)/, true, false)) {
    return 'operator';
  }

  // everything else is an error
  return 'error';
}

function tokenString(stream, state) {
  var next, end = false, escaped = false;
  while ((next = stream.next()) != null) {
    if (next === '"' && !escaped) {
      end = true;
      break;
    }
    escaped = !escaped && next === '\\';
  }
  if (end && !escaped) {
    state.tokenize = tokenBase;
  }
  return 'string';
};

function tokenComment(stream, state) {
  var prev, next;
  while((next = stream.next()) != null) {
    if (prev === '*' && next === '/') {
      state.tokenize = tokenBase;
      break;
    }
    prev = next;
  }
  return 'comment';
}

function currentScope(state) {
  var scope = null;
  if (state.scopes.length > 0)
    scope = state.scopes[state.scopes.length - 1];
  return scope;
}

const yacas = {
  name: "yacas",
  startState: function() {
    return {
      tokenize: tokenBase,
      scopes: []
    };
  },
  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    return state.tokenize(stream, state);
  },
  indent: function(state, textAfter, cx) {
    if (state.tokenize !== tokenBase && state.tokenize !== null)
      return null;

    var delta = 0;
    if (textAfter === ']' || textAfter === '];' ||
        textAfter === '}' || textAfter === '};' ||
        textAfter === ');')
      delta = -1;

    return (state.scopes.length + delta) * cx.unit;
  },

  languageData: {
    electricInput: /[{}\[\]()\;]/,
    commentTokens: {line: "//", block: {open: "/*", close: "*/"}}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfeWFjYXNfanMuNzk0MDVjMjYxNWE5ZGE0YTI2YTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTs7QUFFQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0NBQWtDO0FBQ2xELHlDQUF5QztBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUMsd0JBQXdCLHNCQUFzQjtBQUM5Qyx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0Isb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS95YWNhcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3b3JkcyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9LCB3b3JkcyA9IHN0ci5zcGxpdChcIiBcIik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIG9ialt3b3Jkc1tpXV0gPSB0cnVlO1xuICByZXR1cm4gb2JqO1xufVxuXG52YXIgYm9kaWVkT3BzID0gd29yZHMoXCJBc3NlcnQgQmFja1F1b3RlIEQgRGVmdW4gRGVyaXYgRm9yIEZvckVhY2ggRnJvbUZpbGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiRnJvbVN0cmluZyBGdW5jdGlvbiBJbnRlZ3JhdGUgSW52ZXJzZVRheWxvciBMaW1pdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJMb2NhbFN5bWJvbHMgTWFjcm8gTWFjcm9SdWxlIE1hY3JvUnVsZVBhdHRlcm4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiTkludGVncmF0ZSBSdWxlIFJ1bGVQYXR0ZXJuIFN1YnN0IFREIFRFeHBsaWNpdFN1bSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgXCJUU3VtIFRheWxvciBUYXlsb3IxIFRheWxvcjIgVGF5bG9yMyBUb0ZpbGUgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgIFwiVG9TdGRvdXQgVG9TdHJpbmcgVHJhY2VSdWxlIFVudGlsIFdoaWxlXCIpO1xuXG4vLyBwYXR0ZXJuc1xudmFyIHBGbG9hdEZvcm0gID0gXCIoPzooPzpcXFxcLlxcXFxkK3xcXFxcZCtcXFxcLlxcXFxkKnxcXFxcZCspKD86W2VFXVsrLV0/XFxcXGQrKT8pXCI7XG52YXIgcElkZW50aWZpZXIgPSBcIig/OlthLXpBLVpcXFxcJCddW2EtekEtWjAtOVxcXFwkJ10qKVwiO1xuXG4vLyByZWd1bGFyIGV4cHJlc3Npb25zXG52YXIgcmVGbG9hdEZvcm0gICAgPSBuZXcgUmVnRXhwKHBGbG9hdEZvcm0pO1xudmFyIHJlSWRlbnRpZmllciAgID0gbmV3IFJlZ0V4cChwSWRlbnRpZmllcik7XG52YXIgcmVQYXR0ZXJuICAgICAgPSBuZXcgUmVnRXhwKHBJZGVudGlmaWVyICsgXCI/X1wiICsgcElkZW50aWZpZXIpO1xudmFyIHJlRnVuY3Rpb25MaWtlID0gbmV3IFJlZ0V4cChwSWRlbnRpZmllciArIFwiXFxcXHMqXFxcXChcIik7XG5cbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaDtcblxuICAvLyBnZXQgbmV4dCBjaGFyYWN0ZXJcbiAgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gIC8vIHN0cmluZ1xuICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuU3RyaW5nO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIC8vIGNvbW1lbnRcbiAgaWYgKGNoID09PSAnLycpIHtcbiAgICBpZiAoc3RyZWFtLmVhdCgnKicpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQ29tbWVudDtcbiAgICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIvXCIpKSB7XG4gICAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICB9XG5cbiAgLy8gZ28gYmFjayBvbmUgY2hhcmFjdGVyXG4gIHN0cmVhbS5iYWNrVXAoMSk7XG5cbiAgLy8gdXBkYXRlIHNjb3BlIGluZm9cbiAgdmFyIG0gPSBzdHJlYW0ubWF0Y2goL14oXFx3KylcXHMqXFwoLywgZmFsc2UpO1xuICBpZiAobSAhPT0gbnVsbCAmJiBib2RpZWRPcHMuaGFzT3duUHJvcGVydHkobVsxXSkpXG4gICAgc3RhdGUuc2NvcGVzLnB1c2goJ2JvZGllZCcpO1xuXG4gIHZhciBzY29wZSA9IGN1cnJlbnRTY29wZShzdGF0ZSk7XG5cbiAgaWYgKHNjb3BlID09PSAnYm9kaWVkJyAmJiBjaCA9PT0gJ1snKVxuICAgIHN0YXRlLnNjb3Blcy5wb3AoKTtcblxuICBpZiAoY2ggPT09ICdbJyB8fCBjaCA9PT0gJ3snIHx8IGNoID09PSAnKCcpXG4gICAgc3RhdGUuc2NvcGVzLnB1c2goY2gpO1xuXG4gIHNjb3BlID0gY3VycmVudFNjb3BlKHN0YXRlKTtcblxuICBpZiAoc2NvcGUgPT09ICdbJyAmJiBjaCA9PT0gJ10nIHx8XG4gICAgICBzY29wZSA9PT0gJ3snICYmIGNoID09PSAnfScgfHxcbiAgICAgIHNjb3BlID09PSAnKCcgJiYgY2ggPT09ICcpJylcbiAgICBzdGF0ZS5zY29wZXMucG9wKCk7XG5cbiAgaWYgKGNoID09PSAnOycpIHtcbiAgICB3aGlsZSAoc2NvcGUgPT09ICdib2RpZWQnKSB7XG4gICAgICBzdGF0ZS5zY29wZXMucG9wKCk7XG4gICAgICBzY29wZSA9IGN1cnJlbnRTY29wZShzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gbG9vayBmb3Igb3JkZXJlZCBydWxlc1xuICBpZiAoc3RyZWFtLm1hdGNoKC9cXGQrICojLywgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgcmV0dXJuICdxdWFsaWZpZXInO1xuICB9XG5cbiAgLy8gbG9vayBmb3IgbnVtYmVyc1xuICBpZiAoc3RyZWFtLm1hdGNoKHJlRmxvYXRGb3JtLCB0cnVlLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gJ251bWJlcic7XG4gIH1cblxuICAvLyBsb29rIGZvciBwbGFjZWhvbGRlcnNcbiAgaWYgKHN0cmVhbS5tYXRjaChyZVBhdHRlcm4sIHRydWUsIGZhbHNlKSkge1xuICAgIHJldHVybiAndmFyaWFibGVOYW1lLnNwZWNpYWwnO1xuICB9XG5cbiAgLy8gbWF0Y2ggYWxsIGJyYWNlcyBzZXBhcmF0ZWx5XG4gIGlmIChzdHJlYW0ubWF0Y2goLyg/OlxcW3xcXF18e3x9fFxcKHxcXCkpLywgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgcmV0dXJuICdicmFja2V0JztcbiAgfVxuXG4gIC8vIGxpdGVyYWxzIGxvb2tpbmcgbGlrZSBmdW5jdGlvbiBjYWxsc1xuICBpZiAoc3RyZWFtLm1hdGNoKHJlRnVuY3Rpb25MaWtlLCB0cnVlLCBmYWxzZSkpIHtcbiAgICBzdHJlYW0uYmFja1VwKDEpO1xuICAgIHJldHVybiAndmFyaWFibGVOYW1lLmZ1bmN0aW9uJztcbiAgfVxuXG4gIC8vIGFsbCBvdGhlciBpZGVudGlmaWVyc1xuICBpZiAoc3RyZWFtLm1hdGNoKHJlSWRlbnRpZmllciwgdHJ1ZSwgZmFsc2UpKSB7XG4gICAgcmV0dXJuICd2YXJpYWJsZSc7XG4gIH1cblxuICAvLyBvcGVyYXRvcnM7IG5vdGUgdGhhdCBvcGVyYXRvcnMgbGlrZSBAQCBvciAvOyBhcmUgbWF0Y2hlZCBzZXBhcmF0ZWx5IGZvciBlYWNoIHN5bWJvbC5cbiAgaWYgKHN0cmVhbS5tYXRjaCgvKD86XFxcXHxcXCt8XFwtfFxcKnxcXC98LHw7fFxcLnw6fEB8fnw9fD58PHwmfFxcfHxffGB8J3xcXF58XFw/fCF8JXwjKS8sIHRydWUsIGZhbHNlKSkge1xuICAgIHJldHVybiAnb3BlcmF0b3InO1xuICB9XG5cbiAgLy8gZXZlcnl0aGluZyBlbHNlIGlzIGFuIGVycm9yXG4gIHJldHVybiAnZXJyb3InO1xufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZXh0LCBlbmQgPSBmYWxzZSwgZXNjYXBlZCA9IGZhbHNlO1xuICB3aGlsZSAoKG5leHQgPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgaWYgKG5leHQgPT09ICdcIicgJiYgIWVzY2FwZWQpIHtcbiAgICAgIGVuZCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIG5leHQgPT09ICdcXFxcJztcbiAgfVxuICBpZiAoZW5kICYmICFlc2NhcGVkKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gIH1cbiAgcmV0dXJuICdzdHJpbmcnO1xufTtcblxuZnVuY3Rpb24gdG9rZW5Db21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIHByZXYsIG5leHQ7XG4gIHdoaWxlKChuZXh0ID0gc3RyZWFtLm5leHQoKSkgIT0gbnVsbCkge1xuICAgIGlmIChwcmV2ID09PSAnKicgJiYgbmV4dCA9PT0gJy8nKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2ID0gbmV4dDtcbiAgfVxuICByZXR1cm4gJ2NvbW1lbnQnO1xufVxuXG5mdW5jdGlvbiBjdXJyZW50U2NvcGUoc3RhdGUpIHtcbiAgdmFyIHNjb3BlID0gbnVsbDtcbiAgaWYgKHN0YXRlLnNjb3Blcy5sZW5ndGggPiAwKVxuICAgIHNjb3BlID0gc3RhdGUuc2NvcGVzW3N0YXRlLnNjb3Blcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHNjb3BlO1xufVxuXG5leHBvcnQgY29uc3QgeWFjYXMgPSB7XG4gIG5hbWU6IFwieWFjYXNcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuaXplOiB0b2tlbkJhc2UsXG4gICAgICBzY29wZXM6IFtdXG4gICAgfTtcbiAgfSxcbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfSxcbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgIGlmIChzdGF0ZS50b2tlbml6ZSAhPT0gdG9rZW5CYXNlICYmIHN0YXRlLnRva2VuaXplICE9PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgZGVsdGEgPSAwO1xuICAgIGlmICh0ZXh0QWZ0ZXIgPT09ICddJyB8fCB0ZXh0QWZ0ZXIgPT09ICddOycgfHxcbiAgICAgICAgdGV4dEFmdGVyID09PSAnfScgfHwgdGV4dEFmdGVyID09PSAnfTsnIHx8XG4gICAgICAgIHRleHRBZnRlciA9PT0gJyk7JylcbiAgICAgIGRlbHRhID0gLTE7XG5cbiAgICByZXR1cm4gKHN0YXRlLnNjb3Blcy5sZW5ndGggKyBkZWx0YSkgKiBjeC51bml0O1xuICB9LFxuXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGVsZWN0cmljSW5wdXQ6IC9be31cXFtcXF0oKVxcO10vLFxuICAgIGNvbW1lbnRUb2tlbnM6IHtsaW5lOiBcIi8vXCIsIGJsb2NrOiB7b3BlbjogXCIvKlwiLCBjbG9zZTogXCIqL1wifX1cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==