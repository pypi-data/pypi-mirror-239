"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_erlang_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/erlang.js":
/*!***************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/erlang.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "erlang": () => (/* binding */ erlang)
/* harmony export */ });
/////////////////////////////////////////////////////////////////////////////
// constants

var typeWords = [
  "-type", "-spec", "-export_type", "-opaque"];

var keywordWords = [
  "after","begin","catch","case","cond","end","fun","if",
  "let","of","query","receive","try","when"];

var separatorRE    = /[\->,;]/;
var separatorWords = [
  "->",";",","];

var operatorAtomWords = [
  "and","andalso","band","bnot","bor","bsl","bsr","bxor",
  "div","not","or","orelse","rem","xor"];

var operatorSymbolRE    = /[\+\-\*\/<>=\|:!]/;
var operatorSymbolWords = [
  "=","+","-","*","/",">",">=","<","=<","=:=","==","=/=","/=","||","<-","!"];

var openParenRE    = /[<\(\[\{]/;
var openParenWords = [
  "<<","(","[","{"];

var closeParenRE    = /[>\)\]\}]/;
var closeParenWords = [
  "}","]",")",">>"];

var guardWords = [
  "is_atom","is_binary","is_bitstring","is_boolean","is_float",
  "is_function","is_integer","is_list","is_number","is_pid",
  "is_port","is_record","is_reference","is_tuple",
  "atom","binary","bitstring","boolean","function","integer","list",
  "number","pid","port","record","reference","tuple"];

var bifWords = [
  "abs","adler32","adler32_combine","alive","apply","atom_to_binary",
  "atom_to_list","binary_to_atom","binary_to_existing_atom",
  "binary_to_list","binary_to_term","bit_size","bitstring_to_list",
  "byte_size","check_process_code","contact_binary","crc32",
  "crc32_combine","date","decode_packet","delete_module",
  "disconnect_node","element","erase","exit","float","float_to_list",
  "garbage_collect","get","get_keys","group_leader","halt","hd",
  "integer_to_list","internal_bif","iolist_size","iolist_to_binary",
  "is_alive","is_atom","is_binary","is_bitstring","is_boolean",
  "is_float","is_function","is_integer","is_list","is_number","is_pid",
  "is_port","is_process_alive","is_record","is_reference","is_tuple",
  "length","link","list_to_atom","list_to_binary","list_to_bitstring",
  "list_to_existing_atom","list_to_float","list_to_integer",
  "list_to_pid","list_to_tuple","load_module","make_ref","module_loaded",
  "monitor_node","node","node_link","node_unlink","nodes","notalive",
  "now","open_port","pid_to_list","port_close","port_command",
  "port_connect","port_control","pre_loaded","process_flag",
  "process_info","processes","purge_module","put","register",
  "registered","round","self","setelement","size","spawn","spawn_link",
  "spawn_monitor","spawn_opt","split_binary","statistics",
  "term_to_binary","time","throw","tl","trunc","tuple_size",
  "tuple_to_list","unlink","unregister","whereis"];

// upper case: [A-Z] [Ø-Þ] [À-Ö]
// lower case: [a-z] [ß-ö] [ø-ÿ]
var anumRE       = /[\w@Ø-ÞÀ-Öß-öø-ÿ]/;
var escapesRE    =
    /[0-7]{1,3}|[bdefnrstv\\"']|\^[a-zA-Z]|x[0-9a-zA-Z]{2}|x{[0-9a-zA-Z]+}/;

/////////////////////////////////////////////////////////////////////////////
// tokenizer

function tokenizer(stream,state) {
  // in multi-line string
  if (state.in_string) {
    state.in_string = (!doubleQuote(stream));
    return rval(state,stream,"string");
  }

  // in multi-line atom
  if (state.in_atom) {
    state.in_atom = (!singleQuote(stream));
    return rval(state,stream,"atom");
  }

  // whitespace
  if (stream.eatSpace()) {
    return rval(state,stream,"whitespace");
  }

  // attributes and type specs
  if (!peekToken(state) &&
      stream.match(/-\s*[a-zß-öø-ÿ][\wØ-ÞÀ-Öß-öø-ÿ]*/)) {
    if (is_member(stream.current(),typeWords)) {
      return rval(state,stream,"type");
    }else{
      return rval(state,stream,"attribute");
    }
  }

  var ch = stream.next();

  // comment
  if (ch == '%') {
    stream.skipToEnd();
    return rval(state,stream,"comment");
  }

  // colon
  if (ch == ":") {
    return rval(state,stream,"colon");
  }

  // macro
  if (ch == '?') {
    stream.eatSpace();
    stream.eatWhile(anumRE);
    return rval(state,stream,"macro");
  }

  // record
  if (ch == "#") {
    stream.eatSpace();
    stream.eatWhile(anumRE);
    return rval(state,stream,"record");
  }

  // dollar escape
  if (ch == "$") {
    if (stream.next() == "\\" && !stream.match(escapesRE)) {
      return rval(state,stream,"error");
    }
    return rval(state,stream,"number");
  }

  // dot
  if (ch == ".") {
    return rval(state,stream,"dot");
  }

  // quoted atom
  if (ch == '\'') {
    if (!(state.in_atom = (!singleQuote(stream)))) {
      if (stream.match(/\s*\/\s*[0-9]/,false)) {
        stream.match(/\s*\/\s*[0-9]/,true);
        return rval(state,stream,"fun");      // 'f'/0 style fun
      }
      if (stream.match(/\s*\(/,false) || stream.match(/\s*:/,false)) {
        return rval(state,stream,"function");
      }
    }
    return rval(state,stream,"atom");
  }

  // string
  if (ch == '"') {
    state.in_string = (!doubleQuote(stream));
    return rval(state,stream,"string");
  }

  // variable
  if (/[A-Z_Ø-ÞÀ-Ö]/.test(ch)) {
    stream.eatWhile(anumRE);
    return rval(state,stream,"variable");
  }

  // atom/keyword/BIF/function
  if (/[a-z_ß-öø-ÿ]/.test(ch)) {
    stream.eatWhile(anumRE);

    if (stream.match(/\s*\/\s*[0-9]/,false)) {
      stream.match(/\s*\/\s*[0-9]/,true);
      return rval(state,stream,"fun");      // f/0 style fun
    }

    var w = stream.current();

    if (is_member(w,keywordWords)) {
      return rval(state,stream,"keyword");
    }else if (is_member(w,operatorAtomWords)) {
      return rval(state,stream,"operator");
    }else if (stream.match(/\s*\(/,false)) {
      // 'put' and 'erlang:put' are bifs, 'foo:put' is not
      if (is_member(w,bifWords) &&
          ((peekToken(state).token != ":") ||
           (peekToken(state,2).token == "erlang"))) {
        return rval(state,stream,"builtin");
      }else if (is_member(w,guardWords)) {
        return rval(state,stream,"guard");
      }else{
        return rval(state,stream,"function");
      }
    }else if (lookahead(stream) == ":") {
      if (w == "erlang") {
        return rval(state,stream,"builtin");
      } else {
        return rval(state,stream,"function");
      }
    }else if (is_member(w,["true","false"])) {
      return rval(state,stream,"boolean");
    }else{
      return rval(state,stream,"atom");
    }
  }

  // number
  var digitRE      = /[0-9]/;
  var radixRE      = /[0-9a-zA-Z]/;         // 36#zZ style int
  if (digitRE.test(ch)) {
    stream.eatWhile(digitRE);
    if (stream.eat('#')) {                // 36#aZ  style integer
      if (!stream.eatWhile(radixRE)) {
        stream.backUp(1);                 //"36#" - syntax error
      }
    } else if (stream.eat('.')) {       // float
      if (!stream.eatWhile(digitRE)) {
        stream.backUp(1);        // "3." - probably end of function
      } else {
        if (stream.eat(/[eE]/)) {        // float with exponent
          if (stream.eat(/[-+]/)) {
            if (!stream.eatWhile(digitRE)) {
              stream.backUp(2);            // "2e-" - syntax error
            }
          } else {
            if (!stream.eatWhile(digitRE)) {
              stream.backUp(1);            // "2e" - syntax error
            }
          }
        }
      }
    }
    return rval(state,stream,"number");   // normal integer
  }

  // open parens
  if (nongreedy(stream,openParenRE,openParenWords)) {
    return rval(state,stream,"open_paren");
  }

  // close parens
  if (nongreedy(stream,closeParenRE,closeParenWords)) {
    return rval(state,stream,"close_paren");
  }

  // separators
  if (greedy(stream,separatorRE,separatorWords)) {
    return rval(state,stream,"separator");
  }

  // operators
  if (greedy(stream,operatorSymbolRE,operatorSymbolWords)) {
    return rval(state,stream,"operator");
  }

  return rval(state,stream,null);
}

/////////////////////////////////////////////////////////////////////////////
// utilities
function nongreedy(stream,re,words) {
  if (stream.current().length == 1 && re.test(stream.current())) {
    stream.backUp(1);
    while (re.test(stream.peek())) {
      stream.next();
      if (is_member(stream.current(),words)) {
        return true;
      }
    }
    stream.backUp(stream.current().length-1);
  }
  return false;
}

function greedy(stream,re,words) {
  if (stream.current().length == 1 && re.test(stream.current())) {
    while (re.test(stream.peek())) {
      stream.next();
    }
    while (0 < stream.current().length) {
      if (is_member(stream.current(),words)) {
        return true;
      }else{
        stream.backUp(1);
      }
    }
    stream.next();
  }
  return false;
}

function doubleQuote(stream) {
  return quote(stream, '"', '\\');
}

function singleQuote(stream) {
  return quote(stream,'\'','\\');
}

function quote(stream,quoteChar,escapeChar) {
  while (!stream.eol()) {
    var ch = stream.next();
    if (ch == quoteChar) {
      return true;
    }else if (ch == escapeChar) {
      stream.next();
    }
  }
  return false;
}

function lookahead(stream) {
  var m = stream.match(/^\s*([^\s%])/, false)
  return m ? m[1] : "";
}

function is_member(element,list) {
  return (-1 < list.indexOf(element));
}

function rval(state,stream,type) {

  // parse stack
  pushToken(state,realToken(type,stream));

  // map erlang token type to CodeMirror style class
  //     erlang             -> CodeMirror tag
  switch (type) {
  case "atom":        return "atom";
  case "attribute":   return "attribute";
  case "boolean":     return "atom";
  case "builtin":     return "builtin";
  case "close_paren": return null;
  case "colon":       return null;
  case "comment":     return "comment";
  case "dot":         return null;
  case "error":       return "error";
  case "fun":         return "meta";
  case "function":    return "tag";
  case "guard":       return "property";
  case "keyword":     return "keyword";
  case "macro":       return "macroName";
  case "number":      return "number";
  case "open_paren":  return null;
  case "operator":    return "operator";
  case "record":      return "bracket";
  case "separator":   return null;
  case "string":      return "string";
  case "type":        return "def";
  case "variable":    return "variable";
  default:            return null;
  }
}

function aToken(tok,col,ind,typ) {
  return {token:  tok,
          column: col,
          indent: ind,
          type:   typ};
}

function realToken(type,stream) {
  return aToken(stream.current(),
                stream.column(),
                stream.indentation(),
                type);
}

function fakeToken(type) {
  return aToken(type,0,0,type);
}

function peekToken(state,depth) {
  var len = state.tokenStack.length;
  var dep = (depth ? depth : 1);

  if (len < dep) {
    return false;
  }else{
    return state.tokenStack[len-dep];
  }
}

function pushToken(state,token) {

  if (!(token.type == "comment" || token.type == "whitespace")) {
    state.tokenStack = maybe_drop_pre(state.tokenStack,token);
    state.tokenStack = maybe_drop_post(state.tokenStack);
  }
}

function maybe_drop_pre(s,token) {
  var last = s.length-1;

  if (0 < last && s[last].type === "record" && token.type === "dot") {
    s.pop();
  }else if (0 < last && s[last].type === "group") {
    s.pop();
    s.push(token);
  }else{
    s.push(token);
  }
  return s;
}

function maybe_drop_post(s) {
  if (!s.length) return s
  var last = s.length-1;

  if (s[last].type === "dot") {
    return [];
  }
  if (last > 1 && s[last].type === "fun" && s[last-1].token === "fun") {
    return s.slice(0,last-1);
  }
  switch (s[last].token) {
  case "}":    return d(s,{g:["{"]});
  case "]":    return d(s,{i:["["]});
  case ")":    return d(s,{i:["("]});
  case ">>":   return d(s,{i:["<<"]});
  case "end":  return d(s,{i:["begin","case","fun","if","receive","try"]});
  case ",":    return d(s,{e:["begin","try","when","->",
                              ",","(","[","{","<<"]});
  case "->":   return d(s,{r:["when"],
                           m:["try","if","case","receive"]});
  case ";":    return d(s,{E:["case","fun","if","receive","try","when"]});
  case "catch":return d(s,{e:["try"]});
  case "of":   return d(s,{e:["case"]});
  case "after":return d(s,{e:["receive","try"]});
  default:     return s;
  }
}

function d(stack,tt) {
  // stack is a stack of Token objects.
  // tt is an object; {type:tokens}
  // type is a char, tokens is a list of token strings.
  // The function returns (possibly truncated) stack.
  // It will descend the stack, looking for a Token such that Token.token
  //  is a member of tokens. If it does not find that, it will normally (but
  //  see "E" below) return stack. If it does find a match, it will remove
  //  all the Tokens between the top and the matched Token.
  // If type is "m", that is all it does.
  // If type is "i", it will also remove the matched Token and the top Token.
  // If type is "g", like "i", but add a fake "group" token at the top.
  // If type is "r", it will remove the matched Token, but not the top Token.
  // If type is "e", it will keep the matched Token but not the top Token.
  // If type is "E", it behaves as for type "e", except if there is no match,
  //  in which case it will return an empty stack.

  for (var type in tt) {
    var len = stack.length-1;
    var tokens = tt[type];
    for (var i = len-1; -1 < i ; i--) {
      if (is_member(stack[i].token,tokens)) {
        var ss = stack.slice(0,i);
        switch (type) {
        case "m": return ss.concat(stack[i]).concat(stack[len]);
        case "r": return ss.concat(stack[len]);
        case "i": return ss;
        case "g": return ss.concat(fakeToken("group"));
        case "E": return ss.concat(stack[i]);
        case "e": return ss.concat(stack[i]);
        }
      }
    }
  }
  return (type == "E" ? [] : stack);
}

/////////////////////////////////////////////////////////////////////////////
// indenter

function indenter(state, textAfter, cx) {
  var t;
  var wordAfter = wordafter(textAfter);
  var currT = peekToken(state,1);
  var prevT = peekToken(state,2);

  if (state.in_string || state.in_atom) {
    return null;
  }else if (!prevT) {
    return 0;
  }else if (currT.token == "when") {
    return currT.column + cx.unit;
  }else if (wordAfter === "when" && prevT.type === "function") {
    return prevT.indent+cx.unit;
  }else if (wordAfter === "(" && currT.token === "fun") {
    return  currT.column+3;
  }else if (wordAfter === "catch" && (t = getToken(state,["try"]))) {
    return t.column;
  }else if (is_member(wordAfter,["end","after","of"])) {
    t = getToken(state,["begin","case","fun","if","receive","try"]);
    return t ? t.column : null;
  }else if (is_member(wordAfter,closeParenWords)) {
    t = getToken(state,openParenWords);
    return t ? t.column : null;
  }else if (is_member(currT.token,[",","|","||"]) ||
            is_member(wordAfter,[",","|","||"])) {
    t = postcommaToken(state);
    return t ? t.column+t.token.length : cx.unit;
  }else if (currT.token == "->") {
    if (is_member(prevT.token, ["receive","case","if","try"])) {
      return prevT.column+cx.unit+cx.unit;
    }else{
      return prevT.column+cx.unit;
    }
  }else if (is_member(currT.token,openParenWords)) {
    return currT.column+currT.token.length;
  }else{
    t = defaultToken(state);
    return truthy(t) ? t.column+cx.unit : 0;
  }
}

function wordafter(str) {
  var m = str.match(/,|[a-z]+|\}|\]|\)|>>|\|+|\(/);

  return truthy(m) && (m.index === 0) ? m[0] : "";
}

function postcommaToken(state) {
  var objs = state.tokenStack.slice(0,-1);
  var i = getTokenIndex(objs,"type",["open_paren"]);

  return truthy(objs[i]) ? objs[i] : false;
}

function defaultToken(state) {
  var objs = state.tokenStack;
  var stop = getTokenIndex(objs,"type",["open_paren","separator","keyword"]);
  var oper = getTokenIndex(objs,"type",["operator"]);

  if (truthy(stop) && truthy(oper) && stop < oper) {
    return objs[stop+1];
  } else if (truthy(stop)) {
    return objs[stop];
  } else {
    return false;
  }
}

function getToken(state,tokens) {
  var objs = state.tokenStack;
  var i = getTokenIndex(objs,"token",tokens);

  return truthy(objs[i]) ? objs[i] : false;
}

function getTokenIndex(objs,propname,propvals) {

  for (var i = objs.length-1; -1 < i ; i--) {
    if (is_member(objs[i][propname],propvals)) {
      return i;
    }
  }
  return false;
}

function truthy(x) {
  return (x !== false) && (x != null);
}

/////////////////////////////////////////////////////////////////////////////
// this object defines the mode

const erlang = {
  name: "erlang",
  startState() {
    return {tokenStack: [],
            in_string:  false,
            in_atom:    false};
  },

  token: tokenizer,

  indent: indenter,

  languageData: {
    commentTokens: {line: "%"}
  }
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV9lcmxhbmdfanMuZjUyMDc5ODVkNjlhNTU3ZWRmMGYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBLGlCQUFpQjs7QUFFakIsK0JBQStCO0FBQy9CO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsSUFBSSx5Q0FBeUMsRUFBRSxHQUFHLGFBQWE7O0FBRTFFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsTUFBTSxrQ0FBa0M7QUFDeEM7QUFDQSxpQ0FBaUM7QUFDakMsUUFBUTtBQUNSLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0JBQWtCLEtBQUssR0FBRztBQUNuQywyQkFBMkIsUUFBUTtBQUNuQywyQkFBMkIsUUFBUTtBQUNuQywyQkFBMkIsU0FBUztBQUNwQywyQkFBMkIsOENBQThDO0FBQ3pFLDJCQUEyQjtBQUMzQiw0Q0FBNEMsUUFBUTtBQUNwRCwyQkFBMkI7QUFDM0IsMkRBQTJEO0FBQzNELFNBQVMsa0JBQWtCLDZDQUE2QztBQUN4RSwyQkFBMkIsVUFBVTtBQUNyQywyQkFBMkIsV0FBVztBQUN0QywyQkFBMkIsb0JBQW9CO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xlZ2FjeS1tb2Rlcy9tb2RlL2VybGFuZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gY29uc3RhbnRzXG5cbnZhciB0eXBlV29yZHMgPSBbXG4gIFwiLXR5cGVcIiwgXCItc3BlY1wiLCBcIi1leHBvcnRfdHlwZVwiLCBcIi1vcGFxdWVcIl07XG5cbnZhciBrZXl3b3JkV29yZHMgPSBbXG4gIFwiYWZ0ZXJcIixcImJlZ2luXCIsXCJjYXRjaFwiLFwiY2FzZVwiLFwiY29uZFwiLFwiZW5kXCIsXCJmdW5cIixcImlmXCIsXG4gIFwibGV0XCIsXCJvZlwiLFwicXVlcnlcIixcInJlY2VpdmVcIixcInRyeVwiLFwid2hlblwiXTtcblxudmFyIHNlcGFyYXRvclJFICAgID0gL1tcXC0+LDtdLztcbnZhciBzZXBhcmF0b3JXb3JkcyA9IFtcbiAgXCItPlwiLFwiO1wiLFwiLFwiXTtcblxudmFyIG9wZXJhdG9yQXRvbVdvcmRzID0gW1xuICBcImFuZFwiLFwiYW5kYWxzb1wiLFwiYmFuZFwiLFwiYm5vdFwiLFwiYm9yXCIsXCJic2xcIixcImJzclwiLFwiYnhvclwiLFxuICBcImRpdlwiLFwibm90XCIsXCJvclwiLFwib3JlbHNlXCIsXCJyZW1cIixcInhvclwiXTtcblxudmFyIG9wZXJhdG9yU3ltYm9sUkUgICAgPSAvW1xcK1xcLVxcKlxcLzw+PVxcfDohXS87XG52YXIgb3BlcmF0b3JTeW1ib2xXb3JkcyA9IFtcbiAgXCI9XCIsXCIrXCIsXCItXCIsXCIqXCIsXCIvXCIsXCI+XCIsXCI+PVwiLFwiPFwiLFwiPTxcIixcIj06PVwiLFwiPT1cIixcIj0vPVwiLFwiLz1cIixcInx8XCIsXCI8LVwiLFwiIVwiXTtcblxudmFyIG9wZW5QYXJlblJFICAgID0gL1s8XFwoXFxbXFx7XS87XG52YXIgb3BlblBhcmVuV29yZHMgPSBbXG4gIFwiPDxcIixcIihcIixcIltcIixcIntcIl07XG5cbnZhciBjbG9zZVBhcmVuUkUgICAgPSAvWz5cXClcXF1cXH1dLztcbnZhciBjbG9zZVBhcmVuV29yZHMgPSBbXG4gIFwifVwiLFwiXVwiLFwiKVwiLFwiPj5cIl07XG5cbnZhciBndWFyZFdvcmRzID0gW1xuICBcImlzX2F0b21cIixcImlzX2JpbmFyeVwiLFwiaXNfYml0c3RyaW5nXCIsXCJpc19ib29sZWFuXCIsXCJpc19mbG9hdFwiLFxuICBcImlzX2Z1bmN0aW9uXCIsXCJpc19pbnRlZ2VyXCIsXCJpc19saXN0XCIsXCJpc19udW1iZXJcIixcImlzX3BpZFwiLFxuICBcImlzX3BvcnRcIixcImlzX3JlY29yZFwiLFwiaXNfcmVmZXJlbmNlXCIsXCJpc190dXBsZVwiLFxuICBcImF0b21cIixcImJpbmFyeVwiLFwiYml0c3RyaW5nXCIsXCJib29sZWFuXCIsXCJmdW5jdGlvblwiLFwiaW50ZWdlclwiLFwibGlzdFwiLFxuICBcIm51bWJlclwiLFwicGlkXCIsXCJwb3J0XCIsXCJyZWNvcmRcIixcInJlZmVyZW5jZVwiLFwidHVwbGVcIl07XG5cbnZhciBiaWZXb3JkcyA9IFtcbiAgXCJhYnNcIixcImFkbGVyMzJcIixcImFkbGVyMzJfY29tYmluZVwiLFwiYWxpdmVcIixcImFwcGx5XCIsXCJhdG9tX3RvX2JpbmFyeVwiLFxuICBcImF0b21fdG9fbGlzdFwiLFwiYmluYXJ5X3RvX2F0b21cIixcImJpbmFyeV90b19leGlzdGluZ19hdG9tXCIsXG4gIFwiYmluYXJ5X3RvX2xpc3RcIixcImJpbmFyeV90b190ZXJtXCIsXCJiaXRfc2l6ZVwiLFwiYml0c3RyaW5nX3RvX2xpc3RcIixcbiAgXCJieXRlX3NpemVcIixcImNoZWNrX3Byb2Nlc3NfY29kZVwiLFwiY29udGFjdF9iaW5hcnlcIixcImNyYzMyXCIsXG4gIFwiY3JjMzJfY29tYmluZVwiLFwiZGF0ZVwiLFwiZGVjb2RlX3BhY2tldFwiLFwiZGVsZXRlX21vZHVsZVwiLFxuICBcImRpc2Nvbm5lY3Rfbm9kZVwiLFwiZWxlbWVudFwiLFwiZXJhc2VcIixcImV4aXRcIixcImZsb2F0XCIsXCJmbG9hdF90b19saXN0XCIsXG4gIFwiZ2FyYmFnZV9jb2xsZWN0XCIsXCJnZXRcIixcImdldF9rZXlzXCIsXCJncm91cF9sZWFkZXJcIixcImhhbHRcIixcImhkXCIsXG4gIFwiaW50ZWdlcl90b19saXN0XCIsXCJpbnRlcm5hbF9iaWZcIixcImlvbGlzdF9zaXplXCIsXCJpb2xpc3RfdG9fYmluYXJ5XCIsXG4gIFwiaXNfYWxpdmVcIixcImlzX2F0b21cIixcImlzX2JpbmFyeVwiLFwiaXNfYml0c3RyaW5nXCIsXCJpc19ib29sZWFuXCIsXG4gIFwiaXNfZmxvYXRcIixcImlzX2Z1bmN0aW9uXCIsXCJpc19pbnRlZ2VyXCIsXCJpc19saXN0XCIsXCJpc19udW1iZXJcIixcImlzX3BpZFwiLFxuICBcImlzX3BvcnRcIixcImlzX3Byb2Nlc3NfYWxpdmVcIixcImlzX3JlY29yZFwiLFwiaXNfcmVmZXJlbmNlXCIsXCJpc190dXBsZVwiLFxuICBcImxlbmd0aFwiLFwibGlua1wiLFwibGlzdF90b19hdG9tXCIsXCJsaXN0X3RvX2JpbmFyeVwiLFwibGlzdF90b19iaXRzdHJpbmdcIixcbiAgXCJsaXN0X3RvX2V4aXN0aW5nX2F0b21cIixcImxpc3RfdG9fZmxvYXRcIixcImxpc3RfdG9faW50ZWdlclwiLFxuICBcImxpc3RfdG9fcGlkXCIsXCJsaXN0X3RvX3R1cGxlXCIsXCJsb2FkX21vZHVsZVwiLFwibWFrZV9yZWZcIixcIm1vZHVsZV9sb2FkZWRcIixcbiAgXCJtb25pdG9yX25vZGVcIixcIm5vZGVcIixcIm5vZGVfbGlua1wiLFwibm9kZV91bmxpbmtcIixcIm5vZGVzXCIsXCJub3RhbGl2ZVwiLFxuICBcIm5vd1wiLFwib3Blbl9wb3J0XCIsXCJwaWRfdG9fbGlzdFwiLFwicG9ydF9jbG9zZVwiLFwicG9ydF9jb21tYW5kXCIsXG4gIFwicG9ydF9jb25uZWN0XCIsXCJwb3J0X2NvbnRyb2xcIixcInByZV9sb2FkZWRcIixcInByb2Nlc3NfZmxhZ1wiLFxuICBcInByb2Nlc3NfaW5mb1wiLFwicHJvY2Vzc2VzXCIsXCJwdXJnZV9tb2R1bGVcIixcInB1dFwiLFwicmVnaXN0ZXJcIixcbiAgXCJyZWdpc3RlcmVkXCIsXCJyb3VuZFwiLFwic2VsZlwiLFwic2V0ZWxlbWVudFwiLFwic2l6ZVwiLFwic3Bhd25cIixcInNwYXduX2xpbmtcIixcbiAgXCJzcGF3bl9tb25pdG9yXCIsXCJzcGF3bl9vcHRcIixcInNwbGl0X2JpbmFyeVwiLFwic3RhdGlzdGljc1wiLFxuICBcInRlcm1fdG9fYmluYXJ5XCIsXCJ0aW1lXCIsXCJ0aHJvd1wiLFwidGxcIixcInRydW5jXCIsXCJ0dXBsZV9zaXplXCIsXG4gIFwidHVwbGVfdG9fbGlzdFwiLFwidW5saW5rXCIsXCJ1bnJlZ2lzdGVyXCIsXCJ3aGVyZWlzXCJdO1xuXG4vLyB1cHBlciBjYXNlOiBbQS1aXSBbw5gtw55dIFvDgC3Dll1cbi8vIGxvd2VyIGNhc2U6IFthLXpdIFvDny3Dtl0gW8O4LcO/XVxudmFyIGFudW1SRSAgICAgICA9IC9bXFx3QMOYLcOew4Atw5bDny3DtsO4LcO/XS87XG52YXIgZXNjYXBlc1JFICAgID1cbiAgICAvWzAtN117MSwzfXxbYmRlZm5yc3R2XFxcXFwiJ118XFxeW2EtekEtWl18eFswLTlhLXpBLVpdezJ9fHh7WzAtOWEtekEtWl0rfS87XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB0b2tlbml6ZXJcblxuZnVuY3Rpb24gdG9rZW5pemVyKHN0cmVhbSxzdGF0ZSkge1xuICAvLyBpbiBtdWx0aS1saW5lIHN0cmluZ1xuICBpZiAoc3RhdGUuaW5fc3RyaW5nKSB7XG4gICAgc3RhdGUuaW5fc3RyaW5nID0gKCFkb3VibGVRdW90ZShzdHJlYW0pKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJzdHJpbmdcIik7XG4gIH1cblxuICAvLyBpbiBtdWx0aS1saW5lIGF0b21cbiAgaWYgKHN0YXRlLmluX2F0b20pIHtcbiAgICBzdGF0ZS5pbl9hdG9tID0gKCFzaW5nbGVRdW90ZShzdHJlYW0pKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJhdG9tXCIpO1xuICB9XG5cbiAgLy8gd2hpdGVzcGFjZVxuICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJ3aGl0ZXNwYWNlXCIpO1xuICB9XG5cbiAgLy8gYXR0cmlidXRlcyBhbmQgdHlwZSBzcGVjc1xuICBpZiAoIXBlZWtUb2tlbihzdGF0ZSkgJiZcbiAgICAgIHN0cmVhbS5tYXRjaCgvLVxccypbYS16w58tw7bDuC3Dv11bXFx3w5gtw57DgC3DlsOfLcO2w7gtw79dKi8pKSB7XG4gICAgaWYgKGlzX21lbWJlcihzdHJlYW0uY3VycmVudCgpLHR5cGVXb3JkcykpIHtcbiAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcInR5cGVcIik7XG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJhdHRyaWJ1dGVcIik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcblxuICAvLyBjb21tZW50XG4gIGlmIChjaCA9PSAnJScpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiY29tbWVudFwiKTtcbiAgfVxuXG4gIC8vIGNvbG9uXG4gIGlmIChjaCA9PSBcIjpcIikge1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImNvbG9uXCIpO1xuICB9XG5cbiAgLy8gbWFjcm9cbiAgaWYgKGNoID09ICc/Jykge1xuICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgIHN0cmVhbS5lYXRXaGlsZShhbnVtUkUpO1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcIm1hY3JvXCIpO1xuICB9XG5cbiAgLy8gcmVjb3JkXG4gIGlmIChjaCA9PSBcIiNcIikge1xuICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgIHN0cmVhbS5lYXRXaGlsZShhbnVtUkUpO1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcInJlY29yZFwiKTtcbiAgfVxuXG4gIC8vIGRvbGxhciBlc2NhcGVcbiAgaWYgKGNoID09IFwiJFwiKSB7XG4gICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gXCJcXFxcXCIgJiYgIXN0cmVhbS5tYXRjaChlc2NhcGVzUkUpKSB7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJlcnJvclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwibnVtYmVyXCIpO1xuICB9XG5cbiAgLy8gZG90XG4gIGlmIChjaCA9PSBcIi5cIikge1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImRvdFwiKTtcbiAgfVxuXG4gIC8vIHF1b3RlZCBhdG9tXG4gIGlmIChjaCA9PSAnXFwnJykge1xuICAgIGlmICghKHN0YXRlLmluX2F0b20gPSAoIXNpbmdsZVF1b3RlKHN0cmVhbSkpKSkge1xuICAgICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxzKlxcL1xccypbMC05XS8sZmFsc2UpKSB7XG4gICAgICAgIHN0cmVhbS5tYXRjaCgvXFxzKlxcL1xccypbMC05XS8sdHJ1ZSk7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImZ1blwiKTsgICAgICAvLyAnZicvMCBzdHlsZSBmdW5cbiAgICAgIH1cbiAgICAgIGlmIChzdHJlYW0ubWF0Y2goL1xccypcXCgvLGZhbHNlKSB8fCBzdHJlYW0ubWF0Y2goL1xccyo6LyxmYWxzZSkpIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImF0b21cIik7XG4gIH1cblxuICAvLyBzdHJpbmdcbiAgaWYgKGNoID09ICdcIicpIHtcbiAgICBzdGF0ZS5pbl9zdHJpbmcgPSAoIWRvdWJsZVF1b3RlKHN0cmVhbSkpO1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcInN0cmluZ1wiKTtcbiAgfVxuXG4gIC8vIHZhcmlhYmxlXG4gIGlmICgvW0EtWl/DmC3DnsOALcOWXS8udGVzdChjaCkpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoYW51bVJFKTtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJ2YXJpYWJsZVwiKTtcbiAgfVxuXG4gIC8vIGF0b20va2V5d29yZC9CSUYvZnVuY3Rpb25cbiAgaWYgKC9bYS16X8OfLcO2w7gtw79dLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZShhbnVtUkUpO1xuXG4gICAgaWYgKHN0cmVhbS5tYXRjaCgvXFxzKlxcL1xccypbMC05XS8sZmFsc2UpKSB7XG4gICAgICBzdHJlYW0ubWF0Y2goL1xccypcXC9cXHMqWzAtOV0vLHRydWUpO1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZnVuXCIpOyAgICAgIC8vIGYvMCBzdHlsZSBmdW5cbiAgICB9XG5cbiAgICB2YXIgdyA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgICBpZiAoaXNfbWVtYmVyKHcsa2V5d29yZFdvcmRzKSkge1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwia2V5d29yZFwiKTtcbiAgICB9ZWxzZSBpZiAoaXNfbWVtYmVyKHcsb3BlcmF0b3JBdG9tV29yZHMpKSB7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJvcGVyYXRvclwiKTtcbiAgICB9ZWxzZSBpZiAoc3RyZWFtLm1hdGNoKC9cXHMqXFwoLyxmYWxzZSkpIHtcbiAgICAgIC8vICdwdXQnIGFuZCAnZXJsYW5nOnB1dCcgYXJlIGJpZnMsICdmb286cHV0JyBpcyBub3RcbiAgICAgIGlmIChpc19tZW1iZXIodyxiaWZXb3JkcykgJiZcbiAgICAgICAgICAoKHBlZWtUb2tlbihzdGF0ZSkudG9rZW4gIT0gXCI6XCIpIHx8XG4gICAgICAgICAgIChwZWVrVG9rZW4oc3RhdGUsMikudG9rZW4gPT0gXCJlcmxhbmdcIikpKSB7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImJ1aWx0aW5cIik7XG4gICAgICB9ZWxzZSBpZiAoaXNfbWVtYmVyKHcsZ3VhcmRXb3JkcykpIHtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZ3VhcmRcIik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKGxvb2thaGVhZChzdHJlYW0pID09IFwiOlwiKSB7XG4gICAgICBpZiAodyA9PSBcImVybGFuZ1wiKSB7XG4gICAgICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcImJ1aWx0aW5cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJmdW5jdGlvblwiKTtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAoaXNfbWVtYmVyKHcsW1widHJ1ZVwiLFwiZmFsc2VcIl0pKSB7XG4gICAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJib29sZWFuXCIpO1xuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiYXRvbVwiKTtcbiAgICB9XG4gIH1cblxuICAvLyBudW1iZXJcbiAgdmFyIGRpZ2l0UkUgICAgICA9IC9bMC05XS87XG4gIHZhciByYWRpeFJFICAgICAgPSAvWzAtOWEtekEtWl0vOyAgICAgICAgIC8vIDM2I3paIHN0eWxlIGludFxuICBpZiAoZGlnaXRSRS50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZShkaWdpdFJFKTtcbiAgICBpZiAoc3RyZWFtLmVhdCgnIycpKSB7ICAgICAgICAgICAgICAgIC8vIDM2I2FaICBzdHlsZSBpbnRlZ2VyXG4gICAgICBpZiAoIXN0cmVhbS5lYXRXaGlsZShyYWRpeFJFKSkge1xuICAgICAgICBzdHJlYW0uYmFja1VwKDEpOyAgICAgICAgICAgICAgICAgLy9cIjM2I1wiIC0gc3ludGF4IGVycm9yXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdHJlYW0uZWF0KCcuJykpIHsgICAgICAgLy8gZmxvYXRcbiAgICAgIGlmICghc3RyZWFtLmVhdFdoaWxlKGRpZ2l0UkUpKSB7XG4gICAgICAgIHN0cmVhbS5iYWNrVXAoMSk7ICAgICAgICAvLyBcIjMuXCIgLSBwcm9iYWJseSBlbmQgb2YgZnVuY3Rpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KC9bZUVdLykpIHsgICAgICAgIC8vIGZsb2F0IHdpdGggZXhwb25lbnRcbiAgICAgICAgICBpZiAoc3RyZWFtLmVhdCgvWy0rXS8pKSB7XG4gICAgICAgICAgICBpZiAoIXN0cmVhbS5lYXRXaGlsZShkaWdpdFJFKSkge1xuICAgICAgICAgICAgICBzdHJlYW0uYmFja1VwKDIpOyAgICAgICAgICAgIC8vIFwiMmUtXCIgLSBzeW50YXggZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzdHJlYW0uZWF0V2hpbGUoZGlnaXRSRSkpIHtcbiAgICAgICAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTsgICAgICAgICAgICAvLyBcIjJlXCIgLSBzeW50YXggZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwibnVtYmVyXCIpOyAgIC8vIG5vcm1hbCBpbnRlZ2VyXG4gIH1cblxuICAvLyBvcGVuIHBhcmVuc1xuICBpZiAobm9uZ3JlZWR5KHN0cmVhbSxvcGVuUGFyZW5SRSxvcGVuUGFyZW5Xb3JkcykpIHtcbiAgICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sXCJvcGVuX3BhcmVuXCIpO1xuICB9XG5cbiAgLy8gY2xvc2UgcGFyZW5zXG4gIGlmIChub25ncmVlZHkoc3RyZWFtLGNsb3NlUGFyZW5SRSxjbG9zZVBhcmVuV29yZHMpKSB7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwiY2xvc2VfcGFyZW5cIik7XG4gIH1cblxuICAvLyBzZXBhcmF0b3JzXG4gIGlmIChncmVlZHkoc3RyZWFtLHNlcGFyYXRvclJFLHNlcGFyYXRvcldvcmRzKSkge1xuICAgIHJldHVybiBydmFsKHN0YXRlLHN0cmVhbSxcInNlcGFyYXRvclwiKTtcbiAgfVxuXG4gIC8vIG9wZXJhdG9yc1xuICBpZiAoZ3JlZWR5KHN0cmVhbSxvcGVyYXRvclN5bWJvbFJFLG9wZXJhdG9yU3ltYm9sV29yZHMpKSB7XG4gICAgcmV0dXJuIHJ2YWwoc3RhdGUsc3RyZWFtLFwib3BlcmF0b3JcIik7XG4gIH1cblxuICByZXR1cm4gcnZhbChzdGF0ZSxzdHJlYW0sbnVsbCk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyB1dGlsaXRpZXNcbmZ1bmN0aW9uIG5vbmdyZWVkeShzdHJlYW0scmUsd29yZHMpIHtcbiAgaWYgKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoID09IDEgJiYgcmUudGVzdChzdHJlYW0uY3VycmVudCgpKSkge1xuICAgIHN0cmVhbS5iYWNrVXAoMSk7XG4gICAgd2hpbGUgKHJlLnRlc3Qoc3RyZWFtLnBlZWsoKSkpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgICBpZiAoaXNfbWVtYmVyKHN0cmVhbS5jdXJyZW50KCksd29yZHMpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW0uYmFja1VwKHN0cmVhbS5jdXJyZW50KCkubGVuZ3RoLTEpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ3JlZWR5KHN0cmVhbSxyZSx3b3Jkcykge1xuICBpZiAoc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGggPT0gMSAmJiByZS50ZXN0KHN0cmVhbS5jdXJyZW50KCkpKSB7XG4gICAgd2hpbGUgKHJlLnRlc3Qoc3RyZWFtLnBlZWsoKSkpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgfVxuICAgIHdoaWxlICgwIDwgc3RyZWFtLmN1cnJlbnQoKS5sZW5ndGgpIHtcbiAgICAgIGlmIChpc19tZW1iZXIoc3RyZWFtLmN1cnJlbnQoKSx3b3JkcykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgc3RyZWFtLmJhY2tVcCgxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RyZWFtLm5leHQoKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGRvdWJsZVF1b3RlKHN0cmVhbSkge1xuICByZXR1cm4gcXVvdGUoc3RyZWFtLCAnXCInLCAnXFxcXCcpO1xufVxuXG5mdW5jdGlvbiBzaW5nbGVRdW90ZShzdHJlYW0pIHtcbiAgcmV0dXJuIHF1b3RlKHN0cmVhbSwnXFwnJywnXFxcXCcpO1xufVxuXG5mdW5jdGlvbiBxdW90ZShzdHJlYW0scXVvdGVDaGFyLGVzY2FwZUNoYXIpIHtcbiAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuICAgIGlmIChjaCA9PSBxdW90ZUNoYXIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1lbHNlIGlmIChjaCA9PSBlc2NhcGVDaGFyKSB7XG4gICAgICBzdHJlYW0ubmV4dCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxvb2thaGVhZChzdHJlYW0pIHtcbiAgdmFyIG0gPSBzdHJlYW0ubWF0Y2goL15cXHMqKFteXFxzJV0pLywgZmFsc2UpXG4gIHJldHVybiBtID8gbVsxXSA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGlzX21lbWJlcihlbGVtZW50LGxpc3QpIHtcbiAgcmV0dXJuICgtMSA8IGxpc3QuaW5kZXhPZihlbGVtZW50KSk7XG59XG5cbmZ1bmN0aW9uIHJ2YWwoc3RhdGUsc3RyZWFtLHR5cGUpIHtcblxuICAvLyBwYXJzZSBzdGFja1xuICBwdXNoVG9rZW4oc3RhdGUscmVhbFRva2VuKHR5cGUsc3RyZWFtKSk7XG5cbiAgLy8gbWFwIGVybGFuZyB0b2tlbiB0eXBlIHRvIENvZGVNaXJyb3Igc3R5bGUgY2xhc3NcbiAgLy8gICAgIGVybGFuZyAgICAgICAgICAgICAtPiBDb2RlTWlycm9yIHRhZ1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSBcImF0b21cIjogICAgICAgIHJldHVybiBcImF0b21cIjtcbiAgY2FzZSBcImF0dHJpYnV0ZVwiOiAgIHJldHVybiBcImF0dHJpYnV0ZVwiO1xuICBjYXNlIFwiYm9vbGVhblwiOiAgICAgcmV0dXJuIFwiYXRvbVwiO1xuICBjYXNlIFwiYnVpbHRpblwiOiAgICAgcmV0dXJuIFwiYnVpbHRpblwiO1xuICBjYXNlIFwiY2xvc2VfcGFyZW5cIjogcmV0dXJuIG51bGw7XG4gIGNhc2UgXCJjb2xvblwiOiAgICAgICByZXR1cm4gbnVsbDtcbiAgY2FzZSBcImNvbW1lbnRcIjogICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgY2FzZSBcImRvdFwiOiAgICAgICAgIHJldHVybiBudWxsO1xuICBjYXNlIFwiZXJyb3JcIjogICAgICAgcmV0dXJuIFwiZXJyb3JcIjtcbiAgY2FzZSBcImZ1blwiOiAgICAgICAgIHJldHVybiBcIm1ldGFcIjtcbiAgY2FzZSBcImZ1bmN0aW9uXCI6ICAgIHJldHVybiBcInRhZ1wiO1xuICBjYXNlIFwiZ3VhcmRcIjogICAgICAgcmV0dXJuIFwicHJvcGVydHlcIjtcbiAgY2FzZSBcImtleXdvcmRcIjogICAgIHJldHVybiBcImtleXdvcmRcIjtcbiAgY2FzZSBcIm1hY3JvXCI6ICAgICAgIHJldHVybiBcIm1hY3JvTmFtZVwiO1xuICBjYXNlIFwibnVtYmVyXCI6ICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gIGNhc2UgXCJvcGVuX3BhcmVuXCI6ICByZXR1cm4gbnVsbDtcbiAgY2FzZSBcIm9wZXJhdG9yXCI6ICAgIHJldHVybiBcIm9wZXJhdG9yXCI7XG4gIGNhc2UgXCJyZWNvcmRcIjogICAgICByZXR1cm4gXCJicmFja2V0XCI7XG4gIGNhc2UgXCJzZXBhcmF0b3JcIjogICByZXR1cm4gbnVsbDtcbiAgY2FzZSBcInN0cmluZ1wiOiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICBjYXNlIFwidHlwZVwiOiAgICAgICAgcmV0dXJuIFwiZGVmXCI7XG4gIGNhc2UgXCJ2YXJpYWJsZVwiOiAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICBkZWZhdWx0OiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFUb2tlbih0b2ssY29sLGluZCx0eXApIHtcbiAgcmV0dXJuIHt0b2tlbjogIHRvayxcbiAgICAgICAgICBjb2x1bW46IGNvbCxcbiAgICAgICAgICBpbmRlbnQ6IGluZCxcbiAgICAgICAgICB0eXBlOiAgIHR5cH07XG59XG5cbmZ1bmN0aW9uIHJlYWxUb2tlbih0eXBlLHN0cmVhbSkge1xuICByZXR1cm4gYVRva2VuKHN0cmVhbS5jdXJyZW50KCksXG4gICAgICAgICAgICAgICAgc3RyZWFtLmNvbHVtbigpLFxuICAgICAgICAgICAgICAgIHN0cmVhbS5pbmRlbnRhdGlvbigpLFxuICAgICAgICAgICAgICAgIHR5cGUpO1xufVxuXG5mdW5jdGlvbiBmYWtlVG9rZW4odHlwZSkge1xuICByZXR1cm4gYVRva2VuKHR5cGUsMCwwLHR5cGUpO1xufVxuXG5mdW5jdGlvbiBwZWVrVG9rZW4oc3RhdGUsZGVwdGgpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLnRva2VuU3RhY2subGVuZ3RoO1xuICB2YXIgZGVwID0gKGRlcHRoID8gZGVwdGggOiAxKTtcblxuICBpZiAobGVuIDwgZGVwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9ZWxzZXtcbiAgICByZXR1cm4gc3RhdGUudG9rZW5TdGFja1tsZW4tZGVwXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXNoVG9rZW4oc3RhdGUsdG9rZW4pIHtcblxuICBpZiAoISh0b2tlbi50eXBlID09IFwiY29tbWVudFwiIHx8IHRva2VuLnR5cGUgPT0gXCJ3aGl0ZXNwYWNlXCIpKSB7XG4gICAgc3RhdGUudG9rZW5TdGFjayA9IG1heWJlX2Ryb3BfcHJlKHN0YXRlLnRva2VuU3RhY2ssdG9rZW4pO1xuICAgIHN0YXRlLnRva2VuU3RhY2sgPSBtYXliZV9kcm9wX3Bvc3Qoc3RhdGUudG9rZW5TdGFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVfZHJvcF9wcmUocyx0b2tlbikge1xuICB2YXIgbGFzdCA9IHMubGVuZ3RoLTE7XG5cbiAgaWYgKDAgPCBsYXN0ICYmIHNbbGFzdF0udHlwZSA9PT0gXCJyZWNvcmRcIiAmJiB0b2tlbi50eXBlID09PSBcImRvdFwiKSB7XG4gICAgcy5wb3AoKTtcbiAgfWVsc2UgaWYgKDAgPCBsYXN0ICYmIHNbbGFzdF0udHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgcy5wb3AoKTtcbiAgICBzLnB1c2godG9rZW4pO1xuICB9ZWxzZXtcbiAgICBzLnB1c2godG9rZW4pO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBtYXliZV9kcm9wX3Bvc3Qocykge1xuICBpZiAoIXMubGVuZ3RoKSByZXR1cm4gc1xuICB2YXIgbGFzdCA9IHMubGVuZ3RoLTE7XG5cbiAgaWYgKHNbbGFzdF0udHlwZSA9PT0gXCJkb3RcIikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBpZiAobGFzdCA+IDEgJiYgc1tsYXN0XS50eXBlID09PSBcImZ1blwiICYmIHNbbGFzdC0xXS50b2tlbiA9PT0gXCJmdW5cIikge1xuICAgIHJldHVybiBzLnNsaWNlKDAsbGFzdC0xKTtcbiAgfVxuICBzd2l0Y2ggKHNbbGFzdF0udG9rZW4pIHtcbiAgY2FzZSBcIn1cIjogICAgcmV0dXJuIGQocyx7ZzpbXCJ7XCJdfSk7XG4gIGNhc2UgXCJdXCI6ICAgIHJldHVybiBkKHMse2k6W1wiW1wiXX0pO1xuICBjYXNlIFwiKVwiOiAgICByZXR1cm4gZChzLHtpOltcIihcIl19KTtcbiAgY2FzZSBcIj4+XCI6ICAgcmV0dXJuIGQocyx7aTpbXCI8PFwiXX0pO1xuICBjYXNlIFwiZW5kXCI6ICByZXR1cm4gZChzLHtpOltcImJlZ2luXCIsXCJjYXNlXCIsXCJmdW5cIixcImlmXCIsXCJyZWNlaXZlXCIsXCJ0cnlcIl19KTtcbiAgY2FzZSBcIixcIjogICAgcmV0dXJuIGQocyx7ZTpbXCJiZWdpblwiLFwidHJ5XCIsXCJ3aGVuXCIsXCItPlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsXCIsXCIoXCIsXCJbXCIsXCJ7XCIsXCI8PFwiXX0pO1xuICBjYXNlIFwiLT5cIjogICByZXR1cm4gZChzLHtyOltcIndoZW5cIl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtOltcInRyeVwiLFwiaWZcIixcImNhc2VcIixcInJlY2VpdmVcIl19KTtcbiAgY2FzZSBcIjtcIjogICAgcmV0dXJuIGQocyx7RTpbXCJjYXNlXCIsXCJmdW5cIixcImlmXCIsXCJyZWNlaXZlXCIsXCJ0cnlcIixcIndoZW5cIl19KTtcbiAgY2FzZSBcImNhdGNoXCI6cmV0dXJuIGQocyx7ZTpbXCJ0cnlcIl19KTtcbiAgY2FzZSBcIm9mXCI6ICAgcmV0dXJuIGQocyx7ZTpbXCJjYXNlXCJdfSk7XG4gIGNhc2UgXCJhZnRlclwiOnJldHVybiBkKHMse2U6W1wicmVjZWl2ZVwiLFwidHJ5XCJdfSk7XG4gIGRlZmF1bHQ6ICAgICByZXR1cm4gcztcbiAgfVxufVxuXG5mdW5jdGlvbiBkKHN0YWNrLHR0KSB7XG4gIC8vIHN0YWNrIGlzIGEgc3RhY2sgb2YgVG9rZW4gb2JqZWN0cy5cbiAgLy8gdHQgaXMgYW4gb2JqZWN0OyB7dHlwZTp0b2tlbnN9XG4gIC8vIHR5cGUgaXMgYSBjaGFyLCB0b2tlbnMgaXMgYSBsaXN0IG9mIHRva2VuIHN0cmluZ3MuXG4gIC8vIFRoZSBmdW5jdGlvbiByZXR1cm5zIChwb3NzaWJseSB0cnVuY2F0ZWQpIHN0YWNrLlxuICAvLyBJdCB3aWxsIGRlc2NlbmQgdGhlIHN0YWNrLCBsb29raW5nIGZvciBhIFRva2VuIHN1Y2ggdGhhdCBUb2tlbi50b2tlblxuICAvLyAgaXMgYSBtZW1iZXIgb2YgdG9rZW5zLiBJZiBpdCBkb2VzIG5vdCBmaW5kIHRoYXQsIGl0IHdpbGwgbm9ybWFsbHkgKGJ1dFxuICAvLyAgc2VlIFwiRVwiIGJlbG93KSByZXR1cm4gc3RhY2suIElmIGl0IGRvZXMgZmluZCBhIG1hdGNoLCBpdCB3aWxsIHJlbW92ZVxuICAvLyAgYWxsIHRoZSBUb2tlbnMgYmV0d2VlbiB0aGUgdG9wIGFuZCB0aGUgbWF0Y2hlZCBUb2tlbi5cbiAgLy8gSWYgdHlwZSBpcyBcIm1cIiwgdGhhdCBpcyBhbGwgaXQgZG9lcy5cbiAgLy8gSWYgdHlwZSBpcyBcImlcIiwgaXQgd2lsbCBhbHNvIHJlbW92ZSB0aGUgbWF0Y2hlZCBUb2tlbiBhbmQgdGhlIHRvcCBUb2tlbi5cbiAgLy8gSWYgdHlwZSBpcyBcImdcIiwgbGlrZSBcImlcIiwgYnV0IGFkZCBhIGZha2UgXCJncm91cFwiIHRva2VuIGF0IHRoZSB0b3AuXG4gIC8vIElmIHR5cGUgaXMgXCJyXCIsIGl0IHdpbGwgcmVtb3ZlIHRoZSBtYXRjaGVkIFRva2VuLCBidXQgbm90IHRoZSB0b3AgVG9rZW4uXG4gIC8vIElmIHR5cGUgaXMgXCJlXCIsIGl0IHdpbGwga2VlcCB0aGUgbWF0Y2hlZCBUb2tlbiBidXQgbm90IHRoZSB0b3AgVG9rZW4uXG4gIC8vIElmIHR5cGUgaXMgXCJFXCIsIGl0IGJlaGF2ZXMgYXMgZm9yIHR5cGUgXCJlXCIsIGV4Y2VwdCBpZiB0aGVyZSBpcyBubyBtYXRjaCxcbiAgLy8gIGluIHdoaWNoIGNhc2UgaXQgd2lsbCByZXR1cm4gYW4gZW1wdHkgc3RhY2suXG5cbiAgZm9yICh2YXIgdHlwZSBpbiB0dCkge1xuICAgIHZhciBsZW4gPSBzdGFjay5sZW5ndGgtMTtcbiAgICB2YXIgdG9rZW5zID0gdHRbdHlwZV07XG4gICAgZm9yICh2YXIgaSA9IGxlbi0xOyAtMSA8IGkgOyBpLS0pIHtcbiAgICAgIGlmIChpc19tZW1iZXIoc3RhY2tbaV0udG9rZW4sdG9rZW5zKSkge1xuICAgICAgICB2YXIgc3MgPSBzdGFjay5zbGljZSgwLGkpO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcIm1cIjogcmV0dXJuIHNzLmNvbmNhdChzdGFja1tpXSkuY29uY2F0KHN0YWNrW2xlbl0pO1xuICAgICAgICBjYXNlIFwiclwiOiByZXR1cm4gc3MuY29uY2F0KHN0YWNrW2xlbl0pO1xuICAgICAgICBjYXNlIFwiaVwiOiByZXR1cm4gc3M7XG4gICAgICAgIGNhc2UgXCJnXCI6IHJldHVybiBzcy5jb25jYXQoZmFrZVRva2VuKFwiZ3JvdXBcIikpO1xuICAgICAgICBjYXNlIFwiRVwiOiByZXR1cm4gc3MuY29uY2F0KHN0YWNrW2ldKTtcbiAgICAgICAgY2FzZSBcImVcIjogcmV0dXJuIHNzLmNvbmNhdChzdGFja1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICh0eXBlID09IFwiRVwiID8gW10gOiBzdGFjayk7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBpbmRlbnRlclxuXG5mdW5jdGlvbiBpbmRlbnRlcihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICB2YXIgdDtcbiAgdmFyIHdvcmRBZnRlciA9IHdvcmRhZnRlcih0ZXh0QWZ0ZXIpO1xuICB2YXIgY3VyclQgPSBwZWVrVG9rZW4oc3RhdGUsMSk7XG4gIHZhciBwcmV2VCA9IHBlZWtUb2tlbihzdGF0ZSwyKTtcblxuICBpZiAoc3RhdGUuaW5fc3RyaW5nIHx8IHN0YXRlLmluX2F0b20pIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfWVsc2UgaWYgKCFwcmV2VCkge1xuICAgIHJldHVybiAwO1xuICB9ZWxzZSBpZiAoY3VyclQudG9rZW4gPT0gXCJ3aGVuXCIpIHtcbiAgICByZXR1cm4gY3VyclQuY29sdW1uICsgY3gudW5pdDtcbiAgfWVsc2UgaWYgKHdvcmRBZnRlciA9PT0gXCJ3aGVuXCIgJiYgcHJldlQudHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIHByZXZULmluZGVudCtjeC51bml0O1xuICB9ZWxzZSBpZiAod29yZEFmdGVyID09PSBcIihcIiAmJiBjdXJyVC50b2tlbiA9PT0gXCJmdW5cIikge1xuICAgIHJldHVybiAgY3VyclQuY29sdW1uKzM7XG4gIH1lbHNlIGlmICh3b3JkQWZ0ZXIgPT09IFwiY2F0Y2hcIiAmJiAodCA9IGdldFRva2VuKHN0YXRlLFtcInRyeVwiXSkpKSB7XG4gICAgcmV0dXJuIHQuY29sdW1uO1xuICB9ZWxzZSBpZiAoaXNfbWVtYmVyKHdvcmRBZnRlcixbXCJlbmRcIixcImFmdGVyXCIsXCJvZlwiXSkpIHtcbiAgICB0ID0gZ2V0VG9rZW4oc3RhdGUsW1wiYmVnaW5cIixcImNhc2VcIixcImZ1blwiLFwiaWZcIixcInJlY2VpdmVcIixcInRyeVwiXSk7XG4gICAgcmV0dXJuIHQgPyB0LmNvbHVtbiA6IG51bGw7XG4gIH1lbHNlIGlmIChpc19tZW1iZXIod29yZEFmdGVyLGNsb3NlUGFyZW5Xb3JkcykpIHtcbiAgICB0ID0gZ2V0VG9rZW4oc3RhdGUsb3BlblBhcmVuV29yZHMpO1xuICAgIHJldHVybiB0ID8gdC5jb2x1bW4gOiBudWxsO1xuICB9ZWxzZSBpZiAoaXNfbWVtYmVyKGN1cnJULnRva2VuLFtcIixcIixcInxcIixcInx8XCJdKSB8fFxuICAgICAgICAgICAgaXNfbWVtYmVyKHdvcmRBZnRlcixbXCIsXCIsXCJ8XCIsXCJ8fFwiXSkpIHtcbiAgICB0ID0gcG9zdGNvbW1hVG9rZW4oc3RhdGUpO1xuICAgIHJldHVybiB0ID8gdC5jb2x1bW4rdC50b2tlbi5sZW5ndGggOiBjeC51bml0O1xuICB9ZWxzZSBpZiAoY3VyclQudG9rZW4gPT0gXCItPlwiKSB7XG4gICAgaWYgKGlzX21lbWJlcihwcmV2VC50b2tlbiwgW1wicmVjZWl2ZVwiLFwiY2FzZVwiLFwiaWZcIixcInRyeVwiXSkpIHtcbiAgICAgIHJldHVybiBwcmV2VC5jb2x1bW4rY3gudW5pdCtjeC51bml0O1xuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIHByZXZULmNvbHVtbitjeC51bml0O1xuICAgIH1cbiAgfWVsc2UgaWYgKGlzX21lbWJlcihjdXJyVC50b2tlbixvcGVuUGFyZW5Xb3JkcykpIHtcbiAgICByZXR1cm4gY3VyclQuY29sdW1uK2N1cnJULnRva2VuLmxlbmd0aDtcbiAgfWVsc2V7XG4gICAgdCA9IGRlZmF1bHRUb2tlbihzdGF0ZSk7XG4gICAgcmV0dXJuIHRydXRoeSh0KSA/IHQuY29sdW1uK2N4LnVuaXQgOiAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdvcmRhZnRlcihzdHIpIHtcbiAgdmFyIG0gPSBzdHIubWF0Y2goLyx8W2Etel0rfFxcfXxcXF18XFwpfD4+fFxcfCt8XFwoLyk7XG5cbiAgcmV0dXJuIHRydXRoeShtKSAmJiAobS5pbmRleCA9PT0gMCkgPyBtWzBdIDogXCJcIjtcbn1cblxuZnVuY3Rpb24gcG9zdGNvbW1hVG9rZW4oc3RhdGUpIHtcbiAgdmFyIG9ianMgPSBzdGF0ZS50b2tlblN0YWNrLnNsaWNlKDAsLTEpO1xuICB2YXIgaSA9IGdldFRva2VuSW5kZXgob2JqcyxcInR5cGVcIixbXCJvcGVuX3BhcmVuXCJdKTtcblxuICByZXR1cm4gdHJ1dGh5KG9ianNbaV0pID8gb2Jqc1tpXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0VG9rZW4oc3RhdGUpIHtcbiAgdmFyIG9ianMgPSBzdGF0ZS50b2tlblN0YWNrO1xuICB2YXIgc3RvcCA9IGdldFRva2VuSW5kZXgob2JqcyxcInR5cGVcIixbXCJvcGVuX3BhcmVuXCIsXCJzZXBhcmF0b3JcIixcImtleXdvcmRcIl0pO1xuICB2YXIgb3BlciA9IGdldFRva2VuSW5kZXgob2JqcyxcInR5cGVcIixbXCJvcGVyYXRvclwiXSk7XG5cbiAgaWYgKHRydXRoeShzdG9wKSAmJiB0cnV0aHkob3BlcikgJiYgc3RvcCA8IG9wZXIpIHtcbiAgICByZXR1cm4gb2Jqc1tzdG9wKzFdO1xuICB9IGVsc2UgaWYgKHRydXRoeShzdG9wKSkge1xuICAgIHJldHVybiBvYmpzW3N0b3BdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUb2tlbihzdGF0ZSx0b2tlbnMpIHtcbiAgdmFyIG9ianMgPSBzdGF0ZS50b2tlblN0YWNrO1xuICB2YXIgaSA9IGdldFRva2VuSW5kZXgob2JqcyxcInRva2VuXCIsdG9rZW5zKTtcblxuICByZXR1cm4gdHJ1dGh5KG9ianNbaV0pID8gb2Jqc1tpXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRUb2tlbkluZGV4KG9ianMscHJvcG5hbWUscHJvcHZhbHMpIHtcblxuICBmb3IgKHZhciBpID0gb2Jqcy5sZW5ndGgtMTsgLTEgPCBpIDsgaS0tKSB7XG4gICAgaWYgKGlzX21lbWJlcihvYmpzW2ldW3Byb3BuYW1lXSxwcm9wdmFscykpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRydXRoeSh4KSB7XG4gIHJldHVybiAoeCAhPT0gZmFsc2UpICYmICh4ICE9IG51bGwpO1xufVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gdGhpcyBvYmplY3QgZGVmaW5lcyB0aGUgbW9kZVxuXG5leHBvcnQgY29uc3QgZXJsYW5nID0ge1xuICBuYW1lOiBcImVybGFuZ1wiLFxuICBzdGFydFN0YXRlKCkge1xuICAgIHJldHVybiB7dG9rZW5TdGFjazogW10sXG4gICAgICAgICAgICBpbl9zdHJpbmc6ICBmYWxzZSxcbiAgICAgICAgICAgIGluX2F0b206ICAgIGZhbHNlfTtcbiAgfSxcblxuICB0b2tlbjogdG9rZW5pemVyLFxuXG4gIGluZGVudDogaW5kZW50ZXIsXG5cbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY29tbWVudFRva2Vuczoge2xpbmU6IFwiJVwifVxuICB9XG59O1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=