"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_codemirror_legacy-modes_mode_xquery_js"],{

/***/ "../node_modules/@codemirror/legacy-modes/mode/xquery.js":
/*!***************************************************************!*\
  !*** ../node_modules/@codemirror/legacy-modes/mode/xquery.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "xQuery": () => (/* binding */ xQuery)
/* harmony export */ });
// The keywords object is set to the result of this self executing
// function. Each keyword is a property of the keywords object whose
// value is {type: atype, style: astyle}
var keywords = function(){
  // convenience functions used to build keywords object
  function kw(type) {return {type: type, style: "keyword"};}
  var operator = kw("operator")
  , atom = {type: "atom", style: "atom"}
  , punctuation = {type: "punctuation", style: null}
  , qualifier = {type: "axis_specifier", style: "qualifier"};

  // kwObj is what is return from this function at the end
  var kwObj = {
    ',': punctuation
  };

  // a list of 'basic' keywords. For each add a property to kwObj with the value of
  // {type: basic[i], style: "keyword"} e.g. 'after' --> {type: "after", style: "keyword"}
  var basic = ['after', 'all', 'allowing', 'ancestor', 'ancestor-or-self', 'any', 'array', 'as',
               'ascending', 'at', 'attribute', 'base-uri', 'before', 'boundary-space', 'by', 'case', 'cast',
               'castable', 'catch', 'child', 'collation', 'comment', 'construction', 'contains', 'content',
               'context', 'copy', 'copy-namespaces', 'count', 'decimal-format', 'declare', 'default', 'delete',
               'descendant', 'descendant-or-self', 'descending', 'diacritics', 'different', 'distance',
               'document', 'document-node', 'element', 'else', 'empty', 'empty-sequence', 'encoding', 'end',
               'entire', 'every', 'exactly', 'except', 'external', 'first', 'following', 'following-sibling',
               'for', 'from', 'ftand', 'ftnot', 'ft-option', 'ftor', 'function', 'fuzzy', 'greatest', 'group',
               'if', 'import', 'in', 'inherit', 'insensitive', 'insert', 'instance', 'intersect', 'into',
               'invoke', 'is', 'item', 'language', 'last', 'lax', 'least', 'let', 'levels', 'lowercase', 'map',
               'modify', 'module', 'most', 'namespace', 'next', 'no', 'node', 'nodes', 'no-inherit',
               'no-preserve', 'not', 'occurs', 'of', 'only', 'option', 'order', 'ordered', 'ordering',
               'paragraph', 'paragraphs', 'parent', 'phrase', 'preceding', 'preceding-sibling', 'preserve',
               'previous', 'processing-instruction', 'relationship', 'rename', 'replace', 'return',
               'revalidation', 'same', 'satisfies', 'schema', 'schema-attribute', 'schema-element', 'score',
               'self', 'sensitive', 'sentence', 'sentences', 'sequence', 'skip', 'sliding', 'some', 'stable',
               'start', 'stemming', 'stop', 'strict', 'strip', 'switch', 'text', 'then', 'thesaurus', 'times',
               'to', 'transform', 'treat', 'try', 'tumbling', 'type', 'typeswitch', 'union', 'unordered',
               'update', 'updating', 'uppercase', 'using', 'validate', 'value', 'variable', 'version',
               'weight', 'when', 'where', 'wildcards', 'window', 'with', 'without', 'word', 'words', 'xquery'];
  for(var i=0, l=basic.length; i < l; i++) { kwObj[basic[i]] = kw(basic[i]);};

  // a list of types. For each add a property to kwObj with the value of
  // {type: "atom", style: "atom"}
  var types = ['xs:anyAtomicType', 'xs:anySimpleType', 'xs:anyType', 'xs:anyURI',
               'xs:base64Binary', 'xs:boolean', 'xs:byte', 'xs:date', 'xs:dateTime', 'xs:dateTimeStamp',
               'xs:dayTimeDuration', 'xs:decimal', 'xs:double', 'xs:duration', 'xs:ENTITIES', 'xs:ENTITY',
               'xs:float', 'xs:gDay', 'xs:gMonth', 'xs:gMonthDay', 'xs:gYear', 'xs:gYearMonth', 'xs:hexBinary',
               'xs:ID', 'xs:IDREF', 'xs:IDREFS', 'xs:int', 'xs:integer', 'xs:item', 'xs:java', 'xs:language',
               'xs:long', 'xs:Name', 'xs:NCName', 'xs:negativeInteger', 'xs:NMTOKEN', 'xs:NMTOKENS',
               'xs:nonNegativeInteger', 'xs:nonPositiveInteger', 'xs:normalizedString', 'xs:NOTATION',
               'xs:numeric', 'xs:positiveInteger', 'xs:precisionDecimal', 'xs:QName', 'xs:short', 'xs:string',
               'xs:time', 'xs:token', 'xs:unsignedByte', 'xs:unsignedInt', 'xs:unsignedLong',
               'xs:unsignedShort', 'xs:untyped', 'xs:untypedAtomic', 'xs:yearMonthDuration'];
  for(var i=0, l=types.length; i < l; i++) { kwObj[types[i]] = atom;};

  // each operator will add a property to kwObj with value of {type: "operator", style: "keyword"}
  var operators = ['eq', 'ne', 'lt', 'le', 'gt', 'ge', ':=', '=', '>', '>=', '<', '<=', '.', '|', '?', 'and', 'or', 'div', 'idiv', 'mod', '*', '/', '+', '-'];
  for(var i=0, l=operators.length; i < l; i++) { kwObj[operators[i]] = operator;};

  // each axis_specifiers will add a property to kwObj with value of {type: "axis_specifier", style: "qualifier"}
  var axis_specifiers = ["self::", "attribute::", "child::", "descendant::", "descendant-or-self::", "parent::",
                         "ancestor::", "ancestor-or-self::", "following::", "preceding::", "following-sibling::", "preceding-sibling::"];
  for(var i=0, l=axis_specifiers.length; i < l; i++) { kwObj[axis_specifiers[i]] = qualifier; };

  return kwObj;
}();

function chain(stream, state, f) {
  state.tokenize = f;
  return f(stream, state);
}

// the primary mode tokenizer
function tokenBase(stream, state) {
  var ch = stream.next(),
      mightBeFunction = false,
      isEQName = isEQNameAhead(stream);

  // an XML tag (if not in some sub, chained tokenizer)
  if (ch == "<") {
    if(stream.match("!--", true))
      return chain(stream, state, tokenXMLComment);

    if(stream.match("![CDATA", false)) {
      state.tokenize = tokenCDATA;
      return "tag";
    }

    if(stream.match("?", false)) {
      return chain(stream, state, tokenPreProcessing);
    }

    var isclose = stream.eat("/");
    stream.eatSpace();
    var tagName = "", c;
    while ((c = stream.eat(/[^\s\u00a0=<>\"\'\/?]/))) tagName += c;

    return chain(stream, state, tokenTag(tagName, isclose));
  }
  // start code block
  else if(ch == "{") {
    pushStateStack(state, { type: "codeblock"});
    return null;
  }
  // end code block
  else if(ch == "}") {
    popStateStack(state);
    return null;
  }
  // if we're in an XML block
  else if(isInXmlBlock(state)) {
    if(ch == ">")
      return "tag";
    else if(ch == "/" && stream.eat(">")) {
      popStateStack(state);
      return "tag";
    }
    else
      return "variable";
  }
  // if a number
  else if (/\d/.test(ch)) {
    stream.match(/^\d*(?:\.\d*)?(?:E[+\-]?\d+)?/);
    return "atom";
  }
  // comment start
  else if (ch === "(" && stream.eat(":")) {
    pushStateStack(state, { type: "comment"});
    return chain(stream, state, tokenComment);
  }
  // quoted string
  else if (!isEQName && (ch === '"' || ch === "'"))
    return chain(stream, state, tokenString(ch));
  // variable
  else if(ch === "$") {
    return chain(stream, state, tokenVariable);
  }
  // assignment
  else if(ch ===":" && stream.eat("=")) {
    return "keyword";
  }
  // open paren
  else if(ch === "(") {
    pushStateStack(state, { type: "paren"});
    return null;
  }
  // close paren
  else if(ch === ")") {
    popStateStack(state);
    return null;
  }
  // open paren
  else if(ch === "[") {
    pushStateStack(state, { type: "bracket"});
    return null;
  }
  // close paren
  else if(ch === "]") {
    popStateStack(state);
    return null;
  }
  else {
    var known = keywords.propertyIsEnumerable(ch) && keywords[ch];

    // if there's a EQName ahead, consume the rest of the string portion, it's likely a function
    if(isEQName && ch === '\"') while(stream.next() !== '"'){}
    if(isEQName && ch === '\'') while(stream.next() !== '\''){}

    // gobble up a word if the character is not known
    if(!known) stream.eatWhile(/[\w\$_-]/);

    // gobble a colon in the case that is a lib func type call fn:doc
    var foundColon = stream.eat(":");

    // if there's not a second colon, gobble another word. Otherwise, it's probably an axis specifier
    // which should get matched as a keyword
    if(!stream.eat(":") && foundColon) {
      stream.eatWhile(/[\w\$_-]/);
    }
    // if the next non whitespace character is an open paren, this is probably a function (if not a keyword of other sort)
    if(stream.match(/^[ \t]*\(/, false)) {
      mightBeFunction = true;
    }
    // is the word a keyword?
    var word = stream.current();
    known = keywords.propertyIsEnumerable(word) && keywords[word];

    // if we think it's a function call but not yet known,
    // set style to variable for now for lack of something better
    if(mightBeFunction && !known) known = {type: "function_call", style: "def"};

    // if the previous word was element, attribute, axis specifier, this word should be the name of that
    if(isInXmlConstructor(state)) {
      popStateStack(state);
      return "variable";
    }
    // as previously checked, if the word is element,attribute, axis specifier, call it an "xmlconstructor" and
    // push the stack so we know to look for it on the next word
    if(word == "element" || word == "attribute" || known.type == "axis_specifier") pushStateStack(state, {type: "xmlconstructor"});

    // if the word is known, return the details of that else just call this a generic 'word'
    return known ? known.style : "variable";
  }
}

// handle comments, including nested
function tokenComment(stream, state) {
  var maybeEnd = false, maybeNested = false, nestedCount = 0, ch;
  while (ch = stream.next()) {
    if (ch == ")" && maybeEnd) {
      if(nestedCount > 0)
        nestedCount--;
      else {
        popStateStack(state);
        break;
      }
    }
    else if(ch == ":" && maybeNested) {
      nestedCount++;
    }
    maybeEnd = (ch == ":");
    maybeNested = (ch == "(");
  }

  return "comment";
}

// tokenizer for string literals
// optionally pass a tokenizer function to set state.tokenize back to when finished
function tokenString(quote, f) {
  return function(stream, state) {
    var ch;

    if(isInString(state) && stream.current() == quote) {
      popStateStack(state);
      if(f) state.tokenize = f;
      return "string";
    }

    pushStateStack(state, { type: "string", name: quote, tokenize: tokenString(quote, f) });

    // if we're in a string and in an XML block, allow an embedded code block
    if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
      state.tokenize = tokenBase;
      return "string";
    }


    while (ch = stream.next()) {
      if (ch ==  quote) {
        popStateStack(state);
        if(f) state.tokenize = f;
        break;
      }
      else {
        // if we're in a string and in an XML block, allow an embedded code block in an attribute
        if(stream.match("{", false) && isInXmlAttributeBlock(state)) {
          state.tokenize = tokenBase;
          return "string";
        }

      }
    }

    return "string";
  };
}

// tokenizer for variables
function tokenVariable(stream, state) {
  var isVariableChar = /[\w\$_-]/;

  // a variable may start with a quoted EQName so if the next character is quote, consume to the next quote
  if(stream.eat("\"")) {
    while(stream.next() !== '\"'){};
    stream.eat(":");
  } else {
    stream.eatWhile(isVariableChar);
    if(!stream.match(":=", false)) stream.eat(":");
  }
  stream.eatWhile(isVariableChar);
  state.tokenize = tokenBase;
  return "variable";
}

// tokenizer for XML tags
function tokenTag(name, isclose) {
  return function(stream, state) {
    stream.eatSpace();
    if(isclose && stream.eat(">")) {
      popStateStack(state);
      state.tokenize = tokenBase;
      return "tag";
    }
    // self closing tag without attributes?
    if(!stream.eat("/"))
      pushStateStack(state, { type: "tag", name: name, tokenize: tokenBase});
    if(!stream.eat(">")) {
      state.tokenize = tokenAttribute;
      return "tag";
    }
    else {
      state.tokenize = tokenBase;
    }
    return "tag";
  };
}

// tokenizer for XML attributes
function tokenAttribute(stream, state) {
  var ch = stream.next();

  if(ch == "/" && stream.eat(">")) {
    if(isInXmlAttributeBlock(state)) popStateStack(state);
    if(isInXmlBlock(state)) popStateStack(state);
    return "tag";
  }
  if(ch == ">") {
    if(isInXmlAttributeBlock(state)) popStateStack(state);
    return "tag";
  }
  if(ch == "=")
    return null;
  // quoted string
  if (ch == '"' || ch == "'")
    return chain(stream, state, tokenString(ch, tokenAttribute));

  if(!isInXmlAttributeBlock(state))
    pushStateStack(state, { type: "attribute", tokenize: tokenAttribute});

  stream.eat(/[a-zA-Z_:]/);
  stream.eatWhile(/[-a-zA-Z0-9_:.]/);
  stream.eatSpace();

  // the case where the attribute has not value and the tag was closed
  if(stream.match(">", false) || stream.match("/", false)) {
    popStateStack(state);
    state.tokenize = tokenBase;
  }

  return "attribute";
}

// handle comments, including nested
function tokenXMLComment(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "-" && stream.match("->", true)) {
      state.tokenize = tokenBase;
      return "comment";
    }
  }
}


// handle CDATA
function tokenCDATA(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "]" && stream.match("]", true)) {
      state.tokenize = tokenBase;
      return "comment";
    }
  }
}

// handle preprocessing instructions
function tokenPreProcessing(stream, state) {
  var ch;
  while (ch = stream.next()) {
    if (ch == "?" && stream.match(">", true)) {
      state.tokenize = tokenBase;
      return "processingInstruction";
    }
  }
}


// functions to test the current context of the state
function isInXmlBlock(state) { return isIn(state, "tag"); }
function isInXmlAttributeBlock(state) { return isIn(state, "attribute"); }
function isInXmlConstructor(state) { return isIn(state, "xmlconstructor"); }
function isInString(state) { return isIn(state, "string"); }

function isEQNameAhead(stream) {
  // assume we've already eaten a quote (")
  if(stream.current() === '"')
    return stream.match(/^[^\"]+\"\:/, false);
  else if(stream.current() === '\'')
    return stream.match(/^[^\"]+\'\:/, false);
  else
    return false;
}

function isIn(state, type) {
  return (state.stack.length && state.stack[state.stack.length - 1].type == type);
}

function pushStateStack(state, newState) {
  state.stack.push(newState);
}

function popStateStack(state) {
  state.stack.pop();
  var reinstateTokenize = state.stack.length && state.stack[state.stack.length-1].tokenize;
  state.tokenize = reinstateTokenize || tokenBase;
}

// the interface for the mode API
const xQuery = {
  name: "xquery",
  startState: function() {
    return {
      tokenize: tokenBase,
      cc: [],
      stack: []
    };
  },

  token: function(stream, state) {
    if (stream.eatSpace()) return null;
    var style = state.tokenize(stream, state);
    return style;
  },

  languageData: {
    commentTokens: {block: {open: "(:", close: ":)"}}
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29kZW1pcnJvcl9sZWdhY3ktbW9kZXNfbW9kZV94cXVlcnlfanMuOTBhZTNmMzU5MTJmMmNkZDA2MDkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsWUFBWTtBQUNaLG1CQUFtQjtBQUNuQixpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxrQ0FBa0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsT0FBTyxPQUFPOztBQUU3QztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPLE9BQU87O0FBRTdDLCtEQUErRDtBQUMvRDtBQUNBLG1DQUFtQyxPQUFPLE9BQU87O0FBRWpELHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0EseUNBQXlDLE9BQU8sT0FBTzs7QUFFdkQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQkFBZ0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLHVCQUF1Qjs7QUFFakk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0Qiw4REFBOEQ7O0FBRTFGO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkNBQTZDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLDRDQUE0Qzs7QUFFeEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQStCO0FBQy9CLHdDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckMsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUveHF1ZXJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRoZSBrZXl3b3JkcyBvYmplY3QgaXMgc2V0IHRvIHRoZSByZXN1bHQgb2YgdGhpcyBzZWxmIGV4ZWN1dGluZ1xuLy8gZnVuY3Rpb24uIEVhY2gga2V5d29yZCBpcyBhIHByb3BlcnR5IG9mIHRoZSBrZXl3b3JkcyBvYmplY3Qgd2hvc2Vcbi8vIHZhbHVlIGlzIHt0eXBlOiBhdHlwZSwgc3R5bGU6IGFzdHlsZX1cbnZhciBrZXl3b3JkcyA9IGZ1bmN0aW9uKCl7XG4gIC8vIGNvbnZlbmllbmNlIGZ1bmN0aW9ucyB1c2VkIHRvIGJ1aWxkIGtleXdvcmRzIG9iamVjdFxuICBmdW5jdGlvbiBrdyh0eXBlKSB7cmV0dXJuIHt0eXBlOiB0eXBlLCBzdHlsZTogXCJrZXl3b3JkXCJ9O31cbiAgdmFyIG9wZXJhdG9yID0ga3coXCJvcGVyYXRvclwiKVxuICAsIGF0b20gPSB7dHlwZTogXCJhdG9tXCIsIHN0eWxlOiBcImF0b21cIn1cbiAgLCBwdW5jdHVhdGlvbiA9IHt0eXBlOiBcInB1bmN0dWF0aW9uXCIsIHN0eWxlOiBudWxsfVxuICAsIHF1YWxpZmllciA9IHt0eXBlOiBcImF4aXNfc3BlY2lmaWVyXCIsIHN0eWxlOiBcInF1YWxpZmllclwifTtcblxuICAvLyBrd09iaiBpcyB3aGF0IGlzIHJldHVybiBmcm9tIHRoaXMgZnVuY3Rpb24gYXQgdGhlIGVuZFxuICB2YXIga3dPYmogPSB7XG4gICAgJywnOiBwdW5jdHVhdGlvblxuICB9O1xuXG4gIC8vIGEgbGlzdCBvZiAnYmFzaWMnIGtleXdvcmRzLiBGb3IgZWFjaCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHRoZSB2YWx1ZSBvZlxuICAvLyB7dHlwZTogYmFzaWNbaV0sIHN0eWxlOiBcImtleXdvcmRcIn0gZS5nLiAnYWZ0ZXInIC0tPiB7dHlwZTogXCJhZnRlclwiLCBzdHlsZTogXCJrZXl3b3JkXCJ9XG4gIHZhciBiYXNpYyA9IFsnYWZ0ZXInLCAnYWxsJywgJ2FsbG93aW5nJywgJ2FuY2VzdG9yJywgJ2FuY2VzdG9yLW9yLXNlbGYnLCAnYW55JywgJ2FycmF5JywgJ2FzJyxcbiAgICAgICAgICAgICAgICdhc2NlbmRpbmcnLCAnYXQnLCAnYXR0cmlidXRlJywgJ2Jhc2UtdXJpJywgJ2JlZm9yZScsICdib3VuZGFyeS1zcGFjZScsICdieScsICdjYXNlJywgJ2Nhc3QnLFxuICAgICAgICAgICAgICAgJ2Nhc3RhYmxlJywgJ2NhdGNoJywgJ2NoaWxkJywgJ2NvbGxhdGlvbicsICdjb21tZW50JywgJ2NvbnN0cnVjdGlvbicsICdjb250YWlucycsICdjb250ZW50JyxcbiAgICAgICAgICAgICAgICdjb250ZXh0JywgJ2NvcHknLCAnY29weS1uYW1lc3BhY2VzJywgJ2NvdW50JywgJ2RlY2ltYWwtZm9ybWF0JywgJ2RlY2xhcmUnLCAnZGVmYXVsdCcsICdkZWxldGUnLFxuICAgICAgICAgICAgICAgJ2Rlc2NlbmRhbnQnLCAnZGVzY2VuZGFudC1vci1zZWxmJywgJ2Rlc2NlbmRpbmcnLCAnZGlhY3JpdGljcycsICdkaWZmZXJlbnQnLCAnZGlzdGFuY2UnLFxuICAgICAgICAgICAgICAgJ2RvY3VtZW50JywgJ2RvY3VtZW50LW5vZGUnLCAnZWxlbWVudCcsICdlbHNlJywgJ2VtcHR5JywgJ2VtcHR5LXNlcXVlbmNlJywgJ2VuY29kaW5nJywgJ2VuZCcsXG4gICAgICAgICAgICAgICAnZW50aXJlJywgJ2V2ZXJ5JywgJ2V4YWN0bHknLCAnZXhjZXB0JywgJ2V4dGVybmFsJywgJ2ZpcnN0JywgJ2ZvbGxvd2luZycsICdmb2xsb3dpbmctc2libGluZycsXG4gICAgICAgICAgICAgICAnZm9yJywgJ2Zyb20nLCAnZnRhbmQnLCAnZnRub3QnLCAnZnQtb3B0aW9uJywgJ2Z0b3InLCAnZnVuY3Rpb24nLCAnZnV6enknLCAnZ3JlYXRlc3QnLCAnZ3JvdXAnLFxuICAgICAgICAgICAgICAgJ2lmJywgJ2ltcG9ydCcsICdpbicsICdpbmhlcml0JywgJ2luc2Vuc2l0aXZlJywgJ2luc2VydCcsICdpbnN0YW5jZScsICdpbnRlcnNlY3QnLCAnaW50bycsXG4gICAgICAgICAgICAgICAnaW52b2tlJywgJ2lzJywgJ2l0ZW0nLCAnbGFuZ3VhZ2UnLCAnbGFzdCcsICdsYXgnLCAnbGVhc3QnLCAnbGV0JywgJ2xldmVscycsICdsb3dlcmNhc2UnLCAnbWFwJyxcbiAgICAgICAgICAgICAgICdtb2RpZnknLCAnbW9kdWxlJywgJ21vc3QnLCAnbmFtZXNwYWNlJywgJ25leHQnLCAnbm8nLCAnbm9kZScsICdub2RlcycsICduby1pbmhlcml0JyxcbiAgICAgICAgICAgICAgICduby1wcmVzZXJ2ZScsICdub3QnLCAnb2NjdXJzJywgJ29mJywgJ29ubHknLCAnb3B0aW9uJywgJ29yZGVyJywgJ29yZGVyZWQnLCAnb3JkZXJpbmcnLFxuICAgICAgICAgICAgICAgJ3BhcmFncmFwaCcsICdwYXJhZ3JhcGhzJywgJ3BhcmVudCcsICdwaHJhc2UnLCAncHJlY2VkaW5nJywgJ3ByZWNlZGluZy1zaWJsaW5nJywgJ3ByZXNlcnZlJyxcbiAgICAgICAgICAgICAgICdwcmV2aW91cycsICdwcm9jZXNzaW5nLWluc3RydWN0aW9uJywgJ3JlbGF0aW9uc2hpcCcsICdyZW5hbWUnLCAncmVwbGFjZScsICdyZXR1cm4nLFxuICAgICAgICAgICAgICAgJ3JldmFsaWRhdGlvbicsICdzYW1lJywgJ3NhdGlzZmllcycsICdzY2hlbWEnLCAnc2NoZW1hLWF0dHJpYnV0ZScsICdzY2hlbWEtZWxlbWVudCcsICdzY29yZScsXG4gICAgICAgICAgICAgICAnc2VsZicsICdzZW5zaXRpdmUnLCAnc2VudGVuY2UnLCAnc2VudGVuY2VzJywgJ3NlcXVlbmNlJywgJ3NraXAnLCAnc2xpZGluZycsICdzb21lJywgJ3N0YWJsZScsXG4gICAgICAgICAgICAgICAnc3RhcnQnLCAnc3RlbW1pbmcnLCAnc3RvcCcsICdzdHJpY3QnLCAnc3RyaXAnLCAnc3dpdGNoJywgJ3RleHQnLCAndGhlbicsICd0aGVzYXVydXMnLCAndGltZXMnLFxuICAgICAgICAgICAgICAgJ3RvJywgJ3RyYW5zZm9ybScsICd0cmVhdCcsICd0cnknLCAndHVtYmxpbmcnLCAndHlwZScsICd0eXBlc3dpdGNoJywgJ3VuaW9uJywgJ3Vub3JkZXJlZCcsXG4gICAgICAgICAgICAgICAndXBkYXRlJywgJ3VwZGF0aW5nJywgJ3VwcGVyY2FzZScsICd1c2luZycsICd2YWxpZGF0ZScsICd2YWx1ZScsICd2YXJpYWJsZScsICd2ZXJzaW9uJyxcbiAgICAgICAgICAgICAgICd3ZWlnaHQnLCAnd2hlbicsICd3aGVyZScsICd3aWxkY2FyZHMnLCAnd2luZG93JywgJ3dpdGgnLCAnd2l0aG91dCcsICd3b3JkJywgJ3dvcmRzJywgJ3hxdWVyeSddO1xuICBmb3IodmFyIGk9MCwgbD1iYXNpYy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbYmFzaWNbaV1dID0ga3coYmFzaWNbaV0pO307XG5cbiAgLy8gYSBsaXN0IG9mIHR5cGVzLiBGb3IgZWFjaCBhZGQgYSBwcm9wZXJ0eSB0byBrd09iaiB3aXRoIHRoZSB2YWx1ZSBvZlxuICAvLyB7dHlwZTogXCJhdG9tXCIsIHN0eWxlOiBcImF0b21cIn1cbiAgdmFyIHR5cGVzID0gWyd4czphbnlBdG9taWNUeXBlJywgJ3hzOmFueVNpbXBsZVR5cGUnLCAneHM6YW55VHlwZScsICd4czphbnlVUkknLFxuICAgICAgICAgICAgICAgJ3hzOmJhc2U2NEJpbmFyeScsICd4czpib29sZWFuJywgJ3hzOmJ5dGUnLCAneHM6ZGF0ZScsICd4czpkYXRlVGltZScsICd4czpkYXRlVGltZVN0YW1wJyxcbiAgICAgICAgICAgICAgICd4czpkYXlUaW1lRHVyYXRpb24nLCAneHM6ZGVjaW1hbCcsICd4czpkb3VibGUnLCAneHM6ZHVyYXRpb24nLCAneHM6RU5USVRJRVMnLCAneHM6RU5USVRZJyxcbiAgICAgICAgICAgICAgICd4czpmbG9hdCcsICd4czpnRGF5JywgJ3hzOmdNb250aCcsICd4czpnTW9udGhEYXknLCAneHM6Z1llYXInLCAneHM6Z1llYXJNb250aCcsICd4czpoZXhCaW5hcnknLFxuICAgICAgICAgICAgICAgJ3hzOklEJywgJ3hzOklEUkVGJywgJ3hzOklEUkVGUycsICd4czppbnQnLCAneHM6aW50ZWdlcicsICd4czppdGVtJywgJ3hzOmphdmEnLCAneHM6bGFuZ3VhZ2UnLFxuICAgICAgICAgICAgICAgJ3hzOmxvbmcnLCAneHM6TmFtZScsICd4czpOQ05hbWUnLCAneHM6bmVnYXRpdmVJbnRlZ2VyJywgJ3hzOk5NVE9LRU4nLCAneHM6Tk1UT0tFTlMnLFxuICAgICAgICAgICAgICAgJ3hzOm5vbk5lZ2F0aXZlSW50ZWdlcicsICd4czpub25Qb3NpdGl2ZUludGVnZXInLCAneHM6bm9ybWFsaXplZFN0cmluZycsICd4czpOT1RBVElPTicsXG4gICAgICAgICAgICAgICAneHM6bnVtZXJpYycsICd4czpwb3NpdGl2ZUludGVnZXInLCAneHM6cHJlY2lzaW9uRGVjaW1hbCcsICd4czpRTmFtZScsICd4czpzaG9ydCcsICd4czpzdHJpbmcnLFxuICAgICAgICAgICAgICAgJ3hzOnRpbWUnLCAneHM6dG9rZW4nLCAneHM6dW5zaWduZWRCeXRlJywgJ3hzOnVuc2lnbmVkSW50JywgJ3hzOnVuc2lnbmVkTG9uZycsXG4gICAgICAgICAgICAgICAneHM6dW5zaWduZWRTaG9ydCcsICd4czp1bnR5cGVkJywgJ3hzOnVudHlwZWRBdG9taWMnLCAneHM6eWVhck1vbnRoRHVyYXRpb24nXTtcbiAgZm9yKHZhciBpPTAsIGw9dHlwZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGt3T2JqW3R5cGVzW2ldXSA9IGF0b207fTtcblxuICAvLyBlYWNoIG9wZXJhdG9yIHdpbGwgYWRkIGEgcHJvcGVydHkgdG8ga3dPYmogd2l0aCB2YWx1ZSBvZiB7dHlwZTogXCJvcGVyYXRvclwiLCBzdHlsZTogXCJrZXl3b3JkXCJ9XG4gIHZhciBvcGVyYXRvcnMgPSBbJ2VxJywgJ25lJywgJ2x0JywgJ2xlJywgJ2d0JywgJ2dlJywgJzo9JywgJz0nLCAnPicsICc+PScsICc8JywgJzw9JywgJy4nLCAnfCcsICc/JywgJ2FuZCcsICdvcicsICdkaXYnLCAnaWRpdicsICdtb2QnLCAnKicsICcvJywgJysnLCAnLSddO1xuICBmb3IodmFyIGk9MCwgbD1vcGVyYXRvcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGt3T2JqW29wZXJhdG9yc1tpXV0gPSBvcGVyYXRvcjt9O1xuXG4gIC8vIGVhY2ggYXhpc19zcGVjaWZpZXJzIHdpbGwgYWRkIGEgcHJvcGVydHkgdG8ga3dPYmogd2l0aCB2YWx1ZSBvZiB7dHlwZTogXCJheGlzX3NwZWNpZmllclwiLCBzdHlsZTogXCJxdWFsaWZpZXJcIn1cbiAgdmFyIGF4aXNfc3BlY2lmaWVycyA9IFtcInNlbGY6OlwiLCBcImF0dHJpYnV0ZTo6XCIsIFwiY2hpbGQ6OlwiLCBcImRlc2NlbmRhbnQ6OlwiLCBcImRlc2NlbmRhbnQtb3Itc2VsZjo6XCIsIFwicGFyZW50OjpcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICBcImFuY2VzdG9yOjpcIiwgXCJhbmNlc3Rvci1vci1zZWxmOjpcIiwgXCJmb2xsb3dpbmc6OlwiLCBcInByZWNlZGluZzo6XCIsIFwiZm9sbG93aW5nLXNpYmxpbmc6OlwiLCBcInByZWNlZGluZy1zaWJsaW5nOjpcIl07XG4gIGZvcih2YXIgaT0wLCBsPWF4aXNfc3BlY2lmaWVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHsga3dPYmpbYXhpc19zcGVjaWZpZXJzW2ldXSA9IHF1YWxpZmllcjsgfTtcblxuICByZXR1cm4ga3dPYmo7XG59KCk7XG5cbmZ1bmN0aW9uIGNoYWluKHN0cmVhbSwgc3RhdGUsIGYpIHtcbiAgc3RhdGUudG9rZW5pemUgPSBmO1xuICByZXR1cm4gZihzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gdGhlIHByaW1hcnkgbW9kZSB0b2tlbml6ZXJcbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCksXG4gICAgICBtaWdodEJlRnVuY3Rpb24gPSBmYWxzZSxcbiAgICAgIGlzRVFOYW1lID0gaXNFUU5hbWVBaGVhZChzdHJlYW0pO1xuXG4gIC8vIGFuIFhNTCB0YWcgKGlmIG5vdCBpbiBzb21lIHN1YiwgY2hhaW5lZCB0b2tlbml6ZXIpXG4gIGlmIChjaCA9PSBcIjxcIikge1xuICAgIGlmKHN0cmVhbS5tYXRjaChcIiEtLVwiLCB0cnVlKSlcbiAgICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblhNTENvbW1lbnQpO1xuXG4gICAgaWYoc3RyZWFtLm1hdGNoKFwiIVtDREFUQVwiLCBmYWxzZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5DREFUQTtcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIH1cblxuICAgIGlmKHN0cmVhbS5tYXRjaChcIj9cIiwgZmFsc2UpKSB7XG4gICAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5QcmVQcm9jZXNzaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgaXNjbG9zZSA9IHN0cmVhbS5lYXQoXCIvXCIpO1xuICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgIHZhciB0YWdOYW1lID0gXCJcIiwgYztcbiAgICB3aGlsZSAoKGMgPSBzdHJlYW0uZWF0KC9bXlxcc1xcdTAwYTA9PD5cXFwiXFwnXFwvP10vKSkpIHRhZ05hbWUgKz0gYztcblxuICAgIHJldHVybiBjaGFpbihzdHJlYW0sIHN0YXRlLCB0b2tlblRhZyh0YWdOYW1lLCBpc2Nsb3NlKSk7XG4gIH1cbiAgLy8gc3RhcnQgY29kZSBibG9ja1xuICBlbHNlIGlmKGNoID09IFwie1wiKSB7XG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJjb2RlYmxvY2tcIn0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGVuZCBjb2RlIGJsb2NrXG4gIGVsc2UgaWYoY2ggPT0gXCJ9XCIpIHtcbiAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBpZiB3ZSdyZSBpbiBhbiBYTUwgYmxvY2tcbiAgZWxzZSBpZihpc0luWG1sQmxvY2soc3RhdGUpKSB7XG4gICAgaWYoY2ggPT0gXCI+XCIpXG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICBlbHNlIGlmKGNoID09IFwiL1wiICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICByZXR1cm4gXCJ2YXJpYWJsZVwiO1xuICB9XG4gIC8vIGlmIGEgbnVtYmVyXG4gIGVsc2UgaWYgKC9cXGQvLnRlc3QoY2gpKSB7XG4gICAgc3RyZWFtLm1hdGNoKC9eXFxkKig/OlxcLlxcZCopPyg/OkVbK1xcLV0/XFxkKyk/Lyk7XG4gICAgcmV0dXJuIFwiYXRvbVwiO1xuICB9XG4gIC8vIGNvbW1lbnQgc3RhcnRcbiAgZWxzZSBpZiAoY2ggPT09IFwiKFwiICYmIHN0cmVhbS5lYXQoXCI6XCIpKSB7XG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJjb21tZW50XCJ9KTtcbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5Db21tZW50KTtcbiAgfVxuICAvLyBxdW90ZWQgc3RyaW5nXG4gIGVsc2UgaWYgKCFpc0VRTmFtZSAmJiAoY2ggPT09ICdcIicgfHwgY2ggPT09IFwiJ1wiKSlcbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5TdHJpbmcoY2gpKTtcbiAgLy8gdmFyaWFibGVcbiAgZWxzZSBpZihjaCA9PT0gXCIkXCIpIHtcbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5WYXJpYWJsZSk7XG4gIH1cbiAgLy8gYXNzaWdubWVudFxuICBlbHNlIGlmKGNoID09PVwiOlwiICYmIHN0cmVhbS5lYXQoXCI9XCIpKSB7XG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuICB9XG4gIC8vIG9wZW4gcGFyZW5cbiAgZWxzZSBpZihjaCA9PT0gXCIoXCIpIHtcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcInBhcmVuXCJ9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvLyBjbG9zZSBwYXJlblxuICBlbHNlIGlmKGNoID09PSBcIilcIikge1xuICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIG9wZW4gcGFyZW5cbiAgZWxzZSBpZihjaCA9PT0gXCJbXCIpIHtcbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcImJyYWNrZXRcIn0pO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIGNsb3NlIHBhcmVuXG4gIGVsc2UgaWYoY2ggPT09IFwiXVwiKSB7XG4gICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGtub3duID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUoY2gpICYmIGtleXdvcmRzW2NoXTtcblxuICAgIC8vIGlmIHRoZXJlJ3MgYSBFUU5hbWUgYWhlYWQsIGNvbnN1bWUgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyBwb3J0aW9uLCBpdCdzIGxpa2VseSBhIGZ1bmN0aW9uXG4gICAgaWYoaXNFUU5hbWUgJiYgY2ggPT09ICdcXFwiJykgd2hpbGUoc3RyZWFtLm5leHQoKSAhPT0gJ1wiJyl7fVxuICAgIGlmKGlzRVFOYW1lICYmIGNoID09PSAnXFwnJykgd2hpbGUoc3RyZWFtLm5leHQoKSAhPT0gJ1xcJycpe31cblxuICAgIC8vIGdvYmJsZSB1cCBhIHdvcmQgaWYgdGhlIGNoYXJhY3RlciBpcyBub3Qga25vd25cbiAgICBpZigha25vd24pIHN0cmVhbS5lYXRXaGlsZSgvW1xcd1xcJF8tXS8pO1xuXG4gICAgLy8gZ29iYmxlIGEgY29sb24gaW4gdGhlIGNhc2UgdGhhdCBpcyBhIGxpYiBmdW5jIHR5cGUgY2FsbCBmbjpkb2NcbiAgICB2YXIgZm91bmRDb2xvbiA9IHN0cmVhbS5lYXQoXCI6XCIpO1xuXG4gICAgLy8gaWYgdGhlcmUncyBub3QgYSBzZWNvbmQgY29sb24sIGdvYmJsZSBhbm90aGVyIHdvcmQuIE90aGVyd2lzZSwgaXQncyBwcm9iYWJseSBhbiBheGlzIHNwZWNpZmllclxuICAgIC8vIHdoaWNoIHNob3VsZCBnZXQgbWF0Y2hlZCBhcyBhIGtleXdvcmRcbiAgICBpZighc3RyZWFtLmVhdChcIjpcIikgJiYgZm91bmRDb2xvbikge1xuICAgICAgc3RyZWFtLmVhdFdoaWxlKC9bXFx3XFwkXy1dLyk7XG4gICAgfVxuICAgIC8vIGlmIHRoZSBuZXh0IG5vbiB3aGl0ZXNwYWNlIGNoYXJhY3RlciBpcyBhbiBvcGVuIHBhcmVuLCB0aGlzIGlzIHByb2JhYmx5IGEgZnVuY3Rpb24gKGlmIG5vdCBhIGtleXdvcmQgb2Ygb3RoZXIgc29ydClcbiAgICBpZihzdHJlYW0ubWF0Y2goL15bIFxcdF0qXFwoLywgZmFsc2UpKSB7XG4gICAgICBtaWdodEJlRnVuY3Rpb24gPSB0cnVlO1xuICAgIH1cbiAgICAvLyBpcyB0aGUgd29yZCBhIGtleXdvcmQ/XG4gICAgdmFyIHdvcmQgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIGtub3duID0ga2V5d29yZHMucHJvcGVydHlJc0VudW1lcmFibGUod29yZCkgJiYga2V5d29yZHNbd29yZF07XG5cbiAgICAvLyBpZiB3ZSB0aGluayBpdCdzIGEgZnVuY3Rpb24gY2FsbCBidXQgbm90IHlldCBrbm93bixcbiAgICAvLyBzZXQgc3R5bGUgdG8gdmFyaWFibGUgZm9yIG5vdyBmb3IgbGFjayBvZiBzb21ldGhpbmcgYmV0dGVyXG4gICAgaWYobWlnaHRCZUZ1bmN0aW9uICYmICFrbm93bikga25vd24gPSB7dHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsIHN0eWxlOiBcImRlZlwifTtcblxuICAgIC8vIGlmIHRoZSBwcmV2aW91cyB3b3JkIHdhcyBlbGVtZW50LCBhdHRyaWJ1dGUsIGF4aXMgc3BlY2lmaWVyLCB0aGlzIHdvcmQgc2hvdWxkIGJlIHRoZSBuYW1lIG9mIHRoYXRcbiAgICBpZihpc0luWG1sQ29uc3RydWN0b3Ioc3RhdGUpKSB7XG4gICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgIHJldHVybiBcInZhcmlhYmxlXCI7XG4gICAgfVxuICAgIC8vIGFzIHByZXZpb3VzbHkgY2hlY2tlZCwgaWYgdGhlIHdvcmQgaXMgZWxlbWVudCxhdHRyaWJ1dGUsIGF4aXMgc3BlY2lmaWVyLCBjYWxsIGl0IGFuIFwieG1sY29uc3RydWN0b3JcIiBhbmRcbiAgICAvLyBwdXNoIHRoZSBzdGFjayBzbyB3ZSBrbm93IHRvIGxvb2sgZm9yIGl0IG9uIHRoZSBuZXh0IHdvcmRcbiAgICBpZih3b3JkID09IFwiZWxlbWVudFwiIHx8IHdvcmQgPT0gXCJhdHRyaWJ1dGVcIiB8fCBrbm93bi50eXBlID09IFwiYXhpc19zcGVjaWZpZXJcIikgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHt0eXBlOiBcInhtbGNvbnN0cnVjdG9yXCJ9KTtcblxuICAgIC8vIGlmIHRoZSB3b3JkIGlzIGtub3duLCByZXR1cm4gdGhlIGRldGFpbHMgb2YgdGhhdCBlbHNlIGp1c3QgY2FsbCB0aGlzIGEgZ2VuZXJpYyAnd29yZCdcbiAgICByZXR1cm4ga25vd24gPyBrbm93bi5zdHlsZSA6IFwidmFyaWFibGVcIjtcbiAgfVxufVxuXG4vLyBoYW5kbGUgY29tbWVudHMsIGluY2x1ZGluZyBuZXN0ZWRcbmZ1bmN0aW9uIHRva2VuQ29tbWVudChzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBtYXliZUVuZCA9IGZhbHNlLCBtYXliZU5lc3RlZCA9IGZhbHNlLCBuZXN0ZWRDb3VudCA9IDAsIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiKVwiICYmIG1heWJlRW5kKSB7XG4gICAgICBpZihuZXN0ZWRDb3VudCA+IDApXG4gICAgICAgIG5lc3RlZENvdW50LS07XG4gICAgICBlbHNlIHtcbiAgICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmKGNoID09IFwiOlwiICYmIG1heWJlTmVzdGVkKSB7XG4gICAgICBuZXN0ZWRDb3VudCsrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIjpcIik7XG4gICAgbWF5YmVOZXN0ZWQgPSAoY2ggPT0gXCIoXCIpO1xuICB9XG5cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG4vLyB0b2tlbml6ZXIgZm9yIHN0cmluZyBsaXRlcmFsc1xuLy8gb3B0aW9uYWxseSBwYXNzIGEgdG9rZW5pemVyIGZ1bmN0aW9uIHRvIHNldCBzdGF0ZS50b2tlbml6ZSBiYWNrIHRvIHdoZW4gZmluaXNoZWRcbmZ1bmN0aW9uIHRva2VuU3RyaW5nKHF1b3RlLCBmKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgdmFyIGNoO1xuXG4gICAgaWYoaXNJblN0cmluZyhzdGF0ZSkgJiYgc3RyZWFtLmN1cnJlbnQoKSA9PSBxdW90ZSkge1xuICAgICAgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgICBpZihmKSBzdGF0ZS50b2tlbml6ZSA9IGY7XG4gICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG5cbiAgICBwdXNoU3RhdGVTdGFjayhzdGF0ZSwgeyB0eXBlOiBcInN0cmluZ1wiLCBuYW1lOiBxdW90ZSwgdG9rZW5pemU6IHRva2VuU3RyaW5nKHF1b3RlLCBmKSB9KTtcblxuICAgIC8vIGlmIHdlJ3JlIGluIGEgc3RyaW5nIGFuZCBpbiBhbiBYTUwgYmxvY2ssIGFsbG93IGFuIGVtYmVkZGVkIGNvZGUgYmxvY2tcbiAgICBpZihzdHJlYW0ubWF0Y2goXCJ7XCIsIGZhbHNlKSAmJiBpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cblxuXG4gICAgd2hpbGUgKGNoID0gc3RyZWFtLm5leHQoKSkge1xuICAgICAgaWYgKGNoID09ICBxdW90ZSkge1xuICAgICAgICBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICAgICAgaWYoZikgc3RhdGUudG9rZW5pemUgPSBmO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBpZiB3ZSdyZSBpbiBhIHN0cmluZyBhbmQgaW4gYW4gWE1MIGJsb2NrLCBhbGxvdyBhbiBlbWJlZGRlZCBjb2RlIGJsb2NrIGluIGFuIGF0dHJpYnV0ZVxuICAgICAgICBpZihzdHJlYW0ubWF0Y2goXCJ7XCIsIGZhbHNlKSAmJiBpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKSB7XG4gICAgICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9O1xufVxuXG4vLyB0b2tlbml6ZXIgZm9yIHZhcmlhYmxlc1xuZnVuY3Rpb24gdG9rZW5WYXJpYWJsZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBpc1ZhcmlhYmxlQ2hhciA9IC9bXFx3XFwkXy1dLztcblxuICAvLyBhIHZhcmlhYmxlIG1heSBzdGFydCB3aXRoIGEgcXVvdGVkIEVRTmFtZSBzbyBpZiB0aGUgbmV4dCBjaGFyYWN0ZXIgaXMgcXVvdGUsIGNvbnN1bWUgdG8gdGhlIG5leHQgcXVvdGVcbiAgaWYoc3RyZWFtLmVhdChcIlxcXCJcIikpIHtcbiAgICB3aGlsZShzdHJlYW0ubmV4dCgpICE9PSAnXFxcIicpe307XG4gICAgc3RyZWFtLmVhdChcIjpcIik7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLmVhdFdoaWxlKGlzVmFyaWFibGVDaGFyKTtcbiAgICBpZighc3RyZWFtLm1hdGNoKFwiOj1cIiwgZmFsc2UpKSBzdHJlYW0uZWF0KFwiOlwiKTtcbiAgfVxuICBzdHJlYW0uZWF0V2hpbGUoaXNWYXJpYWJsZUNoYXIpO1xuICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgcmV0dXJuIFwidmFyaWFibGVcIjtcbn1cblxuLy8gdG9rZW5pemVyIGZvciBYTUwgdGFnc1xuZnVuY3Rpb24gdG9rZW5UYWcobmFtZSwgaXNjbG9zZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHN0cmVhbS5lYXRTcGFjZSgpO1xuICAgIGlmKGlzY2xvc2UgJiYgc3RyZWFtLmVhdChcIj5cIikpIHtcbiAgICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJ0YWdcIjtcbiAgICB9XG4gICAgLy8gc2VsZiBjbG9zaW5nIHRhZyB3aXRob3V0IGF0dHJpYnV0ZXM/XG4gICAgaWYoIXN0cmVhbS5lYXQoXCIvXCIpKVxuICAgICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJ0YWdcIiwgbmFtZTogbmFtZSwgdG9rZW5pemU6IHRva2VuQmFzZX0pO1xuICAgIGlmKCFzdHJlYW0uZWF0KFwiPlwiKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkF0dHJpYnV0ZTtcbiAgICAgIHJldHVybiBcInRhZ1wiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIH1cbiAgICByZXR1cm4gXCJ0YWdcIjtcbiAgfTtcbn1cblxuLy8gdG9rZW5pemVyIGZvciBYTUwgYXR0cmlidXRlc1xuZnVuY3Rpb24gdG9rZW5BdHRyaWJ1dGUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2ggPSBzdHJlYW0ubmV4dCgpO1xuXG4gIGlmKGNoID09IFwiL1wiICYmIHN0cmVhbS5lYXQoXCI+XCIpKSB7XG4gICAgaWYoaXNJblhtbEF0dHJpYnV0ZUJsb2NrKHN0YXRlKSkgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgaWYoaXNJblhtbEJsb2NrKHN0YXRlKSkgcG9wU3RhdGVTdGFjayhzdGF0ZSk7XG4gICAgcmV0dXJuIFwidGFnXCI7XG4gIH1cbiAgaWYoY2ggPT0gXCI+XCIpIHtcbiAgICBpZihpc0luWG1sQXR0cmlidXRlQmxvY2soc3RhdGUpKSBwb3BTdGF0ZVN0YWNrKHN0YXRlKTtcbiAgICByZXR1cm4gXCJ0YWdcIjtcbiAgfVxuICBpZihjaCA9PSBcIj1cIilcbiAgICByZXR1cm4gbnVsbDtcbiAgLy8gcXVvdGVkIHN0cmluZ1xuICBpZiAoY2ggPT0gJ1wiJyB8fCBjaCA9PSBcIidcIilcbiAgICByZXR1cm4gY2hhaW4oc3RyZWFtLCBzdGF0ZSwgdG9rZW5TdHJpbmcoY2gsIHRva2VuQXR0cmlidXRlKSk7XG5cbiAgaWYoIWlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkpXG4gICAgcHVzaFN0YXRlU3RhY2soc3RhdGUsIHsgdHlwZTogXCJhdHRyaWJ1dGVcIiwgdG9rZW5pemU6IHRva2VuQXR0cmlidXRlfSk7XG5cbiAgc3RyZWFtLmVhdCgvW2EtekEtWl86XS8pO1xuICBzdHJlYW0uZWF0V2hpbGUoL1stYS16QS1aMC05XzouXS8pO1xuICBzdHJlYW0uZWF0U3BhY2UoKTtcblxuICAvLyB0aGUgY2FzZSB3aGVyZSB0aGUgYXR0cmlidXRlIGhhcyBub3QgdmFsdWUgYW5kIHRoZSB0YWcgd2FzIGNsb3NlZFxuICBpZihzdHJlYW0ubWF0Y2goXCI+XCIsIGZhbHNlKSB8fCBzdHJlYW0ubWF0Y2goXCIvXCIsIGZhbHNlKSkge1xuICAgIHBvcFN0YXRlU3RhY2soc3RhdGUpO1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICB9XG5cbiAgcmV0dXJuIFwiYXR0cmlidXRlXCI7XG59XG5cbi8vIGhhbmRsZSBjb21tZW50cywgaW5jbHVkaW5nIG5lc3RlZFxuZnVuY3Rpb24gdG9rZW5YTUxDb21tZW50KHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiLVwiICYmIHN0cmVhbS5tYXRjaChcIi0+XCIsIHRydWUpKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIHJldHVybiBcImNvbW1lbnRcIjtcbiAgICB9XG4gIH1cbn1cblxuXG4vLyBoYW5kbGUgQ0RBVEFcbmZ1bmN0aW9uIHRva2VuQ0RBVEEoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgY2g7XG4gIHdoaWxlIChjaCA9IHN0cmVhbS5uZXh0KCkpIHtcbiAgICBpZiAoY2ggPT0gXCJdXCIgJiYgc3RyZWFtLm1hdGNoKFwiXVwiLCB0cnVlKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkJhc2U7XG4gICAgICByZXR1cm4gXCJjb21tZW50XCI7XG4gICAgfVxuICB9XG59XG5cbi8vIGhhbmRsZSBwcmVwcm9jZXNzaW5nIGluc3RydWN0aW9uc1xuZnVuY3Rpb24gdG9rZW5QcmVQcm9jZXNzaW5nKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGNoO1xuICB3aGlsZSAoY2ggPSBzdHJlYW0ubmV4dCgpKSB7XG4gICAgaWYgKGNoID09IFwiP1wiICYmIHN0cmVhbS5tYXRjaChcIj5cIiwgdHJ1ZSkpIHtcbiAgICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgICAgcmV0dXJuIFwicHJvY2Vzc2luZ0luc3RydWN0aW9uXCI7XG4gICAgfVxuICB9XG59XG5cblxuLy8gZnVuY3Rpb25zIHRvIHRlc3QgdGhlIGN1cnJlbnQgY29udGV4dCBvZiB0aGUgc3RhdGVcbmZ1bmN0aW9uIGlzSW5YbWxCbG9jayhzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJ0YWdcIik7IH1cbmZ1bmN0aW9uIGlzSW5YbWxBdHRyaWJ1dGVCbG9jayhzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJhdHRyaWJ1dGVcIik7IH1cbmZ1bmN0aW9uIGlzSW5YbWxDb25zdHJ1Y3RvcihzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJ4bWxjb25zdHJ1Y3RvclwiKTsgfVxuZnVuY3Rpb24gaXNJblN0cmluZyhzdGF0ZSkgeyByZXR1cm4gaXNJbihzdGF0ZSwgXCJzdHJpbmdcIik7IH1cblxuZnVuY3Rpb24gaXNFUU5hbWVBaGVhZChzdHJlYW0pIHtcbiAgLy8gYXNzdW1lIHdlJ3ZlIGFscmVhZHkgZWF0ZW4gYSBxdW90ZSAoXCIpXG4gIGlmKHN0cmVhbS5jdXJyZW50KCkgPT09ICdcIicpXG4gICAgcmV0dXJuIHN0cmVhbS5tYXRjaCgvXlteXFxcIl0rXFxcIlxcOi8sIGZhbHNlKTtcbiAgZWxzZSBpZihzdHJlYW0uY3VycmVudCgpID09PSAnXFwnJylcbiAgICByZXR1cm4gc3RyZWFtLm1hdGNoKC9eW15cXFwiXStcXCdcXDovLCBmYWxzZSk7XG4gIGVsc2VcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzSW4oc3RhdGUsIHR5cGUpIHtcbiAgcmV0dXJuIChzdGF0ZS5zdGFjay5sZW5ndGggJiYgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoIC0gMV0udHlwZSA9PSB0eXBlKTtcbn1cblxuZnVuY3Rpb24gcHVzaFN0YXRlU3RhY2soc3RhdGUsIG5ld1N0YXRlKSB7XG4gIHN0YXRlLnN0YWNrLnB1c2gobmV3U3RhdGUpO1xufVxuXG5mdW5jdGlvbiBwb3BTdGF0ZVN0YWNrKHN0YXRlKSB7XG4gIHN0YXRlLnN0YWNrLnBvcCgpO1xuICB2YXIgcmVpbnN0YXRlVG9rZW5pemUgPSBzdGF0ZS5zdGFjay5sZW5ndGggJiYgc3RhdGUuc3RhY2tbc3RhdGUuc3RhY2subGVuZ3RoLTFdLnRva2VuaXplO1xuICBzdGF0ZS50b2tlbml6ZSA9IHJlaW5zdGF0ZVRva2VuaXplIHx8IHRva2VuQmFzZTtcbn1cblxuLy8gdGhlIGludGVyZmFjZSBmb3IgdGhlIG1vZGUgQVBJXG5leHBvcnQgY29uc3QgeFF1ZXJ5ID0ge1xuICBuYW1lOiBcInhxdWVyeVwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgIGNjOiBbXSxcbiAgICAgIHN0YWNrOiBbXVxuICAgIH07XG4gIH0sXG5cbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7YmxvY2s6IHtvcGVuOiBcIig6XCIsIGNsb3NlOiBcIjopXCJ9fVxuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9