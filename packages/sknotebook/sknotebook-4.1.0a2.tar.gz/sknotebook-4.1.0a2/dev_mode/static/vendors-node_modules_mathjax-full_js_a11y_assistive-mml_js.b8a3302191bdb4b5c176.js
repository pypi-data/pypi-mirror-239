"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_a11y_assistive-mml_js"],{

/***/ "../node_modules/mathjax-full/js/a11y/assistive-mml.js":
/*!*************************************************************!*\
  !*** ../node_modules/mathjax-full/js/a11y/assistive-mml.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssistiveMmlHandler = exports.AssistiveMmlMathDocumentMixin = exports.AssistiveMmlMathItemMixin = exports.LimitedMmlVisitor = void 0;
var MathItem_js_1 = __webpack_require__(/*! ../core/MathItem.js */ "../node_modules/mathjax-full/js/core/MathItem.js");
var SerializedMmlVisitor_js_1 = __webpack_require__(/*! ../core/MmlTree/SerializedMmlVisitor.js */ "../node_modules/mathjax-full/js/core/MmlTree/SerializedMmlVisitor.js");
var Options_js_1 = __webpack_require__(/*! ../util/Options.js */ "../node_modules/mathjax-full/js/util/Options.js");
var LimitedMmlVisitor = (function (_super) {
    __extends(LimitedMmlVisitor, _super);
    function LimitedMmlVisitor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LimitedMmlVisitor.prototype.getAttributes = function (node) {
        return _super.prototype.getAttributes.call(this, node).replace(/ ?id=".*?"/, '');
    };
    return LimitedMmlVisitor;
}(SerializedMmlVisitor_js_1.SerializedMmlVisitor));
exports.LimitedMmlVisitor = LimitedMmlVisitor;
(0, MathItem_js_1.newState)('ASSISTIVEMML', 153);
function AssistiveMmlMathItemMixin(BaseMathItem) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.assistiveMml = function (document, force) {
            if (force === void 0) { force = false; }
            if (this.state() >= MathItem_js_1.STATE.ASSISTIVEMML)
                return;
            if (!this.isEscaped && (document.options.enableAssistiveMml || force)) {
                var adaptor = document.adaptor;
                var mml = document.toMML(this.root).replace(/\n */g, '').replace(/<!--.*?-->/g, '');
                var mmlNodes = adaptor.firstChild(adaptor.body(adaptor.parse(mml, 'text/html')));
                var node = adaptor.node('mjx-assistive-mml', {
                    unselectable: 'on', display: (this.display ? 'block' : 'inline')
                }, [mmlNodes]);
                adaptor.setAttribute(adaptor.firstChild(this.typesetRoot), 'aria-hidden', 'true');
                adaptor.setStyle(this.typesetRoot, 'position', 'relative');
                adaptor.append(this.typesetRoot, node);
            }
            this.state(MathItem_js_1.STATE.ASSISTIVEMML);
        };
        return class_1;
    }(BaseMathItem));
}
exports.AssistiveMmlMathItemMixin = AssistiveMmlMathItemMixin;
function AssistiveMmlMathDocumentMixin(BaseDocument) {
    var _a;
    return _a = (function (_super) {
            __extends(BaseClass, _super);
            function BaseClass() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
                var CLASS = _this.constructor;
                var ProcessBits = CLASS.ProcessBits;
                if (!ProcessBits.has('assistive-mml')) {
                    ProcessBits.allocate('assistive-mml');
                }
                _this.visitor = new LimitedMmlVisitor(_this.mmlFactory);
                _this.options.MathItem =
                    AssistiveMmlMathItemMixin(_this.options.MathItem);
                if ('addStyles' in _this) {
                    _this.addStyles(CLASS.assistiveStyles);
                }
                return _this;
            }
            BaseClass.prototype.toMML = function (node) {
                return this.visitor.visitTree(node);
            };
            BaseClass.prototype.assistiveMml = function () {
                var e_1, _a;
                if (!this.processed.isSet('assistive-mml')) {
                    try {
                        for (var _b = __values(this.math), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var math = _c.value;
                            math.assistiveMml(this);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    this.processed.set('assistive-mml');
                }
                return this;
            };
            BaseClass.prototype.state = function (state, restore) {
                if (restore === void 0) { restore = false; }
                _super.prototype.state.call(this, state, restore);
                if (state < MathItem_js_1.STATE.ASSISTIVEMML) {
                    this.processed.clear('assistive-mml');
                }
                return this;
            };
            return BaseClass;
        }(BaseDocument)),
        _a.OPTIONS = __assign(__assign({}, BaseDocument.OPTIONS), { enableAssistiveMml: true, renderActions: (0, Options_js_1.expandable)(__assign(__assign({}, BaseDocument.OPTIONS.renderActions), { assistiveMml: [MathItem_js_1.STATE.ASSISTIVEMML] })) }),
        _a.assistiveStyles = {
            'mjx-assistive-mml': {
                position: 'absolute !important',
                top: '0px', left: '0px',
                clip: 'rect(1px, 1px, 1px, 1px)',
                padding: '1px 0px 0px 0px !important',
                border: '0px !important',
                display: 'block !important',
                width: 'auto !important',
                overflow: 'hidden !important',
                '-webkit-touch-callout': 'none',
                '-webkit-user-select': 'none',
                '-khtml-user-select': 'none',
                '-moz-user-select': 'none',
                '-ms-user-select': 'none',
                'user-select': 'none'
            },
            'mjx-assistive-mml[display="block"]': {
                width: '100% !important'
            }
        },
        _a;
}
exports.AssistiveMmlMathDocumentMixin = AssistiveMmlMathDocumentMixin;
function AssistiveMmlHandler(handler) {
    handler.documentClass =
        AssistiveMmlMathDocumentMixin(handler.documentClass);
    return handler;
}
exports.AssistiveMmlHandler = AssistiveMmlHandler;
//# sourceMappingURL=assistive-mml.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/core/MmlTree/MmlVisitor.js":
/*!******************************************************************!*\
  !*** ../node_modules/mathjax-full/js/core/MmlTree/MmlVisitor.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MmlVisitor = void 0;
var MmlFactory_js_1 = __webpack_require__(/*! ./MmlFactory.js */ "../node_modules/mathjax-full/js/core/MmlTree/MmlFactory.js");
var Visitor_js_1 = __webpack_require__(/*! ../Tree/Visitor.js */ "../node_modules/mathjax-full/js/core/Tree/Visitor.js");
var MmlVisitor = (function (_super) {
    __extends(MmlVisitor, _super);
    function MmlVisitor(factory) {
        if (factory === void 0) { factory = null; }
        if (!factory) {
            factory = new MmlFactory_js_1.MmlFactory();
        }
        return _super.call(this, factory) || this;
    }
    MmlVisitor.prototype.visitTextNode = function (_node) {
        var _args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            _args[_i - 1] = arguments[_i];
        }
    };
    MmlVisitor.prototype.visitXMLNode = function (_node) {
        var _args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            _args[_i - 1] = arguments[_i];
        }
    };
    return MmlVisitor;
}(Visitor_js_1.AbstractVisitor));
exports.MmlVisitor = MmlVisitor;
//# sourceMappingURL=MmlVisitor.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/core/MmlTree/SerializedMmlVisitor.js":
/*!****************************************************************************!*\
  !*** ../node_modules/mathjax-full/js/core/MmlTree/SerializedMmlVisitor.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SerializedMmlVisitor = exports.toEntity = exports.DATAMJX = void 0;
var MmlVisitor_js_1 = __webpack_require__(/*! ./MmlVisitor.js */ "../node_modules/mathjax-full/js/core/MmlTree/MmlVisitor.js");
var MmlNode_js_1 = __webpack_require__(/*! ./MmlNode.js */ "../node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var mi_js_1 = __webpack_require__(/*! ./MmlNodes/mi.js */ "../node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mi.js");
exports.DATAMJX = 'data-mjx-';
var toEntity = function (c) { return '&#x' + c.codePointAt(0).toString(16).toUpperCase() + ';'; };
exports.toEntity = toEntity;
var SerializedMmlVisitor = (function (_super) {
    __extends(SerializedMmlVisitor, _super);
    function SerializedMmlVisitor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SerializedMmlVisitor.prototype.visitTree = function (node) {
        return this.visitNode(node, '');
    };
    SerializedMmlVisitor.prototype.visitTextNode = function (node, _space) {
        return this.quoteHTML(node.getText());
    };
    SerializedMmlVisitor.prototype.visitXMLNode = function (node, space) {
        return space + node.getSerializedXML();
    };
    SerializedMmlVisitor.prototype.visitInferredMrowNode = function (node, space) {
        var e_1, _a;
        var mml = [];
        try {
            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                mml.push(this.visitNode(child, space));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return mml.join('\n');
    };
    SerializedMmlVisitor.prototype.visitTeXAtomNode = function (node, space) {
        var children = this.childNodeMml(node, space + '  ', '\n');
        var mml = space + '<mrow' + this.getAttributes(node) + '>' +
            (children.match(/\S/) ? '\n' + children + space : '') + '</mrow>';
        return mml;
    };
    SerializedMmlVisitor.prototype.visitAnnotationNode = function (node, space) {
        return space + '<annotation' + this.getAttributes(node) + '>'
            + this.childNodeMml(node, '', '')
            + '</annotation>';
    };
    SerializedMmlVisitor.prototype.visitDefault = function (node, space) {
        var kind = node.kind;
        var _a = __read((node.isToken || node.childNodes.length === 0 ? ['', ''] : ['\n', space]), 2), nl = _a[0], endspace = _a[1];
        var children = this.childNodeMml(node, space + '  ', nl);
        return space + '<' + kind + this.getAttributes(node) + '>'
            + (children.match(/\S/) ? nl + children + endspace : '')
            + '</' + kind + '>';
    };
    SerializedMmlVisitor.prototype.childNodeMml = function (node, space, nl) {
        var e_2, _a;
        var mml = '';
        try {
            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                mml += this.visitNode(child, space) + nl;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return mml;
    };
    SerializedMmlVisitor.prototype.getAttributes = function (node) {
        var e_3, _a;
        var attr = [];
        var defaults = this.constructor.defaultAttributes[node.kind] || {};
        var attributes = Object.assign({}, defaults, this.getDataAttributes(node), node.attributes.getAllAttributes());
        var variants = this.constructor.variants;
        if (attributes.hasOwnProperty('mathvariant') && variants.hasOwnProperty(attributes.mathvariant)) {
            attributes.mathvariant = variants[attributes.mathvariant];
        }
        try {
            for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var name_1 = _c.value;
                var value = String(attributes[name_1]);
                if (value === undefined)
                    continue;
                attr.push(name_1 + '="' + this.quoteHTML(value) + '"');
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return attr.length ? ' ' + attr.join(' ') : '';
    };
    SerializedMmlVisitor.prototype.getDataAttributes = function (node) {
        var data = {};
        var variant = node.attributes.getExplicit('mathvariant');
        var variants = this.constructor.variants;
        variant && variants.hasOwnProperty(variant) && this.setDataAttribute(data, 'variant', variant);
        node.getProperty('variantForm') && this.setDataAttribute(data, 'alternate', '1');
        node.getProperty('pseudoscript') && this.setDataAttribute(data, 'pseudoscript', 'true');
        node.getProperty('autoOP') === false && this.setDataAttribute(data, 'auto-op', 'false');
        var scriptalign = node.getProperty('scriptalign');
        scriptalign && this.setDataAttribute(data, 'script-align', scriptalign);
        var texclass = node.getProperty('texClass');
        if (texclass !== undefined) {
            var setclass = true;
            if (texclass === MmlNode_js_1.TEXCLASS.OP && node.isKind('mi')) {
                var name_2 = node.getText();
                setclass = !(name_2.length > 1 && name_2.match(mi_js_1.MmlMi.operatorName));
            }
            setclass && this.setDataAttribute(data, 'texclass', texclass < 0 ? 'NONE' : MmlNode_js_1.TEXCLASSNAMES[texclass]);
        }
        node.getProperty('scriptlevel') && node.getProperty('useHeight') === false &&
            this.setDataAttribute(data, 'smallmatrix', 'true');
        return data;
    };
    SerializedMmlVisitor.prototype.setDataAttribute = function (data, name, value) {
        data[exports.DATAMJX + name] = value;
    };
    SerializedMmlVisitor.prototype.quoteHTML = function (value) {
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;').replace(/>/g, '&gt;')
            .replace(/\"/g, '&quot;')
            .replace(/[\uD800-\uDBFF]./g, exports.toEntity)
            .replace(/[\u0080-\uD7FF\uE000-\uFFFF]/g, exports.toEntity);
    };
    SerializedMmlVisitor.variants = {
        '-tex-calligraphic': 'script',
        '-tex-bold-calligraphic': 'bold-script',
        '-tex-oldstyle': 'normal',
        '-tex-bold-oldstyle': 'bold',
        '-tex-mathit': 'italic'
    };
    SerializedMmlVisitor.defaultAttributes = {
        math: {
            xmlns: 'http://www.w3.org/1998/Math/MathML'
        }
    };
    return SerializedMmlVisitor;
}(MmlVisitor_js_1.MmlVisitor));
exports.SerializedMmlVisitor = SerializedMmlVisitor;
//# sourceMappingURL=SerializedMmlVisitor.js.map

/***/ }),

/***/ "../node_modules/mathjax-full/js/core/Tree/Visitor.js":
/*!************************************************************!*\
  !*** ../node_modules/mathjax-full/js/core/Tree/Visitor.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractVisitor = void 0;
var Node_js_1 = __webpack_require__(/*! ./Node.js */ "../node_modules/mathjax-full/js/core/Tree/Node.js");
var AbstractVisitor = (function () {
    function AbstractVisitor(factory) {
        var e_1, _a;
        this.nodeHandlers = new Map();
        try {
            for (var _b = __values(factory.getKinds()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var kind = _c.value;
                var method = this[AbstractVisitor.methodName(kind)];
                if (method) {
                    this.nodeHandlers.set(kind, method);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    AbstractVisitor.methodName = function (kind) {
        return 'visit' + (kind.charAt(0).toUpperCase() + kind.substr(1)).replace(/[^a-z0-9_]/ig, '_') + 'Node';
    };
    AbstractVisitor.prototype.visitTree = function (tree) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return this.visitNode.apply(this, __spreadArray([tree], __read(args), false));
    };
    AbstractVisitor.prototype.visitNode = function (node) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var handler = this.nodeHandlers.get(node.kind) || this.visitDefault;
        return handler.call.apply(handler, __spreadArray([this, node], __read(args), false));
    };
    AbstractVisitor.prototype.visitDefault = function (node) {
        var e_2, _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (node instanceof Node_js_1.AbstractNode) {
            try {
                for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    this.visitNode.apply(this, __spreadArray([child], __read(args), false));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    AbstractVisitor.prototype.setNodeHandler = function (kind, handler) {
        this.nodeHandlers.set(kind, handler);
    };
    AbstractVisitor.prototype.removeNodeHandler = function (kind) {
        this.nodeHandlers.delete(kind);
    };
    return AbstractVisitor;
}());
exports.AbstractVisitor = AbstractVisitor;
//# sourceMappingURL=Visitor.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX2ExMXlfYXNzaXN0aXZlLW1tbF9qcy5iOGEzMzAyMTkxYmRiNGI1YzE3Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHFDQUFxQyxHQUFHLGlDQUFpQyxHQUFHLHlCQUF5QjtBQUNuSSxvQkFBb0IsbUJBQU8sQ0FBQyw2RUFBcUI7QUFDakQsZ0NBQWdDLG1CQUFPLENBQUMscUhBQXlDO0FBQ2pGLG1CQUFtQixtQkFBTyxDQUFDLDJFQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FB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QixnQkFBZ0IsbUJBQU8sQ0FBQyxvRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvYTExeS9hc3Npc3RpdmUtbW1sLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvcmUvTW1sVHJlZS9NbWxWaXNpdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvcmUvTW1sVHJlZS9TZXJpYWxpemVkTW1sVmlzaXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9jb3JlL1RyZWUvVmlzaXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3Npc3RpdmVNbWxIYW5kbGVyID0gZXhwb3J0cy5Bc3Npc3RpdmVNbWxNYXRoRG9jdW1lbnRNaXhpbiA9IGV4cG9ydHMuQXNzaXN0aXZlTW1sTWF0aEl0ZW1NaXhpbiA9IGV4cG9ydHMuTGltaXRlZE1tbFZpc2l0b3IgPSB2b2lkIDA7XG52YXIgTWF0aEl0ZW1fanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL01hdGhJdGVtLmpzXCIpO1xudmFyIFNlcmlhbGl6ZWRNbWxWaXNpdG9yX2pzXzEgPSByZXF1aXJlKFwiLi4vY29yZS9NbWxUcmVlL1NlcmlhbGl6ZWRNbWxWaXNpdG9yLmpzXCIpO1xudmFyIE9wdGlvbnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL09wdGlvbnMuanNcIik7XG52YXIgTGltaXRlZE1tbFZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhMaW1pdGVkTW1sVmlzaXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMaW1pdGVkTW1sVmlzaXRvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBMaW1pdGVkTW1sVmlzaXRvci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIucHJvdG90eXBlLmdldEF0dHJpYnV0ZXMuY2FsbCh0aGlzLCBub2RlKS5yZXBsYWNlKC8gP2lkPVwiLio/XCIvLCAnJyk7XG4gICAgfTtcbiAgICByZXR1cm4gTGltaXRlZE1tbFZpc2l0b3I7XG59KFNlcmlhbGl6ZWRNbWxWaXNpdG9yX2pzXzEuU2VyaWFsaXplZE1tbFZpc2l0b3IpKTtcbmV4cG9ydHMuTGltaXRlZE1tbFZpc2l0b3IgPSBMaW1pdGVkTW1sVmlzaXRvcjtcbigwLCBNYXRoSXRlbV9qc18xLm5ld1N0YXRlKSgnQVNTSVNUSVZFTU1MJywgMTUzKTtcbmZ1bmN0aW9uIEFzc2lzdGl2ZU1tbE1hdGhJdGVtTWl4aW4oQmFzZU1hdGhJdGVtKSB7XG4gICAgcmV0dXJuIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgIF9fZXh0ZW5kcyhjbGFzc18xLCBfc3VwZXIpO1xuICAgICAgICBmdW5jdGlvbiBjbGFzc18xKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmFzc2lzdGl2ZU1tbCA9IGZ1bmN0aW9uIChkb2N1bWVudCwgZm9yY2UpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSA9PT0gdm9pZCAwKSB7IGZvcmNlID0gZmFsc2U7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPj0gTWF0aEl0ZW1fanNfMS5TVEFURS5BU1NJU1RJVkVNTUwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRXNjYXBlZCAmJiAoZG9jdW1lbnQub3B0aW9ucy5lbmFibGVBc3Npc3RpdmVNbWwgfHwgZm9yY2UpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkYXB0b3IgPSBkb2N1bWVudC5hZGFwdG9yO1xuICAgICAgICAgICAgICAgIHZhciBtbWwgPSBkb2N1bWVudC50b01NTCh0aGlzLnJvb3QpLnJlcGxhY2UoL1xcbiAqL2csICcnKS5yZXBsYWNlKC88IS0tLio/LS0+L2csICcnKTtcbiAgICAgICAgICAgICAgICB2YXIgbW1sTm9kZXMgPSBhZGFwdG9yLmZpcnN0Q2hpbGQoYWRhcHRvci5ib2R5KGFkYXB0b3IucGFyc2UobW1sLCAndGV4dC9odG1sJykpKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGFkYXB0b3Iubm9kZSgnbWp4LWFzc2lzdGl2ZS1tbWwnLCB7XG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0YWJsZTogJ29uJywgZGlzcGxheTogKHRoaXMuZGlzcGxheSA/ICdibG9jaycgOiAnaW5saW5lJylcbiAgICAgICAgICAgICAgICB9LCBbbW1sTm9kZXNdKTtcbiAgICAgICAgICAgICAgICBhZGFwdG9yLnNldEF0dHJpYnV0ZShhZGFwdG9yLmZpcnN0Q2hpbGQodGhpcy50eXBlc2V0Um9vdCksICdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgYWRhcHRvci5zZXRTdHlsZSh0aGlzLnR5cGVzZXRSb290LCAncG9zaXRpb24nLCAncmVsYXRpdmUnKTtcbiAgICAgICAgICAgICAgICBhZGFwdG9yLmFwcGVuZCh0aGlzLnR5cGVzZXRSb290LCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUoTWF0aEl0ZW1fanNfMS5TVEFURS5BU1NJU1RJVkVNTUwpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2xhc3NfMTtcbiAgICB9KEJhc2VNYXRoSXRlbSkpO1xufVxuZXhwb3J0cy5Bc3Npc3RpdmVNbWxNYXRoSXRlbU1peGluID0gQXNzaXN0aXZlTW1sTWF0aEl0ZW1NaXhpbjtcbmZ1bmN0aW9uIEFzc2lzdGl2ZU1tbE1hdGhEb2N1bWVudE1peGluKEJhc2VEb2N1bWVudCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX2EgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKEJhc2VDbGFzcywgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIEJhc2VDbGFzcygpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSwgZmFsc2UpKSB8fCB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBDTEFTUyA9IF90aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgICAgIHZhciBQcm9jZXNzQml0cyA9IENMQVNTLlByb2Nlc3NCaXRzO1xuICAgICAgICAgICAgICAgIGlmICghUHJvY2Vzc0JpdHMuaGFzKCdhc3Npc3RpdmUtbW1sJykpIHtcbiAgICAgICAgICAgICAgICAgICAgUHJvY2Vzc0JpdHMuYWxsb2NhdGUoJ2Fzc2lzdGl2ZS1tbWwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMudmlzaXRvciA9IG5ldyBMaW1pdGVkTW1sVmlzaXRvcihfdGhpcy5tbWxGYWN0b3J5KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLk1hdGhJdGVtID1cbiAgICAgICAgICAgICAgICAgICAgQXNzaXN0aXZlTW1sTWF0aEl0ZW1NaXhpbihfdGhpcy5vcHRpb25zLk1hdGhJdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoJ2FkZFN0eWxlcycgaW4gX3RoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWRkU3R5bGVzKENMQVNTLmFzc2lzdGl2ZVN0eWxlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEJhc2VDbGFzcy5wcm90b3R5cGUudG9NTUwgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0b3IudmlzaXRUcmVlKG5vZGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEJhc2VDbGFzcy5wcm90b3R5cGUuYXNzaXN0aXZlTW1sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wcm9jZXNzZWQuaXNTZXQoJ2Fzc2lzdGl2ZS1tbWwnKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLm1hdGgpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGggPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRoLmFzc2lzdGl2ZU1tbCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkLnNldCgnYXNzaXN0aXZlLW1tbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBCYXNlQ2xhc3MucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCByZXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RvcmUgPT09IHZvaWQgMCkgeyByZXN0b3JlID0gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnN0YXRlLmNhbGwodGhpcywgc3RhdGUsIHJlc3RvcmUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA8IE1hdGhJdGVtX2pzXzEuU1RBVEUuQVNTSVNUSVZFTU1MKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkLmNsZWFyKCdhc3Npc3RpdmUtbW1sJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBCYXNlQ2xhc3M7XG4gICAgICAgIH0oQmFzZURvY3VtZW50KSksXG4gICAgICAgIF9hLk9QVElPTlMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgQmFzZURvY3VtZW50Lk9QVElPTlMpLCB7IGVuYWJsZUFzc2lzdGl2ZU1tbDogdHJ1ZSwgcmVuZGVyQWN0aW9uczogKDAsIE9wdGlvbnNfanNfMS5leHBhbmRhYmxlKShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgQmFzZURvY3VtZW50Lk9QVElPTlMucmVuZGVyQWN0aW9ucyksIHsgYXNzaXN0aXZlTW1sOiBbTWF0aEl0ZW1fanNfMS5TVEFURS5BU1NJU1RJVkVNTUxdIH0pKSB9KSxcbiAgICAgICAgX2EuYXNzaXN0aXZlU3R5bGVzID0ge1xuICAgICAgICAgICAgJ21qeC1hc3Npc3RpdmUtbW1sJzoge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUgIWltcG9ydGFudCcsXG4gICAgICAgICAgICAgICAgdG9wOiAnMHB4JywgbGVmdDogJzBweCcsXG4gICAgICAgICAgICAgICAgY2xpcDogJ3JlY3QoMXB4LCAxcHgsIDFweCwgMXB4KScsXG4gICAgICAgICAgICAgICAgcGFkZGluZzogJzFweCAwcHggMHB4IDBweCAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICBib3JkZXI6ICcwcHggIWltcG9ydGFudCcsXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgIHdpZHRoOiAnYXV0byAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbiAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICAnLXdlYmtpdC10b3VjaC1jYWxsb3V0JzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICctd2Via2l0LXVzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICcta2h0bWwtdXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgJy1tb3otdXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgJy1tcy11c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAgICAgICAgICAgICAndXNlci1zZWxlY3QnOiAnbm9uZSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWp4LWFzc2lzdGl2ZS1tbWxbZGlzcGxheT1cImJsb2NrXCJdJzoge1xuICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJSAhaW1wb3J0YW50J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBfYTtcbn1cbmV4cG9ydHMuQXNzaXN0aXZlTW1sTWF0aERvY3VtZW50TWl4aW4gPSBBc3Npc3RpdmVNbWxNYXRoRG9jdW1lbnRNaXhpbjtcbmZ1bmN0aW9uIEFzc2lzdGl2ZU1tbEhhbmRsZXIoaGFuZGxlcikge1xuICAgIGhhbmRsZXIuZG9jdW1lbnRDbGFzcyA9XG4gICAgICAgIEFzc2lzdGl2ZU1tbE1hdGhEb2N1bWVudE1peGluKGhhbmRsZXIuZG9jdW1lbnRDbGFzcyk7XG4gICAgcmV0dXJuIGhhbmRsZXI7XG59XG5leHBvcnRzLkFzc2lzdGl2ZU1tbEhhbmRsZXIgPSBBc3Npc3RpdmVNbWxIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNzaXN0aXZlLW1tbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1tbFZpc2l0b3IgPSB2b2lkIDA7XG52YXIgTW1sRmFjdG9yeV9qc18xID0gcmVxdWlyZShcIi4vTW1sRmFjdG9yeS5qc1wiKTtcbnZhciBWaXNpdG9yX2pzXzEgPSByZXF1aXJlKFwiLi4vVHJlZS9WaXNpdG9yLmpzXCIpO1xudmFyIE1tbFZpc2l0b3IgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNbWxWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1tbFZpc2l0b3IoZmFjdG9yeSkge1xuICAgICAgICBpZiAoZmFjdG9yeSA9PT0gdm9pZCAwKSB7IGZhY3RvcnkgPSBudWxsOyB9XG4gICAgICAgIGlmICghZmFjdG9yeSkge1xuICAgICAgICAgICAgZmFjdG9yeSA9IG5ldyBNbWxGYWN0b3J5X2pzXzEuTW1sRmFjdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBmYWN0b3J5KSB8fCB0aGlzO1xuICAgIH1cbiAgICBNbWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRleHROb2RlID0gZnVuY3Rpb24gKF9ub2RlKSB7XG4gICAgICAgIHZhciBfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgX2FyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1tbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0WE1MTm9kZSA9IGZ1bmN0aW9uIChfbm9kZSkge1xuICAgICAgICB2YXIgX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIF9hcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTW1sVmlzaXRvcjtcbn0oVmlzaXRvcl9qc18xLkFic3RyYWN0VmlzaXRvcikpO1xuZXhwb3J0cy5NbWxWaXNpdG9yID0gTW1sVmlzaXRvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1tbFZpc2l0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJpYWxpemVkTW1sVmlzaXRvciA9IGV4cG9ydHMudG9FbnRpdHkgPSBleHBvcnRzLkRBVEFNSlggPSB2b2lkIDA7XG52YXIgTW1sVmlzaXRvcl9qc18xID0gcmVxdWlyZShcIi4vTW1sVmlzaXRvci5qc1wiKTtcbnZhciBNbWxOb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9NbWxOb2RlLmpzXCIpO1xudmFyIG1pX2pzXzEgPSByZXF1aXJlKFwiLi9NbWxOb2Rlcy9taS5qc1wiKTtcbmV4cG9ydHMuREFUQU1KWCA9ICdkYXRhLW1qeC0nO1xudmFyIHRvRW50aXR5ID0gZnVuY3Rpb24gKGMpIHsgcmV0dXJuICcmI3gnICsgYy5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICc7JzsgfTtcbmV4cG9ydHMudG9FbnRpdHkgPSB0b0VudGl0eTtcbnZhciBTZXJpYWxpemVkTW1sVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNlcmlhbGl6ZWRNbWxWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlcmlhbGl6ZWRNbWxWaXNpdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNlcmlhbGl6ZWRNbWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyZWUgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE5vZGUobm9kZSwgJycpO1xuICAgIH07XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgX3NwYWNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1b3RlSFRNTChub2RlLmdldFRleHQoKSk7XG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRYTUxOb2RlID0gZnVuY3Rpb24gKG5vZGUsIHNwYWNlKSB7XG4gICAgICAgIHJldHVybiBzcGFjZSArIG5vZGUuZ2V0U2VyaWFsaXplZFhNTCgpO1xuICAgIH07XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0SW5mZXJyZWRNcm93Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBzcGFjZSkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIG1tbCA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhub2RlLmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgbW1sLnB1c2godGhpcy52aXNpdE5vZGUoY2hpbGQsIHNwYWNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW1sLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGVYQXRvbU5vZGUgPSBmdW5jdGlvbiAobm9kZSwgc3BhY2UpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZE5vZGVNbWwobm9kZSwgc3BhY2UgKyAnICAnLCAnXFxuJyk7XG4gICAgICAgIHZhciBtbWwgPSBzcGFjZSArICc8bXJvdycgKyB0aGlzLmdldEF0dHJpYnV0ZXMobm9kZSkgKyAnPicgK1xuICAgICAgICAgICAgKGNoaWxkcmVuLm1hdGNoKC9cXFMvKSA/ICdcXG4nICsgY2hpbGRyZW4gKyBzcGFjZSA6ICcnKSArICc8L21yb3c+JztcbiAgICAgICAgcmV0dXJuIG1tbDtcbiAgICB9O1xuICAgIFNlcmlhbGl6ZWRNbWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdEFubm90YXRpb25Ob2RlID0gZnVuY3Rpb24gKG5vZGUsIHNwYWNlKSB7XG4gICAgICAgIHJldHVybiBzcGFjZSArICc8YW5ub3RhdGlvbicgKyB0aGlzLmdldEF0dHJpYnV0ZXMobm9kZSkgKyAnPidcbiAgICAgICAgICAgICsgdGhpcy5jaGlsZE5vZGVNbWwobm9kZSwgJycsICcnKVxuICAgICAgICAgICAgKyAnPC9hbm5vdGF0aW9uPic7XG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5wcm90b3R5cGUudmlzaXREZWZhdWx0ID0gZnVuY3Rpb24gKG5vZGUsIHNwYWNlKSB7XG4gICAgICAgIHZhciBraW5kID0gbm9kZS5raW5kO1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoKG5vZGUuaXNUb2tlbiB8fCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoID09PSAwID8gWycnLCAnJ10gOiBbJ1xcbicsIHNwYWNlXSksIDIpLCBubCA9IF9hWzBdLCBlbmRzcGFjZSA9IF9hWzFdO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkTm9kZU1tbChub2RlLCBzcGFjZSArICcgICcsIG5sKTtcbiAgICAgICAgcmV0dXJuIHNwYWNlICsgJzwnICsga2luZCArIHRoaXMuZ2V0QXR0cmlidXRlcyhub2RlKSArICc+J1xuICAgICAgICAgICAgKyAoY2hpbGRyZW4ubWF0Y2goL1xcUy8pID8gbmwgKyBjaGlsZHJlbiArIGVuZHNwYWNlIDogJycpXG4gICAgICAgICAgICArICc8LycgKyBraW5kICsgJz4nO1xuICAgIH07XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IucHJvdG90eXBlLmNoaWxkTm9kZU1tbCA9IGZ1bmN0aW9uIChub2RlLCBzcGFjZSwgbmwpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHZhciBtbWwgPSAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMobm9kZS5jaGlsZE5vZGVzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIG1tbCArPSB0aGlzLnZpc2l0Tm9kZShjaGlsZCwgc3BhY2UpICsgbmw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW1sO1xuICAgIH07XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IucHJvdG90eXBlLmdldEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgZV8zLCBfYTtcbiAgICAgICAgdmFyIGF0dHIgPSBbXTtcbiAgICAgICAgdmFyIGRlZmF1bHRzID0gdGhpcy5jb25zdHJ1Y3Rvci5kZWZhdWx0QXR0cmlidXRlc1tub2RlLmtpbmRdIHx8IHt9O1xuICAgICAgICB2YXIgYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCB0aGlzLmdldERhdGFBdHRyaWJ1dGVzKG5vZGUpLCBub2RlLmF0dHJpYnV0ZXMuZ2V0QWxsQXR0cmlidXRlcygpKTtcbiAgICAgICAgdmFyIHZhcmlhbnRzID0gdGhpcy5jb25zdHJ1Y3Rvci52YXJpYW50cztcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoJ21hdGh2YXJpYW50JykgJiYgdmFyaWFudHMuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlcy5tYXRodmFyaWFudCkpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMubWF0aHZhcmlhbnQgPSB2YXJpYW50c1thdHRyaWJ1dGVzLm1hdGh2YXJpYW50XTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gU3RyaW5nKGF0dHJpYnV0ZXNbbmFtZV8xXSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGF0dHIucHVzaChuYW1lXzEgKyAnPVwiJyArIHRoaXMucXVvdGVIVE1MKHZhbHVlKSArICdcIicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF0dHIubGVuZ3RoID8gJyAnICsgYXR0ci5qb2luKCcgJykgOiAnJztcbiAgICB9O1xuICAgIFNlcmlhbGl6ZWRNbWxWaXNpdG9yLnByb3RvdHlwZS5nZXREYXRhQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciB2YXJpYW50ID0gbm9kZS5hdHRyaWJ1dGVzLmdldEV4cGxpY2l0KCdtYXRodmFyaWFudCcpO1xuICAgICAgICB2YXIgdmFyaWFudHMgPSB0aGlzLmNvbnN0cnVjdG9yLnZhcmlhbnRzO1xuICAgICAgICB2YXJpYW50ICYmIHZhcmlhbnRzLmhhc093blByb3BlcnR5KHZhcmlhbnQpICYmIHRoaXMuc2V0RGF0YUF0dHJpYnV0ZShkYXRhLCAndmFyaWFudCcsIHZhcmlhbnQpO1xuICAgICAgICBub2RlLmdldFByb3BlcnR5KCd2YXJpYW50Rm9ybScpICYmIHRoaXMuc2V0RGF0YUF0dHJpYnV0ZShkYXRhLCAnYWx0ZXJuYXRlJywgJzEnKTtcbiAgICAgICAgbm9kZS5nZXRQcm9wZXJ0eSgncHNldWRvc2NyaXB0JykgJiYgdGhpcy5zZXREYXRhQXR0cmlidXRlKGRhdGEsICdwc2V1ZG9zY3JpcHQnLCAndHJ1ZScpO1xuICAgICAgICBub2RlLmdldFByb3BlcnR5KCdhdXRvT1AnKSA9PT0gZmFsc2UgJiYgdGhpcy5zZXREYXRhQXR0cmlidXRlKGRhdGEsICdhdXRvLW9wJywgJ2ZhbHNlJyk7XG4gICAgICAgIHZhciBzY3JpcHRhbGlnbiA9IG5vZGUuZ2V0UHJvcGVydHkoJ3NjcmlwdGFsaWduJyk7XG4gICAgICAgIHNjcmlwdGFsaWduICYmIHRoaXMuc2V0RGF0YUF0dHJpYnV0ZShkYXRhLCAnc2NyaXB0LWFsaWduJywgc2NyaXB0YWxpZ24pO1xuICAgICAgICB2YXIgdGV4Y2xhc3MgPSBub2RlLmdldFByb3BlcnR5KCd0ZXhDbGFzcycpO1xuICAgICAgICBpZiAodGV4Y2xhc3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHNldGNsYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0ZXhjbGFzcyA9PT0gTW1sTm9kZV9qc18xLlRFWENMQVNTLk9QICYmIG5vZGUuaXNLaW5kKCdtaScpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMiA9IG5vZGUuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgICAgIHNldGNsYXNzID0gIShuYW1lXzIubGVuZ3RoID4gMSAmJiBuYW1lXzIubWF0Y2gobWlfanNfMS5NbWxNaS5vcGVyYXRvck5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldGNsYXNzICYmIHRoaXMuc2V0RGF0YUF0dHJpYnV0ZShkYXRhLCAndGV4Y2xhc3MnLCB0ZXhjbGFzcyA8IDAgPyAnTk9ORScgOiBNbWxOb2RlX2pzXzEuVEVYQ0xBU1NOQU1FU1t0ZXhjbGFzc10pO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuZ2V0UHJvcGVydHkoJ3NjcmlwdGxldmVsJykgJiYgbm9kZS5nZXRQcm9wZXJ0eSgndXNlSGVpZ2h0JykgPT09IGZhbHNlICYmXG4gICAgICAgICAgICB0aGlzLnNldERhdGFBdHRyaWJ1dGUoZGF0YSwgJ3NtYWxsbWF0cml4JywgJ3RydWUnKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5wcm90b3R5cGUuc2V0RGF0YUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChkYXRhLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICBkYXRhW2V4cG9ydHMuREFUQU1KWCArIG5hbWVdID0gdmFsdWU7XG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5wcm90b3R5cGUucXVvdGVIVE1MID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxcIi9nLCAnJnF1b3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1RDgwMC1cXHVEQkZGXS4vZywgZXhwb3J0cy50b0VudGl0eSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx1MDA4MC1cXHVEN0ZGXFx1RTAwMC1cXHVGRkZGXS9nLCBleHBvcnRzLnRvRW50aXR5KTtcbiAgICB9O1xuICAgIFNlcmlhbGl6ZWRNbWxWaXNpdG9yLnZhcmlhbnRzID0ge1xuICAgICAgICAnLXRleC1jYWxsaWdyYXBoaWMnOiAnc2NyaXB0JyxcbiAgICAgICAgJy10ZXgtYm9sZC1jYWxsaWdyYXBoaWMnOiAnYm9sZC1zY3JpcHQnLFxuICAgICAgICAnLXRleC1vbGRzdHlsZSc6ICdub3JtYWwnLFxuICAgICAgICAnLXRleC1ib2xkLW9sZHN0eWxlJzogJ2JvbGQnLFxuICAgICAgICAnLXRleC1tYXRoaXQnOiAnaXRhbGljJ1xuICAgIH07XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IuZGVmYXVsdEF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIG1hdGg6IHtcbiAgICAgICAgICAgIHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCdcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlcmlhbGl6ZWRNbWxWaXNpdG9yO1xufShNbWxWaXNpdG9yX2pzXzEuTW1sVmlzaXRvcikpO1xuZXhwb3J0cy5TZXJpYWxpemVkTW1sVmlzaXRvciA9IFNlcmlhbGl6ZWRNbWxWaXNpdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2VyaWFsaXplZE1tbFZpc2l0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic3RyYWN0VmlzaXRvciA9IHZvaWQgMDtcbnZhciBOb2RlX2pzXzEgPSByZXF1aXJlKFwiLi9Ob2RlLmpzXCIpO1xudmFyIEFic3RyYWN0VmlzaXRvciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RWaXNpdG9yKGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHRoaXMubm9kZUhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhmYWN0b3J5LmdldEtpbmRzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbWV0aG9kID0gdGhpc1tBYnN0cmFjdFZpc2l0b3IubWV0aG9kTmFtZShraW5kKV07XG4gICAgICAgICAgICAgICAgaWYgKG1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVIYW5kbGVycy5zZXQoa2luZCwgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBBYnN0cmFjdFZpc2l0b3IubWV0aG9kTmFtZSA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICAgIHJldHVybiAndmlzaXQnICsgKGtpbmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBraW5kLnN1YnN0cigxKSkucmVwbGFjZSgvW15hLXowLTlfXS9pZywgJ18nKSArICdOb2RlJztcbiAgICB9O1xuICAgIEFic3RyYWN0VmlzaXRvci5wcm90b3R5cGUudmlzaXRUcmVlID0gZnVuY3Rpb24gKHRyZWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXROb2RlLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW3RyZWVdLCBfX3JlYWQoYXJncyksIGZhbHNlKSk7XG4gICAgfTtcbiAgICBBYnN0cmFjdFZpc2l0b3IucHJvdG90eXBlLnZpc2l0Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5ub2RlSGFuZGxlcnMuZ2V0KG5vZGUua2luZCkgfHwgdGhpcy52aXNpdERlZmF1bHQ7XG4gICAgICAgIHJldHVybiBoYW5kbGVyLmNhbGwuYXBwbHkoaGFuZGxlciwgX19zcHJlYWRBcnJheShbdGhpcywgbm9kZV0sIF9fcmVhZChhcmdzKSwgZmFsc2UpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0VmlzaXRvci5wcm90b3R5cGUudmlzaXREZWZhdWx0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgTm9kZV9qc18xLkFic3RyYWN0Tm9kZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKG5vZGUuY2hpbGROb2RlcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXROb2RlLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW2NoaWxkXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3RWaXNpdG9yLnByb3RvdHlwZS5zZXROb2RlSGFuZGxlciA9IGZ1bmN0aW9uIChraW5kLCBoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMubm9kZUhhbmRsZXJzLnNldChraW5kLCBoYW5kbGVyKTtcbiAgICB9O1xuICAgIEFic3RyYWN0VmlzaXRvci5wcm90b3R5cGUucmVtb3ZlTm9kZUhhbmRsZXIgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgICAgICB0aGlzLm5vZGVIYW5kbGVycy5kZWxldGUoa2luZCk7XG4gICAgfTtcbiAgICByZXR1cm4gQWJzdHJhY3RWaXNpdG9yO1xufSgpKTtcbmV4cG9ydHMuQWJzdHJhY3RWaXNpdG9yID0gQWJzdHJhY3RWaXNpdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmlzaXRvci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=