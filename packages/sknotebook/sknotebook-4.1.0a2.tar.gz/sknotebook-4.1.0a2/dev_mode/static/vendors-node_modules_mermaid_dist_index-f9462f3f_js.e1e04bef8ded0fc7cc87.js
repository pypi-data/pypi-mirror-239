"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mermaid_dist_index-f9462f3f_js"],{

/***/ "../node_modules/dagre-d3-es/src/graphlib/json.js":
/*!********************************************************!*\
  !*** ../node_modules/dagre-d3-es/src/graphlib/json.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "read": () => (/* binding */ read),
/* harmony export */   "write": () => (/* binding */ write)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "../node_modules/lodash-es/isUndefined.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "../node_modules/lodash-es/clone.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "../node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "../node_modules/lodash-es/forEach.js");
/* harmony import */ var _graph_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph.js */ "../node_modules/dagre-d3-es/src/graphlib/graph.js");





function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound(),
    },
    nodes: writeNodes(g),
    edges: writeEdges(g),
  };
  if (!lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"](g.graph())) {
    json.value = lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"](g.graph());
  }
  return json;
}

function writeNodes(g) {
  return lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"](g.nodes(), function (v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = { v: v };
    if (!lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"](nodeValue)) {
      node.value = nodeValue;
    }
    if (!lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"](parent)) {
      node.parent = parent;
    }
    return node;
  });
}

function writeEdges(g) {
  return lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"](g.edges(), function (e) {
    var edgeValue = g.edge(e);
    var edge = { v: e.v, w: e.w };
    if (!lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"](e.name)) {
      edge.name = e.name;
    }
    if (!lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"](edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}

function read(json) {
  var g = new _graph_js__WEBPACK_IMPORTED_MODULE_0__.Graph(json.options).setGraph(json.value);
  lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"](json.nodes, function (entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"](json.edges, function (entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g;
}


/***/ }),

/***/ "../node_modules/lodash-es/clone.js":
/*!******************************************!*\
  !*** ../node_modules/lodash-es/clone.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseClone.js */ "../node_modules/lodash-es/_baseClone.js");


/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return (0,_baseClone_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clone);


/***/ }),

/***/ "../node_modules/mermaid/dist/index-f9462f3f.js":
/*!******************************************************!*\
  !*** ../node_modules/mermaid/dist/index-f9462f3f.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "r": () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var dagre_d3_es_src_dagre_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dagre-d3-es/src/dagre/index.js */ "../node_modules/dagre-d3-es/src/dagre/index.js");
/* harmony import */ var dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! dagre-d3-es/src/graphlib/json.js */ "../node_modules/dagre-d3-es/src/graphlib/json.js");
/* harmony import */ var _edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./edges-f15a7e05.js */ "../node_modules/mermaid/dist/edges-f15a7e05.js");
/* harmony import */ var _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mermaid-0d192ec3.js */ "../node_modules/mermaid/dist/mermaid-0d192ec3.js");
/* harmony import */ var dagre_d3_es_src_graphlib_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! dagre-d3-es/src/graphlib/index.js */ "../node_modules/dagre-d3-es/src/graphlib/index.js");
/* harmony import */ var _createText_80c3befb_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createText-80c3befb.js */ "../node_modules/mermaid/dist/createText-80c3befb.js");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3 */ "../node_modules/d3/src/index.js");







let clusterDb = {};
let descendants = {};
let parents = {};
const clear$1 = () => {
  descendants = {};
  parents = {};
  clusterDb = {};
};
const isDescendant = (id, ancenstorId) => {
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("In isDecendant", ancenstorId, " ", id, " = ", descendants[ancenstorId].includes(id));
  if (descendants[ancenstorId].includes(id)) {
    return true;
  }
  return false;
};
const edgeInCluster = (edge, clusterId) => {
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Decendants of ", clusterId, " is ", descendants[clusterId]);
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Edge is ", edge);
  if (edge.v === clusterId) {
    return false;
  }
  if (edge.w === clusterId) {
    return false;
  }
  if (!descendants[clusterId]) {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Tilt, ", clusterId, ",not in decendants");
    return false;
  }
  return descendants[clusterId].includes(edge.v) || isDescendant(edge.v, clusterId) || isDescendant(edge.w, clusterId) || descendants[clusterId].includes(edge.w);
};
const copy = (clusterId, graph, newGraph, rootId) => {
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn(
    "Copying children of ",
    clusterId,
    "root",
    rootId,
    "data",
    graph.node(clusterId),
    rootId
  );
  const nodes = graph.children(clusterId) || [];
  if (clusterId !== rootId) {
    nodes.push(clusterId);
  }
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Copying (nodes) clusterId", clusterId, "nodes", nodes);
  nodes.forEach((node) => {
    if (graph.children(node).length > 0) {
      copy(node, graph, newGraph, rootId);
    } else {
      const data = graph.node(node);
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("cp ", node, " to ", rootId, " with parent ", clusterId);
      newGraph.setNode(node, data);
      if (rootId !== graph.parent(node)) {
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Setting parent", node, graph.parent(node));
        newGraph.setParent(node, graph.parent(node));
      }
      if (clusterId !== rootId && node !== clusterId) {
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Setting parent", node, clusterId);
        newGraph.setParent(node, clusterId);
      } else {
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("In copy ", clusterId, "root", rootId, "data", graph.node(clusterId), rootId);
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug(
          "Not Setting parent for node=",
          node,
          "cluster!==rootId",
          clusterId !== rootId,
          "node!==clusterId",
          node !== clusterId
        );
      }
      const edges = graph.edges(node);
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Copying Edges", edges);
      edges.forEach((edge) => {
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Edge", edge);
        const data2 = graph.edge(edge.v, edge.w, edge.name);
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Edge data", data2, rootId);
        try {
          if (edgeInCluster(edge, rootId)) {
            _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Copying as ", edge.v, edge.w, data2, edge.name);
            newGraph.setEdge(edge.v, edge.w, data2, edge.name);
            _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("newGraph edges ", newGraph.edges(), newGraph.edge(newGraph.edges()[0]));
          } else {
            _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info(
              "Skipping copy of edge ",
              edge.v,
              "-->",
              edge.w,
              " rootId: ",
              rootId,
              " clusterId:",
              clusterId
            );
          }
        } catch (e) {
          _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.error(e);
        }
      });
    }
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Removing node", node);
    graph.removeNode(node);
  });
};
const extractDescendants = (id, graph) => {
  const children = graph.children(id);
  let res = [...children];
  for (const child of children) {
    parents[child] = id;
    res = [...res, ...extractDescendants(child, graph)];
  }
  return res;
};
const findNonClusterChild = (id, graph) => {
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("Searching", id);
  const children = graph.children(id);
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("Searching children of id ", id, children);
  if (children.length < 1) {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("This is a valid node", id);
    return id;
  }
  for (const child of children) {
    const _id = findNonClusterChild(child, graph);
    if (_id) {
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("Found replacement for", id, " => ", _id);
      return _id;
    }
  }
};
const getAnchorId = (id) => {
  if (!clusterDb[id]) {
    return id;
  }
  if (!clusterDb[id].externalConnections) {
    return id;
  }
  if (clusterDb[id]) {
    return clusterDb[id].id;
  }
  return id;
};
const adjustClustersAndEdges = (graph, depth) => {
  if (!graph || depth > 10) {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Opting out, no graph ");
    return;
  } else {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Opting in, graph ");
  }
  graph.nodes().forEach(function(id) {
    const children = graph.children(id);
    if (children.length > 0) {
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn(
        "Cluster identified",
        id,
        " Replacement id in edges: ",
        findNonClusterChild(id, graph)
      );
      descendants[id] = extractDescendants(id, graph);
      clusterDb[id] = { id: findNonClusterChild(id, graph), clusterData: graph.node(id) };
    }
  });
  graph.nodes().forEach(function(id) {
    const children = graph.children(id);
    const edges = graph.edges();
    if (children.length > 0) {
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Cluster identified", id, descendants);
      edges.forEach((edge) => {
        if (edge.v !== id && edge.w !== id) {
          const d1 = isDescendant(edge.v, id);
          const d2 = isDescendant(edge.w, id);
          if (d1 ^ d2) {
            _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Edge: ", edge, " leaves cluster ", id);
            _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Decendants of XXX ", id, ": ", descendants[id]);
            clusterDb[id].externalConnections = true;
          }
        }
      });
    } else {
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Not a cluster ", id, descendants);
    }
  });
  graph.edges().forEach(function(e) {
    const edge = graph.edge(e);
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(graph.edge(e)));
    let v = e.v;
    let w = e.w;
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn(
      "Fix XXX",
      clusterDb,
      "ids:",
      e.v,
      e.w,
      "Translating: ",
      clusterDb[e.v],
      " --- ",
      clusterDb[e.w]
    );
    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Fixing and trixing link to self - removing XXX", e.v, e.w, e.name);
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
      v = getAnchorId(e.v);
      w = getAnchorId(e.w);
      graph.removeEdge(e.v, e.w, e.name);
      const specialId = e.w + "---" + e.v;
      graph.setNode(specialId, {
        domId: specialId,
        id: specialId,
        labelStyle: "",
        labelText: edge.label,
        padding: 0,
        shape: "labelRect",
        style: ""
      });
      const edge1 = structuredClone(edge);
      const edge2 = structuredClone(edge);
      edge1.label = "";
      edge1.arrowTypeEnd = "none";
      edge2.label = "";
      edge1.fromCluster = e.v;
      edge2.toCluster = e.v;
      graph.setEdge(v, specialId, edge1, e.name + "-cyclic-special");
      graph.setEdge(specialId, w, edge2, e.name + "-cyclic-special");
    } else if (clusterDb[e.v] || clusterDb[e.w]) {
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
      v = getAnchorId(e.v);
      w = getAnchorId(e.w);
      graph.removeEdge(e.v, e.w, e.name);
      if (v !== e.v) {
        edge.fromCluster = e.v;
      }
      if (w !== e.w) {
        edge.toCluster = e.w;
      }
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Fix Replacing with XXX", v, w, e.name);
      graph.setEdge(v, w, edge, e.name);
    }
  });
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Adjusted Graph", dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__.write(graph));
  extractor(graph, 0);
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace(clusterDb);
};
const extractor = (graph, depth) => {
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("extractor - ", depth, dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__.write(graph), graph.children("D"));
  if (depth > 10) {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.error("Bailing out");
    return;
  }
  let nodes = graph.nodes();
  let hasChildren = false;
  for (const node of nodes) {
    const children = graph.children(node);
    hasChildren = hasChildren || children.length > 0;
  }
  if (!hasChildren) {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Done, no node has children", graph.nodes());
    return;
  }
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Nodes = ", nodes, depth);
  for (const node of nodes) {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug(
      "Extracting node",
      node,
      clusterDb,
      clusterDb[node] && !clusterDb[node].externalConnections,
      !graph.parent(node),
      graph.node(node),
      graph.children("D"),
      " Depth ",
      depth
    );
    if (!clusterDb[node]) {
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Not a cluster", node, depth);
    } else if (!clusterDb[node].externalConnections && // !graph.parent(node) &&
    graph.children(node) && graph.children(node).length > 0) {
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn(
        "Cluster without external connections, without a parent and with children",
        node,
        depth
      );
      const graphSettings = graph.graph();
      let dir = graphSettings.rankdir === "TB" ? "LR" : "TB";
      if (clusterDb[node] && clusterDb[node].clusterData && clusterDb[node].clusterData.dir) {
        dir = clusterDb[node].clusterData.dir;
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Fixing dir", clusterDb[node].clusterData.dir, dir);
      }
      const clusterGraph = new dagre_d3_es_src_graphlib_index_js__WEBPACK_IMPORTED_MODULE_2__.Graph({
        multigraph: true,
        compound: true
      }).setGraph({
        rankdir: dir,
        // Todo: set proper spacing
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function() {
        return {};
      });
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Old graph before copy", dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__.write(graph));
      copy(node, graph, clusterGraph, node);
      graph.setNode(node, {
        clusterNode: true,
        id: node,
        clusterData: clusterDb[node].clusterData,
        labelText: clusterDb[node].labelText,
        graph: clusterGraph
      });
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("New graph after copy node: (", node, ")", dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__.write(clusterGraph));
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug("Old graph after copy", dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__.write(graph));
    } else {
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn(
        "Cluster ** ",
        node,
        " **not meeting the criteria !externalConnections:",
        !clusterDb[node].externalConnections,
        " no parent: ",
        !graph.parent(node),
        " children ",
        graph.children(node) && graph.children(node).length > 0,
        graph.children("D"),
        depth
      );
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.debug(clusterDb);
    }
  }
  nodes = graph.nodes();
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("New list of nodes", nodes);
  for (const node of nodes) {
    const data = graph.node(node);
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn(" Now next level", node, data);
    if (data.clusterNode) {
      extractor(data.graph, depth + 1);
    }
  }
};
const sorter = (graph, nodes) => {
  if (nodes.length === 0) {
    return [];
  }
  let result = Object.assign(nodes);
  nodes.forEach((node) => {
    const children = graph.children(node);
    const sorted = sorter(graph, children);
    result = [...result, ...sorted];
  });
  return result;
};
const sortNodesByHierarchy = (graph) => sorter(graph, graph.children());
const rect = (parent, node) => {
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Creating subgraph rect for ", node.id, node);
  const shapeSvg = parent.insert("g").attr("class", "cluster" + (node.class ? " " + node.class : "")).attr("id", node.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const useHtmlLabels = (0,_mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.m)((0,_mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.c)().flowchart.htmlLabels);
  const label = shapeSvg.insert("g").attr("class", "cluster-label");
  const text = node.labelType === "markdown" ? (0,_createText_80c3befb_js__WEBPACK_IMPORTED_MODULE_5__.c)(label, node.labelText, { style: node.labelStyle, useHtmlLabels }) : label.node().appendChild((0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.c)(node.labelText, node.labelStyle, void 0, true));
  let bbox = text.getBBox();
  if ((0,_mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.m)((0,_mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.c)().flowchart.htmlLabels)) {
    const div = text.children[0];
    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_3__.select)(text);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const padding = 0 * node.padding;
  const halfPadding = padding / 2;
  const width = node.width <= bbox.width + padding ? bbox.width + padding : node.width;
  if (node.width <= bbox.width + padding) {
    node.diff = (bbox.width - node.width) / 2 - node.padding / 2;
  } else {
    node.diff = -node.padding / 2;
  }
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("Data ", node, JSON.stringify(node));
  rect2.attr("style", node.style).attr("rx", node.rx).attr("ry", node.ry).attr("x", node.x - width / 2).attr("y", node.y - node.height / 2 - halfPadding).attr("width", width).attr("height", node.height + padding);
  if (useHtmlLabels) {
    label.attr(
      "transform",
      // This puts the labal on top of the box instead of inside it
      "translate(" + (node.x - bbox.width / 2) + ", " + (node.y - node.height / 2) + ")"
    );
  } else {
    label.attr(
      "transform",
      // This puts the labal on top of the box instead of inside it
      "translate(" + node.x + ", " + (node.y - node.height / 2) + ")"
    );
  }
  const rectBox = rect2.node().getBBox();
  node.width = rectBox.width;
  node.height = rectBox.height;
  node.intersect = function(point) {
    return (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.i)(node, point);
  };
  return shapeSvg;
};
const noteGroup = (parent, node) => {
  const shapeSvg = parent.insert("g").attr("class", "note-cluster").attr("id", node.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const padding = 0 * node.padding;
  const halfPadding = padding / 2;
  rect2.attr("rx", node.rx).attr("ry", node.ry).attr("x", node.x - node.width / 2 - halfPadding).attr("y", node.y - node.height / 2 - halfPadding).attr("width", node.width + padding).attr("height", node.height + padding).attr("fill", "none");
  const rectBox = rect2.node().getBBox();
  node.width = rectBox.width;
  node.height = rectBox.height;
  node.intersect = function(point) {
    return (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.i)(node, point);
  };
  return shapeSvg;
};
const roundedWithTitle = (parent, node) => {
  const shapeSvg = parent.insert("g").attr("class", node.classes).attr("id", node.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const label = shapeSvg.insert("g").attr("class", "cluster-label");
  const innerRect = shapeSvg.append("rect");
  const text = label.node().appendChild((0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.c)(node.labelText, node.labelStyle, void 0, true));
  let bbox = text.getBBox();
  if ((0,_mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.m)((0,_mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.c)().flowchart.htmlLabels)) {
    const div = text.children[0];
    const dv = (0,d3__WEBPACK_IMPORTED_MODULE_3__.select)(text);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  bbox = text.getBBox();
  const padding = 0 * node.padding;
  const halfPadding = padding / 2;
  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;
  if (node.width <= bbox.width + node.padding) {
    node.diff = (bbox.width + node.padding * 0 - node.width) / 2;
  } else {
    node.diff = -node.padding / 2;
  }
  rect2.attr("class", "outer").attr("x", node.x - width / 2 - halfPadding).attr("y", node.y - node.height / 2 - halfPadding).attr("width", width + padding).attr("height", node.height + padding);
  innerRect.attr("class", "inner").attr("x", node.x - width / 2 - halfPadding).attr("y", node.y - node.height / 2 - halfPadding + bbox.height - 1).attr("width", width + padding).attr("height", node.height + padding - bbox.height - 3);
  label.attr(
    "transform",
    "translate(" + (node.x - bbox.width / 2) + ", " + (node.y - node.height / 2 - node.padding / 3 + ((0,_mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.m)((0,_mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.c)().flowchart.htmlLabels) ? 5 : 3)) + ")"
  );
  const rectBox = rect2.node().getBBox();
  node.height = rectBox.height;
  node.intersect = function(point) {
    return (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.i)(node, point);
  };
  return shapeSvg;
};
const divider = (parent, node) => {
  const shapeSvg = parent.insert("g").attr("class", node.classes).attr("id", node.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const padding = 0 * node.padding;
  const halfPadding = padding / 2;
  rect2.attr("class", "divider").attr("x", node.x - node.width / 2 - halfPadding).attr("y", node.y - node.height / 2).attr("width", node.width + padding).attr("height", node.height + padding);
  const rectBox = rect2.node().getBBox();
  node.width = rectBox.width;
  node.height = rectBox.height;
  node.diff = -node.padding / 2;
  node.intersect = function(point) {
    return (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.i)(node, point);
  };
  return shapeSvg;
};
const shapes = { rect, roundedWithTitle, noteGroup, divider };
let clusterElems = {};
const insertCluster = (elem, node) => {
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("Inserting cluster");
  const shape = node.shape || "rect";
  clusterElems[node.id] = shapes[shape](elem, node);
};
const clear = () => {
  clusterElems = {};
};
const recursiveRender = async (_elem, graph, diagramtype, id, parentCluster) => {
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Graph in recursive render: XXX", dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__.write(graph), parentCluster);
  const dir = graph.graph().rankdir;
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("Dir in recursive render - dir:", dir);
  const elem = _elem.insert("g").attr("class", "root");
  if (!graph.nodes()) {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("No nodes found for", graph);
  } else {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Recursive render XXX", graph.nodes());
  }
  if (graph.edges().length > 0) {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("Recursive edges", graph.edge(graph.edges()[0]));
  }
  const clusters = elem.insert("g").attr("class", "clusters");
  const edgePaths = elem.insert("g").attr("class", "edgePaths");
  const edgeLabels = elem.insert("g").attr("class", "edgeLabels");
  const nodes = elem.insert("g").attr("class", "nodes");
  await Promise.all(
    graph.nodes().map(async function(v) {
      const node = graph.node(v);
      if (parentCluster !== void 0) {
        const data = JSON.parse(JSON.stringify(parentCluster.clusterData));
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Setting data for cluster XXX (", v, ") ", data, parentCluster);
        graph.setNode(parentCluster.id, data);
        if (!graph.parent(v)) {
          _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.trace("Setting parent", v, parentCluster.id);
          graph.setParent(v, parentCluster.id, data);
        }
      }
      _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("(Insert) Node XXX" + v + ": " + JSON.stringify(graph.node(v)));
      if (node && node.clusterNode) {
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Cluster identified", v, node.width, graph.node(v));
        const o = await recursiveRender(nodes, node.graph, diagramtype, id, graph.node(v));
        const newEl = o.elem;
        (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.u)(node, newEl);
        node.diff = o.diff || 0;
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Node bounds (abc123)", v, node, node.width, node.x, node.y);
        (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.s)(newEl, node);
        _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Recursive render complete ", newEl, node);
      } else {
        if (graph.children(v).length > 0) {
          _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Cluster - the non recursive path XXX", v, node.id, node, graph);
          _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info(findNonClusterChild(node.id, graph));
          clusterDb[node.id] = { id: findNonClusterChild(node.id, graph), node };
        } else {
          _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Node - the non recursive path", v, node.id, node);
          await (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.e)(nodes, graph.node(v), dir);
        }
      }
    })
  );
  graph.edges().forEach(function(e) {
    const edge = graph.edge(e.v, e.w, e.name);
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Edge " + e.v + " -> " + e.w + ": ", e, " ", JSON.stringify(graph.edge(e)));
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Fix", clusterDb, "ids:", e.v, e.w, "Translateing: ", clusterDb[e.v], clusterDb[e.w]);
    (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.f)(edgeLabels, edge);
  });
  graph.edges().forEach(function(e) {
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
  });
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("#############################################");
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("###                Layout                 ###");
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("#############################################");
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info(graph);
  (0,dagre_d3_es_src_dagre_index_js__WEBPACK_IMPORTED_MODULE_0__.layout)(graph);
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Graph after layout:", dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__.write(graph));
  let diff = 0;
  sortNodesByHierarchy(graph).forEach(function(v) {
    const node = graph.node(v);
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Position " + v + ": " + JSON.stringify(graph.node(v)));
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info(
      "Position " + v + ": (" + node.x,
      "," + node.y,
      ") width: ",
      node.width,
      " height: ",
      node.height
    );
    if (node && node.clusterNode) {
      (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.p)(node);
    } else {
      if (graph.children(v).length > 0) {
        insertCluster(clusters, node);
        clusterDb[node.id].node = node;
      } else {
        (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.p)(node);
      }
    }
  });
  graph.edges().forEach(function(e) {
    const edge = graph.edge(e);
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(edge), edge);
    const paths = (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.g)(edgePaths, e, edge, clusterDb, diagramtype, graph, id);
    (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.h)(edge, paths);
  });
  graph.nodes().forEach(function(v) {
    const n = graph.node(v);
    _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.info(v, n.type, n.diff);
    if (n.type === "group") {
      diff = n.diff;
    }
  });
  return { elem, diff };
};
const render = async (elem, graph, markers, diagramtype, id) => {
  (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.a)(elem, markers, diagramtype, id);
  (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.b)();
  (0,_edges_f15a7e05_js__WEBPACK_IMPORTED_MODULE_6__.d)();
  clear();
  clear$1();
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Graph at first:", JSON.stringify(dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__.write(graph)));
  adjustClustersAndEdges(graph);
  _mermaid_0d192ec3_js__WEBPACK_IMPORTED_MODULE_4__.l.warn("Graph after:", JSON.stringify(dagre_d3_es_src_graphlib_json_js__WEBPACK_IMPORTED_MODULE_1__.write(graph)));
  await recursiveRender(elem, graph, diagramtype, id);
};



/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWVybWFpZF9kaXN0X2luZGV4LWY5NDYyZjNmX2pzLmUxZTA0YmVmOGRlZDBmYzdjYzg3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDSTs7QUFFWjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU8saURBQWE7QUFDcEIsaUJBQWlCLGlEQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsaURBQUs7QUFDZDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVMsaURBQWE7QUFDdEI7QUFDQTtBQUNBLFNBQVMsaURBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsU0FBUyxpREFBSztBQUNkO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVMsaURBQWE7QUFDdEI7QUFDQTtBQUNBLFNBQVMsaURBQWE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsY0FBYyw0Q0FBSztBQUNuQixFQUFFLGlEQUFNO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxpREFBTTtBQUNSLGdCQUFnQiwwQ0FBMEM7QUFDMUQsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5RHdDOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUSxJQUFJLFFBQVE7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBUztBQUNsQjs7QUFFQSxpRUFBZSxLQUFLLEVBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQ21DO0FB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WDtBQUNBO0FBQ0EsRUFBRSxxREFBYTtBQUNmLEVBQUUscURBQU87QUFDVCxFQUFFLHFEQUFPO0FBQ1Q7QUFDQTtBQUNBLEVBQUUsd0RBQVEsbUNBQW1DLG1FQUFrQjtBQUMvRDtBQUNBLEVBQUUsd0RBQVEsZ0NBQWdDLG1FQUFrQjtBQUM1RDtBQUNBO0FBR0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL2RhZ3JlLWQzLWVzL3NyYy9ncmFwaGxpYi9qc29uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Nsb25lLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvbWVybWFpZC9kaXN0L2luZGV4LWY5NDYyZjNmLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIF8gZnJvbSAnbG9kYXNoLWVzJztcbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnLi9ncmFwaC5qcyc7XG5cbmV4cG9ydCB7IHdyaXRlLCByZWFkIH07XG5cbmZ1bmN0aW9uIHdyaXRlKGcpIHtcbiAgdmFyIGpzb24gPSB7XG4gICAgb3B0aW9uczoge1xuICAgICAgZGlyZWN0ZWQ6IGcuaXNEaXJlY3RlZCgpLFxuICAgICAgbXVsdGlncmFwaDogZy5pc011bHRpZ3JhcGgoKSxcbiAgICAgIGNvbXBvdW5kOiBnLmlzQ29tcG91bmQoKSxcbiAgICB9LFxuICAgIG5vZGVzOiB3cml0ZU5vZGVzKGcpLFxuICAgIGVkZ2VzOiB3cml0ZUVkZ2VzKGcpLFxuICB9O1xuICBpZiAoIV8uaXNVbmRlZmluZWQoZy5ncmFwaCgpKSkge1xuICAgIGpzb24udmFsdWUgPSBfLmNsb25lKGcuZ3JhcGgoKSk7XG4gIH1cbiAgcmV0dXJuIGpzb247XG59XG5cbmZ1bmN0aW9uIHdyaXRlTm9kZXMoZykge1xuICByZXR1cm4gXy5tYXAoZy5ub2RlcygpLCBmdW5jdGlvbiAodikge1xuICAgIHZhciBub2RlVmFsdWUgPSBnLm5vZGUodik7XG4gICAgdmFyIHBhcmVudCA9IGcucGFyZW50KHYpO1xuICAgIHZhciBub2RlID0geyB2OiB2IH07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKG5vZGVWYWx1ZSkpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlVmFsdWU7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChwYXJlbnQpKSB7XG4gICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB3cml0ZUVkZ2VzKGcpIHtcbiAgcmV0dXJuIF8ubWFwKGcuZWRnZXMoKSwgZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZWRnZVZhbHVlID0gZy5lZGdlKGUpO1xuICAgIHZhciBlZGdlID0geyB2OiBlLnYsIHc6IGUudyB9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlLm5hbWUpKSB7XG4gICAgICBlZGdlLm5hbWUgPSBlLm5hbWU7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChlZGdlVmFsdWUpKSB7XG4gICAgICBlZGdlLnZhbHVlID0gZWRnZVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlYWQoanNvbikge1xuICB2YXIgZyA9IG5ldyBHcmFwaChqc29uLm9wdGlvbnMpLnNldEdyYXBoKGpzb24udmFsdWUpO1xuICBfLmVhY2goanNvbi5ub2RlcywgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgZy5zZXROb2RlKGVudHJ5LnYsIGVudHJ5LnZhbHVlKTtcbiAgICBpZiAoZW50cnkucGFyZW50KSB7XG4gICAgICBnLnNldFBhcmVudChlbnRyeS52LCBlbnRyeS5wYXJlbnQpO1xuICAgIH1cbiAgfSk7XG4gIF8uZWFjaChqc29uLmVkZ2VzLCBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICBnLnNldEVkZ2UoeyB2OiBlbnRyeS52LCB3OiBlbnRyeS53LCBuYW1lOiBlbnRyeS5uYW1lIH0sIGVudHJ5LnZhbHVlKTtcbiAgfSk7XG4gIHJldHVybiBnO1xufVxuIiwiaW1wb3J0IGJhc2VDbG9uZSBmcm9tICcuL19iYXNlQ2xvbmUuanMnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciBjbG9uaW5nLiAqL1xudmFyIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNoYWxsb3cgY2xvbmUgb2YgYHZhbHVlYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvbiB0aGVcbiAqIFtzdHJ1Y3R1cmVkIGNsb25lIGFsZ29yaXRobV0oaHR0cHM6Ly9tZG4uaW8vU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0pXG4gKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gKiBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLCBzZXRzLCBzdHJpbmdzLCBzeW1ib2xzLCBhbmQgdHlwZWRcbiAqIGFycmF5cy4gVGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYGFyZ3VtZW50c2Agb2JqZWN0cyBhcmUgY2xvbmVkXG4gKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gKiBhcyBlcnJvciBvYmplY3RzLCBmdW5jdGlvbnMsIERPTSBub2RlcywgYW5kIFdlYWtNYXBzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBzaGFsbG93ID0gXy5jbG9uZShvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbG9uZTtcbiIsImltcG9ydCB7IGxheW91dCB9IGZyb20gXCJkYWdyZS1kMy1lcy9zcmMvZGFncmUvaW5kZXguanNcIjtcbmltcG9ydCAqIGFzIGdyYXBobGliSnNvbiBmcm9tIFwiZGFncmUtZDMtZXMvc3JjL2dyYXBobGliL2pzb24uanNcIjtcbmltcG9ydCB7IGMgYXMgY3JlYXRlTGFiZWwsIGkgYXMgaW50ZXJzZWN0UmVjdCwgYSBhcyBpbnNlcnRNYXJrZXJzLCBiIGFzIGNsZWFyJDIsIGQgYXMgY2xlYXIkMywgdSBhcyB1cGRhdGVOb2RlQm91bmRzLCBzIGFzIHNldE5vZGVFbGVtLCBlIGFzIGluc2VydE5vZGUsIGYgYXMgaW5zZXJ0RWRnZUxhYmVsLCBwIGFzIHBvc2l0aW9uTm9kZSwgZyBhcyBpbnNlcnRFZGdlLCBoIGFzIHBvc2l0aW9uRWRnZUxhYmVsIH0gZnJvbSBcIi4vZWRnZXMtZjE1YTdlMDUuanNcIjtcbmltcG9ydCB7IGwgYXMgbG9nLCBtIGFzIGV2YWx1YXRlLCBjIGFzIGdldENvbmZpZyB9IGZyb20gXCIuL21lcm1haWQtMGQxOTJlYzMuanNcIjtcbmltcG9ydCAqIGFzIGdyYXBobGliIGZyb20gXCJkYWdyZS1kMy1lcy9zcmMvZ3JhcGhsaWIvaW5kZXguanNcIjtcbmltcG9ydCB7IGMgYXMgY3JlYXRlVGV4dCB9IGZyb20gXCIuL2NyZWF0ZVRleHQtODBjM2JlZmIuanNcIjtcbmltcG9ydCB7IHNlbGVjdCB9IGZyb20gXCJkM1wiO1xubGV0IGNsdXN0ZXJEYiA9IHt9O1xubGV0IGRlc2NlbmRhbnRzID0ge307XG5sZXQgcGFyZW50cyA9IHt9O1xuY29uc3QgY2xlYXIkMSA9ICgpID0+IHtcbiAgZGVzY2VuZGFudHMgPSB7fTtcbiAgcGFyZW50cyA9IHt9O1xuICBjbHVzdGVyRGIgPSB7fTtcbn07XG5jb25zdCBpc0Rlc2NlbmRhbnQgPSAoaWQsIGFuY2Vuc3RvcklkKSA9PiB7XG4gIGxvZy50cmFjZShcIkluIGlzRGVjZW5kYW50XCIsIGFuY2Vuc3RvcklkLCBcIiBcIiwgaWQsIFwiID0gXCIsIGRlc2NlbmRhbnRzW2FuY2Vuc3RvcklkXS5pbmNsdWRlcyhpZCkpO1xuICBpZiAoZGVzY2VuZGFudHNbYW5jZW5zdG9ySWRdLmluY2x1ZGVzKGlkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBlZGdlSW5DbHVzdGVyID0gKGVkZ2UsIGNsdXN0ZXJJZCkgPT4ge1xuICBsb2cuaW5mbyhcIkRlY2VuZGFudHMgb2YgXCIsIGNsdXN0ZXJJZCwgXCIgaXMgXCIsIGRlc2NlbmRhbnRzW2NsdXN0ZXJJZF0pO1xuICBsb2cuaW5mbyhcIkVkZ2UgaXMgXCIsIGVkZ2UpO1xuICBpZiAoZWRnZS52ID09PSBjbHVzdGVySWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGVkZ2UudyA9PT0gY2x1c3RlcklkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghZGVzY2VuZGFudHNbY2x1c3RlcklkXSkge1xuICAgIGxvZy5kZWJ1ZyhcIlRpbHQsIFwiLCBjbHVzdGVySWQsIFwiLG5vdCBpbiBkZWNlbmRhbnRzXCIpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gZGVzY2VuZGFudHNbY2x1c3RlcklkXS5pbmNsdWRlcyhlZGdlLnYpIHx8IGlzRGVzY2VuZGFudChlZGdlLnYsIGNsdXN0ZXJJZCkgfHwgaXNEZXNjZW5kYW50KGVkZ2UudywgY2x1c3RlcklkKSB8fCBkZXNjZW5kYW50c1tjbHVzdGVySWRdLmluY2x1ZGVzKGVkZ2Uudyk7XG59O1xuY29uc3QgY29weSA9IChjbHVzdGVySWQsIGdyYXBoLCBuZXdHcmFwaCwgcm9vdElkKSA9PiB7XG4gIGxvZy53YXJuKFxuICAgIFwiQ29weWluZyBjaGlsZHJlbiBvZiBcIixcbiAgICBjbHVzdGVySWQsXG4gICAgXCJyb290XCIsXG4gICAgcm9vdElkLFxuICAgIFwiZGF0YVwiLFxuICAgIGdyYXBoLm5vZGUoY2x1c3RlcklkKSxcbiAgICByb290SWRcbiAgKTtcbiAgY29uc3Qgbm9kZXMgPSBncmFwaC5jaGlsZHJlbihjbHVzdGVySWQpIHx8IFtdO1xuICBpZiAoY2x1c3RlcklkICE9PSByb290SWQpIHtcbiAgICBub2Rlcy5wdXNoKGNsdXN0ZXJJZCk7XG4gIH1cbiAgbG9nLndhcm4oXCJDb3B5aW5nIChub2RlcykgY2x1c3RlcklkXCIsIGNsdXN0ZXJJZCwgXCJub2Rlc1wiLCBub2Rlcyk7XG4gIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICBpZiAoZ3JhcGguY2hpbGRyZW4obm9kZSkubGVuZ3RoID4gMCkge1xuICAgICAgY29weShub2RlLCBncmFwaCwgbmV3R3JhcGgsIHJvb3RJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRhdGEgPSBncmFwaC5ub2RlKG5vZGUpO1xuICAgICAgbG9nLmluZm8oXCJjcCBcIiwgbm9kZSwgXCIgdG8gXCIsIHJvb3RJZCwgXCIgd2l0aCBwYXJlbnQgXCIsIGNsdXN0ZXJJZCk7XG4gICAgICBuZXdHcmFwaC5zZXROb2RlKG5vZGUsIGRhdGEpO1xuICAgICAgaWYgKHJvb3RJZCAhPT0gZ3JhcGgucGFyZW50KG5vZGUpKSB7XG4gICAgICAgIGxvZy53YXJuKFwiU2V0dGluZyBwYXJlbnRcIiwgbm9kZSwgZ3JhcGgucGFyZW50KG5vZGUpKTtcbiAgICAgICAgbmV3R3JhcGguc2V0UGFyZW50KG5vZGUsIGdyYXBoLnBhcmVudChub2RlKSk7XG4gICAgICB9XG4gICAgICBpZiAoY2x1c3RlcklkICE9PSByb290SWQgJiYgbm9kZSAhPT0gY2x1c3RlcklkKSB7XG4gICAgICAgIGxvZy5kZWJ1ZyhcIlNldHRpbmcgcGFyZW50XCIsIG5vZGUsIGNsdXN0ZXJJZCk7XG4gICAgICAgIG5ld0dyYXBoLnNldFBhcmVudChub2RlLCBjbHVzdGVySWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nLmluZm8oXCJJbiBjb3B5IFwiLCBjbHVzdGVySWQsIFwicm9vdFwiLCByb290SWQsIFwiZGF0YVwiLCBncmFwaC5ub2RlKGNsdXN0ZXJJZCksIHJvb3RJZCk7XG4gICAgICAgIGxvZy5kZWJ1ZyhcbiAgICAgICAgICBcIk5vdCBTZXR0aW5nIHBhcmVudCBmb3Igbm9kZT1cIixcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIFwiY2x1c3RlciE9PXJvb3RJZFwiLFxuICAgICAgICAgIGNsdXN0ZXJJZCAhPT0gcm9vdElkLFxuICAgICAgICAgIFwibm9kZSE9PWNsdXN0ZXJJZFwiLFxuICAgICAgICAgIG5vZGUgIT09IGNsdXN0ZXJJZFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRnZXMgPSBncmFwaC5lZGdlcyhub2RlKTtcbiAgICAgIGxvZy5kZWJ1ZyhcIkNvcHlpbmcgRWRnZXNcIiwgZWRnZXMpO1xuICAgICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBsb2cuaW5mbyhcIkVkZ2VcIiwgZWRnZSk7XG4gICAgICAgIGNvbnN0IGRhdGEyID0gZ3JhcGguZWRnZShlZGdlLnYsIGVkZ2UudywgZWRnZS5uYW1lKTtcbiAgICAgICAgbG9nLmluZm8oXCJFZGdlIGRhdGFcIiwgZGF0YTIsIHJvb3RJZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGVkZ2VJbkNsdXN0ZXIoZWRnZSwgcm9vdElkKSkge1xuICAgICAgICAgICAgbG9nLmluZm8oXCJDb3B5aW5nIGFzIFwiLCBlZGdlLnYsIGVkZ2UudywgZGF0YTIsIGVkZ2UubmFtZSk7XG4gICAgICAgICAgICBuZXdHcmFwaC5zZXRFZGdlKGVkZ2UudiwgZWRnZS53LCBkYXRhMiwgZWRnZS5uYW1lKTtcbiAgICAgICAgICAgIGxvZy5pbmZvKFwibmV3R3JhcGggZWRnZXMgXCIsIG5ld0dyYXBoLmVkZ2VzKCksIG5ld0dyYXBoLmVkZ2UobmV3R3JhcGguZWRnZXMoKVswXSkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2cuaW5mbyhcbiAgICAgICAgICAgICAgXCJTa2lwcGluZyBjb3B5IG9mIGVkZ2UgXCIsXG4gICAgICAgICAgICAgIGVkZ2UudixcbiAgICAgICAgICAgICAgXCItLT5cIixcbiAgICAgICAgICAgICAgZWRnZS53LFxuICAgICAgICAgICAgICBcIiByb290SWQ6IFwiLFxuICAgICAgICAgICAgICByb290SWQsXG4gICAgICAgICAgICAgIFwiIGNsdXN0ZXJJZDpcIixcbiAgICAgICAgICAgICAgY2x1c3RlcklkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGxvZy5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxvZy5kZWJ1ZyhcIlJlbW92aW5nIG5vZGVcIiwgbm9kZSk7XG4gICAgZ3JhcGgucmVtb3ZlTm9kZShub2RlKTtcbiAgfSk7XG59O1xuY29uc3QgZXh0cmFjdERlc2NlbmRhbnRzID0gKGlkLCBncmFwaCkgPT4ge1xuICBjb25zdCBjaGlsZHJlbiA9IGdyYXBoLmNoaWxkcmVuKGlkKTtcbiAgbGV0IHJlcyA9IFsuLi5jaGlsZHJlbl07XG4gIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICBwYXJlbnRzW2NoaWxkXSA9IGlkO1xuICAgIHJlcyA9IFsuLi5yZXMsIC4uLmV4dHJhY3REZXNjZW5kYW50cyhjaGlsZCwgZ3JhcGgpXTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbmNvbnN0IGZpbmROb25DbHVzdGVyQ2hpbGQgPSAoaWQsIGdyYXBoKSA9PiB7XG4gIGxvZy50cmFjZShcIlNlYXJjaGluZ1wiLCBpZCk7XG4gIGNvbnN0IGNoaWxkcmVuID0gZ3JhcGguY2hpbGRyZW4oaWQpO1xuICBsb2cudHJhY2UoXCJTZWFyY2hpbmcgY2hpbGRyZW4gb2YgaWQgXCIsIGlkLCBjaGlsZHJlbik7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGggPCAxKSB7XG4gICAgbG9nLnRyYWNlKFwiVGhpcyBpcyBhIHZhbGlkIG5vZGVcIiwgaWQpO1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgY29uc3QgX2lkID0gZmluZE5vbkNsdXN0ZXJDaGlsZChjaGlsZCwgZ3JhcGgpO1xuICAgIGlmIChfaWQpIHtcbiAgICAgIGxvZy50cmFjZShcIkZvdW5kIHJlcGxhY2VtZW50IGZvclwiLCBpZCwgXCIgPT4gXCIsIF9pZCk7XG4gICAgICByZXR1cm4gX2lkO1xuICAgIH1cbiAgfVxufTtcbmNvbnN0IGdldEFuY2hvcklkID0gKGlkKSA9PiB7XG4gIGlmICghY2x1c3RlckRiW2lkXSkge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBpZiAoIWNsdXN0ZXJEYltpZF0uZXh0ZXJuYWxDb25uZWN0aW9ucykge1xuICAgIHJldHVybiBpZDtcbiAgfVxuICBpZiAoY2x1c3RlckRiW2lkXSkge1xuICAgIHJldHVybiBjbHVzdGVyRGJbaWRdLmlkO1xuICB9XG4gIHJldHVybiBpZDtcbn07XG5jb25zdCBhZGp1c3RDbHVzdGVyc0FuZEVkZ2VzID0gKGdyYXBoLCBkZXB0aCkgPT4ge1xuICBpZiAoIWdyYXBoIHx8IGRlcHRoID4gMTApIHtcbiAgICBsb2cuZGVidWcoXCJPcHRpbmcgb3V0LCBubyBncmFwaCBcIik7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIGxvZy5kZWJ1ZyhcIk9wdGluZyBpbiwgZ3JhcGggXCIpO1xuICB9XG4gIGdyYXBoLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbihpZCkge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JhcGguY2hpbGRyZW4oaWQpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBsb2cud2FybihcbiAgICAgICAgXCJDbHVzdGVyIGlkZW50aWZpZWRcIixcbiAgICAgICAgaWQsXG4gICAgICAgIFwiIFJlcGxhY2VtZW50IGlkIGluIGVkZ2VzOiBcIixcbiAgICAgICAgZmluZE5vbkNsdXN0ZXJDaGlsZChpZCwgZ3JhcGgpXG4gICAgICApO1xuICAgICAgZGVzY2VuZGFudHNbaWRdID0gZXh0cmFjdERlc2NlbmRhbnRzKGlkLCBncmFwaCk7XG4gICAgICBjbHVzdGVyRGJbaWRdID0geyBpZDogZmluZE5vbkNsdXN0ZXJDaGlsZChpZCwgZ3JhcGgpLCBjbHVzdGVyRGF0YTogZ3JhcGgubm9kZShpZCkgfTtcbiAgICB9XG4gIH0pO1xuICBncmFwaC5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24oaWQpIHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGdyYXBoLmNoaWxkcmVuKGlkKTtcbiAgICBjb25zdCBlZGdlcyA9IGdyYXBoLmVkZ2VzKCk7XG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGxvZy5kZWJ1ZyhcIkNsdXN0ZXIgaWRlbnRpZmllZFwiLCBpZCwgZGVzY2VuZGFudHMpO1xuICAgICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBpZiAoZWRnZS52ICE9PSBpZCAmJiBlZGdlLncgIT09IGlkKSB7XG4gICAgICAgICAgY29uc3QgZDEgPSBpc0Rlc2NlbmRhbnQoZWRnZS52LCBpZCk7XG4gICAgICAgICAgY29uc3QgZDIgPSBpc0Rlc2NlbmRhbnQoZWRnZS53LCBpZCk7XG4gICAgICAgICAgaWYgKGQxIF4gZDIpIHtcbiAgICAgICAgICAgIGxvZy53YXJuKFwiRWRnZTogXCIsIGVkZ2UsIFwiIGxlYXZlcyBjbHVzdGVyIFwiLCBpZCk7XG4gICAgICAgICAgICBsb2cud2FybihcIkRlY2VuZGFudHMgb2YgWFhYIFwiLCBpZCwgXCI6IFwiLCBkZXNjZW5kYW50c1tpZF0pO1xuICAgICAgICAgICAgY2x1c3RlckRiW2lkXS5leHRlcm5hbENvbm5lY3Rpb25zID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cuZGVidWcoXCJOb3QgYSBjbHVzdGVyIFwiLCBpZCwgZGVzY2VuZGFudHMpO1xuICAgIH1cbiAgfSk7XG4gIGdyYXBoLmVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgZWRnZSA9IGdyYXBoLmVkZ2UoZSk7XG4gICAgbG9nLndhcm4oXCJFZGdlIFwiICsgZS52ICsgXCIgLT4gXCIgKyBlLncgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgbG9nLndhcm4oXCJFZGdlIFwiICsgZS52ICsgXCIgLT4gXCIgKyBlLncgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShncmFwaC5lZGdlKGUpKSk7XG4gICAgbGV0IHYgPSBlLnY7XG4gICAgbGV0IHcgPSBlLnc7XG4gICAgbG9nLndhcm4oXG4gICAgICBcIkZpeCBYWFhcIixcbiAgICAgIGNsdXN0ZXJEYixcbiAgICAgIFwiaWRzOlwiLFxuICAgICAgZS52LFxuICAgICAgZS53LFxuICAgICAgXCJUcmFuc2xhdGluZzogXCIsXG4gICAgICBjbHVzdGVyRGJbZS52XSxcbiAgICAgIFwiIC0tLSBcIixcbiAgICAgIGNsdXN0ZXJEYltlLnddXG4gICAgKTtcbiAgICBpZiAoY2x1c3RlckRiW2Uudl0gJiYgY2x1c3RlckRiW2Uud10gJiYgY2x1c3RlckRiW2Uudl0gPT09IGNsdXN0ZXJEYltlLnddKSB7XG4gICAgICBsb2cud2FybihcIkZpeGluZyBhbmQgdHJpeGluZyBsaW5rIHRvIHNlbGYgLSByZW1vdmluZyBYWFhcIiwgZS52LCBlLncsIGUubmFtZSk7XG4gICAgICBsb2cud2FybihcIkZpeGluZyBhbmQgdHJpeGluZyAtIHJlbW92aW5nIFhYWFwiLCBlLnYsIGUudywgZS5uYW1lKTtcbiAgICAgIHYgPSBnZXRBbmNob3JJZChlLnYpO1xuICAgICAgdyA9IGdldEFuY2hvcklkKGUudyk7XG4gICAgICBncmFwaC5yZW1vdmVFZGdlKGUudiwgZS53LCBlLm5hbWUpO1xuICAgICAgY29uc3Qgc3BlY2lhbElkID0gZS53ICsgXCItLS1cIiArIGUudjtcbiAgICAgIGdyYXBoLnNldE5vZGUoc3BlY2lhbElkLCB7XG4gICAgICAgIGRvbUlkOiBzcGVjaWFsSWQsXG4gICAgICAgIGlkOiBzcGVjaWFsSWQsXG4gICAgICAgIGxhYmVsU3R5bGU6IFwiXCIsXG4gICAgICAgIGxhYmVsVGV4dDogZWRnZS5sYWJlbCxcbiAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgc2hhcGU6IFwibGFiZWxSZWN0XCIsXG4gICAgICAgIHN0eWxlOiBcIlwiXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGVkZ2UxID0gc3RydWN0dXJlZENsb25lKGVkZ2UpO1xuICAgICAgY29uc3QgZWRnZTIgPSBzdHJ1Y3R1cmVkQ2xvbmUoZWRnZSk7XG4gICAgICBlZGdlMS5sYWJlbCA9IFwiXCI7XG4gICAgICBlZGdlMS5hcnJvd1R5cGVFbmQgPSBcIm5vbmVcIjtcbiAgICAgIGVkZ2UyLmxhYmVsID0gXCJcIjtcbiAgICAgIGVkZ2UxLmZyb21DbHVzdGVyID0gZS52O1xuICAgICAgZWRnZTIudG9DbHVzdGVyID0gZS52O1xuICAgICAgZ3JhcGguc2V0RWRnZSh2LCBzcGVjaWFsSWQsIGVkZ2UxLCBlLm5hbWUgKyBcIi1jeWNsaWMtc3BlY2lhbFwiKTtcbiAgICAgIGdyYXBoLnNldEVkZ2Uoc3BlY2lhbElkLCB3LCBlZGdlMiwgZS5uYW1lICsgXCItY3ljbGljLXNwZWNpYWxcIik7XG4gICAgfSBlbHNlIGlmIChjbHVzdGVyRGJbZS52XSB8fCBjbHVzdGVyRGJbZS53XSkge1xuICAgICAgbG9nLndhcm4oXCJGaXhpbmcgYW5kIHRyaXhpbmcgLSByZW1vdmluZyBYWFhcIiwgZS52LCBlLncsIGUubmFtZSk7XG4gICAgICB2ID0gZ2V0QW5jaG9ySWQoZS52KTtcbiAgICAgIHcgPSBnZXRBbmNob3JJZChlLncpO1xuICAgICAgZ3JhcGgucmVtb3ZlRWRnZShlLnYsIGUudywgZS5uYW1lKTtcbiAgICAgIGlmICh2ICE9PSBlLnYpIHtcbiAgICAgICAgZWRnZS5mcm9tQ2x1c3RlciA9IGUudjtcbiAgICAgIH1cbiAgICAgIGlmICh3ICE9PSBlLncpIHtcbiAgICAgICAgZWRnZS50b0NsdXN0ZXIgPSBlLnc7XG4gICAgICB9XG4gICAgICBsb2cud2FybihcIkZpeCBSZXBsYWNpbmcgd2l0aCBYWFhcIiwgdiwgdywgZS5uYW1lKTtcbiAgICAgIGdyYXBoLnNldEVkZ2UodiwgdywgZWRnZSwgZS5uYW1lKTtcbiAgICB9XG4gIH0pO1xuICBsb2cud2FybihcIkFkanVzdGVkIEdyYXBoXCIsIGdyYXBobGliSnNvbi53cml0ZShncmFwaCkpO1xuICBleHRyYWN0b3IoZ3JhcGgsIDApO1xuICBsb2cudHJhY2UoY2x1c3RlckRiKTtcbn07XG5jb25zdCBleHRyYWN0b3IgPSAoZ3JhcGgsIGRlcHRoKSA9PiB7XG4gIGxvZy53YXJuKFwiZXh0cmFjdG9yIC0gXCIsIGRlcHRoLCBncmFwaGxpYkpzb24ud3JpdGUoZ3JhcGgpLCBncmFwaC5jaGlsZHJlbihcIkRcIikpO1xuICBpZiAoZGVwdGggPiAxMCkge1xuICAgIGxvZy5lcnJvcihcIkJhaWxpbmcgb3V0XCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbm9kZXMgPSBncmFwaC5ub2RlcygpO1xuICBsZXQgaGFzQ2hpbGRyZW4gPSBmYWxzZTtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBncmFwaC5jaGlsZHJlbihub2RlKTtcbiAgICBoYXNDaGlsZHJlbiA9IGhhc0NoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA+IDA7XG4gIH1cbiAgaWYgKCFoYXNDaGlsZHJlbikge1xuICAgIGxvZy5kZWJ1ZyhcIkRvbmUsIG5vIG5vZGUgaGFzIGNoaWxkcmVuXCIsIGdyYXBoLm5vZGVzKCkpO1xuICAgIHJldHVybjtcbiAgfVxuICBsb2cuZGVidWcoXCJOb2RlcyA9IFwiLCBub2RlcywgZGVwdGgpO1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBsb2cuZGVidWcoXG4gICAgICBcIkV4dHJhY3Rpbmcgbm9kZVwiLFxuICAgICAgbm9kZSxcbiAgICAgIGNsdXN0ZXJEYixcbiAgICAgIGNsdXN0ZXJEYltub2RlXSAmJiAhY2x1c3RlckRiW25vZGVdLmV4dGVybmFsQ29ubmVjdGlvbnMsXG4gICAgICAhZ3JhcGgucGFyZW50KG5vZGUpLFxuICAgICAgZ3JhcGgubm9kZShub2RlKSxcbiAgICAgIGdyYXBoLmNoaWxkcmVuKFwiRFwiKSxcbiAgICAgIFwiIERlcHRoIFwiLFxuICAgICAgZGVwdGhcbiAgICApO1xuICAgIGlmICghY2x1c3RlckRiW25vZGVdKSB7XG4gICAgICBsb2cuZGVidWcoXCJOb3QgYSBjbHVzdGVyXCIsIG5vZGUsIGRlcHRoKTtcbiAgICB9IGVsc2UgaWYgKCFjbHVzdGVyRGJbbm9kZV0uZXh0ZXJuYWxDb25uZWN0aW9ucyAmJiAvLyAhZ3JhcGgucGFyZW50KG5vZGUpICYmXG4gICAgZ3JhcGguY2hpbGRyZW4obm9kZSkgJiYgZ3JhcGguY2hpbGRyZW4obm9kZSkubGVuZ3RoID4gMCkge1xuICAgICAgbG9nLndhcm4oXG4gICAgICAgIFwiQ2x1c3RlciB3aXRob3V0IGV4dGVybmFsIGNvbm5lY3Rpb25zLCB3aXRob3V0IGEgcGFyZW50IGFuZCB3aXRoIGNoaWxkcmVuXCIsXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGRlcHRoXG4gICAgICApO1xuICAgICAgY29uc3QgZ3JhcGhTZXR0aW5ncyA9IGdyYXBoLmdyYXBoKCk7XG4gICAgICBsZXQgZGlyID0gZ3JhcGhTZXR0aW5ncy5yYW5rZGlyID09PSBcIlRCXCIgPyBcIkxSXCIgOiBcIlRCXCI7XG4gICAgICBpZiAoY2x1c3RlckRiW25vZGVdICYmIGNsdXN0ZXJEYltub2RlXS5jbHVzdGVyRGF0YSAmJiBjbHVzdGVyRGJbbm9kZV0uY2x1c3RlckRhdGEuZGlyKSB7XG4gICAgICAgIGRpciA9IGNsdXN0ZXJEYltub2RlXS5jbHVzdGVyRGF0YS5kaXI7XG4gICAgICAgIGxvZy53YXJuKFwiRml4aW5nIGRpclwiLCBjbHVzdGVyRGJbbm9kZV0uY2x1c3RlckRhdGEuZGlyLCBkaXIpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2x1c3RlckdyYXBoID0gbmV3IGdyYXBobGliLkdyYXBoKHtcbiAgICAgICAgbXVsdGlncmFwaDogdHJ1ZSxcbiAgICAgICAgY29tcG91bmQ6IHRydWVcbiAgICAgIH0pLnNldEdyYXBoKHtcbiAgICAgICAgcmFua2RpcjogZGlyLFxuICAgICAgICAvLyBUb2RvOiBzZXQgcHJvcGVyIHNwYWNpbmdcbiAgICAgICAgbm9kZXNlcDogNTAsXG4gICAgICAgIHJhbmtzZXA6IDUwLFxuICAgICAgICBtYXJnaW54OiA4LFxuICAgICAgICBtYXJnaW55OiA4XG4gICAgICB9KS5zZXREZWZhdWx0RWRnZUxhYmVsKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9KTtcbiAgICAgIGxvZy53YXJuKFwiT2xkIGdyYXBoIGJlZm9yZSBjb3B5XCIsIGdyYXBobGliSnNvbi53cml0ZShncmFwaCkpO1xuICAgICAgY29weShub2RlLCBncmFwaCwgY2x1c3RlckdyYXBoLCBub2RlKTtcbiAgICAgIGdyYXBoLnNldE5vZGUobm9kZSwge1xuICAgICAgICBjbHVzdGVyTm9kZTogdHJ1ZSxcbiAgICAgICAgaWQ6IG5vZGUsXG4gICAgICAgIGNsdXN0ZXJEYXRhOiBjbHVzdGVyRGJbbm9kZV0uY2x1c3RlckRhdGEsXG4gICAgICAgIGxhYmVsVGV4dDogY2x1c3RlckRiW25vZGVdLmxhYmVsVGV4dCxcbiAgICAgICAgZ3JhcGg6IGNsdXN0ZXJHcmFwaFxuICAgICAgfSk7XG4gICAgICBsb2cud2FybihcIk5ldyBncmFwaCBhZnRlciBjb3B5IG5vZGU6IChcIiwgbm9kZSwgXCIpXCIsIGdyYXBobGliSnNvbi53cml0ZShjbHVzdGVyR3JhcGgpKTtcbiAgICAgIGxvZy5kZWJ1ZyhcIk9sZCBncmFwaCBhZnRlciBjb3B5XCIsIGdyYXBobGliSnNvbi53cml0ZShncmFwaCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2cud2FybihcbiAgICAgICAgXCJDbHVzdGVyICoqIFwiLFxuICAgICAgICBub2RlLFxuICAgICAgICBcIiAqKm5vdCBtZWV0aW5nIHRoZSBjcml0ZXJpYSAhZXh0ZXJuYWxDb25uZWN0aW9uczpcIixcbiAgICAgICAgIWNsdXN0ZXJEYltub2RlXS5leHRlcm5hbENvbm5lY3Rpb25zLFxuICAgICAgICBcIiBubyBwYXJlbnQ6IFwiLFxuICAgICAgICAhZ3JhcGgucGFyZW50KG5vZGUpLFxuICAgICAgICBcIiBjaGlsZHJlbiBcIixcbiAgICAgICAgZ3JhcGguY2hpbGRyZW4obm9kZSkgJiYgZ3JhcGguY2hpbGRyZW4obm9kZSkubGVuZ3RoID4gMCxcbiAgICAgICAgZ3JhcGguY2hpbGRyZW4oXCJEXCIpLFxuICAgICAgICBkZXB0aFxuICAgICAgKTtcbiAgICAgIGxvZy5kZWJ1ZyhjbHVzdGVyRGIpO1xuICAgIH1cbiAgfVxuICBub2RlcyA9IGdyYXBoLm5vZGVzKCk7XG4gIGxvZy53YXJuKFwiTmV3IGxpc3Qgb2Ygbm9kZXNcIiwgbm9kZXMpO1xuICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICBjb25zdCBkYXRhID0gZ3JhcGgubm9kZShub2RlKTtcbiAgICBsb2cud2FybihcIiBOb3cgbmV4dCBsZXZlbFwiLCBub2RlLCBkYXRhKTtcbiAgICBpZiAoZGF0YS5jbHVzdGVyTm9kZSkge1xuICAgICAgZXh0cmFjdG9yKGRhdGEuZ3JhcGgsIGRlcHRoICsgMSk7XG4gICAgfVxuICB9XG59O1xuY29uc3Qgc29ydGVyID0gKGdyYXBoLCBub2RlcykgPT4ge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGxldCByZXN1bHQgPSBPYmplY3QuYXNzaWduKG5vZGVzKTtcbiAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gZ3JhcGguY2hpbGRyZW4obm9kZSk7XG4gICAgY29uc3Qgc29ydGVkID0gc29ydGVyKGdyYXBoLCBjaGlsZHJlbik7XG4gICAgcmVzdWx0ID0gWy4uLnJlc3VsdCwgLi4uc29ydGVkXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3Qgc29ydE5vZGVzQnlIaWVyYXJjaHkgPSAoZ3JhcGgpID0+IHNvcnRlcihncmFwaCwgZ3JhcGguY2hpbGRyZW4oKSk7XG5jb25zdCByZWN0ID0gKHBhcmVudCwgbm9kZSkgPT4ge1xuICBsb2cuaW5mbyhcIkNyZWF0aW5nIHN1YmdyYXBoIHJlY3QgZm9yIFwiLCBub2RlLmlkLCBub2RlKTtcbiAgY29uc3Qgc2hhcGVTdmcgPSBwYXJlbnQuaW5zZXJ0KFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJjbHVzdGVyXCIgKyAobm9kZS5jbGFzcyA/IFwiIFwiICsgbm9kZS5jbGFzcyA6IFwiXCIpKS5hdHRyKFwiaWRcIiwgbm9kZS5pZCk7XG4gIGNvbnN0IHJlY3QyID0gc2hhcGVTdmcuaW5zZXJ0KFwicmVjdFwiLCBcIjpmaXJzdC1jaGlsZFwiKTtcbiAgY29uc3QgdXNlSHRtbExhYmVscyA9IGV2YWx1YXRlKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKTtcbiAgY29uc3QgbGFiZWwgPSBzaGFwZVN2Zy5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImNsdXN0ZXItbGFiZWxcIik7XG4gIGNvbnN0IHRleHQgPSBub2RlLmxhYmVsVHlwZSA9PT0gXCJtYXJrZG93blwiID8gY3JlYXRlVGV4dChsYWJlbCwgbm9kZS5sYWJlbFRleHQsIHsgc3R5bGU6IG5vZGUubGFiZWxTdHlsZSwgdXNlSHRtbExhYmVscyB9KSA6IGxhYmVsLm5vZGUoKS5hcHBlbmRDaGlsZChjcmVhdGVMYWJlbChub2RlLmxhYmVsVGV4dCwgbm9kZS5sYWJlbFN0eWxlLCB2b2lkIDAsIHRydWUpKTtcbiAgbGV0IGJib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgaWYgKGV2YWx1YXRlKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKSkge1xuICAgIGNvbnN0IGRpdiA9IHRleHQuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgZHYgPSBzZWxlY3QodGV4dCk7XG4gICAgYmJveCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBkdi5hdHRyKFwid2lkdGhcIiwgYmJveC53aWR0aCk7XG4gICAgZHYuYXR0cihcImhlaWdodFwiLCBiYm94LmhlaWdodCk7XG4gIH1cbiAgY29uc3QgcGFkZGluZyA9IDAgKiBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IGhhbGZQYWRkaW5nID0gcGFkZGluZyAvIDI7XG4gIGNvbnN0IHdpZHRoID0gbm9kZS53aWR0aCA8PSBiYm94LndpZHRoICsgcGFkZGluZyA/IGJib3gud2lkdGggKyBwYWRkaW5nIDogbm9kZS53aWR0aDtcbiAgaWYgKG5vZGUud2lkdGggPD0gYmJveC53aWR0aCArIHBhZGRpbmcpIHtcbiAgICBub2RlLmRpZmYgPSAoYmJveC53aWR0aCAtIG5vZGUud2lkdGgpIC8gMiAtIG5vZGUucGFkZGluZyAvIDI7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5kaWZmID0gLW5vZGUucGFkZGluZyAvIDI7XG4gIH1cbiAgbG9nLnRyYWNlKFwiRGF0YSBcIiwgbm9kZSwgSlNPTi5zdHJpbmdpZnkobm9kZSkpO1xuICByZWN0Mi5hdHRyKFwic3R5bGVcIiwgbm9kZS5zdHlsZSkuYXR0cihcInJ4XCIsIG5vZGUucngpLmF0dHIoXCJyeVwiLCBub2RlLnJ5KS5hdHRyKFwieFwiLCBub2RlLnggLSB3aWR0aCAvIDIpLmF0dHIoXCJ5XCIsIG5vZGUueSAtIG5vZGUuaGVpZ2h0IC8gMiAtIGhhbGZQYWRkaW5nKS5hdHRyKFwid2lkdGhcIiwgd2lkdGgpLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5oZWlnaHQgKyBwYWRkaW5nKTtcbiAgaWYgKHVzZUh0bWxMYWJlbHMpIHtcbiAgICBsYWJlbC5hdHRyKFxuICAgICAgXCJ0cmFuc2Zvcm1cIixcbiAgICAgIC8vIFRoaXMgcHV0cyB0aGUgbGFiYWwgb24gdG9wIG9mIHRoZSBib3ggaW5zdGVhZCBvZiBpbnNpZGUgaXRcbiAgICAgIFwidHJhbnNsYXRlKFwiICsgKG5vZGUueCAtIGJib3gud2lkdGggLyAyKSArIFwiLCBcIiArIChub2RlLnkgLSBub2RlLmhlaWdodCAvIDIpICsgXCIpXCJcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIGxhYmVsLmF0dHIoXG4gICAgICBcInRyYW5zZm9ybVwiLFxuICAgICAgLy8gVGhpcyBwdXRzIHRoZSBsYWJhbCBvbiB0b3Agb2YgdGhlIGJveCBpbnN0ZWFkIG9mIGluc2lkZSBpdFxuICAgICAgXCJ0cmFuc2xhdGUoXCIgKyBub2RlLnggKyBcIiwgXCIgKyAobm9kZS55IC0gbm9kZS5oZWlnaHQgLyAyKSArIFwiKVwiXG4gICAgKTtcbiAgfVxuICBjb25zdCByZWN0Qm94ID0gcmVjdDIubm9kZSgpLmdldEJCb3goKTtcbiAgbm9kZS53aWR0aCA9IHJlY3RCb3gud2lkdGg7XG4gIG5vZGUuaGVpZ2h0ID0gcmVjdEJveC5oZWlnaHQ7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0UmVjdChub2RlLCBwb2ludCk7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCBub3RlR3JvdXAgPSAocGFyZW50LCBub2RlKSA9PiB7XG4gIGNvbnN0IHNoYXBlU3ZnID0gcGFyZW50Lmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwibm90ZS1jbHVzdGVyXCIpLmF0dHIoXCJpZFwiLCBub2RlLmlkKTtcbiAgY29uc3QgcmVjdDIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICBjb25zdCBwYWRkaW5nID0gMCAqIG5vZGUucGFkZGluZztcbiAgY29uc3QgaGFsZlBhZGRpbmcgPSBwYWRkaW5nIC8gMjtcbiAgcmVjdDIuYXR0cihcInJ4XCIsIG5vZGUucngpLmF0dHIoXCJyeVwiLCBub2RlLnJ5KS5hdHRyKFwieFwiLCBub2RlLnggLSBub2RlLndpZHRoIC8gMiAtIGhhbGZQYWRkaW5nKS5hdHRyKFwieVwiLCBub2RlLnkgLSBub2RlLmhlaWdodCAvIDIgLSBoYWxmUGFkZGluZykuYXR0cihcIndpZHRoXCIsIG5vZGUud2lkdGggKyBwYWRkaW5nKS5hdHRyKFwiaGVpZ2h0XCIsIG5vZGUuaGVpZ2h0ICsgcGFkZGluZykuYXR0cihcImZpbGxcIiwgXCJub25lXCIpO1xuICBjb25zdCByZWN0Qm94ID0gcmVjdDIubm9kZSgpLmdldEJCb3goKTtcbiAgbm9kZS53aWR0aCA9IHJlY3RCb3gud2lkdGg7XG4gIG5vZGUuaGVpZ2h0ID0gcmVjdEJveC5oZWlnaHQ7XG4gIG5vZGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgICByZXR1cm4gaW50ZXJzZWN0UmVjdChub2RlLCBwb2ludCk7XG4gIH07XG4gIHJldHVybiBzaGFwZVN2Zztcbn07XG5jb25zdCByb3VuZGVkV2l0aFRpdGxlID0gKHBhcmVudCwgbm9kZSkgPT4ge1xuICBjb25zdCBzaGFwZVN2ZyA9IHBhcmVudC5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBub2RlLmNsYXNzZXMpLmF0dHIoXCJpZFwiLCBub2RlLmlkKTtcbiAgY29uc3QgcmVjdDIgPSBzaGFwZVN2Zy5pbnNlcnQoXCJyZWN0XCIsIFwiOmZpcnN0LWNoaWxkXCIpO1xuICBjb25zdCBsYWJlbCA9IHNoYXBlU3ZnLmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiY2x1c3Rlci1sYWJlbFwiKTtcbiAgY29uc3QgaW5uZXJSZWN0ID0gc2hhcGVTdmcuYXBwZW5kKFwicmVjdFwiKTtcbiAgY29uc3QgdGV4dCA9IGxhYmVsLm5vZGUoKS5hcHBlbmRDaGlsZChjcmVhdGVMYWJlbChub2RlLmxhYmVsVGV4dCwgbm9kZS5sYWJlbFN0eWxlLCB2b2lkIDAsIHRydWUpKTtcbiAgbGV0IGJib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgaWYgKGV2YWx1YXRlKGdldENvbmZpZygpLmZsb3djaGFydC5odG1sTGFiZWxzKSkge1xuICAgIGNvbnN0IGRpdiA9IHRleHQuY2hpbGRyZW5bMF07XG4gICAgY29uc3QgZHYgPSBzZWxlY3QodGV4dCk7XG4gICAgYmJveCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBkdi5hdHRyKFwid2lkdGhcIiwgYmJveC53aWR0aCk7XG4gICAgZHYuYXR0cihcImhlaWdodFwiLCBiYm94LmhlaWdodCk7XG4gIH1cbiAgYmJveCA9IHRleHQuZ2V0QkJveCgpO1xuICBjb25zdCBwYWRkaW5nID0gMCAqIG5vZGUucGFkZGluZztcbiAgY29uc3QgaGFsZlBhZGRpbmcgPSBwYWRkaW5nIC8gMjtcbiAgY29uc3Qgd2lkdGggPSBub2RlLndpZHRoIDw9IGJib3gud2lkdGggKyBub2RlLnBhZGRpbmcgPyBiYm94LndpZHRoICsgbm9kZS5wYWRkaW5nIDogbm9kZS53aWR0aDtcbiAgaWYgKG5vZGUud2lkdGggPD0gYmJveC53aWR0aCArIG5vZGUucGFkZGluZykge1xuICAgIG5vZGUuZGlmZiA9IChiYm94LndpZHRoICsgbm9kZS5wYWRkaW5nICogMCAtIG5vZGUud2lkdGgpIC8gMjtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmRpZmYgPSAtbm9kZS5wYWRkaW5nIC8gMjtcbiAgfVxuICByZWN0Mi5hdHRyKFwiY2xhc3NcIiwgXCJvdXRlclwiKS5hdHRyKFwieFwiLCBub2RlLnggLSB3aWR0aCAvIDIgLSBoYWxmUGFkZGluZykuYXR0cihcInlcIiwgbm9kZS55IC0gbm9kZS5oZWlnaHQgLyAyIC0gaGFsZlBhZGRpbmcpLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIHBhZGRpbmcpLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5oZWlnaHQgKyBwYWRkaW5nKTtcbiAgaW5uZXJSZWN0LmF0dHIoXCJjbGFzc1wiLCBcImlubmVyXCIpLmF0dHIoXCJ4XCIsIG5vZGUueCAtIHdpZHRoIC8gMiAtIGhhbGZQYWRkaW5nKS5hdHRyKFwieVwiLCBub2RlLnkgLSBub2RlLmhlaWdodCAvIDIgLSBoYWxmUGFkZGluZyArIGJib3guaGVpZ2h0IC0gMSkuYXR0cihcIndpZHRoXCIsIHdpZHRoICsgcGFkZGluZykuYXR0cihcImhlaWdodFwiLCBub2RlLmhlaWdodCArIHBhZGRpbmcgLSBiYm94LmhlaWdodCAtIDMpO1xuICBsYWJlbC5hdHRyKFxuICAgIFwidHJhbnNmb3JtXCIsXG4gICAgXCJ0cmFuc2xhdGUoXCIgKyAobm9kZS54IC0gYmJveC53aWR0aCAvIDIpICsgXCIsIFwiICsgKG5vZGUueSAtIG5vZGUuaGVpZ2h0IC8gMiAtIG5vZGUucGFkZGluZyAvIDMgKyAoZXZhbHVhdGUoZ2V0Q29uZmlnKCkuZmxvd2NoYXJ0Lmh0bWxMYWJlbHMpID8gNSA6IDMpKSArIFwiKVwiXG4gICk7XG4gIGNvbnN0IHJlY3RCb3ggPSByZWN0Mi5ub2RlKCkuZ2V0QkJveCgpO1xuICBub2RlLmhlaWdodCA9IHJlY3RCb3guaGVpZ2h0O1xuICBub2RlLmludGVyc2VjdCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgcmV0dXJuIGludGVyc2VjdFJlY3Qobm9kZSwgcG9pbnQpO1xuICB9O1xuICByZXR1cm4gc2hhcGVTdmc7XG59O1xuY29uc3QgZGl2aWRlciA9IChwYXJlbnQsIG5vZGUpID0+IHtcbiAgY29uc3Qgc2hhcGVTdmcgPSBwYXJlbnQuaW5zZXJ0KFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgbm9kZS5jbGFzc2VzKS5hdHRyKFwiaWRcIiwgbm9kZS5pZCk7XG4gIGNvbnN0IHJlY3QyID0gc2hhcGVTdmcuaW5zZXJ0KFwicmVjdFwiLCBcIjpmaXJzdC1jaGlsZFwiKTtcbiAgY29uc3QgcGFkZGluZyA9IDAgKiBub2RlLnBhZGRpbmc7XG4gIGNvbnN0IGhhbGZQYWRkaW5nID0gcGFkZGluZyAvIDI7XG4gIHJlY3QyLmF0dHIoXCJjbGFzc1wiLCBcImRpdmlkZXJcIikuYXR0cihcInhcIiwgbm9kZS54IC0gbm9kZS53aWR0aCAvIDIgLSBoYWxmUGFkZGluZykuYXR0cihcInlcIiwgbm9kZS55IC0gbm9kZS5oZWlnaHQgLyAyKS5hdHRyKFwid2lkdGhcIiwgbm9kZS53aWR0aCArIHBhZGRpbmcpLmF0dHIoXCJoZWlnaHRcIiwgbm9kZS5oZWlnaHQgKyBwYWRkaW5nKTtcbiAgY29uc3QgcmVjdEJveCA9IHJlY3QyLm5vZGUoKS5nZXRCQm94KCk7XG4gIG5vZGUud2lkdGggPSByZWN0Qm94LndpZHRoO1xuICBub2RlLmhlaWdodCA9IHJlY3RCb3guaGVpZ2h0O1xuICBub2RlLmRpZmYgPSAtbm9kZS5wYWRkaW5nIC8gMjtcbiAgbm9kZS5pbnRlcnNlY3QgPSBmdW5jdGlvbihwb2ludCkge1xuICAgIHJldHVybiBpbnRlcnNlY3RSZWN0KG5vZGUsIHBvaW50KTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlU3ZnO1xufTtcbmNvbnN0IHNoYXBlcyA9IHsgcmVjdCwgcm91bmRlZFdpdGhUaXRsZSwgbm90ZUdyb3VwLCBkaXZpZGVyIH07XG5sZXQgY2x1c3RlckVsZW1zID0ge307XG5jb25zdCBpbnNlcnRDbHVzdGVyID0gKGVsZW0sIG5vZGUpID0+IHtcbiAgbG9nLnRyYWNlKFwiSW5zZXJ0aW5nIGNsdXN0ZXJcIik7XG4gIGNvbnN0IHNoYXBlID0gbm9kZS5zaGFwZSB8fCBcInJlY3RcIjtcbiAgY2x1c3RlckVsZW1zW25vZGUuaWRdID0gc2hhcGVzW3NoYXBlXShlbGVtLCBub2RlKTtcbn07XG5jb25zdCBjbGVhciA9ICgpID0+IHtcbiAgY2x1c3RlckVsZW1zID0ge307XG59O1xuY29uc3QgcmVjdXJzaXZlUmVuZGVyID0gYXN5bmMgKF9lbGVtLCBncmFwaCwgZGlhZ3JhbXR5cGUsIGlkLCBwYXJlbnRDbHVzdGVyKSA9PiB7XG4gIGxvZy5pbmZvKFwiR3JhcGggaW4gcmVjdXJzaXZlIHJlbmRlcjogWFhYXCIsIGdyYXBobGliSnNvbi53cml0ZShncmFwaCksIHBhcmVudENsdXN0ZXIpO1xuICBjb25zdCBkaXIgPSBncmFwaC5ncmFwaCgpLnJhbmtkaXI7XG4gIGxvZy50cmFjZShcIkRpciBpbiByZWN1cnNpdmUgcmVuZGVyIC0gZGlyOlwiLCBkaXIpO1xuICBjb25zdCBlbGVtID0gX2VsZW0uaW5zZXJ0KFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJyb290XCIpO1xuICBpZiAoIWdyYXBoLm5vZGVzKCkpIHtcbiAgICBsb2cuaW5mbyhcIk5vIG5vZGVzIGZvdW5kIGZvclwiLCBncmFwaCk7XG4gIH0gZWxzZSB7XG4gICAgbG9nLmluZm8oXCJSZWN1cnNpdmUgcmVuZGVyIFhYWFwiLCBncmFwaC5ub2RlcygpKTtcbiAgfVxuICBpZiAoZ3JhcGguZWRnZXMoKS5sZW5ndGggPiAwKSB7XG4gICAgbG9nLnRyYWNlKFwiUmVjdXJzaXZlIGVkZ2VzXCIsIGdyYXBoLmVkZ2UoZ3JhcGguZWRnZXMoKVswXSkpO1xuICB9XG4gIGNvbnN0IGNsdXN0ZXJzID0gZWxlbS5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImNsdXN0ZXJzXCIpO1xuICBjb25zdCBlZGdlUGF0aHMgPSBlbGVtLmluc2VydChcImdcIikuYXR0cihcImNsYXNzXCIsIFwiZWRnZVBhdGhzXCIpO1xuICBjb25zdCBlZGdlTGFiZWxzID0gZWxlbS5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcImVkZ2VMYWJlbHNcIik7XG4gIGNvbnN0IG5vZGVzID0gZWxlbS5pbnNlcnQoXCJnXCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGVzXCIpO1xuICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBncmFwaC5ub2RlcygpLm1hcChhc3luYyBmdW5jdGlvbih2KSB7XG4gICAgICBjb25zdCBub2RlID0gZ3JhcGgubm9kZSh2KTtcbiAgICAgIGlmIChwYXJlbnRDbHVzdGVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocGFyZW50Q2x1c3Rlci5jbHVzdGVyRGF0YSkpO1xuICAgICAgICBsb2cuaW5mbyhcIlNldHRpbmcgZGF0YSBmb3IgY2x1c3RlciBYWFggKFwiLCB2LCBcIikgXCIsIGRhdGEsIHBhcmVudENsdXN0ZXIpO1xuICAgICAgICBncmFwaC5zZXROb2RlKHBhcmVudENsdXN0ZXIuaWQsIGRhdGEpO1xuICAgICAgICBpZiAoIWdyYXBoLnBhcmVudCh2KSkge1xuICAgICAgICAgIGxvZy50cmFjZShcIlNldHRpbmcgcGFyZW50XCIsIHYsIHBhcmVudENsdXN0ZXIuaWQpO1xuICAgICAgICAgIGdyYXBoLnNldFBhcmVudCh2LCBwYXJlbnRDbHVzdGVyLmlkLCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbG9nLmluZm8oXCIoSW5zZXJ0KSBOb2RlIFhYWFwiICsgdiArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KGdyYXBoLm5vZGUodikpKTtcbiAgICAgIGlmIChub2RlICYmIG5vZGUuY2x1c3Rlck5vZGUpIHtcbiAgICAgICAgbG9nLmluZm8oXCJDbHVzdGVyIGlkZW50aWZpZWRcIiwgdiwgbm9kZS53aWR0aCwgZ3JhcGgubm9kZSh2KSk7XG4gICAgICAgIGNvbnN0IG8gPSBhd2FpdCByZWN1cnNpdmVSZW5kZXIobm9kZXMsIG5vZGUuZ3JhcGgsIGRpYWdyYW10eXBlLCBpZCwgZ3JhcGgubm9kZSh2KSk7XG4gICAgICAgIGNvbnN0IG5ld0VsID0gby5lbGVtO1xuICAgICAgICB1cGRhdGVOb2RlQm91bmRzKG5vZGUsIG5ld0VsKTtcbiAgICAgICAgbm9kZS5kaWZmID0gby5kaWZmIHx8IDA7XG4gICAgICAgIGxvZy5pbmZvKFwiTm9kZSBib3VuZHMgKGFiYzEyMylcIiwgdiwgbm9kZSwgbm9kZS53aWR0aCwgbm9kZS54LCBub2RlLnkpO1xuICAgICAgICBzZXROb2RlRWxlbShuZXdFbCwgbm9kZSk7XG4gICAgICAgIGxvZy53YXJuKFwiUmVjdXJzaXZlIHJlbmRlciBjb21wbGV0ZSBcIiwgbmV3RWwsIG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdyYXBoLmNoaWxkcmVuKHYpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsb2cuaW5mbyhcIkNsdXN0ZXIgLSB0aGUgbm9uIHJlY3Vyc2l2ZSBwYXRoIFhYWFwiLCB2LCBub2RlLmlkLCBub2RlLCBncmFwaCk7XG4gICAgICAgICAgbG9nLmluZm8oZmluZE5vbkNsdXN0ZXJDaGlsZChub2RlLmlkLCBncmFwaCkpO1xuICAgICAgICAgIGNsdXN0ZXJEYltub2RlLmlkXSA9IHsgaWQ6IGZpbmROb25DbHVzdGVyQ2hpbGQobm9kZS5pZCwgZ3JhcGgpLCBub2RlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nLmluZm8oXCJOb2RlIC0gdGhlIG5vbiByZWN1cnNpdmUgcGF0aFwiLCB2LCBub2RlLmlkLCBub2RlKTtcbiAgICAgICAgICBhd2FpdCBpbnNlcnROb2RlKG5vZGVzLCBncmFwaC5ub2RlKHYpLCBkaXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgKTtcbiAgZ3JhcGguZWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zdCBlZGdlID0gZ3JhcGguZWRnZShlLnYsIGUudywgZS5uYW1lKTtcbiAgICBsb2cuaW5mbyhcIkVkZ2UgXCIgKyBlLnYgKyBcIiAtPiBcIiArIGUudyArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICBsb2cuaW5mbyhcIkVkZ2UgXCIgKyBlLnYgKyBcIiAtPiBcIiArIGUudyArIFwiOiBcIiwgZSwgXCIgXCIsIEpTT04uc3RyaW5naWZ5KGdyYXBoLmVkZ2UoZSkpKTtcbiAgICBsb2cuaW5mbyhcIkZpeFwiLCBjbHVzdGVyRGIsIFwiaWRzOlwiLCBlLnYsIGUudywgXCJUcmFuc2xhdGVpbmc6IFwiLCBjbHVzdGVyRGJbZS52XSwgY2x1c3RlckRiW2Uud10pO1xuICAgIGluc2VydEVkZ2VMYWJlbChlZGdlTGFiZWxzLCBlZGdlKTtcbiAgfSk7XG4gIGdyYXBoLmVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgbG9nLmluZm8oXCJFZGdlIFwiICsgZS52ICsgXCIgLT4gXCIgKyBlLncgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShlKSk7XG4gIH0pO1xuICBsb2cuaW5mbyhcIiMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1wiKTtcbiAgbG9nLmluZm8oXCIjIyMgICAgICAgICAgICAgICAgTGF5b3V0ICAgICAgICAgICAgICAgICAjIyNcIik7XG4gIGxvZy5pbmZvKFwiIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXCIpO1xuICBsb2cuaW5mbyhncmFwaCk7XG4gIGxheW91dChncmFwaCk7XG4gIGxvZy5pbmZvKFwiR3JhcGggYWZ0ZXIgbGF5b3V0OlwiLCBncmFwaGxpYkpzb24ud3JpdGUoZ3JhcGgpKTtcbiAgbGV0IGRpZmYgPSAwO1xuICBzb3J0Tm9kZXNCeUhpZXJhcmNoeShncmFwaCkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgY29uc3Qgbm9kZSA9IGdyYXBoLm5vZGUodik7XG4gICAgbG9nLmluZm8oXCJQb3NpdGlvbiBcIiArIHYgKyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeShncmFwaC5ub2RlKHYpKSk7XG4gICAgbG9nLmluZm8oXG4gICAgICBcIlBvc2l0aW9uIFwiICsgdiArIFwiOiAoXCIgKyBub2RlLngsXG4gICAgICBcIixcIiArIG5vZGUueSxcbiAgICAgIFwiKSB3aWR0aDogXCIsXG4gICAgICBub2RlLndpZHRoLFxuICAgICAgXCIgaGVpZ2h0OiBcIixcbiAgICAgIG5vZGUuaGVpZ2h0XG4gICAgKTtcbiAgICBpZiAobm9kZSAmJiBub2RlLmNsdXN0ZXJOb2RlKSB7XG4gICAgICBwb3NpdGlvbk5vZGUobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChncmFwaC5jaGlsZHJlbih2KS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGluc2VydENsdXN0ZXIoY2x1c3RlcnMsIG5vZGUpO1xuICAgICAgICBjbHVzdGVyRGJbbm9kZS5pZF0ubm9kZSA9IG5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3NpdGlvbk5vZGUobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZ3JhcGguZWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICBjb25zdCBlZGdlID0gZ3JhcGguZWRnZShlKTtcbiAgICBsb2cuaW5mbyhcIkVkZ2UgXCIgKyBlLnYgKyBcIiAtPiBcIiArIGUudyArIFwiOiBcIiArIEpTT04uc3RyaW5naWZ5KGVkZ2UpLCBlZGdlKTtcbiAgICBjb25zdCBwYXRocyA9IGluc2VydEVkZ2UoZWRnZVBhdGhzLCBlLCBlZGdlLCBjbHVzdGVyRGIsIGRpYWdyYW10eXBlLCBncmFwaCwgaWQpO1xuICAgIHBvc2l0aW9uRWRnZUxhYmVsKGVkZ2UsIHBhdGhzKTtcbiAgfSk7XG4gIGdyYXBoLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgY29uc3QgbiA9IGdyYXBoLm5vZGUodik7XG4gICAgbG9nLmluZm8odiwgbi50eXBlLCBuLmRpZmYpO1xuICAgIGlmIChuLnR5cGUgPT09IFwiZ3JvdXBcIikge1xuICAgICAgZGlmZiA9IG4uZGlmZjtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4geyBlbGVtLCBkaWZmIH07XG59O1xuY29uc3QgcmVuZGVyID0gYXN5bmMgKGVsZW0sIGdyYXBoLCBtYXJrZXJzLCBkaWFncmFtdHlwZSwgaWQpID0+IHtcbiAgaW5zZXJ0TWFya2VycyhlbGVtLCBtYXJrZXJzLCBkaWFncmFtdHlwZSwgaWQpO1xuICBjbGVhciQyKCk7XG4gIGNsZWFyJDMoKTtcbiAgY2xlYXIoKTtcbiAgY2xlYXIkMSgpO1xuICBsb2cud2FybihcIkdyYXBoIGF0IGZpcnN0OlwiLCBKU09OLnN0cmluZ2lmeShncmFwaGxpYkpzb24ud3JpdGUoZ3JhcGgpKSk7XG4gIGFkanVzdENsdXN0ZXJzQW5kRWRnZXMoZ3JhcGgpO1xuICBsb2cud2FybihcIkdyYXBoIGFmdGVyOlwiLCBKU09OLnN0cmluZ2lmeShncmFwaGxpYkpzb24ud3JpdGUoZ3JhcGgpKSk7XG4gIGF3YWl0IHJlY3Vyc2l2ZVJlbmRlcihlbGVtLCBncmFwaCwgZGlhZ3JhbXR5cGUsIGlkKTtcbn07XG5leHBvcnQge1xuICByZW5kZXIgYXMgclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==