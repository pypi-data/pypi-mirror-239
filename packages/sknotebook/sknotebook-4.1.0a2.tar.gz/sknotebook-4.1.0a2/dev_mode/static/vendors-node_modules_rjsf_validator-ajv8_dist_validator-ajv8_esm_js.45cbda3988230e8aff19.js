"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_rjsf_validator-ajv8_dist_validator-ajv8_esm_js"],{

/***/ "../node_modules/@rjsf/validator-ajv8/dist/validator-ajv8.esm.js":
/*!***********************************************************************!*\
  !*** ../node_modules/@rjsf/validator-ajv8/dist/validator-ajv8.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "customizeValidator": () => (/* binding */ customizeValidator),
/* harmony export */   "default": () => (/* binding */ index)
/* harmony export */ });
/* harmony import */ var lodash_es_toPath__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es/toPath */ "../node_modules/lodash-es/toPath.js");
/* harmony import */ var lodash_es_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es/isObject */ "../node_modules/lodash-es/isObject.js");
/* harmony import */ var lodash_es_clone__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es/clone */ "../node_modules/lodash-es/clone.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_es_get__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es/get */ "../node_modules/lodash-es/get.js");
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ajv */ "../node_modules/ajv/dist/ajv.js");
/* harmony import */ var ajv__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ajv__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var ajv_formats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ajv-formats */ "../node_modules/ajv-formats/dist/index.js");
/* harmony import */ var ajv_formats__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ajv_formats__WEBPACK_IMPORTED_MODULE_2__);








function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}

var AJV_CONFIG = {
  allErrors: true,
  multipleOfPrecision: 8,
  strict: false,
  verbose: true
};
var COLOR_FORMAT_REGEX = /^(#?([0-9A-Fa-f]{3}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\)))$/;
var DATA_URL_FORMAT_REGEX = /^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/;
/** Creates an Ajv version 8 implementation object with standard support for the 'color` and `data-url` custom formats.
 * If `additionalMetaSchemas` are provided then the Ajv instance is modified to add each of the meta schemas in the
 * list. If `customFormats` are provided then those additional formats are added to the list of supported formats. If
 * `ajvOptionsOverrides` are provided then they are spread on top of the default `AJV_CONFIG` options when constructing
 * the `Ajv` instance. With Ajv v8, the JSON Schema formats are not provided by default, but can be plugged in. By
 * default, all formats from the `ajv-formats` library are added. To disable this capability, set the `ajvFormatOptions`
 * parameter to `false`. Additionally, you can configure the `ajv-formats` by providing a custom set of
 * [format options](https://github.com/ajv-validator/ajv-formats) to the `ajvFormatOptions` parameter.
 *
 * @param [additionalMetaSchemas] - The list of additional meta schemas that the validator can access
 * @param [customFormats] - The set of additional custom formats that the validator will support
 * @param [ajvOptionsOverrides={}] - The set of validator config override options
 * @param [ajvFormatOptions] - The `ajv-format` options to use when adding formats to `ajv`; pass `false` to disable it
 * @param [AjvClass] - The `Ajv` class to use when creating the validator instance
 */
function createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass) {
  if (ajvOptionsOverrides === void 0) {
    ajvOptionsOverrides = {};
  }
  if (AjvClass === void 0) {
    AjvClass = (ajv__WEBPACK_IMPORTED_MODULE_1___default());
  }
  var ajv = new AjvClass(_extends({}, AJV_CONFIG, ajvOptionsOverrides));
  if (ajvFormatOptions) {
    ajv_formats__WEBPACK_IMPORTED_MODULE_2___default()(ajv, ajvFormatOptions);
  } else if (ajvFormatOptions !== false) {
    ajv_formats__WEBPACK_IMPORTED_MODULE_2___default()(ajv);
  }
  // add custom formats
  ajv.addFormat('data-url', DATA_URL_FORMAT_REGEX);
  ajv.addFormat('color', COLOR_FORMAT_REGEX);
  // Add RJSF-specific additional properties keywords so Ajv doesn't report errors if strict is enabled.
  ajv.addKeyword(_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ADDITIONAL_PROPERTY_FLAG);
  ajv.addKeyword(_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.RJSF_ADDITONAL_PROPERTIES_FLAG);
  // add more schemas to validate against
  if (Array.isArray(additionalMetaSchemas)) {
    ajv.addMetaSchema(additionalMetaSchemas);
  }
  // add more custom formats to validate against
  if ((0,lodash_es_isObject__WEBPACK_IMPORTED_MODULE_3__["default"])(customFormats)) {
    Object.keys(customFormats).forEach(function (formatName) {
      ajv.addFormat(formatName, customFormats[formatName]);
    });
  }
  return ajv;
}

var _excluded = ["instancePath", "keyword", "params", "schemaPath", "parentSchema"];
var ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';
/** `ValidatorType` implementation that uses the AJV 8 validation mechanism.
 */
var AJV8Validator = /*#__PURE__*/function () {
  /** The AJV instance to use for all validations
   *
   * @private
   */

  /** The Localizer function to use for localizing Ajv errors
   *
   * @private
   */

  /** Constructs an `AJV8Validator` instance using the `options`
   *
   * @param options - The `CustomValidatorOptionsType` options that are used to create the AJV instance
   * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
   */
  function AJV8Validator(options, localizer) {
    this.ajv = void 0;
    this.localizer = void 0;
    var additionalMetaSchemas = options.additionalMetaSchemas,
      customFormats = options.customFormats,
      ajvOptionsOverrides = options.ajvOptionsOverrides,
      ajvFormatOptions = options.ajvFormatOptions,
      AjvClass = options.AjvClass;
    this.ajv = createAjvInstance(additionalMetaSchemas, customFormats, ajvOptionsOverrides, ajvFormatOptions, AjvClass);
    this.localizer = localizer;
  }
  /** Transforms a ajv validation errors list:
   * [
   *   {property: '.level1.level2[2].level3', message: 'err a'},
   *   {property: '.level1.level2[2].level3', message: 'err b'},
   *   {property: '.level1.level2[4].level3', message: 'err b'},
   * ]
   * Into an error tree:
   * {
   *   level1: {
   *     level2: {
   *       2: {level3: {errors: ['err a', 'err b']}},
   *       4: {level3: {errors: ['err b']}},
   *     }
   *   }
   * };
   *
   * @param errors - The list of RJSFValidationError objects
   * @private
   */
  var _proto = AJV8Validator.prototype;
  _proto.toErrorSchema = function toErrorSchema(errors) {
    var builder = new _rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ErrorSchemaBuilder();
    if (errors.length) {
      errors.forEach(function (error) {
        var property = error.property,
          message = error.message;
        var path = (0,lodash_es_toPath__WEBPACK_IMPORTED_MODULE_4__["default"])(property);
        // If the property is at the root (.level1) then toPath creates
        // an empty array element at the first index. Remove it.
        if (path.length > 0 && path[0] === '') {
          path.splice(0, 1);
        }
        if (message) {
          builder.addErrors(message, path);
        }
      });
    }
    return builder.ErrorSchema;
  }
  /** Converts an `errorSchema` into a list of `RJSFValidationErrors`
   *
   * @param errorSchema - The `ErrorSchema` instance to convert
   * @param [fieldPath=[]] - The current field path, defaults to [] if not specified
   */;
  _proto.toErrorList = function toErrorList(errorSchema, fieldPath) {
    var _this = this;
    if (fieldPath === void 0) {
      fieldPath = [];
    }
    if (!errorSchema) {
      return [];
    }
    var errorList = [];
    if (_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ERRORS_KEY in errorSchema) {
      errorList = errorList.concat(errorSchema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ERRORS_KEY].map(function (message) {
        var property = "." + fieldPath.join('.');
        return {
          property: property,
          message: message,
          stack: property + " " + message
        };
      }));
    }
    return Object.keys(errorSchema).reduce(function (acc, key) {
      if (key !== _rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ERRORS_KEY) {
        acc = acc.concat(_this.toErrorList(errorSchema[key], [].concat(fieldPath, [key])));
      }
      return acc;
    }, errorList);
  }
  /** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it
   *
   * @param formData - The form data around which the error handler is created
   * @private
   */;
  _proto.createErrorHandler = function createErrorHandler(formData) {
    var _this2 = this;
    var handler = {
      // We store the list of errors for this node in a property named __errors
      // to avoid name collision with a possible sub schema field named
      // 'errors' (see `utils.toErrorSchema`).
      __errors: [],
      addError: function addError(message) {
        this.__errors.push(message);
      }
    };
    if (Array.isArray(formData)) {
      return formData.reduce(function (acc, value, key) {
        var _extends2;
        return _extends({}, acc, (_extends2 = {}, _extends2[key] = _this2.createErrorHandler(value), _extends2));
      }, handler);
    }
    if ((0,lodash_es_isObject__WEBPACK_IMPORTED_MODULE_3__["default"])(formData)) {
      var formObject = formData;
      return Object.keys(formObject).reduce(function (acc, key) {
        var _extends3;
        return _extends({}, acc, (_extends3 = {}, _extends3[key] = _this2.createErrorHandler(formObject[key]), _extends3));
      }, handler);
    }
    return handler;
  }
  /** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError` functions from it
   *
   * @param errorHandler - The `FormValidation` error handling structure
   * @private
   */;
  _proto.unwrapErrorHandler = function unwrapErrorHandler(errorHandler) {
    var _this3 = this;
    return Object.keys(errorHandler).reduce(function (acc, key) {
      var _extends5;
      if (key === 'addError') {
        return acc;
      } else if (key === _rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.ERRORS_KEY) {
        var _extends4;
        return _extends({}, acc, (_extends4 = {}, _extends4[key] = errorHandler[key], _extends4));
      }
      return _extends({}, acc, (_extends5 = {}, _extends5[key] = _this3.unwrapErrorHandler(errorHandler[key]), _extends5));
    }, {});
  }
  /** Transforming the error output from ajv to format used by @rjsf/utils.
   * At some point, components should be updated to support ajv.
   *
   * @param errors - The list of AJV errors to convert to `RJSFValidationErrors`
   * @protected
   */;
  _proto.transformRJSFValidationErrors = function transformRJSFValidationErrors(errors, uiSchema) {
    if (errors === void 0) {
      errors = [];
    }
    return errors.map(function (e) {
      var instancePath = e.instancePath,
        keyword = e.keyword,
        params = e.params,
        schemaPath = e.schemaPath,
        parentSchema = e.parentSchema,
        rest = _objectWithoutPropertiesLoose(e, _excluded);
      var _rest$message = rest.message,
        message = _rest$message === void 0 ? '' : _rest$message;
      var property = instancePath.replace(/\//g, '.');
      var stack = (property + " " + message).trim();
      if ('missingProperty' in params) {
        property = property ? property + "." + params.missingProperty : params.missingProperty;
        var currentProperty = params.missingProperty;
        var uiSchemaTitle = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.getUiOptions)((0,lodash_es_get__WEBPACK_IMPORTED_MODULE_5__["default"])(uiSchema, "" + property.replace(/^\./, ''))).title;
        if (uiSchemaTitle) {
          message = message.replace(currentProperty, uiSchemaTitle);
        } else {
          var parentSchemaTitle = (0,lodash_es_get__WEBPACK_IMPORTED_MODULE_5__["default"])(parentSchema, [_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.PROPERTIES_KEY, currentProperty, 'title']);
          if (parentSchemaTitle) {
            message = message.replace(currentProperty, parentSchemaTitle);
          }
        }
        stack = message;
      } else {
        var _uiSchemaTitle = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.getUiOptions)((0,lodash_es_get__WEBPACK_IMPORTED_MODULE_5__["default"])(uiSchema, "" + property.replace(/^\./, ''))).title;
        if (_uiSchemaTitle) {
          stack = ("'" + _uiSchemaTitle + "' " + message).trim();
        } else {
          var _parentSchemaTitle = parentSchema === null || parentSchema === void 0 ? void 0 : parentSchema.title;
          if (_parentSchemaTitle) {
            stack = ("'" + _parentSchemaTitle + "' " + message).trim();
          }
        }
      }
      // put data in expected format
      return {
        name: keyword,
        property: property,
        message: message,
        params: params,
        stack: stack,
        schemaPath: schemaPath
      };
    });
  }
  /** Runs the pure validation of the `schema` and `formData` without any of the RJSF functionality. Provided for use
   * by the playground. Returns the `errors` from the validation
   *
   * @param schema - The schema against which to validate the form data   * @param schema
   * @param formData - The form data to validate
   */;
  _proto.rawValidation = function rawValidation(schema, formData) {
    var compilationError = undefined;
    var compiledValidator;
    if (schema['$id']) {
      compiledValidator = this.ajv.getSchema(schema['$id']);
    }
    try {
      if (compiledValidator === undefined) {
        compiledValidator = this.ajv.compile(schema);
      }
      compiledValidator(formData);
    } catch (err) {
      compilationError = err;
    }
    var errors;
    if (compiledValidator) {
      if (typeof this.localizer === 'function') {
        this.localizer(compiledValidator.errors);
      }
      errors = compiledValidator.errors || undefined;
      // Clear errors to prevent persistent errors, see #1104
      compiledValidator.errors = null;
    }
    return {
      errors: errors,
      validationError: compilationError
    };
  }
  /** This function processes the `formData` with an optional user contributed `customValidate` function, which receives
   * the form data and a `errorHandler` function that will be used to add custom validation errors for each field. Also
   * supports a `transformErrors` function that will take the raw AJV validation errors, prior to custom validation and
   * transform them in what ever way it chooses.
   *
   * @param formData - The form data to validate
   * @param schema - The schema against which to validate the form data
   * @param [customValidate] - An optional function that is used to perform custom validation
   * @param [transformErrors] - An optional function that is used to transform errors after AJV validation
   * @param [uiSchema] - An optional uiSchema that is passed to `transformErrors` and `customValidate`
   */;
  _proto.validateFormData = function validateFormData(formData, schema, customValidate, transformErrors, uiSchema) {
    var rawErrors = this.rawValidation(schema, formData);
    var invalidSchemaError = rawErrors.validationError;
    var errors = this.transformRJSFValidationErrors(rawErrors.errors, uiSchema);
    if (invalidSchemaError) {
      errors = [].concat(errors, [{
        stack: invalidSchemaError.message
      }]);
    }
    if (typeof transformErrors === 'function') {
      errors = transformErrors(errors, uiSchema);
    }
    var errorSchema = this.toErrorSchema(errors);
    if (invalidSchemaError) {
      errorSchema = _extends({}, errorSchema, {
        $schema: {
          __errors: [invalidSchemaError.message]
        }
      });
    }
    if (typeof customValidate !== 'function') {
      return {
        errors: errors,
        errorSchema: errorSchema
      };
    }
    // Include form data with undefined values, which is required for custom validation.
    var newFormData = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.getDefaultFormState)(this, schema, formData, schema, true);
    var errorHandler = customValidate(newFormData, this.createErrorHandler(newFormData), uiSchema);
    var userErrorSchema = this.unwrapErrorHandler(errorHandler);
    return (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.mergeValidationData)(this, {
      errors: errors,
      errorSchema: errorSchema
    }, userErrorSchema);
  }
  /** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling
   * `withIdRefPrefix` for any other elements.
   *
   * @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it
   * @private
   */;
  _proto.withIdRefPrefixObject = function withIdRefPrefixObject(node) {
    for (var key in node) {
      var realObj = node;
      var value = realObj[key];
      if (key === _rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.REF_KEY && typeof value === 'string' && value.startsWith('#')) {
        realObj[key] = ROOT_SCHEMA_PREFIX + value;
      } else {
        realObj[key] = this.withIdRefPrefix(value);
      }
    }
    return node;
  }
  /** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling
   * `withIdRefPrefix` for any other elements.
   *
   * @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it
   * @private
   */;
  _proto.withIdRefPrefixArray = function withIdRefPrefixArray(node) {
    for (var i = 0; i < node.length; i++) {
      node[i] = this.withIdRefPrefix(node[i]);
    }
    return node;
  }
  /** Validates data against a schema, returning true if the data is valid, or
   * false otherwise. If the schema is invalid, then this function will return
   * false.
   *
   * @param schema - The schema against which to validate the form data
   * @param formData - The form data to validate
   * @param rootSchema - The root schema used to provide $ref resolutions
   */;
  _proto.isValid = function isValid(schema, formData, rootSchema) {
    var _rootSchema$$id;
    var rootSchemaId = (_rootSchema$$id = rootSchema['$id']) != null ? _rootSchema$$id : ROOT_SCHEMA_PREFIX;
    try {
      // add the rootSchema ROOT_SCHEMA_PREFIX as id.
      // then rewrite the schema ref's to point to the rootSchema
      // this accounts for the case where schema have references to models
      // that lives in the rootSchema but not in the schema in question.
      if (this.ajv.getSchema(rootSchemaId) === undefined) {
        this.ajv.addSchema(rootSchema, rootSchemaId);
      }
      var schemaWithIdRefPrefix = this.withIdRefPrefix(schema);
      var compiledValidator;
      if (schemaWithIdRefPrefix['$id']) {
        compiledValidator = this.ajv.getSchema(schemaWithIdRefPrefix['$id']);
      }
      if (compiledValidator === undefined) {
        compiledValidator = this.ajv.compile(schemaWithIdRefPrefix);
      }
      var result = compiledValidator(formData);
      return result;
    } catch (e) {
      console.warn('Error encountered compiling schema:', e);
      return false;
    } finally {
      // TODO: A function should be called if the root schema changes so we don't have to remove and recompile the schema every run.
      // make sure we remove the rootSchema from the global ajv instance
      this.ajv.removeSchema(rootSchemaId);
    }
  }
  /** Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`
   * This is used in isValid to make references to the rootSchema
   *
   * @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it
   * @protected
   */;
  _proto.withIdRefPrefix = function withIdRefPrefix(schemaNode) {
    if (Array.isArray(schemaNode)) {
      return this.withIdRefPrefixArray([].concat(schemaNode));
    }
    if ((0,lodash_es_isObject__WEBPACK_IMPORTED_MODULE_3__["default"])(schemaNode)) {
      return this.withIdRefPrefixObject((0,lodash_es_clone__WEBPACK_IMPORTED_MODULE_6__["default"])(schemaNode));
    }
    return schemaNode;
  };
  return AJV8Validator;
}();

/** Creates and returns a customized implementation of the `ValidatorType` with the given customization `options` if
 * provided.
 *
 * @param [options={}] - The `CustomValidatorOptionsType` options that are used to create the `ValidatorType` instance
 * @param [localizer] - If provided, is used to localize a list of Ajv `ErrorObject`s
 */
function customizeValidator(options, localizer) {
  if (options === void 0) {
    options = {};
  }
  return new AJV8Validator(options, localizer);
}

var index = /*#__PURE__*/customizeValidator();


//# sourceMappingURL=validator-ajv8.esm.js.map


/***/ }),

/***/ "../node_modules/ajv-formats/dist/formats.js":
/*!***************************************************!*\
  !*** ../node_modules/ajv-formats/dist/formats.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
function fmtDef(validate, compare) {
    return { validate, compare };
}
exports.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: { type: "number", validate: validateInt32 },
    // signed 64 bit integer
    int64: { type: "number", validate: validateInt64 },
    // C-type float
    float: { type: "number", validate: validateNumber },
    // C-type double
    double: { type: "number", validate: validateNumber },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true,
};
exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
};
exports.formatNames = Object.keys(exports.fullFormats);
function isLeapYear(year) {
    // https://tools.ietf.org/html/rfc3339#appendix-C
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
const DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date(str) {
    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
    const matches = DATE.exec(str);
    if (!matches)
        return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return (month >= 1 &&
        month <= 12 &&
        day >= 1 &&
        day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]));
}
function compareDate(d1, d2) {
    if (!(d1 && d2))
        return undefined;
    if (d1 > d2)
        return 1;
    if (d1 < d2)
        return -1;
    return 0;
}
const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches)
        return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (((hour <= 23 && minute <= 59 && second <= 59) ||
        (hour === 23 && minute === 59 && second === 60)) &&
        (!withTimeZone || timeZone !== ""));
}
function compareTime(t1, t2) {
    if (!(t1 && t2))
        return undefined;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2))
        return undefined;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2)
        return 1;
    if (t1 < t2)
        return -1;
    return 0;
}
const DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
    // http://tools.ietf.org/html/rfc3339#section-5.6
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
}
function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2))
        return undefined;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === undefined)
        return undefined;
    return res || compareTime(t1, t2);
}
const NOT_URI_FRAGMENT = /\/|:/;
const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
}
const MIN_INT32 = -(2 ** 31);
const MAX_INT32 = 2 ** 31 - 1;
function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
    return Number.isInteger(value);
}
function validateNumber() {
    return true;
}
const Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
    if (Z_ANCHOR.test(str))
        return false;
    try {
        new RegExp(str);
        return true;
    }
    catch (e) {
        return false;
    }
}
//# sourceMappingURL=formats.js.map

/***/ }),

/***/ "../node_modules/ajv-formats/dist/index.js":
/*!*************************************************!*\
  !*** ../node_modules/ajv-formats/dist/index.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const formats_1 = __webpack_require__(/*! ./formats */ "../node_modules/ajv-formats/dist/formats.js");
const limit_1 = __webpack_require__(/*! ./limit */ "../node_modules/ajv-formats/dist/limit.js");
const codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ "../node_modules/ajv/dist/compile/codegen/index.js");
const fullName = new codegen_1.Name("fullFormats");
const fastName = new codegen_1.Name("fastFormats");
const formatsPlugin = (ajv, opts = { keywords: true }) => {
    if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
    }
    const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv, list, formats, exportName);
    if (opts.keywords)
        limit_1.default(ajv);
    return ajv;
};
formatsPlugin.get = (name, mode = "full") => {
    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats[name];
    if (!f)
        throw new Error(`Unknown format "${name}"`);
    return f;
};
function addFormats(ajv, list, fs, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : (_b.formats = codegen_1._ `require("ajv-formats/dist/formats").${exportName}`);
    for (const f of list)
        ajv.addFormat(f, fs[f]);
}
module.exports = exports = formatsPlugin;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = formatsPlugin;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../node_modules/ajv-formats/dist/limit.js":
/*!*************************************************!*\
  !*** ../node_modules/ajv-formats/dist/limit.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatLimitDefinition = void 0;
const ajv_1 = __webpack_require__(/*! ajv */ "../node_modules/ajv/dist/ajv.js");
const codegen_1 = __webpack_require__(/*! ajv/dist/compile/codegen */ "../node_modules/ajv/dist/compile/codegen/index.js");
const ops = codegen_1.operators;
const KWDs = {
    formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
    formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
    formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
    formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE },
};
const error = {
    message: ({ keyword, schemaCode }) => codegen_1.str `should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode }) => codegen_1._ `{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`,
};
exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs),
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
            return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            });
            const fmt = gen.const("fmt", codegen_1._ `${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data(codegen_1.or(codegen_1._ `typeof ${fmt} != "object"`, codegen_1._ `${fmt} instanceof RegExp`, codegen_1._ `typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
            const format = fCxt.schema;
            const fmtDef = self.formats[format];
            if (!fmtDef || fmtDef === true)
                return;
            if (typeof fmtDef != "object" ||
                fmtDef instanceof RegExp ||
                typeof fmtDef.compare != "function") {
                throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
                key: format,
                ref: fmtDef,
                code: opts.code.formats ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(format)}` : undefined,
            });
            cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
            return codegen_1._ `${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
    },
    dependencies: ["format"],
};
const formatLimitPlugin = (ajv) => {
    ajv.addKeyword(exports.formatLimitDefinition);
    return ajv;
};
exports["default"] = formatLimitPlugin;
//# sourceMappingURL=limit.js.map

/***/ }),

/***/ "../node_modules/lodash-es/clone.js":
/*!******************************************!*\
  !*** ../node_modules/lodash-es/clone.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseClone.js */ "../node_modules/lodash-es/_baseClone.js");


/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return (0,_baseClone_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clone);


/***/ }),

/***/ "../node_modules/lodash-es/toPath.js":
/*!*******************************************!*\
  !*** ../node_modules/lodash-es/toPath.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayMap.js */ "../node_modules/lodash-es/_arrayMap.js");
/* harmony import */ var _copyArray_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_copyArray.js */ "../node_modules/lodash-es/_copyArray.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "../node_modules/lodash-es/isArray.js");
/* harmony import */ var _isSymbol_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isSymbol.js */ "../node_modules/lodash-es/isSymbol.js");
/* harmony import */ var _stringToPath_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_stringToPath.js */ "../node_modules/lodash-es/_stringToPath.js");
/* harmony import */ var _toKey_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_toKey.js */ "../node_modules/lodash-es/_toKey.js");
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./toString.js */ "../node_modules/lodash-es/toString.js");








/**
 * Converts `value` to a property path array.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Util
 * @param {*} value The value to convert.
 * @returns {Array} Returns the new property path array.
 * @example
 *
 * _.toPath('a.b.c');
 * // => ['a', 'b', 'c']
 *
 * _.toPath('a[0].b.c');
 * // => ['a', '0', 'b', 'c']
 */
function toPath(value) {
  if ((0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
    return (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value, _toKey_js__WEBPACK_IMPORTED_MODULE_2__["default"]);
  }
  return (0,_isSymbol_js__WEBPACK_IMPORTED_MODULE_3__["default"])(value) ? [value] : (0,_copyArray_js__WEBPACK_IMPORTED_MODULE_4__["default"])((0,_stringToPath_js__WEBPACK_IMPORTED_MODULE_5__["default"])((0,_toString_js__WEBPACK_IMPORTED_MODULE_6__["default"])(value)));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toPath);


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcmpzZl92YWxpZGF0b3ItYWp2OF9kaXN0X3ZhbGlkYXRvci1hanY4X2VzbV9qcy40NWNiZGEzOTg4MjMwZThhZmYxOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7QUFDSTtBQUNOO0FBQ29LO0FBQ3hLO0FBQ1Y7QUFDZTs7QUFFckM7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUUsRUFBRSxJQUFJO0FBQ25ELDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw0Q0FBRztBQUNsQjtBQUNBLG9DQUFvQztBQUNwQztBQUNBLElBQUksa0RBQVU7QUFDZCxJQUFJO0FBQ0osSUFBSSxrREFBVTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUVBQXdCO0FBQ3pDLGlCQUFpQix1RUFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQVE7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRLGFBQWEsT0FBTztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrQkFBa0IsRUFBRSw4QkFBOEI7QUFDM0csYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxJQUFJLFdBQVcsS0FBSyxJQUFJLFdBQVcsSUFBSSxvQkFBb0I7QUFDN0Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7QUFDZjs7Ozs7Ozs7Ozs7Ozs7O0FDcEV3Qzs7QUFFeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLEdBQUc7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsSUFBSSxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQVM7QUFDbEI7O0FBRUEsaUVBQWUsS0FBSyxFQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNpQjtBQUNFO0FBQ0w7QUFDRTtBQUNTO0FBQ2Q7QUFDSzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBTztBQUNiLFdBQVcsd0RBQVEsUUFBUSxpREFBSztBQUNoQztBQUNBLFNBQVMsd0RBQVEsb0JBQW9CLHlEQUFTLENBQUMsNERBQVksQ0FBQyx3REFBUTtBQUNwRTs7QUFFQSxpRUFBZSxNQUFNLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL0ByanNmL3ZhbGlkYXRvci1hanY4L2Rpc3QvdmFsaWRhdG9yLWFqdjguZXNtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uLi9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi4vbm9kZV9tb2R1bGVzL2Fqdi1mb3JtYXRzL2Rpc3QvbGltaXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9QYXRoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0b1BhdGggZnJvbSAnbG9kYXNoLWVzL3RvUGF0aCc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnbG9kYXNoLWVzL2lzT2JqZWN0JztcbmltcG9ydCBjbG9uZSBmcm9tICdsb2Rhc2gtZXMvY2xvbmUnO1xuaW1wb3J0IHsgQURESVRJT05BTF9QUk9QRVJUWV9GTEFHLCBSSlNGX0FERElUT05BTF9QUk9QRVJUSUVTX0ZMQUcsIEVycm9yU2NoZW1hQnVpbGRlciwgRVJST1JTX0tFWSwgZ2V0VWlPcHRpb25zLCBQUk9QRVJUSUVTX0tFWSwgZ2V0RGVmYXVsdEZvcm1TdGF0ZSwgbWVyZ2VWYWxpZGF0aW9uRGF0YSwgUkVGX0tFWSB9IGZyb20gJ0ByanNmL3V0aWxzJztcbmltcG9ydCBnZXQgZnJvbSAnbG9kYXNoLWVzL2dldCc7XG5pbXBvcnQgQWp2IGZyb20gJ2Fqdic7XG5pbXBvcnQgYWRkRm9ybWF0cyBmcm9tICdhanYtZm9ybWF0cyc7XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gPyBPYmplY3QuYXNzaWduLmJpbmQoKSA6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIEFKVl9DT05GSUcgPSB7XG4gIGFsbEVycm9yczogdHJ1ZSxcbiAgbXVsdGlwbGVPZlByZWNpc2lvbjogOCxcbiAgc3RyaWN0OiBmYWxzZSxcbiAgdmVyYm9zZTogdHJ1ZVxufTtcbnZhciBDT0xPUl9GT1JNQVRfUkVHRVggPSAvXigjPyhbMC05QS1GYS1mXXszfSl7MSwyfVxcYnxhcXVhfGJsYWNrfGJsdWV8ZnVjaHNpYXxncmF5fGdyZWVufGxpbWV8bWFyb29ufG5hdnl8b2xpdmV8b3JhbmdlfHB1cnBsZXxyZWR8c2lsdmVyfHRlYWx8d2hpdGV8eWVsbG93fChyZ2JcXChcXHMqXFxiKFswLTldfFsxLTldWzAtOV18MVswLTldWzAtOV18MlswLTRdWzAtOV18MjVbMC01XSlcXGJcXHMqLFxccypcXGIoWzAtOV18WzEtOV1bMC05XXwxWzAtOV1bMC05XXwyWzAtNF1bMC05XXwyNVswLTVdKVxcYlxccyosXFxzKlxcYihbMC05XXxbMS05XVswLTldfDFbMC05XVswLTldfDJbMC00XVswLTldfDI1WzAtNV0pXFxiXFxzKlxcKSl8KHJnYlxcKFxccyooXFxkP1xcZCV8MTAwJSkrXFxzKixcXHMqKFxcZD9cXGQlfDEwMCUpK1xccyosXFxzKihcXGQ/XFxkJXwxMDAlKStcXHMqXFwpKSkkLztcbnZhciBEQVRBX1VSTF9GT1JNQVRfUkVHRVggPSAvXmRhdGE6KFthLXpdK1xcL1thLXowLTktKy5dKyk/Oyg/Om5hbWU9KC4qKTspP2Jhc2U2NCwoLiopJC87XG4vKiogQ3JlYXRlcyBhbiBBanYgdmVyc2lvbiA4IGltcGxlbWVudGF0aW9uIG9iamVjdCB3aXRoIHN0YW5kYXJkIHN1cHBvcnQgZm9yIHRoZSAnY29sb3JgIGFuZCBgZGF0YS11cmxgIGN1c3RvbSBmb3JtYXRzLlxyXG4gKiBJZiBgYWRkaXRpb25hbE1ldGFTY2hlbWFzYCBhcmUgcHJvdmlkZWQgdGhlbiB0aGUgQWp2IGluc3RhbmNlIGlzIG1vZGlmaWVkIHRvIGFkZCBlYWNoIG9mIHRoZSBtZXRhIHNjaGVtYXMgaW4gdGhlXHJcbiAqIGxpc3QuIElmIGBjdXN0b21Gb3JtYXRzYCBhcmUgcHJvdmlkZWQgdGhlbiB0aG9zZSBhZGRpdGlvbmFsIGZvcm1hdHMgYXJlIGFkZGVkIHRvIHRoZSBsaXN0IG9mIHN1cHBvcnRlZCBmb3JtYXRzLiBJZlxyXG4gKiBgYWp2T3B0aW9uc092ZXJyaWRlc2AgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSBhcmUgc3ByZWFkIG9uIHRvcCBvZiB0aGUgZGVmYXVsdCBgQUpWX0NPTkZJR2Agb3B0aW9ucyB3aGVuIGNvbnN0cnVjdGluZ1xyXG4gKiB0aGUgYEFqdmAgaW5zdGFuY2UuIFdpdGggQWp2IHY4LCB0aGUgSlNPTiBTY2hlbWEgZm9ybWF0cyBhcmUgbm90IHByb3ZpZGVkIGJ5IGRlZmF1bHQsIGJ1dCBjYW4gYmUgcGx1Z2dlZCBpbi4gQnlcclxuICogZGVmYXVsdCwgYWxsIGZvcm1hdHMgZnJvbSB0aGUgYGFqdi1mb3JtYXRzYCBsaWJyYXJ5IGFyZSBhZGRlZC4gVG8gZGlzYWJsZSB0aGlzIGNhcGFiaWxpdHksIHNldCB0aGUgYGFqdkZvcm1hdE9wdGlvbnNgXHJcbiAqIHBhcmFtZXRlciB0byBgZmFsc2VgLiBBZGRpdGlvbmFsbHksIHlvdSBjYW4gY29uZmlndXJlIHRoZSBgYWp2LWZvcm1hdHNgIGJ5IHByb3ZpZGluZyBhIGN1c3RvbSBzZXQgb2ZcclxuICogW2Zvcm1hdCBvcHRpb25zXShodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYtZm9ybWF0cykgdG8gdGhlIGBhanZGb3JtYXRPcHRpb25zYCBwYXJhbWV0ZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSBbYWRkaXRpb25hbE1ldGFTY2hlbWFzXSAtIFRoZSBsaXN0IG9mIGFkZGl0aW9uYWwgbWV0YSBzY2hlbWFzIHRoYXQgdGhlIHZhbGlkYXRvciBjYW4gYWNjZXNzXHJcbiAqIEBwYXJhbSBbY3VzdG9tRm9ybWF0c10gLSBUaGUgc2V0IG9mIGFkZGl0aW9uYWwgY3VzdG9tIGZvcm1hdHMgdGhhdCB0aGUgdmFsaWRhdG9yIHdpbGwgc3VwcG9ydFxyXG4gKiBAcGFyYW0gW2Fqdk9wdGlvbnNPdmVycmlkZXM9e31dIC0gVGhlIHNldCBvZiB2YWxpZGF0b3IgY29uZmlnIG92ZXJyaWRlIG9wdGlvbnNcclxuICogQHBhcmFtIFthanZGb3JtYXRPcHRpb25zXSAtIFRoZSBgYWp2LWZvcm1hdGAgb3B0aW9ucyB0byB1c2Ugd2hlbiBhZGRpbmcgZm9ybWF0cyB0byBgYWp2YDsgcGFzcyBgZmFsc2VgIHRvIGRpc2FibGUgaXRcclxuICogQHBhcmFtIFtBanZDbGFzc10gLSBUaGUgYEFqdmAgY2xhc3MgdG8gdXNlIHdoZW4gY3JlYXRpbmcgdGhlIHZhbGlkYXRvciBpbnN0YW5jZVxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUFqdkluc3RhbmNlKGFkZGl0aW9uYWxNZXRhU2NoZW1hcywgY3VzdG9tRm9ybWF0cywgYWp2T3B0aW9uc092ZXJyaWRlcywgYWp2Rm9ybWF0T3B0aW9ucywgQWp2Q2xhc3MpIHtcbiAgaWYgKGFqdk9wdGlvbnNPdmVycmlkZXMgPT09IHZvaWQgMCkge1xuICAgIGFqdk9wdGlvbnNPdmVycmlkZXMgPSB7fTtcbiAgfVxuICBpZiAoQWp2Q2xhc3MgPT09IHZvaWQgMCkge1xuICAgIEFqdkNsYXNzID0gQWp2O1xuICB9XG4gIHZhciBhanYgPSBuZXcgQWp2Q2xhc3MoX2V4dGVuZHMoe30sIEFKVl9DT05GSUcsIGFqdk9wdGlvbnNPdmVycmlkZXMpKTtcbiAgaWYgKGFqdkZvcm1hdE9wdGlvbnMpIHtcbiAgICBhZGRGb3JtYXRzKGFqdiwgYWp2Rm9ybWF0T3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAoYWp2Rm9ybWF0T3B0aW9ucyAhPT0gZmFsc2UpIHtcbiAgICBhZGRGb3JtYXRzKGFqdik7XG4gIH1cbiAgLy8gYWRkIGN1c3RvbSBmb3JtYXRzXG4gIGFqdi5hZGRGb3JtYXQoJ2RhdGEtdXJsJywgREFUQV9VUkxfRk9STUFUX1JFR0VYKTtcbiAgYWp2LmFkZEZvcm1hdCgnY29sb3InLCBDT0xPUl9GT1JNQVRfUkVHRVgpO1xuICAvLyBBZGQgUkpTRi1zcGVjaWZpYyBhZGRpdGlvbmFsIHByb3BlcnRpZXMga2V5d29yZHMgc28gQWp2IGRvZXNuJ3QgcmVwb3J0IGVycm9ycyBpZiBzdHJpY3QgaXMgZW5hYmxlZC5cbiAgYWp2LmFkZEtleXdvcmQoQURESVRJT05BTF9QUk9QRVJUWV9GTEFHKTtcbiAgYWp2LmFkZEtleXdvcmQoUkpTRl9BRERJVE9OQUxfUFJPUEVSVElFU19GTEFHKTtcbiAgLy8gYWRkIG1vcmUgc2NoZW1hcyB0byB2YWxpZGF0ZSBhZ2FpbnN0XG4gIGlmIChBcnJheS5pc0FycmF5KGFkZGl0aW9uYWxNZXRhU2NoZW1hcykpIHtcbiAgICBhanYuYWRkTWV0YVNjaGVtYShhZGRpdGlvbmFsTWV0YVNjaGVtYXMpO1xuICB9XG4gIC8vIGFkZCBtb3JlIGN1c3RvbSBmb3JtYXRzIHRvIHZhbGlkYXRlIGFnYWluc3RcbiAgaWYgKGlzT2JqZWN0KGN1c3RvbUZvcm1hdHMpKSB7XG4gICAgT2JqZWN0LmtleXMoY3VzdG9tRm9ybWF0cykuZm9yRWFjaChmdW5jdGlvbiAoZm9ybWF0TmFtZSkge1xuICAgICAgYWp2LmFkZEZvcm1hdChmb3JtYXROYW1lLCBjdXN0b21Gb3JtYXRzW2Zvcm1hdE5hbWVdKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYWp2O1xufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wiaW5zdGFuY2VQYXRoXCIsIFwia2V5d29yZFwiLCBcInBhcmFtc1wiLCBcInNjaGVtYVBhdGhcIiwgXCJwYXJlbnRTY2hlbWFcIl07XG52YXIgUk9PVF9TQ0hFTUFfUFJFRklYID0gJ19fcmpzZl9yb290U2NoZW1hJztcbi8qKiBgVmFsaWRhdG9yVHlwZWAgaW1wbGVtZW50YXRpb24gdGhhdCB1c2VzIHRoZSBBSlYgOCB2YWxpZGF0aW9uIG1lY2hhbmlzbS5cclxuICovXG52YXIgQUpWOFZhbGlkYXRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKiBUaGUgQUpWIGluc3RhbmNlIHRvIHVzZSBmb3IgYWxsIHZhbGlkYXRpb25zXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuXG4gIC8qKiBUaGUgTG9jYWxpemVyIGZ1bmN0aW9uIHRvIHVzZSBmb3IgbG9jYWxpemluZyBBanYgZXJyb3JzXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuXG4gIC8qKiBDb25zdHJ1Y3RzIGFuIGBBSlY4VmFsaWRhdG9yYCBpbnN0YW5jZSB1c2luZyB0aGUgYG9wdGlvbnNgXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBgQ3VzdG9tVmFsaWRhdG9yT3B0aW9uc1R5cGVgIG9wdGlvbnMgdGhhdCBhcmUgdXNlZCB0byBjcmVhdGUgdGhlIEFKViBpbnN0YW5jZVxyXG4gICAqIEBwYXJhbSBbbG9jYWxpemVyXSAtIElmIHByb3ZpZGVkLCBpcyB1c2VkIHRvIGxvY2FsaXplIGEgbGlzdCBvZiBBanYgYEVycm9yT2JqZWN0YHNcclxuICAgKi9cbiAgZnVuY3Rpb24gQUpWOFZhbGlkYXRvcihvcHRpb25zLCBsb2NhbGl6ZXIpIHtcbiAgICB0aGlzLmFqdiA9IHZvaWQgMDtcbiAgICB0aGlzLmxvY2FsaXplciA9IHZvaWQgMDtcbiAgICB2YXIgYWRkaXRpb25hbE1ldGFTY2hlbWFzID0gb3B0aW9ucy5hZGRpdGlvbmFsTWV0YVNjaGVtYXMsXG4gICAgICBjdXN0b21Gb3JtYXRzID0gb3B0aW9ucy5jdXN0b21Gb3JtYXRzLFxuICAgICAgYWp2T3B0aW9uc092ZXJyaWRlcyA9IG9wdGlvbnMuYWp2T3B0aW9uc092ZXJyaWRlcyxcbiAgICAgIGFqdkZvcm1hdE9wdGlvbnMgPSBvcHRpb25zLmFqdkZvcm1hdE9wdGlvbnMsXG4gICAgICBBanZDbGFzcyA9IG9wdGlvbnMuQWp2Q2xhc3M7XG4gICAgdGhpcy5hanYgPSBjcmVhdGVBanZJbnN0YW5jZShhZGRpdGlvbmFsTWV0YVNjaGVtYXMsIGN1c3RvbUZvcm1hdHMsIGFqdk9wdGlvbnNPdmVycmlkZXMsIGFqdkZvcm1hdE9wdGlvbnMsIEFqdkNsYXNzKTtcbiAgICB0aGlzLmxvY2FsaXplciA9IGxvY2FsaXplcjtcbiAgfVxuICAvKiogVHJhbnNmb3JtcyBhIGFqdiB2YWxpZGF0aW9uIGVycm9ycyBsaXN0OlxyXG4gICAqIFtcclxuICAgKiAgIHtwcm9wZXJ0eTogJy5sZXZlbDEubGV2ZWwyWzJdLmxldmVsMycsIG1lc3NhZ2U6ICdlcnIgYSd9LFxyXG4gICAqICAge3Byb3BlcnR5OiAnLmxldmVsMS5sZXZlbDJbMl0ubGV2ZWwzJywgbWVzc2FnZTogJ2VyciBiJ30sXHJcbiAgICogICB7cHJvcGVydHk6ICcubGV2ZWwxLmxldmVsMls0XS5sZXZlbDMnLCBtZXNzYWdlOiAnZXJyIGInfSxcclxuICAgKiBdXHJcbiAgICogSW50byBhbiBlcnJvciB0cmVlOlxyXG4gICAqIHtcclxuICAgKiAgIGxldmVsMToge1xyXG4gICAqICAgICBsZXZlbDI6IHtcclxuICAgKiAgICAgICAyOiB7bGV2ZWwzOiB7ZXJyb3JzOiBbJ2VyciBhJywgJ2VyciBiJ119fSxcclxuICAgKiAgICAgICA0OiB7bGV2ZWwzOiB7ZXJyb3JzOiBbJ2VyciBiJ119fSxcclxuICAgKiAgICAgfVxyXG4gICAqICAgfVxyXG4gICAqIH07XHJcbiAgICpcclxuICAgKiBAcGFyYW0gZXJyb3JzIC0gVGhlIGxpc3Qgb2YgUkpTRlZhbGlkYXRpb25FcnJvciBvYmplY3RzXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cbiAgdmFyIF9wcm90byA9IEFKVjhWYWxpZGF0b3IucHJvdG90eXBlO1xuICBfcHJvdG8udG9FcnJvclNjaGVtYSA9IGZ1bmN0aW9uIHRvRXJyb3JTY2hlbWEoZXJyb3JzKSB7XG4gICAgdmFyIGJ1aWxkZXIgPSBuZXcgRXJyb3JTY2hlbWFCdWlsZGVyKCk7XG4gICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcbiAgICAgIGVycm9ycy5mb3JFYWNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB2YXIgcHJvcGVydHkgPSBlcnJvci5wcm9wZXJ0eSxcbiAgICAgICAgICBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgdmFyIHBhdGggPSB0b1BhdGgocHJvcGVydHkpO1xuICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgYXQgdGhlIHJvb3QgKC5sZXZlbDEpIHRoZW4gdG9QYXRoIGNyZWF0ZXNcbiAgICAgICAgLy8gYW4gZW1wdHkgYXJyYXkgZWxlbWVudCBhdCB0aGUgZmlyc3QgaW5kZXguIFJlbW92ZSBpdC5cbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoWzBdID09PSAnJykge1xuICAgICAgICAgIHBhdGguc3BsaWNlKDAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgYnVpbGRlci5hZGRFcnJvcnMobWVzc2FnZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRlci5FcnJvclNjaGVtYTtcbiAgfVxuICAvKiogQ29udmVydHMgYW4gYGVycm9yU2NoZW1hYCBpbnRvIGEgbGlzdCBvZiBgUkpTRlZhbGlkYXRpb25FcnJvcnNgXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZXJyb3JTY2hlbWEgLSBUaGUgYEVycm9yU2NoZW1hYCBpbnN0YW5jZSB0byBjb252ZXJ0XHJcbiAgICogQHBhcmFtIFtmaWVsZFBhdGg9W11dIC0gVGhlIGN1cnJlbnQgZmllbGQgcGF0aCwgZGVmYXVsdHMgdG8gW10gaWYgbm90IHNwZWNpZmllZFxyXG4gICAqLztcbiAgX3Byb3RvLnRvRXJyb3JMaXN0ID0gZnVuY3Rpb24gdG9FcnJvckxpc3QoZXJyb3JTY2hlbWEsIGZpZWxkUGF0aCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaWYgKGZpZWxkUGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgICBmaWVsZFBhdGggPSBbXTtcbiAgICB9XG4gICAgaWYgKCFlcnJvclNjaGVtYSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgZXJyb3JMaXN0ID0gW107XG4gICAgaWYgKEVSUk9SU19LRVkgaW4gZXJyb3JTY2hlbWEpIHtcbiAgICAgIGVycm9yTGlzdCA9IGVycm9yTGlzdC5jb25jYXQoZXJyb3JTY2hlbWFbRVJST1JTX0tFWV0ubWFwKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IFwiLlwiICsgZmllbGRQYXRoLmpvaW4oJy4nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHksXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBzdGFjazogcHJvcGVydHkgKyBcIiBcIiArIG1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGVycm9yU2NoZW1hKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgICBpZiAoa2V5ICE9PSBFUlJPUlNfS0VZKSB7XG4gICAgICAgIGFjYyA9IGFjYy5jb25jYXQoX3RoaXMudG9FcnJvckxpc3QoZXJyb3JTY2hlbWFba2V5XSwgW10uY29uY2F0KGZpZWxkUGF0aCwgW2tleV0pKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIGVycm9yTGlzdCk7XG4gIH1cbiAgLyoqIEdpdmVuIGEgYGZvcm1EYXRhYCBvYmplY3QsIHJlY3Vyc2l2ZWx5IGNyZWF0ZXMgYSBgRm9ybVZhbGlkYXRpb25gIGVycm9yIGhhbmRsaW5nIHN0cnVjdHVyZSBhcm91bmQgaXRcclxuICAgKlxyXG4gICAqIEBwYXJhbSBmb3JtRGF0YSAtIFRoZSBmb3JtIGRhdGEgYXJvdW5kIHdoaWNoIHRoZSBlcnJvciBoYW5kbGVyIGlzIGNyZWF0ZWRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLztcbiAgX3Byb3RvLmNyZWF0ZUVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9ySGFuZGxlcihmb3JtRGF0YSkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgIHZhciBoYW5kbGVyID0ge1xuICAgICAgLy8gV2Ugc3RvcmUgdGhlIGxpc3Qgb2YgZXJyb3JzIGZvciB0aGlzIG5vZGUgaW4gYSBwcm9wZXJ0eSBuYW1lZCBfX2Vycm9yc1xuICAgICAgLy8gdG8gYXZvaWQgbmFtZSBjb2xsaXNpb24gd2l0aCBhIHBvc3NpYmxlIHN1YiBzY2hlbWEgZmllbGQgbmFtZWRcbiAgICAgIC8vICdlcnJvcnMnIChzZWUgYHV0aWxzLnRvRXJyb3JTY2hlbWFgKS5cbiAgICAgIF9fZXJyb3JzOiBbXSxcbiAgICAgIGFkZEVycm9yOiBmdW5jdGlvbiBhZGRFcnJvcihtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX19lcnJvcnMucHVzaChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KGZvcm1EYXRhKSkge1xuICAgICAgcmV0dXJuIGZvcm1EYXRhLnJlZHVjZShmdW5jdGlvbiAoYWNjLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBfZXh0ZW5kczI7XG4gICAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCAoX2V4dGVuZHMyID0ge30sIF9leHRlbmRzMltrZXldID0gX3RoaXMyLmNyZWF0ZUVycm9ySGFuZGxlcih2YWx1ZSksIF9leHRlbmRzMikpO1xuICAgICAgfSwgaGFuZGxlcik7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChmb3JtRGF0YSkpIHtcbiAgICAgIHZhciBmb3JtT2JqZWN0ID0gZm9ybURhdGE7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZm9ybU9iamVjdCkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xuICAgICAgICB2YXIgX2V4dGVuZHMzO1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzMyA9IHt9LCBfZXh0ZW5kczNba2V5XSA9IF90aGlzMi5jcmVhdGVFcnJvckhhbmRsZXIoZm9ybU9iamVjdFtrZXldKSwgX2V4dGVuZHMzKSk7XG4gICAgICB9LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhbmRsZXI7XG4gIH1cbiAgLyoqIFVud3JhcHMgdGhlIGBlcnJvckhhbmRsZXJgIHN0cnVjdHVyZSBpbnRvIHRoZSBhc3NvY2lhdGVkIGBFcnJvclNjaGVtYWAsIHN0cmlwcGluZyB0aGUgYGFkZEVycm9yYCBmdW5jdGlvbnMgZnJvbSBpdFxyXG4gICAqXHJcbiAgICogQHBhcmFtIGVycm9ySGFuZGxlciAtIFRoZSBgRm9ybVZhbGlkYXRpb25gIGVycm9yIGhhbmRsaW5nIHN0cnVjdHVyZVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovO1xuICBfcHJvdG8udW53cmFwRXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gdW53cmFwRXJyb3JIYW5kbGVyKGVycm9ySGFuZGxlcikge1xuICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhlcnJvckhhbmRsZXIpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICAgIHZhciBfZXh0ZW5kczU7XG4gICAgICBpZiAoa2V5ID09PSAnYWRkRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gRVJST1JTX0tFWSkge1xuICAgICAgICB2YXIgX2V4dGVuZHM0O1xuICAgICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGFjYywgKF9leHRlbmRzNCA9IHt9LCBfZXh0ZW5kczRba2V5XSA9IGVycm9ySGFuZGxlcltrZXldLCBfZXh0ZW5kczQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgYWNjLCAoX2V4dGVuZHM1ID0ge30sIF9leHRlbmRzNVtrZXldID0gX3RoaXMzLnVud3JhcEVycm9ySGFuZGxlcihlcnJvckhhbmRsZXJba2V5XSksIF9leHRlbmRzNSkpO1xuICAgIH0sIHt9KTtcbiAgfVxuICAvKiogVHJhbnNmb3JtaW5nIHRoZSBlcnJvciBvdXRwdXQgZnJvbSBhanYgdG8gZm9ybWF0IHVzZWQgYnkgQHJqc2YvdXRpbHMuXHJcbiAgICogQXQgc29tZSBwb2ludCwgY29tcG9uZW50cyBzaG91bGQgYmUgdXBkYXRlZCB0byBzdXBwb3J0IGFqdi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBlcnJvcnMgLSBUaGUgbGlzdCBvZiBBSlYgZXJyb3JzIHRvIGNvbnZlcnQgdG8gYFJKU0ZWYWxpZGF0aW9uRXJyb3JzYFxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi87XG4gIF9wcm90by50cmFuc2Zvcm1SSlNGVmFsaWRhdGlvbkVycm9ycyA9IGZ1bmN0aW9uIHRyYW5zZm9ybVJKU0ZWYWxpZGF0aW9uRXJyb3JzKGVycm9ycywgdWlTY2hlbWEpIHtcbiAgICBpZiAoZXJyb3JzID09PSB2b2lkIDApIHtcbiAgICAgIGVycm9ycyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGluc3RhbmNlUGF0aCA9IGUuaW5zdGFuY2VQYXRoLFxuICAgICAgICBrZXl3b3JkID0gZS5rZXl3b3JkLFxuICAgICAgICBwYXJhbXMgPSBlLnBhcmFtcyxcbiAgICAgICAgc2NoZW1hUGF0aCA9IGUuc2NoZW1hUGF0aCxcbiAgICAgICAgcGFyZW50U2NoZW1hID0gZS5wYXJlbnRTY2hlbWEsXG4gICAgICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShlLCBfZXhjbHVkZWQpO1xuICAgICAgdmFyIF9yZXN0JG1lc3NhZ2UgPSByZXN0Lm1lc3NhZ2UsXG4gICAgICAgIG1lc3NhZ2UgPSBfcmVzdCRtZXNzYWdlID09PSB2b2lkIDAgPyAnJyA6IF9yZXN0JG1lc3NhZ2U7XG4gICAgICB2YXIgcHJvcGVydHkgPSBpbnN0YW5jZVBhdGgucmVwbGFjZSgvXFwvL2csICcuJyk7XG4gICAgICB2YXIgc3RhY2sgPSAocHJvcGVydHkgKyBcIiBcIiArIG1lc3NhZ2UpLnRyaW0oKTtcbiAgICAgIGlmICgnbWlzc2luZ1Byb3BlcnR5JyBpbiBwYXJhbXMpIHtcbiAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eSA/IHByb3BlcnR5ICsgXCIuXCIgKyBwYXJhbXMubWlzc2luZ1Byb3BlcnR5IDogcGFyYW1zLm1pc3NpbmdQcm9wZXJ0eTtcbiAgICAgICAgdmFyIGN1cnJlbnRQcm9wZXJ0eSA9IHBhcmFtcy5taXNzaW5nUHJvcGVydHk7XG4gICAgICAgIHZhciB1aVNjaGVtYVRpdGxlID0gZ2V0VWlPcHRpb25zKGdldCh1aVNjaGVtYSwgXCJcIiArIHByb3BlcnR5LnJlcGxhY2UoL15cXC4vLCAnJykpKS50aXRsZTtcbiAgICAgICAgaWYgKHVpU2NoZW1hVGl0bGUpIHtcbiAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5yZXBsYWNlKGN1cnJlbnRQcm9wZXJ0eSwgdWlTY2hlbWFUaXRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBhcmVudFNjaGVtYVRpdGxlID0gZ2V0KHBhcmVudFNjaGVtYSwgW1BST1BFUlRJRVNfS0VZLCBjdXJyZW50UHJvcGVydHksICd0aXRsZSddKTtcbiAgICAgICAgICBpZiAocGFyZW50U2NoZW1hVGl0bGUpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoY3VycmVudFByb3BlcnR5LCBwYXJlbnRTY2hlbWFUaXRsZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YWNrID0gbWVzc2FnZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdWlTY2hlbWFUaXRsZSA9IGdldFVpT3B0aW9ucyhnZXQodWlTY2hlbWEsIFwiXCIgKyBwcm9wZXJ0eS5yZXBsYWNlKC9eXFwuLywgJycpKSkudGl0bGU7XG4gICAgICAgIGlmIChfdWlTY2hlbWFUaXRsZSkge1xuICAgICAgICAgIHN0YWNrID0gKFwiJ1wiICsgX3VpU2NoZW1hVGl0bGUgKyBcIicgXCIgKyBtZXNzYWdlKS50cmltKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9wYXJlbnRTY2hlbWFUaXRsZSA9IHBhcmVudFNjaGVtYSA9PT0gbnVsbCB8fCBwYXJlbnRTY2hlbWEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudFNjaGVtYS50aXRsZTtcbiAgICAgICAgICBpZiAoX3BhcmVudFNjaGVtYVRpdGxlKSB7XG4gICAgICAgICAgICBzdGFjayA9IChcIidcIiArIF9wYXJlbnRTY2hlbWFUaXRsZSArIFwiJyBcIiArIG1lc3NhZ2UpLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHB1dCBkYXRhIGluIGV4cGVjdGVkIGZvcm1hdFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZToga2V5d29yZCxcbiAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgc3RhY2s6IHN0YWNrLFxuICAgICAgICBzY2hlbWFQYXRoOiBzY2hlbWFQYXRoXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIC8qKiBSdW5zIHRoZSBwdXJlIHZhbGlkYXRpb24gb2YgdGhlIGBzY2hlbWFgIGFuZCBgZm9ybURhdGFgIHdpdGhvdXQgYW55IG9mIHRoZSBSSlNGIGZ1bmN0aW9uYWxpdHkuIFByb3ZpZGVkIGZvciB1c2VcclxuICAgKiBieSB0aGUgcGxheWdyb3VuZC4gUmV0dXJucyB0aGUgYGVycm9yc2AgZnJvbSB0aGUgdmFsaWRhdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgYWdhaW5zdCB3aGljaCB0byB2YWxpZGF0ZSB0aGUgZm9ybSBkYXRhICAgKiBAcGFyYW0gc2NoZW1hXHJcbiAgICogQHBhcmFtIGZvcm1EYXRhIC0gVGhlIGZvcm0gZGF0YSB0byB2YWxpZGF0ZVxyXG4gICAqLztcbiAgX3Byb3RvLnJhd1ZhbGlkYXRpb24gPSBmdW5jdGlvbiByYXdWYWxpZGF0aW9uKHNjaGVtYSwgZm9ybURhdGEpIHtcbiAgICB2YXIgY29tcGlsYXRpb25FcnJvciA9IHVuZGVmaW5lZDtcbiAgICB2YXIgY29tcGlsZWRWYWxpZGF0b3I7XG4gICAgaWYgKHNjaGVtYVsnJGlkJ10pIHtcbiAgICAgIGNvbXBpbGVkVmFsaWRhdG9yID0gdGhpcy5hanYuZ2V0U2NoZW1hKHNjaGVtYVsnJGlkJ10pO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKGNvbXBpbGVkVmFsaWRhdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcGlsZWRWYWxpZGF0b3IgPSB0aGlzLmFqdi5jb21waWxlKHNjaGVtYSk7XG4gICAgICB9XG4gICAgICBjb21waWxlZFZhbGlkYXRvcihmb3JtRGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb21waWxhdGlvbkVycm9yID0gZXJyO1xuICAgIH1cbiAgICB2YXIgZXJyb3JzO1xuICAgIGlmIChjb21waWxlZFZhbGlkYXRvcikge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLmxvY2FsaXplciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmxvY2FsaXplcihjb21waWxlZFZhbGlkYXRvci5lcnJvcnMpO1xuICAgICAgfVxuICAgICAgZXJyb3JzID0gY29tcGlsZWRWYWxpZGF0b3IuZXJyb3JzIHx8IHVuZGVmaW5lZDtcbiAgICAgIC8vIENsZWFyIGVycm9ycyB0byBwcmV2ZW50IHBlcnNpc3RlbnQgZXJyb3JzLCBzZWUgIzExMDRcbiAgICAgIGNvbXBpbGVkVmFsaWRhdG9yLmVycm9ycyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgIHZhbGlkYXRpb25FcnJvcjogY29tcGlsYXRpb25FcnJvclxuICAgIH07XG4gIH1cbiAgLyoqIFRoaXMgZnVuY3Rpb24gcHJvY2Vzc2VzIHRoZSBgZm9ybURhdGFgIHdpdGggYW4gb3B0aW9uYWwgdXNlciBjb250cmlidXRlZCBgY3VzdG9tVmFsaWRhdGVgIGZ1bmN0aW9uLCB3aGljaCByZWNlaXZlc1xyXG4gICAqIHRoZSBmb3JtIGRhdGEgYW5kIGEgYGVycm9ySGFuZGxlcmAgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIHVzZWQgdG8gYWRkIGN1c3RvbSB2YWxpZGF0aW9uIGVycm9ycyBmb3IgZWFjaCBmaWVsZC4gQWxzb1xyXG4gICAqIHN1cHBvcnRzIGEgYHRyYW5zZm9ybUVycm9yc2AgZnVuY3Rpb24gdGhhdCB3aWxsIHRha2UgdGhlIHJhdyBBSlYgdmFsaWRhdGlvbiBlcnJvcnMsIHByaW9yIHRvIGN1c3RvbSB2YWxpZGF0aW9uIGFuZFxyXG4gICAqIHRyYW5zZm9ybSB0aGVtIGluIHdoYXQgZXZlciB3YXkgaXQgY2hvb3Nlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBmb3JtRGF0YSAtIFRoZSBmb3JtIGRhdGEgdG8gdmFsaWRhdGVcclxuICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBhZ2FpbnN0IHdoaWNoIHRvIHZhbGlkYXRlIHRoZSBmb3JtIGRhdGFcclxuICAgKiBAcGFyYW0gW2N1c3RvbVZhbGlkYXRlXSAtIEFuIG9wdGlvbmFsIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBwZXJmb3JtIGN1c3RvbSB2YWxpZGF0aW9uXHJcbiAgICogQHBhcmFtIFt0cmFuc2Zvcm1FcnJvcnNdIC0gQW4gb3B0aW9uYWwgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIHRyYW5zZm9ybSBlcnJvcnMgYWZ0ZXIgQUpWIHZhbGlkYXRpb25cclxuICAgKiBAcGFyYW0gW3VpU2NoZW1hXSAtIEFuIG9wdGlvbmFsIHVpU2NoZW1hIHRoYXQgaXMgcGFzc2VkIHRvIGB0cmFuc2Zvcm1FcnJvcnNgIGFuZCBgY3VzdG9tVmFsaWRhdGVgXHJcbiAgICovO1xuICBfcHJvdG8udmFsaWRhdGVGb3JtRGF0YSA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybURhdGEoZm9ybURhdGEsIHNjaGVtYSwgY3VzdG9tVmFsaWRhdGUsIHRyYW5zZm9ybUVycm9ycywgdWlTY2hlbWEpIHtcbiAgICB2YXIgcmF3RXJyb3JzID0gdGhpcy5yYXdWYWxpZGF0aW9uKHNjaGVtYSwgZm9ybURhdGEpO1xuICAgIHZhciBpbnZhbGlkU2NoZW1hRXJyb3IgPSByYXdFcnJvcnMudmFsaWRhdGlvbkVycm9yO1xuICAgIHZhciBlcnJvcnMgPSB0aGlzLnRyYW5zZm9ybVJKU0ZWYWxpZGF0aW9uRXJyb3JzKHJhd0Vycm9ycy5lcnJvcnMsIHVpU2NoZW1hKTtcbiAgICBpZiAoaW52YWxpZFNjaGVtYUVycm9yKSB7XG4gICAgICBlcnJvcnMgPSBbXS5jb25jYXQoZXJyb3JzLCBbe1xuICAgICAgICBzdGFjazogaW52YWxpZFNjaGVtYUVycm9yLm1lc3NhZ2VcbiAgICAgIH1dKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0cmFuc2Zvcm1FcnJvcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9ycyA9IHRyYW5zZm9ybUVycm9ycyhlcnJvcnMsIHVpU2NoZW1hKTtcbiAgICB9XG4gICAgdmFyIGVycm9yU2NoZW1hID0gdGhpcy50b0Vycm9yU2NoZW1hKGVycm9ycyk7XG4gICAgaWYgKGludmFsaWRTY2hlbWFFcnJvcikge1xuICAgICAgZXJyb3JTY2hlbWEgPSBfZXh0ZW5kcyh7fSwgZXJyb3JTY2hlbWEsIHtcbiAgICAgICAgJHNjaGVtYToge1xuICAgICAgICAgIF9fZXJyb3JzOiBbaW52YWxpZFNjaGVtYUVycm9yLm1lc3NhZ2VdXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGN1c3RvbVZhbGlkYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgZXJyb3JTY2hlbWE6IGVycm9yU2NoZW1hXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBJbmNsdWRlIGZvcm0gZGF0YSB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciBjdXN0b20gdmFsaWRhdGlvbi5cbiAgICB2YXIgbmV3Rm9ybURhdGEgPSBnZXREZWZhdWx0Rm9ybVN0YXRlKHRoaXMsIHNjaGVtYSwgZm9ybURhdGEsIHNjaGVtYSwgdHJ1ZSk7XG4gICAgdmFyIGVycm9ySGFuZGxlciA9IGN1c3RvbVZhbGlkYXRlKG5ld0Zvcm1EYXRhLCB0aGlzLmNyZWF0ZUVycm9ySGFuZGxlcihuZXdGb3JtRGF0YSksIHVpU2NoZW1hKTtcbiAgICB2YXIgdXNlckVycm9yU2NoZW1hID0gdGhpcy51bndyYXBFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyKTtcbiAgICByZXR1cm4gbWVyZ2VWYWxpZGF0aW9uRGF0YSh0aGlzLCB7XG4gICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgIGVycm9yU2NoZW1hOiBlcnJvclNjaGVtYVxuICAgIH0sIHVzZXJFcnJvclNjaGVtYSk7XG4gIH1cbiAgLyoqIFRha2VzIGEgYG5vZGVgIG9iamVjdCBhbmQgdHJhbnNmb3JtcyBhbnkgY29udGFpbmVkIGAkcmVmYCBub2RlIHZhcmlhYmxlcyB3aXRoIGEgcHJlZml4LCByZWN1cnNpdmVseSBjYWxsaW5nXHJcbiAgICogYHdpdGhJZFJlZlByZWZpeGAgZm9yIGFueSBvdGhlciBlbGVtZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBub2RlIC0gVGhlIG9iamVjdCBub2RlIHRvIHdoaWNoIGEgUk9PVF9TQ0hFTUFfUFJFRklYIGlzIGFkZGVkIHdoZW4gYSBSRUZfS0VZIGlzIHBhcnQgb2YgaXRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLztcbiAgX3Byb3RvLndpdGhJZFJlZlByZWZpeE9iamVjdCA9IGZ1bmN0aW9uIHdpdGhJZFJlZlByZWZpeE9iamVjdChub2RlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICAgIHZhciByZWFsT2JqID0gbm9kZTtcbiAgICAgIHZhciB2YWx1ZSA9IHJlYWxPYmpba2V5XTtcbiAgICAgIGlmIChrZXkgPT09IFJFRl9LRVkgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5zdGFydHNXaXRoKCcjJykpIHtcbiAgICAgICAgcmVhbE9ialtrZXldID0gUk9PVF9TQ0hFTUFfUFJFRklYICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWFsT2JqW2tleV0gPSB0aGlzLndpdGhJZFJlZlByZWZpeCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG4gIC8qKiBUYWtlcyBhIGBub2RlYCBvYmplY3QgbGlzdCBhbmQgdHJhbnNmb3JtcyBhbnkgY29udGFpbmVkIGAkcmVmYCBub2RlIHZhcmlhYmxlcyB3aXRoIGEgcHJlZml4LCByZWN1cnNpdmVseSBjYWxsaW5nXHJcbiAgICogYHdpdGhJZFJlZlByZWZpeGAgZm9yIGFueSBvdGhlciBlbGVtZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBub2RlIC0gVGhlIGxpc3Qgb2Ygb2JqZWN0IG5vZGVzIHRvIHdoaWNoIGEgUk9PVF9TQ0hFTUFfUFJFRklYIGlzIGFkZGVkIHdoZW4gYSBSRUZfS0VZIGlzIHBhcnQgb2YgaXRcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqLztcbiAgX3Byb3RvLndpdGhJZFJlZlByZWZpeEFycmF5ID0gZnVuY3Rpb24gd2l0aElkUmVmUHJlZml4QXJyYXkobm9kZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgbm9kZVtpXSA9IHRoaXMud2l0aElkUmVmUHJlZml4KG5vZGVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICAvKiogVmFsaWRhdGVzIGRhdGEgYWdhaW5zdCBhIHNjaGVtYSwgcmV0dXJuaW5nIHRydWUgaWYgdGhlIGRhdGEgaXMgdmFsaWQsIG9yXHJcbiAgICogZmFsc2Ugb3RoZXJ3aXNlLiBJZiB0aGUgc2NoZW1hIGlzIGludmFsaWQsIHRoZW4gdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVyblxyXG4gICAqIGZhbHNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHNjaGVtYSAtIFRoZSBzY2hlbWEgYWdhaW5zdCB3aGljaCB0byB2YWxpZGF0ZSB0aGUgZm9ybSBkYXRhXHJcbiAgICogQHBhcmFtIGZvcm1EYXRhIC0gVGhlIGZvcm0gZGF0YSB0byB2YWxpZGF0ZVxyXG4gICAqIEBwYXJhbSByb290U2NoZW1hIC0gVGhlIHJvb3Qgc2NoZW1hIHVzZWQgdG8gcHJvdmlkZSAkcmVmIHJlc29sdXRpb25zXHJcbiAgICovO1xuICBfcHJvdG8uaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQoc2NoZW1hLCBmb3JtRGF0YSwgcm9vdFNjaGVtYSkge1xuICAgIHZhciBfcm9vdFNjaGVtYSQkaWQ7XG4gICAgdmFyIHJvb3RTY2hlbWFJZCA9IChfcm9vdFNjaGVtYSQkaWQgPSByb290U2NoZW1hWyckaWQnXSkgIT0gbnVsbCA/IF9yb290U2NoZW1hJCRpZCA6IFJPT1RfU0NIRU1BX1BSRUZJWDtcbiAgICB0cnkge1xuICAgICAgLy8gYWRkIHRoZSByb290U2NoZW1hIFJPT1RfU0NIRU1BX1BSRUZJWCBhcyBpZC5cbiAgICAgIC8vIHRoZW4gcmV3cml0ZSB0aGUgc2NoZW1hIHJlZidzIHRvIHBvaW50IHRvIHRoZSByb290U2NoZW1hXG4gICAgICAvLyB0aGlzIGFjY291bnRzIGZvciB0aGUgY2FzZSB3aGVyZSBzY2hlbWEgaGF2ZSByZWZlcmVuY2VzIHRvIG1vZGVsc1xuICAgICAgLy8gdGhhdCBsaXZlcyBpbiB0aGUgcm9vdFNjaGVtYSBidXQgbm90IGluIHRoZSBzY2hlbWEgaW4gcXVlc3Rpb24uXG4gICAgICBpZiAodGhpcy5hanYuZ2V0U2NoZW1hKHJvb3RTY2hlbWFJZCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmFqdi5hZGRTY2hlbWEocm9vdFNjaGVtYSwgcm9vdFNjaGVtYUlkKTtcbiAgICAgIH1cbiAgICAgIHZhciBzY2hlbWFXaXRoSWRSZWZQcmVmaXggPSB0aGlzLndpdGhJZFJlZlByZWZpeChzY2hlbWEpO1xuICAgICAgdmFyIGNvbXBpbGVkVmFsaWRhdG9yO1xuICAgICAgaWYgKHNjaGVtYVdpdGhJZFJlZlByZWZpeFsnJGlkJ10pIHtcbiAgICAgICAgY29tcGlsZWRWYWxpZGF0b3IgPSB0aGlzLmFqdi5nZXRTY2hlbWEoc2NoZW1hV2l0aElkUmVmUHJlZml4WyckaWQnXSk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWRWYWxpZGF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21waWxlZFZhbGlkYXRvciA9IHRoaXMuYWp2LmNvbXBpbGUoc2NoZW1hV2l0aElkUmVmUHJlZml4KTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBjb21waWxlZFZhbGlkYXRvcihmb3JtRGF0YSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignRXJyb3IgZW5jb3VudGVyZWQgY29tcGlsaW5nIHNjaGVtYTonLCBlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gVE9ETzogQSBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGlmIHRoZSByb290IHNjaGVtYSBjaGFuZ2VzIHNvIHdlIGRvbid0IGhhdmUgdG8gcmVtb3ZlIGFuZCByZWNvbXBpbGUgdGhlIHNjaGVtYSBldmVyeSBydW4uXG4gICAgICAvLyBtYWtlIHN1cmUgd2UgcmVtb3ZlIHRoZSByb290U2NoZW1hIGZyb20gdGhlIGdsb2JhbCBhanYgaW5zdGFuY2VcbiAgICAgIHRoaXMuYWp2LnJlbW92ZVNjaGVtYShyb290U2NoZW1hSWQpO1xuICAgIH1cbiAgfVxuICAvKiogUmVjdXJzaXZlbHkgcHJlZml4ZXMgYWxsICRyZWYncyBpbiBhIHNjaGVtYSB3aXRoIGBST09UX1NDSEVNQV9QUkVGSVhgXHJcbiAgICogVGhpcyBpcyB1c2VkIGluIGlzVmFsaWQgdG8gbWFrZSByZWZlcmVuY2VzIHRvIHRoZSByb290U2NoZW1hXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc2NoZW1hTm9kZSAtIFRoZSBvYmplY3Qgbm9kZSB0byB3aGljaCBhIFJPT1RfU0NIRU1BX1BSRUZJWCBpcyBhZGRlZCB3aGVuIGEgUkVGX0tFWSBpcyBwYXJ0IG9mIGl0XHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqLztcbiAgX3Byb3RvLndpdGhJZFJlZlByZWZpeCA9IGZ1bmN0aW9uIHdpdGhJZFJlZlByZWZpeChzY2hlbWFOb2RlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hTm9kZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhJZFJlZlByZWZpeEFycmF5KFtdLmNvbmNhdChzY2hlbWFOb2RlKSk7XG4gICAgfVxuICAgIGlmIChpc09iamVjdChzY2hlbWFOb2RlKSkge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aElkUmVmUHJlZml4T2JqZWN0KGNsb25lKHNjaGVtYU5vZGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjaGVtYU5vZGU7XG4gIH07XG4gIHJldHVybiBBSlY4VmFsaWRhdG9yO1xufSgpO1xuXG4vKiogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGN1c3RvbWl6ZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGBWYWxpZGF0b3JUeXBlYCB3aXRoIHRoZSBnaXZlbiBjdXN0b21pemF0aW9uIGBvcHRpb25zYCBpZlxyXG4gKiBwcm92aWRlZC5cclxuICpcclxuICogQHBhcmFtIFtvcHRpb25zPXt9XSAtIFRoZSBgQ3VzdG9tVmFsaWRhdG9yT3B0aW9uc1R5cGVgIG9wdGlvbnMgdGhhdCBhcmUgdXNlZCB0byBjcmVhdGUgdGhlIGBWYWxpZGF0b3JUeXBlYCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0gW2xvY2FsaXplcl0gLSBJZiBwcm92aWRlZCwgaXMgdXNlZCB0byBsb2NhbGl6ZSBhIGxpc3Qgb2YgQWp2IGBFcnJvck9iamVjdGBzXHJcbiAqL1xuZnVuY3Rpb24gY3VzdG9taXplVmFsaWRhdG9yKG9wdGlvbnMsIGxvY2FsaXplcikge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIHJldHVybiBuZXcgQUpWOFZhbGlkYXRvcihvcHRpb25zLCBsb2NhbGl6ZXIpO1xufVxuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovY3VzdG9taXplVmFsaWRhdG9yKCk7XG5cbmV4cG9ydCB7IGN1c3RvbWl6ZVZhbGlkYXRvciwgaW5kZXggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFsaWRhdG9yLWFqdjguZXNtLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdE5hbWVzID0gZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IGV4cG9ydHMuZnVsbEZvcm1hdHMgPSB2b2lkIDA7XG5mdW5jdGlvbiBmbXREZWYodmFsaWRhdGUsIGNvbXBhcmUpIHtcbiAgICByZXR1cm4geyB2YWxpZGF0ZSwgY29tcGFyZSB9O1xufVxuZXhwb3J0cy5mdWxsRm9ybWF0cyA9IHtcbiAgICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICB0aW1lOiBmbXREZWYodGltZSwgY29tcGFyZVRpbWUpLFxuICAgIFwiZGF0ZS10aW1lXCI6IGZtdERlZihkYXRlX3RpbWUsIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gICAgdXJpLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAgIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgICBcInVyaS10ZW1wbGF0ZVwiOiAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gICAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgICBlbWFpbDogL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gICAgaG9zdG5hbWU6IC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gICAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pJC8sXG4gICAgaXB2NjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2ksXG4gICAgcmVnZXgsXG4gICAgLy8gdXVpZDogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDEyMlxuICAgIHV1aWQ6IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pLFxuICAgIC8vIEpTT04tcG9pbnRlcjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDFcbiAgICAvLyB1cmkgZnJhZ21lbnQ6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUFcbiAgICBcImpzb24tcG9pbnRlclwiOiAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvLFxuICAgIFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiOiAvXiMoPzpcXC8oPzpbYS16MC05X1xcLS4hJCYnKCkqKyw7Oj1AXXwlWzAtOWEtZl17Mn18fjB8fjEpKikqJC9pLFxuICAgIC8vIHJlbGF0aXZlIEpTT04tcG9pbnRlcjogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbHVmZi1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDBcbiAgICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC8sXG4gICAgLy8gdGhlIGZvbGxvd2luZyBmb3JtYXRzIGFyZSB1c2VkIGJ5IHRoZSBvcGVuYXBpIHNwZWNpZmljYXRpb246IGh0dHBzOi8vc3BlYy5vcGVuYXBpcy5vcmcvb2FzL3YzLjAuMCNkYXRhLXR5cGVzXG4gICAgLy8gYnl0ZTogaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbG1vdGEvaXMtYmFzZTY0XG4gICAgYnl0ZSxcbiAgICAvLyBzaWduZWQgMzIgYml0IGludGVnZXJcbiAgICBpbnQzMjogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQzMiB9LFxuICAgIC8vIHNpZ25lZCA2NCBiaXQgaW50ZWdlclxuICAgIGludDY0OiB7IHR5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDY0IH0sXG4gICAgLy8gQy10eXBlIGZsb2F0XG4gICAgZmxvYXQ6IHsgdHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgLy8gQy10eXBlIGRvdWJsZVxuICAgIGRvdWJsZTogeyB0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAvLyBoaW50IHRvIHRoZSBVSSB0byBoaWRlIGlucHV0IHN0cmluZ3NcbiAgICBwYXNzd29yZDogdHJ1ZSxcbiAgICAvLyB1bmNoZWNrZWQgc3RyaW5nIHBheWxvYWRcbiAgICBiaW5hcnk6IHRydWUsXG59O1xuZXhwb3J0cy5mYXN0Rm9ybWF0cyA9IHtcbiAgICAuLi5leHBvcnRzLmZ1bGxGb3JtYXRzLFxuICAgIGRhdGU6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZCQvLCBjb21wYXJlRGF0ZSksXG4gICAgdGltZTogZm10RGVmKC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLCBjb21wYXJlVGltZSksXG4gICAgXCJkYXRlLXRpbWVcIjogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksIGNvbXBhcmVEYXRlVGltZSksXG4gICAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICAgIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICAgIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gICAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsZnVsIHZpb2xhdGlvbicpXG4gICAgZW1haWw6IC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG59O1xuZXhwb3J0cy5mb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKGV4cG9ydHMuZnVsbEZvcm1hdHMpO1xuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyKSB7XG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICAgIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbn1cbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC87XG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdO1xuZnVuY3Rpb24gZGF0ZShzdHIpIHtcbiAgICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgbWF0Y2hlcyA9IERBVEUuZXhlYyhzdHIpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHllYXIgPSArbWF0Y2hlc1sxXTtcbiAgICBjb25zdCBtb250aCA9ICttYXRjaGVzWzJdO1xuICAgIGNvbnN0IGRheSA9ICttYXRjaGVzWzNdO1xuICAgIHJldHVybiAobW9udGggPj0gMSAmJlxuICAgICAgICBtb250aCA8PSAxMiAmJlxuICAgICAgICBkYXkgPj0gMSAmJlxuICAgICAgICBkYXkgPD0gKG1vbnRoID09PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKSk7XG59XG5mdW5jdGlvbiBjb21wYXJlRGF0ZShkMSwgZDIpIHtcbiAgICBpZiAoIShkMSAmJiBkMikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKGQxID4gZDIpXG4gICAgICAgIHJldHVybiAxO1xuICAgIGlmIChkMSA8IGQyKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgcmV0dXJuIDA7XG59XG5jb25zdCBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKShcXC5cXGQrKT8oenxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pO1xuZnVuY3Rpb24gdGltZShzdHIsIHdpdGhUaW1lWm9uZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBUSU1FLmV4ZWMoc3RyKTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBob3VyID0gK21hdGNoZXNbMV07XG4gICAgY29uc3QgbWludXRlID0gK21hdGNoZXNbMl07XG4gICAgY29uc3Qgc2Vjb25kID0gK21hdGNoZXNbM107XG4gICAgY29uc3QgdGltZVpvbmUgPSBtYXRjaGVzWzVdO1xuICAgIHJldHVybiAoKChob3VyIDw9IDIzICYmIG1pbnV0ZSA8PSA1OSAmJiBzZWNvbmQgPD0gNTkpIHx8XG4gICAgICAgIChob3VyID09PSAyMyAmJiBtaW51dGUgPT09IDU5ICYmIHNlY29uZCA9PT0gNjApKSAmJlxuICAgICAgICAoIXdpdGhUaW1lWm9uZSB8fCB0aW1lWm9uZSAhPT0gXCJcIikpO1xufVxuZnVuY3Rpb24gY29tcGFyZVRpbWUodDEsIHQyKSB7XG4gICAgaWYgKCEodDEgJiYgdDIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IGExID0gVElNRS5leGVjKHQxKTtcbiAgICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0Mik7XG4gICAgaWYgKCEoYTEgJiYgYTIpKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdICsgKGExWzRdIHx8IFwiXCIpO1xuICAgIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdICsgKGEyWzRdIHx8IFwiXCIpO1xuICAgIGlmICh0MSA+IHQyKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAodDEgPCB0MilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xufVxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pO1xuZnVuY3Rpb24gZGF0ZV90aW1lKHN0cikge1xuICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBkYXRlVGltZSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKTtcbiAgICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09PSAyICYmIGRhdGUoZGF0ZVRpbWVbMF0pICYmIHRpbWUoZGF0ZVRpbWVbMV0sIHRydWUpO1xufVxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MSwgZHQyKSB7XG4gICAgaWYgKCEoZHQxICYmIGR0MikpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY29uc3QgW2QxLCB0MV0gPSBkdDEuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgW2QyLCB0Ml0gPSBkdDIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUik7XG4gICAgY29uc3QgcmVzID0gY29tcGFyZURhdGUoZDEsIGQyKTtcbiAgICBpZiAocmVzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlcyB8fCBjb21wYXJlVGltZSh0MSwgdDIpO1xufVxuY29uc3QgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi87XG5jb25zdCBVUkkgPSAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pO1xuZnVuY3Rpb24gdXJpKHN0cikge1xuICAgIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gICAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cik7XG59XG5jb25zdCBCWVRFID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvZ207XG5mdW5jdGlvbiBieXRlKHN0cikge1xuICAgIEJZVEUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gQllURS50ZXN0KHN0cik7XG59XG5jb25zdCBNSU5fSU5UMzIgPSAtKDIgKiogMzEpO1xuY29uc3QgTUFYX0lOVDMyID0gMiAqKiAzMSAtIDE7XG5mdW5jdGlvbiB2YWxpZGF0ZUludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIHZhbHVlIDw9IE1BWF9JTlQzMiAmJiB2YWx1ZSA+PSBNSU5fSU5UMzI7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUludDY0KHZhbHVlKSB7XG4gICAgLy8gSlNPTiBhbmQgamF2YXNjcmlwdCBtYXggSW50IGlzIDIqKjUzLCBzbyBhbnkgaW50IHRoYXQgcGFzc2VzIGlzSW50ZWdlciBpcyB2YWxpZCBmb3IgSW50NjRcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNvbnN0IFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi87XG5mdW5jdGlvbiByZWdleChzdHIpIHtcbiAgICBpZiAoWl9BTkNIT1IudGVzdChzdHIpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChzdHIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvcm1hdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBmb3JtYXRzXzEgPSByZXF1aXJlKFwiLi9mb3JtYXRzXCIpO1xuY29uc3QgbGltaXRfMSA9IHJlcXVpcmUoXCIuL2xpbWl0XCIpO1xuY29uc3QgY29kZWdlbl8xID0gcmVxdWlyZShcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiKTtcbmNvbnN0IGZ1bGxOYW1lID0gbmV3IGNvZGVnZW5fMS5OYW1lKFwiZnVsbEZvcm1hdHNcIik7XG5jb25zdCBmYXN0TmFtZSA9IG5ldyBjb2RlZ2VuXzEuTmFtZShcImZhc3RGb3JtYXRzXCIpO1xuY29uc3QgZm9ybWF0c1BsdWdpbiA9IChhanYsIG9wdHMgPSB7IGtleXdvcmRzOiB0cnVlIH0pID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICBhZGRGb3JtYXRzKGFqdiwgb3B0cywgZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZSk7XG4gICAgICAgIHJldHVybiBhanY7XG4gICAgfVxuICAgIGNvbnN0IFtmb3JtYXRzLCBleHBvcnROYW1lXSA9IG9wdHMubW9kZSA9PT0gXCJmYXN0XCIgPyBbZm9ybWF0c18xLmZhc3RGb3JtYXRzLCBmYXN0TmFtZV0gOiBbZm9ybWF0c18xLmZ1bGxGb3JtYXRzLCBmdWxsTmFtZV07XG4gICAgY29uc3QgbGlzdCA9IG9wdHMuZm9ybWF0cyB8fCBmb3JtYXRzXzEuZm9ybWF0TmFtZXM7XG4gICAgYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZvcm1hdHMsIGV4cG9ydE5hbWUpO1xuICAgIGlmIChvcHRzLmtleXdvcmRzKVxuICAgICAgICBsaW1pdF8xLmRlZmF1bHQoYWp2KTtcbiAgICByZXR1cm4gYWp2O1xufTtcbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWUsIG1vZGUgPSBcImZ1bGxcIikgPT4ge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZvcm1hdHNfMS5mYXN0Rm9ybWF0cyA6IGZvcm1hdHNfMS5mdWxsRm9ybWF0cztcbiAgICBjb25zdCBmID0gZm9ybWF0c1tuYW1lXTtcbiAgICBpZiAoIWYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmb3JtYXQgXCIke25hbWV9XCJgKTtcbiAgICByZXR1cm4gZjtcbn07XG5mdW5jdGlvbiBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZnMsIGV4cG9ydE5hbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIChfYSA9IChfYiA9IGFqdi5vcHRzLmNvZGUpLmZvcm1hdHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYi5mb3JtYXRzID0gY29kZWdlbl8xLl8gYHJlcXVpcmUoXCJhanYtZm9ybWF0cy9kaXN0L2Zvcm1hdHNcIikuJHtleHBvcnROYW1lfWApO1xuICAgIGZvciAoY29uc3QgZiBvZiBsaXN0KVxuICAgICAgICBhanYuYWRkRm9ybWF0KGYsIGZzW2ZdKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZvcm1hdHNQbHVnaW47XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRzUGx1Z2luO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFqdl8xID0gcmVxdWlyZShcImFqdlwiKTtcbmNvbnN0IGNvZGVnZW5fMSA9IHJlcXVpcmUoXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIik7XG5jb25zdCBvcHMgPSBjb2RlZ2VuXzEub3BlcmF0b3JzO1xuY29uc3QgS1dEcyA9IHtcbiAgICBmb3JtYXRNYXhpbXVtOiB7IG9rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1QgfSxcbiAgICBmb3JtYXRNaW5pbXVtOiB7IG9rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFQgfSxcbiAgICBmb3JtYXRFeGNsdXNpdmVNYXhpbXVtOiB7IG9rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURSB9LFxuICAgIGZvcm1hdEV4Y2x1c2l2ZU1pbmltdW06IHsgb2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFIH0sXG59O1xuY29uc3QgZXJyb3IgPSB7XG4gICAgbWVzc2FnZTogKHsga2V5d29yZCwgc2NoZW1hQ29kZSB9KSA9PiBjb2RlZ2VuXzEuc3RyIGBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmRdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgICBwYXJhbXM6ICh7IGtleXdvcmQsIHNjaGVtYUNvZGUgfSkgPT4gY29kZWdlbl8xLl8gYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufTtcbmV4cG9ydHMuZm9ybWF0TGltaXREZWZpbml0aW9uID0ge1xuICAgIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgICAkZGF0YTogdHJ1ZSxcbiAgICBlcnJvcixcbiAgICBjb2RlKGN4dCkge1xuICAgICAgICBjb25zdCB7IGdlbiwgZGF0YSwgc2NoZW1hQ29kZSwga2V5d29yZCwgaXQgfSA9IGN4dDtcbiAgICAgICAgY29uc3QgeyBvcHRzLCBzZWxmIH0gPSBpdDtcbiAgICAgICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgZkN4dCA9IG5ldyBhanZfMS5LZXl3b3JkQ3h0KGl0LCBzZWxmLlJVTEVTLmFsbC5mb3JtYXQuZGVmaW5pdGlvbiwgXCJmb3JtYXRcIik7XG4gICAgICAgIGlmIChmQ3h0LiRkYXRhKVxuICAgICAgICAgICAgdmFsaWRhdGUkRGF0YUZvcm1hdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2YWxpZGF0ZUZvcm1hdCgpO1xuICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgICAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgICAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGZtdCA9IGdlbi5jb25zdChcImZtdFwiLCBjb2RlZ2VuXzEuXyBgJHtmbXRzfVske2ZDeHQuc2NoZW1hQ29kZX1dYCk7XG4gICAgICAgICAgICBjeHQuZmFpbCRkYXRhKGNvZGVnZW5fMS5vcihjb2RlZ2VuXzEuXyBgdHlwZW9mICR7Zm10fSAhPSBcIm9iamVjdFwiYCwgY29kZWdlbl8xLl8gYCR7Zm10fSBpbnN0YW5jZW9mIFJlZ0V4cGAsIGNvZGVnZW5fMS5fIGB0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCwgY29tcGFyZUNvZGUoZm10KSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCkge1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBmbXREZWYgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XTtcbiAgICAgICAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/IGNvZGVnZW5fMS5fIGAke29wdHMuY29kZS5mb3JtYXRzfSR7Y29kZWdlbl8xLmdldFByb3BlcnR5KGZvcm1hdCl9YCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3h0LmZhaWwkZGF0YShjb21wYXJlQ29kZShmbXQpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlQ29kZShmbXQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlZ2VuXzEuXyBgJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmRdLmZhaWx9IDBgO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn07XG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbiA9IChhanYpID0+IHtcbiAgICBhanYuYWRkS2V5d29yZChleHBvcnRzLmZvcm1hdExpbWl0RGVmaW5pdGlvbik7XG4gICAgcmV0dXJuIGFqdjtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBmb3JtYXRMaW1pdFBsdWdpbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbWl0LmpzLm1hcCIsImltcG9ydCBiYXNlQ2xvbmUgZnJvbSAnLi9fYmFzZUNsb25lLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmU7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc1N5bWJvbCBmcm9tICcuL2lzU3ltYm9sLmpzJztcbmltcG9ydCBzdHJpbmdUb1BhdGggZnJvbSAnLi9fc3RyaW5nVG9QYXRoLmpzJztcbmltcG9ydCB0b0tleSBmcm9tICcuL190b0tleS5qcyc7XG5pbXBvcnQgdG9TdHJpbmcgZnJvbSAnLi90b1N0cmluZy5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvUGF0aCgnYS5iLmMnKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICpcbiAqIF8udG9QYXRoKCdhWzBdLmIuYycpO1xuICogLy8gPT4gWydhJywgJzAnLCAnYicsICdjJ11cbiAqL1xuZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICB9XG4gIHJldHVybiBpc1N5bWJvbCh2YWx1ZSkgPyBbdmFsdWVdIDogY29weUFycmF5KHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9QYXRoO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9